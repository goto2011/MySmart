<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">19.互联网</span></span><ul><li><span class="name"><span class="innerContentContainer">信息与货币相似. <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">货币的出现为解决货物交换的供求的时间、地点和种类的矛盾。</span></span></li><li><span class="name"><span class="innerContentContainer">数字化信息，同样是解决了信息交换的时空及种类的矛盾。</span></span></li><li><span class="name"><span class="innerContentContainer">在供求两方的平台上实现信息的价值，而在传输过程中信息是不计特征的。</span></span></li><li><span class="name"><span class="innerContentContainer">货币有价值尺度、流通手段、储备手段和支付手段的作用，那么信息的作用呢？</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">人们最想从科技当中得到的, 是控制生活的能力.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">科技会逐渐从强度、物质和能量问题转变为结构、组织、信息和控制问题.  --约翰·冯·诺伊曼</span></span></li><li><span class="name"><span class="innerContentContainer">软件世界最核心的概念 <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">数据和程序统一编址</span></span></li><li><span class="name"><span class="innerContentContainer">分层</span></span></li><li><span class="name"><span class="innerContentContainer">数据抽象</span></span></li><li><span class="name"><span class="innerContentContainer">循环和递归</span></span></li><li><span class="name"><span class="innerContentContainer">类和对象</span></span></li><li><span class="name"><span class="innerContentContainer">回调</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">信息世界的层次 <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">物理层：物质世界</span></span></li><li><span class="name"><span class="innerContentContainer">芯片层：物理和信息的互转；提供算力</span></span></li><li><span class="name"><span class="innerContentContainer">信息层+传输层：信息编解码和传输</span></span></li><li><span class="name"><span class="innerContentContainer">应用层：个人和机器的互操作界面</span></span></li><li><span class="name"><span class="innerContentContainer">运营层：人、钱、数据、算力的在时间和空间上的协同</span></span></li><li><span class="name"><span class="innerContentContainer">管理层：管人</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一切问题都是分辨率问题。不仅计算机问题如此，真实世界也如此。&nbsp; <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">判断一个技术变革是否是未来的大趋势，看两个指标： <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">1是，单位能耗处理的信息量是否在提升；</span></span></li><li><span class="name"><span class="innerContentContainer">2是，单位能耗存储的信息量是否在增加。</span></span></li><li><span class="name"><span class="innerContentContainer">xSpace 要发射1万颗卫星到外太空，超过摩托罗拉的铱星计划，让世界上每一个地方的人都能通上电话。这个项目能成吗？</span></span><ul><li><span class="name"><span class="innerContentContainer">肯定成不了.</span></span></li><li><span class="name"><span class="innerContentContainer">因为一个卫星的实际有效传输率大概只有一个基站的1%，全中国有大约500万个基站，所以1万颗卫星解决不了什么问题。</span></span></li><li><span class="name"><span class="innerContentContainer">回到前面提到的两个指标，卫星处理和存储信息的单位能耗在提高，这就是逆势而行，不符合科技的大趋势。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">苹果TV首部自制剧《为全人类》首发预告&nbsp;&nbsp;<span class="contentTag" title="Filter @iVideo">@<span class="contentTagText">iVideo</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">全球苹果爱好者前往专卖店悼念乔布斯 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">乔布斯的告别 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">乔布斯遗命平安卓 苹果将秉承既定战略 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">Mac OS X 背后的故事 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">googel非常擅长于围绕着自己的核心资产构筑“护城河”。</span></span><ul><li><span class="name"><span class="innerContentContainer">通过提供集成了这些核心功能的免费软件和服务来保护搜索市场。</span></span></li><li><span class="name"><span class="innerContentContainer">android也是如此。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">壮士断腕，义无再辱 --阮一峰,  2010/1/14  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">纽约时报：“谷歌”在中国：他不是Google  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">谷歌中国身后事 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Google退出中国后续报道之二  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">百度封杀Google的黑内幕 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Google 退出中国声明原文（英文原版+中文翻译） <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #Google">#<span class="contentTagText">Google</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">互联网商业模式</span></span><ul><li><span class="name"><span class="innerContentContainer">IT行业预测</span></span><ul><li><span class="name"><span class="innerContentContainer">现有的行业情况</span></span><ul><li><span class="name"><span class="innerContentContainer">内容 - 软件 - 网络-用户 - 硬件。</span></span></li><li><span class="name"><span class="innerContentContainer">网络占据中心，垄断用户。</span></span></li><li><span class="name"><span class="innerContentContainer">软件和硬件分得很开。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">未来可能的行业情况</span></span><ul><li><span class="name"><span class="innerContentContainer">硬件 - 软件 - 内容 - 网络 - 用户。 </span></span></li><li><span class="name"><span class="innerContentContainer">以硬件为核心，软件和应用围绕硬件，做全面整合；</span></span></li><li><span class="name"><span class="innerContentContainer">软件发挥硬件的特性；</span></span></li><li><span class="name"><span class="innerContentContainer">软件、硬件成为内容创新的点。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">南方周末特稿：“系统”   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #社交网络">#<span class="contentTagText">社交网络</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">阿里组   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #电商">#<span class="contentTagText">电商</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">“狗日的”腾讯 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #社交网络">#<span class="contentTagText">社交网络</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #广告">#<span class="contentTagText">广告</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">推荐卖货</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #游戏">#<span class="contentTagText">游戏</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #电商">#<span class="contentTagText">电商</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #供应链金融">#<span class="contentTagText">供应链金融</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #消费大数据">#<span class="contentTagText">消费大数据</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #社交网络">#<span class="contentTagText">社交网络</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">2012.7.24, 张小龙内部讲座《通过微信谈产品》完整版   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #社交网络">#<span class="contentTagText">社交网络</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #共享经济">#<span class="contentTagText">共享经济</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #在线教育">#<span class="contentTagText">在线教育</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关键指标</span></span><ul><li><span class="name"><span class="innerContentContainer">设备的数量 <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">第一代PC互联网时期，全世界的联网设备大约是10亿台。</span></span></li><li><span class="name"><span class="innerContentContainer">第二代互联网，由于手机的加入，全球大概有40亿台设备接入网络。</span></span></li><li><span class="name"><span class="innerContentContainer">IoT时代，汽车、智能家居都可以联网，据保守估计，至少有百亿台的设备要接入网络.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络流量</span></span><ul><li><span class="name"><span class="innerContentContainer">色情网站占全球网站整体数量的12%</span></span><ul><li><span class="name"><span class="innerContentContainer">2012-06-09, 美国科技博客Business Insider早前公开调查结果称，如今色情网站占全球网站整体数量的12%；</span></span></li><li><span class="name"><span class="innerContentContainer">每秒钟有28258人在观看色情网站；</span></span></li><li><span class="name"><span class="innerContentContainer">差不多4千万美国人有浏览色情网站习惯，其中每3人当中有1人是女性;</span></span></li><li><span class="name"><span class="innerContentContainer">色情档案占所有网际网络下载量的35%，超1/3份额。</span></span></li><li><span class="name"><span class="innerContentContainer">不久前，根据谷歌旗下广告服务商Doubleclick的数据显示，独立访问量前500名的网站中，竟有数十个是色情网站。</span></span></li><li><span class="name"><span class="innerContentContainer">而色情网站的数据流量又极大，有人估计，色情网站的数据传送量可能占整个互联网的30%。</span></span></li><li><span class="name"><span class="innerContentContainer">色情网站用户对高清图片和视频的需求是推动宽带普及的重要因素。</span></span></li><li><span class="name"><span class="innerContentContainer">2000年《纽约时报》曾报道，在当年运营商AT&amp;T的付费开通宽带的用户中，有20%是为了“观看在线真人性爱视频”；</span></span></li><li><span class="name"><span class="innerContentContainer">2003年AC尼尔森市场研究公司在一份调查报告中也指出，“在线音乐分享和色情消费是当时宽带在欧洲得以普及的两大最重要因素”。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">用户量</span></span><ul><li><span class="name"><span class="innerContentContainer">注册用户数水分太多, 业界再也不提了. 现在提的是活跃用户数.</span></span></li><li><span class="name"><span class="innerContentContainer">DAU: 日活</span></span><ul><li><span class="name"><span class="innerContentContainer">Daily Active User, 日活跃用户数量, 简称"日活".</span></span></li><li><span class="name"><span class="innerContentContainer">反应产品短期用户活跃度.</span></span></li><li><span class="name"><span class="innerContentContainer">通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MAU: 月活</span></span><ul><li><span class="name"><span class="innerContentContainer">月活跃用户数量. 简称"月活".</span></span></li><li><span class="name"><span class="innerContentContainer">反应产品长期用户活跃度. 一般用来衡量服务的用户粘性以及服务的衰退周期。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">日活和月活的比值高，代表一个月有使用产品的用户中，每天都使用产品的用户比例高，即使用频率高，用户对产品的依赖性强，同时也说明用户粘度较强。另一方面，也代表了用户的流失率低，留存率高。</span></span></li><li><span class="name"><span class="innerContentContainer">日活和月活的比值低，则结论相反: 用户使用频率低，依赖性弱，粘度较弱，用户流失率高，留存率低。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低延时</span></span><ul><li><span class="name"><span class="innerContentContainer">低延时有两个范畴, 对于泛智能硬件领域, 低延时指50mS、100mS的时钟周期. </span></span></li><li><span class="name"><span class="innerContentContainer">而对于工业自动化而言, 低延时指100μS这样的时钟周期. </span></span></li><li><span class="name"><span class="innerContentContainer">两者差了1000倍. 完全不是同一个概念.</span></span></li><li><span class="name"><span class="innerContentContainer">之所以有这个差异, 关键在于泛智能硬件领域是基于数据的路由的, 工业自动化是基于信号的控制的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低功耗</span></span></li><li><span class="name"><span class="innerContentContainer">防水</span></span><ul><li><span class="name"><span class="innerContentContainer">IP** 是GB/T 4208-2017 外壳防护等级(IP代码)中，防尘防水等级标准。</span></span></li><li><span class="name"><span class="innerContentContainer">其中:第一位*是防尘等级, 从0到6，最高为6.</span></span><ul><li><span class="name"><span class="innerContentContainer">6表示: 完全防止外物及灰尘侵入</span></span></li><li><span class="name"><span class="innerContentContainer">5表示: 完全防止外物侵入，虽不能完全防止灰尘侵入，但灰尘的侵入量不会影响电器的正常运作</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第2位*是防水等级, 从0到8，最高为8.</span></span><ul><li><span class="name"><span class="innerContentContainer">8表示电器无限期沉没在指定的水压下，可确保不因浸水而造成损坏</span></span></li><li><span class="name"><span class="innerContentContainer">5表示防止来自各个方向飞由喷嘴射出的水侵入电器而造成损坏.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IP68 是连接器防水等级标准的最高级别。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一个常见于智能手表的防水指标是IP55.</span></span></li><li><span class="name"><span class="innerContentContainer">某些品牌的IP68防水测试是：保证在10米水深，工作2个星期，而不进水；放入100米水深，破坏测试12小时，仍旧能够保持产品的良好性能。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #芯片">#<span class="contentTagText">芯片</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">ARM的历史 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #芯片">#<span class="contentTagText">芯片</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #存储芯片">#<span class="contentTagText">存储芯片</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #电脑">#<span class="contentTagText">电脑</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">2007-1-9, 苹果推出革命性手机产品 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">2007-7-11, 苹果iPhone为何能让世界疯狂？ <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">2007-7-11, 新闻周刊：有史以来最受期待产品iPhone <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #苹果">#<span class="contentTagText">苹果</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">复盘中国手机历史性崛起：华米OV靠什么打败国际品牌？ <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">山寨机揭秘 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #平板">#<span class="contentTagText">平板</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #电视">#<span class="contentTagText">电视</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #基站">#<span class="contentTagText">基站</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #LCD">#<span class="contentTagText">LCD</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #战争已经结束">#<span class="contentTagText">战争已经结束</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #camera">#<span class="contentTagText">camera</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #巨头的游戏">#<span class="contentTagText">巨头的游戏</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能音箱">#<span class="contentTagText">智能音箱</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #巨头的游戏">#<span class="contentTagText">巨头的游戏</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #无线耳机">#<span class="contentTagText">无线耳机</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #巨头的游戏">#<span class="contentTagText">巨头的游戏</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能汽车">#<span class="contentTagText">智能汽车</span><span class="contentTagNub"></span></span> ,  智能仪表盘+中控.  <span class="contentTag" title="Filter #巨头的游戏">#<span class="contentTagText">巨头的游戏</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">六种锂电池特性及参数分析（钴酸锂、锰酸锂、镍钴锰酸锂、镍钴铝酸锂、磷酸铁锂、钛酸锂）<a class="contentLink" target="_blank" rel="noreferrer" href="http://www.sohu.com/a/285321529_733088">http://www.sohu.com/a/285321529_733088</a>    <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #电动车">#<span class="contentTagText">电动车</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>关于“新能源经济”41个事实  <span class="contentTag" title="Filter #电动车">#<span class="contentTagText">电动车</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">1. 碳氢化合物供应占到世界总能源的80%以上：这一切如果都以石油形态存在，那么这些石油桶将从华盛顿特区一直排到洛杉矶，且这条线路每周增加的长度，都相当于华盛顿纪念碑的高度。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 碳氢化合物在世界能源使用中所占比例下降了2个百分点，导致在此期间全球用于替代能源的累计支出超过2万亿美元；今天，太阳能和风能供应只占全球能源不到2%。</span></span></li><li><span class="name"><span class="innerContentContainer">3. 当全球40亿贫困人口人均能源使用量增加到欧洲人均水平1/3时，全球需求增加量将相当于美国总消费量的两倍。</span></span></li><li><span class="name"><span class="innerContentContainer">4. （假设）到2040年，上路的电动汽车数量增长100倍，达到4亿辆，将替代全球石油需求的5%。</span></span></li><li><span class="name"><span class="innerContentContainer">5. 可再生能源必须扩大90倍，才能在20年内替代全球的碳氢化合物。半个世纪后，全球石油产量“仅”扩大10倍。</span></span></li><li><span class="name"><span class="innerContentContainer">6. 要在未来30年里替代美国以碳氢化合物为基础的发电，需要一个以比以往任何时候都快14倍的速度铺设电网的建设计划。</span></span></li><li><span class="name"><span class="innerContentContainer">7. 即使取消用碳氢化合物给美国发电(不可能很快实现，几十年内都不可能实现)，美国70%碳氢化合物的使用仍原封不动——美国使用了世界16%的能源。</span></span></li><li><span class="name"><span class="innerContentContainer">8. 效率导致产品和服务价格降低，能源需求量增加：自1990年以来，全球能源效率提高了33%，经济增长了80%，全球能源使用量增加了40%。</span></span></li><li><span class="name"><span class="innerContentContainer">9. 效率导致能源需求量增加：自1995年以来，航空燃料使用量/客位英里数下降了70%，航空交通量增长了10倍以上，全球航空燃料使用量增长了50%以上。</span></span></li><li><span class="name"><span class="innerContentContainer">10. 效率导致能源需求量增加：自1995年以来，每字节耗能减少了约1万倍，但全球数据流量增加了约100万倍；全球用于数据运算的电量飙升。</span></span></li><li><span class="name"><span class="innerContentContainer">11. 自1995年以来，世界能源使用总量增长了50%，相当于增加了整整两个美国的需求量。</span></span></li><li><span class="name"><span class="innerContentContainer">12. 为了保障安全和可靠性，全美对碳氢化合物无论何时都有平均2个月的储存需求。今天在美国，所有实用尺度的电池加上100万辆电动汽车的全部电池，仅能满足全美2小时电力需求。</span></span></li><li><span class="name"><span class="innerContentContainer">13. 特斯拉GIGA十亿级工厂(全球最大电池厂)每年生产的电池仅能储存相当于美国年电力需求3分钟的电量。</span></span></li><li><span class="name"><span class="innerContentContainer">14. 要生产足够储存2天美国电力需求的电池，这家全球最大电池厂（特斯拉）需要生产1000年。</span></span></li><li><span class="name"><span class="innerContentContainer">15. 每生产10亿美元飞机，在过去20年里就会消耗大约50亿美元航空燃料。全球每年在新飞机上花钱超过500亿美元，还在不断增长。</span></span></li><li><span class="name"><span class="innerContentContainer">16. 在数据中心上每花费10亿美元，就会在20年内消耗70亿美元电力。全球对数据中心的支出每年超过1000亿美元，还在不断增长。</span></span></li><li><span class="name"><span class="innerContentContainer">17. 在30年时间内，价值100万美元达到实用尺度的太阳能或风能发电设备分别产生4000万千瓦时和5500万千瓦时电能：一座价值100万美元的页岩气井生产的天然气足以在30年内产生3亿千瓦时电能。</span></span></li><li><span class="name"><span class="innerContentContainer">18. 建造一座页岩井的成本大致相当于建造两台风力涡轮发电机的成本：后者每小时合起来生产的电能相当于0.7桶石油，页岩钻井平均每小时生产10桶石油。</span></span></li><li><span class="name"><span class="innerContentContainer">19. 储存一桶石油（或其按油气当量折合的天然气）成本不到0.5美元，但将一桶石油等效能量储存在电池中的成本高达200美元。</span></span></li><li><span class="name"><span class="innerContentContainer">20. 风能和太阳能成本模型分别假定了41%和29%的容量系数(即它们多常发电)。现实世界的数据显示了，这两项指标都要低10个百分点。这意味着，一台2兆瓦300万美元风力涡轮发电机，在它20年使用寿命内产生的电能，比假设的要少赚300万美元。</span></span></li><li><span class="name"><span class="innerContentContainer">21. 为了补偿不稳定的风能/太阳能输出，美国的各家公用事业公司正在使用燃烧石油和天然气的往复式发动机(大型游轮式柴油发动机)；自2000年以来，新增电网数量是此前50年的3倍。</span></span></li><li><span class="name"><span class="innerContentContainer">22. 风力发电场的容量系数以每年约0.7%的速度提高；这一微幅增长主要来自每英亩涡轮机数量的减少，导致用于生产千瓦时风能的平均土地增加了50%。</span></span></li><li><span class="name"><span class="innerContentContainer">23. 美国90%以上的电力以及99%交通运输用电力来自于但凡市场需要即可随时向经济提供能量的能源。</span></span></li><li><span class="name"><span class="innerContentContainer">24. 风能和太阳能机器平均在25%到30%的时间里产生能量，而且只有在自然条件允许的情况下。传统发电厂几乎可以连续运转且随需取用。</span></span></li><li><span class="name"><span class="innerContentContainer">25. 页岩油气革命导致天然气和煤炭价格暴跌，这两种燃料为美国提供了70%的电力。但电价没有下降，自2008年以来反而上涨了20%。对太阳能和风能的直接和间接补贴抵消了这些节约。</span></span></li><li><span class="name"><span class="innerContentContainer">26. 政客和专家好引“登月”的豪言壮语。但是，让能源经济转型，并不像把几个人送上月球那么简单，其难度就好像把全体人类永久性送到月球上居住。</span></span></li><li><span class="name"><span class="innerContentContainer">27. 常见的陈词滥调是：能源技术的颠覆效应相呼应于数字技术的颠覆效应。但制造信息的机器和制造能源的机器涉及的物理原理大相径庭；这句陈词滥调，比起把苹果和保龄球相提并论还要愚不可及。</span></span></li><li><span class="name"><span class="innerContentContainer">28. 如果太阳能发电设施的尺度有如计算机技术那样，那么一张邮票大小的太阳能电池阵列将为帝国大厦提供动力。不过这只会发生在漫画书里。</span></span></li><li><span class="name"><span class="innerContentContainer">29. 如果电池的尺度有如数字技术那样，一本书大小的电池只要3美分就可以为飞往亚洲的喷气客机提供动力。不过这只会发生在漫画书里。</span></span></li><li><span class="name"><span class="innerContentContainer">30. 如果内燃机的尺度有如计算机那样，汽车发动机就能缩小到蚂蚁一般大小，产生一千倍的马力；实际像蚂蚁大小的发动机产生的功率要小10万倍。</span></span></li><li><span class="name"><span class="innerContentContainer">31. 太阳能技术不存在像数字技术那样的10倍速率改进。太阳能电池的物理极限（肖克利-奎伊瑟极限）是最大光电转换率33%；目前商用电池的比例为26%。</span></span></li><li><span class="name"><span class="innerContentContainer">32. 风能技术不存在像数字技术那样的10倍速率改进。风力涡轮发电机的物理极限(贝茨极限)是在气流中最大捕获60%的能量；商用涡轮发电机达到45%。</span></span></li><li><span class="name"><span class="innerContentContainer">33. 电池不存在像数字技术那样的10倍速率改进：一磅石油的最大理论能量比一磅性能最佳的电池化学品的最大理论能量高出150%。</span></span></li><li><span class="name"><span class="innerContentContainer">34. 大约需要60磅电池来储存相当于1磅碳氢化合物的能量。</span></span></li><li><span class="name"><span class="innerContentContainer">35. 每生产1磅电池至少要开采、移动和加工100磅材料。</span></span></li><li><span class="name"><span class="innerContentContainer">36. 储存相当于一桶石油(300磅重)的能量需要2万磅特斯拉电池(价值20万美元)。</span></span></li><li><span class="name"><span class="innerContentContainer">37. 携带相当于一架飞往亚洲的客机所用航空燃料的能量，需要价值6000万美元的特斯拉型电池，重量是这架飞机的5倍。</span></span></li><li><span class="name"><span class="innerContentContainer">38. 制造一组储能相当于1桶石油的电池需要的能量相当于100桶石油。</span></span></li><li><span class="name"><span class="innerContentContainer">39. 一个以电池为中心的电网和汽车世界意味着开采更多地球资源来获取锂、铜、镍、石墨、稀土、钴等，并在采矿和制造金属和混凝土中使用数百万吨石油和煤炭。</span></span></li><li><span class="name"><span class="innerContentContainer">40. 中国大陆在全球电池生产中占据主导地位，其电网70%的燃料为煤炭：使用这些电池的电动汽车产生的二氧化碳，将超过更换燃油发动机所节省的二氧化碳。</span></span></li><li><span class="name"><span class="innerContentContainer">41. 人们不会使用直升机进行常规的跨大西洋旅行（需要昂贵的后勤设施才可能做到），就像不会使用核反应堆为火车提供动力或完全使用光伏系统为一个国家提供电力一样。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @K150">@<span class="contentTagText">K150</span><span class="contentTagNub"></span></span> 锂电池和燃料电池的能量密度瓶颈分析.高工锂电技术与应用.2017-12-05.<a class="contentLink" target="_blank" rel="noreferrer" href="http://www.elecfans.com/d/594117.html">http://www.elecfans.com/d/594117.html</a>   <span class="contentTag" title="Filter @iNote">@<span class="contentTagText">iNote</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #电动车">#<span class="contentTagText">电动车</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">东风汽车集团的股权结构 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #无人机">#<span class="contentTagText">无人机</span><span class="contentTagNub"></span></span>   <span class="contentTag" title="Filter #巨头的游戏">#<span class="contentTagText">巨头的游戏</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #IoT">#<span class="contentTagText">IoT</span><span class="contentTagNub"></span></span>: Internet of Things, 国内翻译为物联网, 也即万物互联.</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #手表">#<span class="contentTagText">手表</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">智能手表就是一个小手机 --小米  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #手表">#<span class="contentTagText">手表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">智能手表的核心竞争力: 独立的通信和网络能力 + 足够丰富的软件生态 <span class="contentTag" title="Filter #手表">#<span class="contentTagText">手表</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">信息回复: 微信</span></span></li><li><span class="name"><span class="innerContentContainer">移动支付: 支付宝</span></span></li><li><span class="name"><span class="innerContentContainer">交通出行: 高德</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">智能手表的关键功能点 <span class="contentTag" title="Filter #手表">#<span class="contentTagText">手表</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">心率</span></span></li><li><span class="name"><span class="innerContentContainer">无线充电</span></span></li><li><span class="name"><span class="innerContentContainer">独立的电话功能</span></span></li><li><span class="name"><span class="innerContentContainer">防水</span></span></li><li><span class="name"><span class="innerContentContainer">续航能力</span></span></li><li><span class="name"><span class="innerContentContainer">GPS</span></span></li><li><span class="name"><span class="innerContentContainer">NFC</span></span></li><li><span class="name"><span class="innerContentContainer">语音助手</span></span></li><li><span class="name"><span class="innerContentContainer">独立音乐播放</span></span></li><li><span class="name"><span class="innerContentContainer">eSIM卡</span></span><ul><li><span class="name"><span class="innerContentContainer">简单说就是你的手表可以和手机之间共用同一个手机号.</span></span></li><li><span class="name"><span class="innerContentContainer">当你只带手表出门的时候，依然可以独立于手机之外，完成依赖通信和网络的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">智能家居控制中心</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #手环">#<span class="contentTagText">手环</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能眼镜">#<span class="contentTagText">智能眼镜</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">“OK，Glass”.   为这位美女留档 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #智能眼镜">#<span class="contentTagText">智能眼镜</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #路由器">#<span class="contentTagText">路由器</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建筑家居</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #灯具">#<span class="contentTagText">灯具</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能插头">#<span class="contentTagText">智能插头</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能门锁">#<span class="contentTagText">智能门锁</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #扫地机器人">#<span class="contentTagText">扫地机器人</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能安防">#<span class="contentTagText">智能安防</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">智能计量</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #血糖仪">#<span class="contentTagText">血糖仪</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #血氧仪">#<span class="contentTagText">血氧仪</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #心电仪">#<span class="contentTagText">心电仪</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">家电</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #空调">#<span class="contentTagText">空调</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #冰箱">#<span class="contentTagText">冰箱</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #洗衣机">#<span class="contentTagText">洗衣机</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #电饭煲">#<span class="contentTagText">电饭煲</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #空气净化器">#<span class="contentTagText">空气净化器</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #相机">#<span class="contentTagText">相机</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #微波炉">#<span class="contentTagText">微波炉</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #净水器">#<span class="contentTagText">净水器</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #电热水壶">#<span class="contentTagText">电热水壶</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #风扇">#<span class="contentTagText">风扇</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工业自动化</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #高精度机床">#<span class="contentTagText">高精度机床</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #机器人">#<span class="contentTagText">机器人</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #高速图文印刷系统">#<span class="contentTagText">高速图文印刷系统</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #智能医疗">#<span class="contentTagText">智能医疗</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #材料">#<span class="contentTagText">材料</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #电池">#<span class="contentTagText">电池</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #3D打印">#<span class="contentTagText">3D打印</span><span class="contentTagNub"></span></span></span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件制造</span></span><ul><li><span class="name"><span class="innerContentContainer">手机生产流程</span></span><ul><li><span class="name"><span class="innerContentContainer">贴片</span></span><ul><li><span class="name"><span class="innerContentContainer">即把CPU等芯片贴到pcb板上，使用贴片机。然后有焊接工序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JDBC加载</span></span><ul><li><span class="name"><span class="innerContentContainer">jtag加载小boot包.</span></span></li><li><span class="name"><span class="innerContentContainer">内容包括qcsbl、oemsbl、partition、oeminfo的初始包（包括otp、logo等）等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DT</span></span><ul><li><span class="name"><span class="innerContentContainer">写单板条码到手机，检查烧片版本的版本信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">升级烧片</span></span><ul><li><span class="name"><span class="innerContentContainer">升级烧片版本。包括多个步骤，比如可能需要格式化U盘等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CT</span></span><ul><li><span class="name"><span class="innerContentContainer">校准射频参数；手机要进FTM模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BT</span></span><ul><li><span class="name"><span class="innerContentContainer">综测。最耗时间的一个步骤。</span></span></li><li><span class="name"><span class="innerContentContainer">手机进FTM模式。</span></span></li><li><span class="name"><span class="innerContentContainer">无卡注册方案和快速注册方案也是用于这个阶段。</span></span><ul><li><span class="name"><span class="innerContentContainer">CDMA无卡注册方案方案</span></span><ul><li><span class="name"><span class="innerContentContainer">将频段、频点信息写入nv 60009，相关代码修改参见特性宏：DTS7X27_CDMA_LOCK_EREQ。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">WCDMA无卡注册方案</span></span><ul><li><span class="name"><span class="innerContentContainer">UMTS无卡注册方案是虚拟出一张sim卡，相关代码修改参见：HUAWEI_FEATHER_BT_NOSIM。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MMI测试</span></span><ul><li><span class="name"><span class="innerContentContainer">MMI测试，确认各器件是否好用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MT</span></span><ul><li><span class="name"><span class="innerContentContainer">整机测试，测试天线，包括rf、gps、wifi。</span></span></li><li><span class="name"><span class="innerContentContainer">手机要进WT模式。</span></span></li><li><span class="name"><span class="innerContentContainer">PT</span></span></li><li><span class="name"><span class="innerContentContainer">整机电流测试，主要测试进待机、电池电压、温度和基底电流。</span></span></li><li><span class="name"><span class="innerContentContainer">相关方案是快速待机。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">正常升级</span></span><ul><li><span class="name"><span class="innerContentContainer">一般用SD卡升级方式（也有USB的），从工程菜单进入升级，以便升级前备份nv。</span></span></li><li><span class="name"><span class="innerContentContainer">现在升级大包中也放了cust包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MMI2</span></span><ul><li><span class="name"><span class="innerContentContainer">版本升级后进行mmi测试，再次确认各器件是否好用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CW(LT)</span></span><ul><li><span class="name"><span class="innerContentContainer">贴背贴，以前叫LT，现在叫CW。</span></span></li><li><span class="name"><span class="innerContentContainer">因为现在是离线打背贴，因为可以在生产前把背贴打印出来，加快生产效率。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CW(LT)</span></span><ul><li><span class="name"><span class="innerContentContainer">关键的一步。</span></span></li><li><span class="name"><span class="innerContentContainer">写入sn、wifi/bt地址、IMEI(for gsm)/MEID/ESN(for cdma)、simlock数据等。</span></span></li><li><span class="name"><span class="innerContentContainer">做cust升级，即写入cust分区、写入vendor/country信息，然后重启。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MC</span></span><ul><li><span class="name"><span class="innerContentContainer">功能是检查手机emei号和背贴上是否一致。</span></span></li><li><span class="name"><span class="innerContentContainer">要恢复出厂设置。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">彩包</span></span><ul><li><span class="name"><span class="innerContentContainer">彩包、装箱。</span></span></li><li><span class="name"><span class="innerContentContainer">产线流程结束。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">生产附属流程1：改制</span></span><ul><li><span class="name"><span class="innerContentContainer">即切换运营商。要修改IMEI，并进行cust升级。</span></span></li><li><span class="name"><span class="innerContentContainer">一般发生在产线和一线库房。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">生产附属流程2：开卡</span></span><ul><li><span class="name"><span class="innerContentContainer">仅针对机卡合一手机。</span></span></li><li><span class="name"><span class="innerContentContainer">在运营商营业点进行开卡操作，然后交付消费者使用。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">基础设施  (系统软件)</span></span><ul><li><span class="name"><span class="innerContentContainer">驱动</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">麒麟操作系统内核同其他操作系统内核的相似性分析  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">诺基亚：跳下着火的平台 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #手机">#<span class="contentTagText">手机</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><b>IoT OS列表</b> <span class="contentTag" title="Filter #IoT">#<span class="contentTagText">IoT</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Android Things -- 应该废了</span></span><ul><li><span class="name"><span class="innerContentContainer">虽然还是Android，但是是精简的Android。</span></span></li><li><span class="name"><span class="innerContentContainer">系统容量缩小一半（700MB减少到400MB），意味着可以使用更便宜的硬件配置。</span></span></li><li><span class="name"><span class="innerContentContainer">因为还是Android，系统Api没什么变化，所以APK开发没什么太大的差别。</span></span></li><li><span class="name"><span class="innerContentContainer">APP不开放给用户自由安装。</span></span></li><li><span class="name"><span class="innerContentContainer">Kernel、Framework不开放给整机厂商定制。</span></span></li><li><span class="name"><span class="innerContentContainer">换句话说，只能使用主流芯片上提供的公版设计。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">VxWorks -- 闭源; 非常贵</span></span></li><li><span class="name"><span class="innerContentContainer">Zephyr</span></span><ul><li><span class="name"><span class="innerContentContainer">Apache 2.0协议许可。</span></span></li><li><span class="name"><span class="innerContentContainer">2016 年 2 月，Linux 基金会发布的实时操作系统。</span></span></li><li><span class="name"><span class="innerContentContainer">可在 RAM 大小为 8KB 的 MCU 上流畅运行，经过裁剪甚至可在 RAM 为最小的 2KB 时运行。</span></span></li><li><span class="name"><span class="innerContentContainer">支持&nbsp;ARM Cortex-M,&nbsp;x86,&nbsp;ARC(DSP 内核),&nbsp;NIOS II(FPGA 软核)&nbsp;以及&nbsp;RISC V。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">μClinux</span></span><ul><li><span class="name"><span class="innerContentContainer">继承了Linux的大部分功能。</span></span></li><li><span class="name"><span class="innerContentContainer">不支持MMU。</span></span></li><li><span class="name"><span class="innerContentContainer">至少需要512KB的RAM空间，lMB的 ROM／Flash空间。</span></span></li><li><span class="name"><span class="innerContentContainer">实时性不稳定。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">μC／OS-II</span></span><ul><li><span class="name"><span class="innerContentContainer">本身内核就很小，经过裁剪后的代码最小可以为 2KB，所需的最小数据RAM空间为 4KB。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">华为鸿蒙(LiteOS)</span></span><ul><li><span class="name"><span class="innerContentContainer">如何看待华为鸿蒙系统？<a class="contentLink" target="_blank" rel="noreferrer" href="https://www.zhihu.com/question/339567108/answer/782431141">https://www.zhihu.com/question/339567108/answer/782431141</a></span></span></li><li><span class="name"><span class="innerContentContainer">鸿蒙技术社区: <a class="contentLink" target="_blank" rel="noreferrer" href="https://aijishu.com/blog/harmonyos">https://aijishu.com/blog/harmonyos</a></span></span></li><li><span class="name"><span class="innerContentContainer">润和鸿蒙技术社区: <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.zhihu.com/people/zuo-ye-he-cao-34">https://www.zhihu.com/people/zuo-ye-he-cao-34</a></span></span></li><li><span class="name"><span class="innerContentContainer">LiteOS开源问题</span></span><ul><li><span class="name"><span class="innerContentContainer">2016年9月，华为发布Huawei LiteOS开源版本，Kernel源代码开源。</span></span></li><li><span class="name"><span class="innerContentContainer">开源网址： <a class="contentLink" target="_blank" rel="noreferrer" href="https://gitee.com/liteos">https://gitee.com/liteos</a></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://github.com/LiteOS/LiteOS">https://github.com/LiteOS/LiteOS</a></span></span></li><li><span class="name"><span class="innerContentContainer">Huawei LiteOS黑客松： <a class="contentLink" target="_blank" rel="noreferrer" href="https://github.com/LiteOS/LiteOS_Hackathon_20170107_Beijing">https://github.com/LiteOS/LiteOS_Hackathon_20170107_Beijing</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LiteOS是假开源，都是给的.a文件. 都没有源代码。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LiteOS特点和背景</span></span><ul><li><span class="name"><span class="innerContentContainer">LiteOS是微内核系统。</span></span></li><li><span class="name"><span class="innerContentContainer">LiteOS就是零几年中研的一个小组写的 S<b>ensorHub,</b> 运行于arm3上, 功能是管理手机的sensor.</span></span></li><li><span class="name"><span class="innerContentContainer">系统起来相当快，大概3秒。</span></span></li><li><span class="name"><span class="innerContentContainer">最小内核尺寸仅为6KB.</span></span></li><li><span class="name"><span class="innerContentContainer">超低功耗， 1 节 5 号电池可工作 5 年。</span></span></li><li><span class="name"><span class="innerContentContainer">2014年，在华为Mate系列、P系列、荣耀系列手机、可穿戴产品上批量应用。</span></span></li><li><span class="name"><span class="innerContentContainer">2015年5月，HNC网络大会上发布 Huawei LiteOS 物联网操作系统，正式推出华为“ 1+2+1 ”物联网解决方案，即“一个物联网平台，两种接入方式，一个轻量级物联网操作系统”；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基于LiteOS内核是没有java虚拟机的，java编写的app只能是未来用在大内存设备上，目前小于128M内存的lite设备只能使用 html+js 的方法编写、编译程序，在LiteOS中使用华为已经开源的 js framework 运行app.</span></span></li><li><span class="name"><span class="innerContentContainer">鸿蒙OS: 微内核, 全场景.</span></span><ul><li><span class="name"><span class="innerContentContainer">微内核: 主要指系统内核/设备驱动是动态加载的。不是什么新概念，多得是，没有一个商业成功的。</span></span></li><li><span class="name"><span class="innerContentContainer">全场景是商业用语，大概指服务器、PC、手机、车载，华为可能再加一个基站。</span></span></li><li><span class="name"><span class="innerContentContainer">全场景相当于以一敌百，要替代所有平台的系统。别的不说，要解多少bug啊。如果真干，肯定完蛋；但华为不笨，三分干七分忽悠而已。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="7" startday="3" style="border-bottom: 1px solid rgb(220, 224, 226);">Wed, Jul 3, 2019</time> , 据法国媒体《Le Point》发布的任正非专访，任正非谈及鸿蒙操作系统又表示，鸿蒙操作系统主要应用于物联网，是一个面向确定时延系统的操作系统，实现系统端到端加密时延时精确到5毫秒，甚至更低的毫秒级乃至亚毫秒级；它原本是为了电信网络而设计的，并不是像大家想象那样用在手机中，做这个系统的时候并不是想替代谷歌的。</span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="8" startday="9" style="border-bottom: 1px solid rgb(220, 224, 226);">Fri, Aug 9, 2019</time>, 华为开发者大会上，华为消费者业务总裁余承东正式宣布发布自有操作系统鸿蒙，内核为Linux内核、鸿蒙微内核和LiteOS。未来将摆脱Linux内核和LiteOS，只有鸿蒙微内核。余承东表示，如果<a class="contentLink" target="_blank" rel="noreferrer" href="https://zh.wikipedia.org/wiki/Google">Google</a><a class="contentLink" target="_blank" rel="noreferrer" href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%8D%93">安卓</a>系统不向华为开放，自家手机将可以随时启用鸿蒙系统.</span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="8" startday="10" style="border-bottom: 1px solid rgb(220, 224, 226);">Sat, Aug 10, 2019</time>, 华为消费者业务首席战略官邵洋表示，LiteOS是为物联网中那些轻量级的设备打造的，比如耳机、音箱、路由器等不带屏设备；而鸿蒙OS是为物联网中重量级设备打造的，比如荣耀刚刚推出的智慧屏、以及未来会涉及的智能手表、汽车等领域。</span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="8" startday="10" style="border-bottom: 1px solid rgb(220, 224, 226);">Sat, Aug 10, 2019</time>，首款搭载鸿蒙系统的产品“荣耀智慧屏”发布。</span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="11" startday="9" style="border-bottom: 1px solid rgb(220, 224, 226);">Sat, Nov 9, 2019</time>，华为向用户推送了适用于荣耀智能屏和荣耀智能屏PRO的鸿蒙1.0.0.71系统，该版本新增了Android应用程序安装功能。 </span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2020" startmonth="4" startday="22" style="border-bottom: 1px solid rgb(220, 224, 226);">Wed, Apr 22, 2020</time>，华为任正非表示:华为的操作系统要想超越安卓和苹果的操作系统，可能需要很长时间，但不会超过300年。 </span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2020" startmonth="7" startday="9" style="border-bottom: 1px solid rgb(220, 224, 226);">Thu, Jul 9, 2020</time> , 余承東指出，美國針對華為的制裁主要會令他們無法發佈新手機，而很多跟 Android 系統相關的生態亦無法再使用。所以，華為已積極建構屬於自己的生態，其中一環就是投資鴻蒙系統。他透露，鴻蒙系統正在不斷改進中，現階段已經可以達到 Android 系統七至八成的水平。</span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2020" startmonth="9" startday="10" style="border-bottom: 1px solid rgb(220, 224, 226);">Thu, Sep 10, 2020</time>，鸿蒙OS 2.0发布。智能电视屏幕、智能手表和车载系统的鸿蒙2.0系统，会即日推出Beta版，而智能手机的Beta版本则会在2020年12月推出，会率先向中国国内的开发者发布和提供。 </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AliOS Things</span></span><ul><li><span class="name"><span class="innerContentContainer">阿里推出的轻量级物联网操作系统，在MCU上实现的具备轻量级内核态的RTOS。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SylixOS</span></span><ul><li><span class="name"><span class="innerContentContainer">北京翼辉信息技术有限公司</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RT-Thread</span></span><ul><li><span class="name"><span class="innerContentContainer">中国开源社区主导的开源物联网操作系统。由上海睿赛德电子科技有限公司拥有。</span></span></li><li><span class="name"><span class="innerContentContainer">累积装机量超过2亿台。</span></span></li><li><span class="name"><span class="innerContentContainer">有非常强的可伸缩能力：</span></span></li><li><span class="name"><span class="innerContentContainer">从一个可以运行在ARM Cortex-M0芯片上的极小内核，到中等的ARM Cortex-M3/4/7系统，甚至是运行于ARM Cortex-A系列处理器上的功能丰富系统。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">技德系统</span></span><ul><li><span class="name"><span class="innerContentContainer">采用了麒麟安全内核，独创了安卓兼容层技术，使技德系统在保证安全的前提下，兼容海量安卓生态应用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">四位计算机的原理及其实现 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">操作系统的分类</span></span><ul><li><span class="name"><span class="innerContentContainer">单内核</span></span><ul><li><span class="name"><span class="innerContentContainer">整个系统为一个单独的进程来实现, 所有内核服务都在同一个地址空间内运行. 可直接调用函数.</span></span></li><li><span class="name"><span class="innerContentContainer">Linux属于单内核.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">微内核</span></span><ul><li><span class="name"><span class="innerContentContainer">内核功能划分为多个独立进程, 分别有自己的地址空间. </span></span></li><li><span class="name"><span class="innerContentContainer">所以不能直接调用函数, 而是通过IPC消息来完成内核通讯. </span></span></li><li><span class="name"><span class="innerContentContainer">优势在于安全, 一个进程的死掉一般不影响另一个. </span></span></li><li><span class="name"><span class="innerContentContainer">缺点是IPC开销较之函数调用大很多, 所以性能不佳. </span></span></li><li><span class="name"><span class="innerContentContainer">WinNT 和 mac osx 都属于微内核.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux的取舍</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux 提供了抢占式内核, 支持内核线程, 以及动态装载内核模块的功能, 汲取了微内核的精华.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux 方案设计的务实态度</span></span><ul><li><span class="name"><span class="innerContentContainer">任何改变都要针对现实中确实存在的问题, 经过完善的设计并有正确简洁的实现.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">多级缓存</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">任务管理</span></span><ul><li><span class="name"><span class="innerContentContainer">进程</span></span></li><li><span class="name"><span class="innerContentContainer">线程</span></span></li><li><span class="name"><span class="innerContentContainer">协程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设备管理</span></span></li><li><span class="name"><span class="innerContentContainer">文件系统</span></span></li><li><span class="name"><span class="innerContentContainer">桌面子系统</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux桌面子系统</span></span><ul><li><span class="name"><span class="innerContentContainer">KDE</span></span><ul><li><span class="name"><span class="innerContentContainer">1998年发布第一个版本.</span></span></li><li><span class="name"><span class="innerContentContainer">基于QT.</span></span></li><li><span class="name"><span class="innerContentContainer">Ubuntu, OpenSUSE, Fedora 都支持.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GNOME</span></span><ul><li><span class="name"><span class="innerContentContainer">1999年发布第一版.</span></span></li><li><span class="name"><span class="innerContentContainer">2011年发布GNOME3, 激怒了很多人, 导致Mate和 cinnamon的出现.</span></span></li><li><span class="name"><span class="innerContentContainer">GNOME 是Fedora的默认桌面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Unity</span></span><ul><li><span class="name"><span class="innerContentContainer">Unity是Ubuntu为cinnamon开发的一个外壳, 在GNOME上运行.</span></span></li><li><span class="name"><span class="innerContentContainer">显示风格类似于Mac.</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #浏览器">#<span class="contentTagText">浏览器</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">JS引擎</span></span><ul><li><span class="name"><span class="innerContentContainer">Node 的是 V8.</span></span></li><li><span class="name"><span class="innerContentContainer">Chrome 的是 V8.</span></span></li><li><span class="name"><span class="innerContentContainer">Safari 的是 JavaScript Core.</span></span></li><li><span class="name"><span class="innerContentContainer">Firefox 的是 SpiderMonkey.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数据库">#<span class="contentTagText">数据库</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">基础理论</span></span><ul><li><span class="name"><span class="innerContentContainer">关系数据库设计的三大范式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MySQL</span></span><ul><li><span class="name"><span class="innerContentContainer">原理</span></span></li><li><span class="name"><span class="innerContentContainer">InnoDB</span></span></li><li><span class="name"><span class="innerContentContainer">优化</span></span></li><li><span class="name"><span class="innerContentContainer">索引</span></span><ul><li><span class="name"><span class="innerContentContainer">聚集索引, 非聚集索引</span></span></li><li><span class="name"><span class="innerContentContainer">复合索引</span></span></li><li><span class="name"><span class="innerContentContainer">自适应哈希索引(AHI)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">explain</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">NoSQL</span></span><ul><li><span class="name"><span class="innerContentContainer">MongoDB</span></span></li><li><span class="name"><span class="innerContentContainer">Hbase</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">中间件</span></span><ul><li><span class="name"><span class="innerContentContainer">Web Server</span></span><ul><li><span class="name"><span class="innerContentContainer">Nginx</span></span></li><li><span class="name"><span class="innerContentContainer">OpenResty</span></span></li><li><span class="name"><span class="innerContentContainer">Tengine</span></span></li><li><span class="name"><span class="innerContentContainer">Apache Httpd</span></span></li><li><span class="name"><span class="innerContentContainer">Tomcat</span></span><ul><li><span class="name"><span class="innerContentContainer">架构原理</span></span></li><li><span class="name"><span class="innerContentContainer">调优方案</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Jetty</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缓存</span></span><ul><li><span class="name"><span class="innerContentContainer">本地缓存</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">客户端缓存</span></span></li><li><span class="name"><span class="innerContentContainer">服务端缓存</span></span><ul><li><span class="name"><span class="innerContentContainer">Web缓存</span></span></li><li><span class="name"><span class="innerContentContainer">Memcached</span></span></li><li><span class="name"><span class="innerContentContainer">Redis</span></span><ul><li><span class="name"><span class="innerContentContainer">架构</span></span></li><li><span class="name"><span class="innerContentContainer">回收策略</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Tair</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">消息队列</span></span><ul><li><span class="name"><span class="innerContentContainer">消息总线</span></span></li><li><span class="name"><span class="innerContentContainer">消息的顺序</span></span></li><li><span class="name"><span class="innerContentContainer">RabbitMQ</span></span></li><li><span class="name"><span class="innerContentContainer">RocketMQ</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveMQ</span></span></li><li><span class="name"><span class="innerContentContainer">Kafka</span></span></li><li><span class="name"><span class="innerContentContainer">Redis 消息推送</span></span></li><li><span class="name"><span class="innerContentContainer">ZeroMQ</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定时调度</span></span><ul><li><span class="name"><span class="innerContentContainer">单机定时调度</span></span></li><li><span class="name"><span class="innerContentContainer">分布式定时调度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RPC</span></span><ul><li><span class="name"><span class="innerContentContainer">Dubbo</span></span></li><li><span class="name"><span class="innerContentContainer">Thrift</span></span></li><li><span class="name"><span class="innerContentContainer">gRPC</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库中间件</span></span><ul><li><span class="name"><span class="innerContentContainer">Sharding Jdbc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">日志系统</span></span><ul><li><span class="name"><span class="innerContentContainer">日志搜集</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">配置中心</span></span></li><li><span class="name"><span class="innerContentContainer">API 网关</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #互联网技术">#<span class="contentTagText">互联网技术</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Hacker 文化史  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #互联网">#<span class="contentTagText">互联网</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">WAREZ 无形帝国   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #互联网">#<span class="contentTagText">互联网</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">互联网之子 – Aaron Swartz  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #互联网">#<span class="contentTagText">互联网</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">协议</span></span><ul><li><span class="name"><span class="innerContentContainer">OSI 七层协议</span></span></li><li><span class="name"><span class="innerContentContainer">TCP/IP</span></span></li><li><span class="name"><span class="innerContentContainer">HTTP</span></span></li><li><span class="name"><span class="innerContentContainer">HTTP2.0</span></span></li><li><span class="name"><span class="innerContentContainer">HTTPS</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络模型</span></span><ul><li><span class="name"><span class="innerContentContainer">Epoll</span></span></li><li><span class="name"><span class="innerContentContainer">Java NIO</span></span></li><li><span class="name"><span class="innerContentContainer">kqueue</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">连接和短连接</span></span></li><li><span class="name"><span class="innerContentContainer">框架</span></span></li><li><span class="name"><span class="innerContentContainer">零拷贝（Zero-copy）</span></span></li><li><span class="name"><span class="innerContentContainer">序列化(二进制协议)</span></span><ul><li><span class="name"><span class="innerContentContainer">Hessian</span></span></li><li><span class="name"><span class="innerContentContainer">Protobuf</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟化</span></span><ul><li><span class="name"><span class="innerContentContainer">KVM</span></span></li><li><span class="name"><span class="innerContentContainer">Xen</span></span></li><li><span class="name"><span class="innerContentContainer">OpenVZ</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">容器技术</span></span><ul><li><span class="name"><span class="innerContentContainer">Docker</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #通讯">#<span class="contentTagText">通讯</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #运营商">#<span class="contentTagText">运营商</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">运营商商业模式</span></span><ul><li><span class="name"><span class="innerContentContainer">从整体趋势讲，电信运营商主要的动力来自于新增用户。</span></span></li><li><span class="name"><span class="innerContentContainer">但目前(2015年)，行业已经不可能找到下一个10亿客户了。</span></span></li><li><span class="name"><span class="innerContentContainer">运营商正处在向基建转变的痛苦时期.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #华为问题">#<span class="contentTagText">华为问题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #5G">#<span class="contentTagText">5G</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">中国的“鸡肋”3G标准： 一场失败的爱国实验 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #通讯">#<span class="contentTagText">通讯</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><time startyear="2020" startmonth="6" startday="1" style="border-bottom: 1px solid rgb(220, 224, 226);">Mon, Jun 1, 2020</time> ，对路人车辆的监控，自动识别。 <span class="contentTag" title="Filter @iVideo">@<span class="contentTagText">iVideo</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="9" startday="3" style="border-bottom: 1px solid rgb(220, 224, 226);">Tue, Sep 3, 2019</time> , 今天在微博看到了这张图，画面里的女生正身处教室，她的旁边是她睡觉、举手、趴桌子和阅读次数的人工智能识别. <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">人脸识别  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #人工智能">#<span class="contentTagText">人工智能</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">人脸识别  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">人工智能管理学生1  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">人工智能管理学生2  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">人工智能管理学生3  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Twitter上的每一句评论都会被实时监控  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">境外采集数据  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><time startyear="2019" startmonth="5" startday="13" style="border-bottom: 1px solid rgb(220, 224, 226);">Mon, May 13, 2019</time>, 华为推出了学生定制手机，这款手机自带管控，校方可以通过统一平台对全校学生手机进行管理，在指定的时间内手机会自动锁死，自动过滤5亿条不良信息，支持学校资源共享，推送学校通知，规行为系统也可以进行记录。它就是定制版华为nova 4手机，价格2499元。&nbsp;<span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #华为问题">#<span class="contentTagText">华为问题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #监控系统">#<span class="contentTagText">监控系统</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #互联网防火墙">#<span class="contentTagText">互联网防火墙</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">被中国大陆封锁网站列表: <a class="contentLink" target="_blank" rel="noreferrer" href="https://zh.wikipedia.org/wiki/被中国大陆封锁网站列表">https://zh.wikipedia.org/wiki/被中国大陆封锁网站列表</a>  <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #云计算">#<span class="contentTagText">云计算</span><span class="contentTagNub"></span></span> （硬件, 非本地化）</span></span><ul><li><span class="name"><span class="innerContentContainer">云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务）。</span></span></li><li><span class="name"><span class="innerContentContainer">云的本质是为了采样方便. 过程即结局. <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">之所以有云计算?</span></span><ul><li><span class="name"><span class="innerContentContainer">廉价pc硬件, 使得堆机器成为可能.</span></span></li><li><span class="name"><span class="innerContentContainer">单机的成本/容量是非线性的，所以分布式的核心是线性的水平扩展整个集群的功能. 包括:</span></span></li><li><span class="name"><span class="innerContentContainer">集群协调管理机制</span></span></li><li><span class="name"><span class="innerContentContainer">容量与弹性伸缩</span></span></li><li><span class="name"><span class="innerContentContainer">数据和状态一致性</span></span></li><li><span class="name"><span class="innerContentContainer">容错和故障恢复</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Google的老五篇</span></span><ul><li><span class="name"><span class="innerContentContainer">Google File System</span></span></li><li><span class="name"><span class="innerContentContainer">MapReduce</span></span></li><li><span class="name"><span class="innerContentContainer">Bigtable</span></span></li><li><span class="name"><span class="innerContentContainer">Cluster</span></span></li><li><span class="name"><span class="innerContentContainer">Chubby</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">云存储 (比较简单)</span></span></li><li><span class="name"><span class="innerContentContainer">IaaS，基础设施即服务，云主机，云PC</span></span><ul><li><span class="name"><span class="innerContentContainer">供应商提供操作系统，存储和网络。</span></span></li><li><span class="name"><span class="innerContentContainer">核心技术是操作系统虚拟化。关键因素有：</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟操作系统</span></span><ul><li><span class="name"><span class="innerContentContainer">linux</span></span></li><li><span class="name"><span class="innerContentContainer">windows</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">宿主系统</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟驱动</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主要供应商：vmware</span></span></li><li><span class="name"><span class="innerContentContainer">OpenStack</span></span></li><li><span class="name"><span class="innerContentContainer">Docker</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PaaS，平台即服务，云服务</span></span><ul><li><span class="name"><span class="innerContentContainer">供应商还提供中间件，运行时，引擎。客户自己完成数据和应用。</span></span></li><li><span class="name"><span class="innerContentContainer">本质是把每个函数和数据分配一个ip地址，放在公网上访问。</span></span></li><li><span class="name"><span class="innerContentContainer">并行编程模型，MapReduce。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分布存储，包括google的GFS和hadoop。</span></span></li><li><span class="name"><span class="innerContentContainer">数据管理技术，例如bigtable。</span></span></li><li><span class="name"><span class="innerContentContainer">主要供应商：微软 Azure，亚马逊 AWS，Google App Engine。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">半PaaS：基础设施和平台都一样，但是硬件放在内网。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>SaaS</b>：软件即服务。一般表现为一个网站。（SaaS和大数据实际上是同一个概念）</span></span><ul><li><span class="name"><span class="innerContentContainer">Google 的秘密- PageRank 彻底解说 中文版 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">浅析PageRank算法 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">搜索的始祖和原理 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">供应商还提供数据和应用。</span></span></li><li><span class="name"><span class="innerContentContainer">Google搜索引擎就是最典型的SaaS。还有比如github。</span></span></li><li><span class="name"><span class="innerContentContainer">软件给人带来的最大的困扰是什么呢?  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">是软件复用.  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">软件看起来是非常容易复用的. ctrl c + ctrl v搞定一切, 本应该比任何其它人类产品都更容易复用才对.</span></span></li><li><span class="name"><span class="innerContentContainer">但是, 有一些非外行人所能理解的原因, 导致软件复用相当困难.</span></span></li><li><span class="name"><span class="innerContentContainer">聪明人思考这个问题有70多年了. </span></span></li><li><span class="name"><span class="innerContentContainer">最新的答案是云计算.</span></span></li><li><span class="name"><span class="innerContentContainer">云计算的本质是给每个代码块分配一个IP地址, 放在公网上. 你访问这个IP, 就等于访问了这个代码块.</span></span></li><li><span class="name"><span class="innerContentContainer">这么做一下子解决了3个问题:</span></span><ul><li><span class="name"><span class="innerContentContainer">可访问性问题.</span></span><ul><li><span class="name"><span class="innerContentContainer">可访问。</span></span></li><li><span class="name"><span class="innerContentContainer">可计费</span></span></li><li><span class="name"><span class="innerContentContainer">可停止访问</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">唯一性问题. </span></span><ul><li><span class="name"><span class="innerContentContainer">网址和公网IP天生是全球唯一的。</span></span></li><li><span class="name"><span class="innerContentContainer">解决了唯一性，就不用重复发明轮子了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">客户端和服务器端各自演进的问题</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码块这个概念的演进历史</span></span><ul><li><span class="name"><span class="innerContentContainer">库，包，API。其实都一个意思，就是一堆函数。</span></span></li><li><span class="name"><span class="innerContentContainer">引擎</span></span></li><li><span class="name"><span class="innerContentContainer">平台</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">半SaaS：运行在内网，供应商只提供应用，不接触数据。</span></span><ul><li><span class="name"><span class="innerContentContainer">但是用这些数据训练出的AI模型可带走。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">边缘计算</span></span><ul><li><span class="name"><span class="innerContentContainer">是一种介于云计算和本地计算之间的一层解决方案。</span></span></li><li><span class="name"><span class="innerContentContainer">因为IoT不需要把所有的信息传到云端去解决。比如一栋写字楼的智能化管理，最好在楼内就可以解决。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #大数据">#<span class="contentTagText">大数据</span><span class="contentTagNub"></span></span> （后端）</span></span><ul><li><span class="name"><span class="innerContentContainer">大数据的本质是为了将来的全数据时代提供访问数据的能力.  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">以后的数据的量级是这样的:    <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">每个人, 每秒种产生100个数据, 每天产生1000万数据, 每年产生 200亿个数据.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">全球70亿人, 每年产生 1400亿亿个数据.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">面对这样的采样率, 一切抽象化, 比如单位, 企业, 阶级, 民族, 国家, 种族, 校友, 老乡, 宗族, 都失去价值了.    <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">为什么这样讲呢?</span></span></li><li><span class="name"><span class="innerContentContainer">首先, 这些东西本身存在的价值在于它们是钥匙, 钥匙的本质就是用小东西控制大东西. </span></span></li><li><span class="name"><span class="innerContentContainer">为什么要用小东西控制大东西? 因为大东西我们拿不动, 至少不能低成本的拿.</span></span></li><li><span class="name"><span class="innerContentContainer">一旦我们拿得动大东西, 谁还去拿小东西?</span></span></li><li><span class="name"><span class="innerContentContainer">比如说你有一个空间戒指, 任何东西都可以放进去, 而且放进去就没有重量了, 那么, 你还需要房子干什么呢? 你什么都带在身上就好了.</span></span></li><li><span class="name"><span class="innerContentContainer">云的目的, 就在于低成本的完成这种密度的采样.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">大数据的目的, 就是每时每刻都能读写 1400亿亿个数据.    <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">AI的目的, 就在于瞬间分析完这些数据, 然后给你提供最优的判断和选择.  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">有这样的数据的支撑, </span></span></li><li><span class="name"><span class="innerContentContainer">我还需要组建企业干什么呢? </span></span></li><li><span class="name"><span class="innerContentContainer">我还需要去民政局登记结婚干什么呢?</span></span></li><li><span class="name"><span class="innerContentContainer">我还需要统计GDP干什么呢?</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">比数据库更大。</span></span></li><li><span class="name"><span class="innerContentContainer">大数据的特点是：</span></span><ul><li><span class="name"><span class="innerContentContainer">记录多（时间长）</span></span></li><li><span class="name"><span class="innerContentContainer">字段多（客观事物自身的属性维度本身就多）</span></span></li><li><span class="name"><span class="innerContentContainer">多数字段是空（收集全数据成本太高）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">搜索引擎原理</span></span></li><li><span class="name"><span class="innerContentContainer">全文检索库</span></span><ul><li><span class="name"><span class="innerContentContainer">Lucene</span></span></li><li><span class="name"><span class="innerContentContainer">Elasticsearch</span></span></li><li><span class="name"><span class="innerContentContainer">Solr</span></span></li><li><span class="name"><span class="innerContentContainer">sphinx</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">大数据的前身</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库时代的界面系统叫IMS。</span></span></li><li><span class="name"><span class="innerContentContainer">大数据库时代的界面系统叫BI（商业智慧），支撑决策。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">访问方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">文件</span></span></li><li><span class="name"><span class="innerContentContainer">SQL</span></span></li><li><span class="name"><span class="innerContentContainer">多维分析（OLAP）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">流式计算</span></span><ul><li><span class="name"><span class="innerContentContainer">Storm</span></span></li><li><span class="name"><span class="innerContentContainer">Flink</span></span></li><li><span class="name"><span class="innerContentContainer">Kafka Stream</span></span></li><li><span class="name"><span class="innerContentContainer">应用场景</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Hadoop：分布式计算框架</span></span><ul><li><span class="name"><span class="innerContentContainer">分布式文件系统（Hadoop Distributed File System，HDFS），负责存储。</span></span></li><li><span class="name"><span class="innerContentContainer">YARN，负责集群管理和调度，相当于进程调度。</span></span></li><li><span class="name"><span class="innerContentContainer">MapReduce，定义了集群上处理数据的基本操作，即分布式编程模型，相当于SDK。其设计原则是把所有计算都拆成Map和Reduce两个过程。</span></span><ul><li><span class="name"><span class="innerContentContainer">Map(映射)：</span></span></li><li><span class="name"><span class="innerContentContainer">Reduce(化简)：就是将业务逻辑复杂的处理调度给处理能力比较高的计算机，将处理能力小的处理给小型的计算机。</span></span></li><li><span class="name"><span class="innerContentContainer">数据处理可以分解为由多个Job（包含一个Mapper和一个Reducer）组成的有向无环图（DAG）,然后每个Mapper和Reducer放到Hadoop集群上执行，就可以得出结果。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Hive ：构建在MapReduce框架之上的类SQL查询引擎。</span></span></li><li><span class="name"><span class="innerContentContainer">Hbase：基于HDFS的键值对存储系统为Hadoop提供了联机事务处理(OLTP)能力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Spark：分布式计算框架（成熟中）</span></span><ul><li><span class="name"><span class="innerContentContainer">大数据引擎。</span></span></li><li><span class="name"><span class="innerContentContainer">万物都是RDD，在RDD之上你可以方便地进行更高层的操作。</span></span></li><li><span class="name"><span class="innerContentContainer">和hadoop相比，优势是：</span></span><ul><li><span class="name"><span class="innerContentContainer">内存数据库性能比hadoop快100倍。</span></span></li><li><span class="name"><span class="innerContentContainer">开发易用性较高。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">前端</span></span><ul><li><span class="name"><span class="innerContentContainer">Web前端</span></span><ul><li><span class="name"><span class="innerContentContainer">jsp</span></span></li><li><span class="name"><span class="innerContentContainer">html/css</span></span></li><li><span class="name"><span class="innerContentContainer">php</span></span><ul><li><span class="name"><span class="innerContentContainer">smarty(MVC模式)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">java</span></span><ul><li><span class="name"><span class="innerContentContainer">SSH框架</span></span><ul><li><span class="name"><span class="innerContentContainer">Struts(MVC)</span></span></li><li><span class="name"><span class="innerContentContainer">Spring</span></span></li><li><span class="name"><span class="innerContentContainer">Hibernate</span></span><ul><li><span class="name"><span class="innerContentContainer">数据表对象化</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SSM框架（更流行）</span></span><ul><li><span class="name"><span class="innerContentContainer">Spring</span></span><ul><li><span class="name"><span class="innerContentContainer">2003年推出。</span></span></li><li><span class="name"><span class="innerContentContainer">核心思想是IoC（控制反转），即不再需要程序员去显式地`new`一个对象，而是让Spring框架帮你来完成这一切。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SpringMVC</span></span><ul><li><span class="name"><span class="innerContentContainer">负责拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MyBatis</span></span><ul><li><span class="name"><span class="innerContentContainer">MyBatis对jdbc的封装。mybatis通过配置文件关联到各实体类的Mapper文件，其中配置了每个类对数据库所需进行的sql语句映射。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Python</span></span><ul><li><span class="name"><span class="innerContentContainer">django(MTV模式)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">PC前端</span></span><ul><li><span class="name"><span class="innerContentContainer">C# </span></span></li><li><span class="name"><span class="innerContentContainer">C++</span></span><ul><li><span class="name"><span class="innerContentContainer">QT</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">手机前端</span></span><ul><li><span class="name"><span class="innerContentContainer">Android</span></span><ul><li><span class="name"><span class="innerContentContainer">java</span></span></li><li><span class="name"><span class="innerContentContainer">Kotlin</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IOS</span></span><ul><li><span class="name"><span class="innerContentContainer">object C</span></span></li><li><span class="name"><span class="innerContentContainer">Swift</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>编程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">编程语言是推动软件技术发展最有力的技术之一。</span></span></li><li><span class="name"><span class="innerContentContainer">函数库，引擎，框架，平台，其实是一个意思。只是羞于用旧词，所以不断发明新词。  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">软件的本质是依赖. 它是人脑对物质世界的理解或投影。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #程序员">#<span class="contentTagText">程序员</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">IDE</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #导入工程">#<span class="contentTagText">导入工程</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #快捷键映射">#<span class="contentTagText">快捷键映射</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #更换主题">#<span class="contentTagText">更换主题</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F1文件名查找">#<span class="contentTagText">F1文件名查找</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F2符号查找">#<span class="contentTagText"><u>F2符号查找</u></span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F3上一处">#<span class="contentTagText">F3上一处</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F4下一处">#<span class="contentTagText">F4下一处</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F5全文检索">#<span class="contentTagText">F5全文检索</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F6关键字高亮">#<span class="contentTagText">F6关键字高亮</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F7已打开文件列表">#<span class="contentTagText">F7已打开文件列表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F8书签列表">#<span class="contentTagText">F8书签列表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F9加书签">#<span class="contentTagText">F9加书签</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常规算法</span></span><ul><li><span class="name"><span class="innerContentContainer">算法复杂度速查表   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">排序、查找算法</span></span><ul><li><span class="name"><span class="innerContentContainer">排序大的分类可以分为两种：内排序和外排序。</span></span><ul><li><span class="name"><span class="innerContentContainer">在排序过程中，全部记录存放在内存，则称为内排序.</span></span></li><li><span class="name"><span class="innerContentContainer">如果排序过程中需要使用外存，则称为外排序。</span></span></li><li><span class="name"><span class="innerContentContainer">下面讲的排序都是属于内排序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">插入排序</span></span><ul><li><span class="name"><span class="innerContentContainer">每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。分为: </span></span></li><li><span class="name"><span class="innerContentContainer">直接插入排序</span></span><ul><li><span class="name"><span class="innerContentContainer">时间复杂度: O(n2)</span></span></li><li><span class="name"><span class="innerContentContainer">稳定.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">二分法插入排序</span></span><ul><li><span class="name"><span class="innerContentContainer">找合适的插入位置时, 采用二分法查找. 因为已排序子集是有序的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">希尔排序</span></span><ul><li><span class="name"><span class="innerContentContainer">先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序.</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">选择排序</span></span><ul><li><span class="name"><span class="innerContentContainer">每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。</span></span></li><li><span class="name"><span class="innerContentContainer">直接选择排序</span></span><ul><li><span class="name"><span class="innerContentContainer">在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(n2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">堆排序</span></span><ul><li><span class="name"><span class="innerContentContainer">堆排序是一种树形选择排序，是对直接选择排序的有效改进。</span></span></li><li><span class="name"><span class="innerContentContainer">初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">交换排序</span></span><ul><li><span class="name"><span class="innerContentContainer">冒泡排序</span></span><ul><li><span class="name"><span class="innerContentContainer">在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(n2)</span></span></li><li><span class="name"><span class="innerContentContainer">稳定.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">快速排序</span></span><ul><li><span class="name"><span class="innerContentContainer">选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">归并排序</span></span><ul><li><span class="name"><span class="innerContentContainer">归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li><li><span class="name"><span class="innerContentContainer">稳定</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">桶排序</span></span><ul><li><span class="name"><span class="innerContentContainer">直接桶排序</span></span><ul><li><span class="name"><span class="innerContentContainer">将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</span></span></li><li><span class="name"><span class="innerContentContainer">然后对每个桶内的元素进行排序。可以选择任意一种排序算法。</span></span></li><li><span class="name"><span class="innerContentContainer">最后将将各个桶中的元素合并成一个大的有序序列。</span></span></li><li><span class="name"><span class="innerContentContainer">假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为 O(n)+O(m)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk 。当 k 接近于 n 时，桶排序的时间复杂度就可以认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">计数排序</span></span><ul><li><span class="name"><span class="innerContentContainer">计数排序本质上是一种特殊的桶排序，当桶的个数取最大( maxV-minV+1 )的时候，就变成了计数排序。</span></span></li><li><span class="name"><span class="innerContentContainer">和桶排序过程比较像，差别在于桶的数量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基数排序</span></span><ul><li><span class="name"><span class="innerContentContainer">将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，按照个位、十位、百位、...依次来排。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(d(n+r))</span></span></li><li><span class="name"><span class="innerContentContainer">稳定.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">二分查找</span></span></li><li><span class="name"><span class="innerContentContainer">Java 中的排序</span></span><ul><li><span class="name"><span class="innerContentContainer">Collections.sort算法调用的是归并排序。</span></span></li><li><span class="name"><span class="innerContentContainer">Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">布隆过滤器</span></span><ul><li><span class="name"><span class="innerContentContainer">常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。</span></span></li><li><span class="name"><span class="innerContentContainer">注意：会有一定的错误率。</span></span></li><li><span class="name"><span class="innerContentContainer">优点：空间和时间效率都很高。 </span></span></li><li><span class="name"><span class="innerContentContainer">缺点：随着存入的元素数量增加，误算率随之增加。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串比较</span></span><ul><li><span class="name"><span class="innerContentContainer">KMP 算法</span></span><ul><li><span class="name"><span class="innerContentContainer">KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">深度优先</span></span><ul><li><span class="name"><span class="innerContentContainer">一条路走到黑, 到黑再回头重走.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">广度优先</span></span><ul><li><span class="name"><span class="innerContentContainer">先遍历完所有邻居, 再找邻居的邻居.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态规划</span></span><ul><li><span class="name"><span class="innerContentContainer">动态规划是一个广泛的概念. 它的基本理念是把一个复杂问题分解为多个简单问题, 然后按照一定的顺序解决这些简单问题, 并把它们的解组合成复杂问题的解.</span></span></li><li><span class="name"><span class="innerContentContainer">动态规划算法有如下几种:</span></span></li><li><span class="name"><span class="innerContentContainer">贪心算法</span></span><ul><li><span class="name"><span class="innerContentContainer">贪心算法每次取当前最佳的，期望通过所有的局部最优解的总和来产生一个全局最优解。</span></span></li><li><span class="name"><span class="innerContentContainer">设计贪心算法的步骤:</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 将优化问题转换成多个子问题, 先基于当前之问题做出最优选择，然后再解决下一个子问题。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 证明原问题总是有一个最优解是贪心选择的得到的，从而说明贪心选择的安全。</span></span></li><li><span class="name"><span class="innerContentContainer">3. 说明在做出贪心选择后，剩下的子问题具有这样一个性质, 即如果将子问题的最优解和我们所做的贪心选择联合起来，可以得到一个更加负责的动态规划解。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">背包问题</span></span><ul><li><span class="name"><span class="innerContentContainer">问题: 给定N个物品和一个容量为C的背包,物品i的重量为Wi，其价值为Vi，背包问题是如何选择装入背包的物品，使得装入背包中物品的总价值最大。</span></span></li><li><span class="name"><span class="innerContentContainer">三种贪心思想：</span></span><ul><li><span class="name"><span class="innerContentContainer">选择价值最大的物品</span></span></li><li><span class="name"><span class="innerContentContainer">选择重量最轻的物品</span></span></li><li><span class="name"><span class="innerContentContainer">选择单位重量价值最大的物品</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">毫无疑问，我们当然选择第三种。先把性价比最高的全部装入，最后不足全部装入的部分装入。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">贪心算法的优势是简单高效, 一步到位, 没有"回溯"过程. 但是缺点就是往往找不到全局最优解, 而且差距甚大.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">回溯算法</span></span><ul><li><span class="name"><span class="innerContentContainer">许多复杂的，规模较大的问题都可以使用回溯法，所以它有“通用解题方法”的美称。</span></span></li><li><span class="name"><span class="innerContentContainer">回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。走不通就退回再走.</span></span></li><li><span class="name"><span class="innerContentContainer">满足回溯条件的某个状态的点称为“回溯点”。</span></span></li><li><span class="name"><span class="innerContentContainer">在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">剪枝算法</span></span><ul><li><span class="name"><span class="innerContentContainer">一种基于剪枝（ α-βcut-off）的深度优先搜索（depth-first search）。</span></span></li><li><span class="name"><span class="innerContentContainer">将走棋方定为MAX方，因为它选择着法时总是对其子节点的评估值取极大值，即选择对自己最为有利的着法；</span></span></li><li><span class="name"><span class="innerContentContainer">将应对方定为MIN方，因为它走棋时需要对其子节点的评估值取极小值，即选择对走棋方最为不利的、最有钳制作用的着法。</span></span></li><li><span class="name"><span class="innerContentContainer">α-β剪枝是根据极大-极小搜索规则的进行的，虽然它没有遍历某些子树的大量节点，但它仍不失为穷尽搜索的本性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">经典动态规划</span></span><ul><li><span class="name"><span class="innerContentContainer">可以采用动态规划算法进行解决的一个重要性质即是该问题必须具备最优子结构性质.</span></span></li><li><span class="name"><span class="innerContentContainer">最优子结构性质, 指原问题的最优解必然包含了原问题的子问题的一个最优解。</span></span></li><li><span class="name"><span class="innerContentContainer">最短路径规划问题</span></span><ul><li><span class="name"><span class="innerContentContainer">解决步骤是: </span></span></li><li><span class="name"><span class="innerContentContainer">从终点开始, 从终点的邻居开始, 计算每个点到终点的最短距离. </span></span></li><li><span class="name"><span class="innerContentContainer">一直延伸到始点, 此时的最短距离即为答案.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态规划算法每一次都会保留所有可能的选择策略中的最优者，因为总体的最优必然包含某个局部最优解.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">朴素贝叶斯</span></span><ul><li><span class="name"><span class="innerContentContainer">贝叶斯定理: P(B|A)=P(A|B)P(B) / P(A)</span></span><ul><li><span class="name"><span class="innerContentContainer">换个形式就是: P(类别|特征)=P(特征|类别)P(类别) / P(特征)</span></span></li><li><span class="name"><span class="innerContentContainer">P(A)称为"先验概率"（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。</span></span></li><li><span class="name"><span class="innerContentContainer">P(A|B)称为"后验概率"（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。</span></span></li><li><span class="name"><span class="innerContentContainer">P(B|A)/P(B)称为"可能性函数"（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。</span></span></li><li><span class="name"><span class="innerContentContainer">后验概率　＝　先验概率 ｘ 调整因子</span></span></li><li><span class="name"><span class="innerContentContainer">这就是贝叶斯推断的含义。我们先预估一个"先验概率"，然后加入实验结果，看这个实验到底是增强还是削弱了"先验概率"，由此得到更接近事实的"后验概率"。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故称.</span></span></li><li><span class="name"><span class="innerContentContainer">朴素贝叶斯分类是其中最简单的, 也是较常见的.</span></span></li><li><span class="name"><span class="innerContentContainer">举例, 假定姑娘们判断嫁不嫁, 会考虑4个特征: 帅不帅, 性格好不好, 高不高, 上进不上进</span></span><ul><li><span class="name"><span class="innerContentContainer">现在有个男生, 4个特征分别是不帅，性格不好，身高矮，不上进, 那么女生是嫁还是不嫁？</span></span></li><li><span class="name"><span class="innerContentContainer">即比较 p(嫁|(不帅、性格不好、身高矮、不上进))与 p(不嫁|(不帅、性格不好、身高矮、不上进)), 哪个概率大? </span></span></li><li><span class="name"><span class="innerContentContainer">直接求p(嫁|(不帅、性格不好、身高矮、不上进)) 不容易, 但是可以应用贝叶斯定理, 将其转化为好求的3个量:</span></span><ul><li><span class="name"><span class="innerContentContainer">p (不帅、性格不好、身高矮、不上进|嫁)</span></span><ul><li><span class="name"><span class="innerContentContainer">它等于 p(不帅|嫁)*p(性格不好|嫁)*p(身高矮|嫁)*p(不上进|嫁). 分别统计这几个概率, 就可以得出结果.</span></span></li><li><span class="name"><span class="innerContentContainer">不过这个等式要成立, 要求各特征之间相互独立.</span></span></li><li><span class="name"><span class="innerContentContainer">这就是朴素的来历, 朴素贝叶斯算法是假设各个特征之间相互独立.</span></span></li><li><span class="name"><span class="innerContentContainer">这一假设使得朴素贝叶斯法变得简单，但有时会牺牲分类准确率。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">p (不帅、性格不好、身高矮、不上进)</span></span></li><li><span class="name"><span class="innerContentContainer">p(嫁)</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">推荐算法通常被分为如下4类:</span></span></li><li><span class="name"><span class="innerContentContainer">协同过滤推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐</span></span></li><li><span class="name"><span class="innerContentContainer">输入：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）</span></span></li><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">基于邻域的协同过滤（基于用户和基于项）</span></span></li><li><span class="name"><span class="innerContentContainer">基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">需要最小域</span></span></li><li><span class="name"><span class="innerContentContainer">不需要用户和项</span></span></li><li><span class="name"><span class="innerContentContainer">大部分场景中能够产生足够好的结果</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">冷启动问题</span></span></li><li><span class="name"><span class="innerContentContainer">需要标准化产品</span></span></li><li><span class="name"><span class="innerContentContainer">需要很高的用户和项的比例（1：10）</span></span></li><li><span class="name"><span class="innerContentContainer">流行度偏见（有长尾的时候表现不够好）</span></span></li><li><span class="name"><span class="innerContentContainer">难于提供解释</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">基于内容的推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：向用户推荐和其过去喜欢项的内容（例如元数据、描述、话题等等）相似的项</span></span></li><li><span class="name"><span class="innerContentContainer">输入：仅仅依赖于项和用户的内容 / 描述（除了惯用数据）</span></span></li><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">信息检索（例如 tf-idf 和 Okapi BM25）</span></span></li><li><span class="name"><span class="innerContentContainer">机器学习（例如朴素贝叶斯、支持向量机、决策树等等）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">没有冷启动问题</span></span></li><li><span class="name"><span class="innerContentContainer">不需要惯用数据</span></span></li><li><span class="name"><span class="innerContentContainer">没有流行度偏见，可以推荐有罕见特性的项</span></span></li><li><span class="name"><span class="innerContentContainer">可以使用用户内容特性来提供解释</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">项内容必须是机器可读的和有意义的</span></span></li><li><span class="name"><span class="innerContentContainer">容易归档用户</span></span></li><li><span class="name"><span class="innerContentContainer">很难有意外，缺少多样性</span></span></li><li><span class="name"><span class="innerContentContainer">很难联合多个项的特性</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">混合推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：综合利用协同过滤推荐算法和基于内容的推荐算法各自的优点同时抵消各自的缺点</span></span></li><li><span class="name"><span class="innerContentContainer">输入：同时使用用户和项的内容特性与惯用数据，同时从两种输入类型中获益</span></span></li><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">加权</span></span></li><li><span class="name"><span class="innerContentContainer">交换</span></span></li><li><span class="name"><span class="innerContentContainer">混合</span></span></li><li><span class="name"><span class="innerContentContainer">特性组合</span></span></li><li><span class="name"><span class="innerContentContainer">案列</span></span></li><li><span class="name"><span class="innerContentContainer">特征增强</span></span></li><li><span class="name"><span class="innerContentContainer">元层次</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">由于单独使用协同过滤推荐算法和基于内容的推荐算法</span></span></li><li><span class="name"><span class="innerContentContainer">没有冷启动问题</span></span></li><li><span class="name"><span class="innerContentContainer">没有流行度偏见，可推荐有罕见特性的项</span></span></li><li><span class="name"><span class="innerContentContainer">可产生意外，实现多样性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">需要通过大量的工作才能得到正确的平衡</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">流行度推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：这是一种推荐流行项的方法 (例如最多下载、最多看过、最大影响的项)</span></span></li><li><span class="name"><span class="innerContentContainer">输入：使用惯用数据和项的内容（例如类目）</span></span></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">相对容易实现</span></span></li><li><span class="name"><span class="innerContentContainer">良好的基准算法</span></span></li><li><span class="name"><span class="innerContentContainer">有助于解决新用户冷启动问题</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">需要标准化产品</span></span></li><li><span class="name"><span class="innerContentContainer">经常需要一些项的类型进行分类</span></span></li><li><span class="name"><span class="innerContentContainer">不会推荐新项（很少有机会被观测到）</span></span></li><li><span class="name"><span class="innerContentContainer">推荐列表不会改变太大</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">高级非传统推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">深度学习</span></span></li><li><span class="name"><span class="innerContentContainer">学习等级</span></span></li><li><span class="name"><span class="innerContentContainer">Multi-armed bandits（探索 / 开发）</span></span></li><li><span class="name"><span class="innerContentContainer">上下文感知推荐</span></span></li><li><span class="name"><span class="innerContentContainer">张量分解</span></span></li><li><span class="name"><span class="innerContentContainer">分解机</span></span></li><li><span class="name"><span class="innerContentContainer">社会推荐</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">利于勉强维持最终性能百分点</span></span></li><li><span class="name"><span class="innerContentContainer">你可以说你正在使用渐进的方式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">难于理解</span></span></li><li><span class="name"><span class="innerContentContainer">缺乏推荐工具支持</span></span></li><li><span class="name"><span class="innerContentContainer">没有为你的首个推荐系统提供推荐的方式</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">最小生成树算法</span></span><ul><li><span class="name"><span class="innerContentContainer">Kruskal算法</span></span><ul><li><span class="name"><span class="innerContentContainer">此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</span></span></li><li><span class="name"><span class="innerContentContainer">1. 把图中的所有边按代价从小到大排序；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 把图中的n个顶点看成独立的n棵树组成的森林；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</span></span></li><li><span class="name"><span class="innerContentContainer">4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Prim算法</span></span><ul><li><span class="name"><span class="innerContentContainer">此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</span></span></li><li><span class="name"><span class="innerContentContainer">图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</span></span></li><li><span class="name"><span class="innerContentContainer">在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</span></span></li><li><span class="name"><span class="innerContentContainer">重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</span></span></li><li><span class="name"><span class="innerContentContainer">由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">最短路径算法</span></span><ul><li><span class="name"><span class="innerContentContainer">从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径. 解决问题的算法：</span></span></li><li><span class="name"><span class="innerContentContainer">迪杰斯特拉算法（Dijkstra算法）</span></span><ul><li><span class="name"><span class="innerContentContainer">迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</span></span></li><li><span class="name"><span class="innerContentContainer">Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，</span></span></li><li><span class="name"><span class="innerContentContainer">然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">弗洛伊德算法（Floyd算法）</span></span></li><li><span class="name"><span class="innerContentContainer">SPFA算法</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">算法</span></span><ul><li><span class="name"><span class="innerContentContainer">显示</span></span></li><li><span class="name"><span class="innerContentContainer">照片效果</span></span></li><li><span class="name"><span class="innerContentContainer">定位</span></span></li><li><span class="name"><span class="innerContentContainer">空间寻路</span></span></li><li><span class="name"><span class="innerContentContainer">物体识别</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据结构</span></span><ul><li><span class="name"><span class="innerContentContainer">链表、数组</span></span><ul><li><span class="name"><span class="innerContentContainer">数组的特点是访问很快，但是元素的插入和删除很慢。</span></span></li><li><span class="name"><span class="innerContentContainer">List主要分为3类，ArrayList， LinkedList和Vector。</span></span></li><li><span class="name"><span class="innerContentContainer">Vector是ArrayList的线程安全版，它的方法前都加了synchronized锁，其他实现逻辑都相同。</span></span></li><li><span class="name"><span class="innerContentContainer">List是一个有序的集合, 允许有空值, 也允许等值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">集合</span></span></li><li><span class="name"><span class="innerContentContainer">队列</span></span><ul><li><span class="name"><span class="innerContentContainer">队列是一个先入先出（FIFO）的数据结构.</span></span></li><li><span class="name"><span class="innerContentContainer">Java中用Queue类. Queue接口与List、Set同一级别，都是继承了Collection接口。</span></span></li><li><span class="name"><span class="innerContentContainer">非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</span></span></li><li><span class="name"><span class="innerContentContainer">阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字典、关联数组</span></span></li><li><span class="name"><span class="innerContentContainer">栈</span></span><ul><li><span class="name"><span class="innerContentContainer">java中 Stack 是线程安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">内部使用数组保存数据，不够时翻倍。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">树</span></span><ul><li><span class="name"><span class="innerContentContainer">二叉树</span></span><ul><li><span class="name"><span class="innerContentContainer">每个节点最多有两个叶子节点。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">完全二叉树</span></span><ul><li><span class="name"><span class="innerContentContainer">叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">平衡二叉树</span></span><ul><li><span class="name"><span class="innerContentContainer">左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">二叉查找树（BST）</span></span><ul><li><span class="name"><span class="innerContentContainer">二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">红黑树</span></span><ul><li><span class="name"><span class="innerContentContainer">红黑树是一个平衡的二叉树，但不完美。虽然我们希望一个所有查找都能在~lgN次比较内结束，但是这样在动态插入中保持树的完美平衡代价太高，所以我们稍微放松逛一下限制，希望找到一个能在对数时间内完成查找的数据结构。</span></span></li><li><span class="name"><span class="innerContentContainer">红黑树需要满足的五条性质：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 节点是红色或者是黑色；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 根节点是黑色；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 每个叶节点（NIL或空节点）是黑色；</span></span></li><li><span class="name"><span class="innerContentContainer">4. 每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）</span></span></li><li><span class="name"><span class="innerContentContainer">5. 从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可以通过数学来证明，满足这五条性质的二叉树可以将查找删除维持在对数时间内。</span></span></li><li><span class="name"><span class="innerContentContainer">添加阶段后，左旋或者右旋从而再次达到平衡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">B，B+，B*树</span></span><ul><li><span class="name"><span class="innerContentContainer">B-树是一种平衡的多路搜索树（并不一定是二叉的）.</span></span></li><li><span class="name"><span class="innerContentContainer">B+树是应文件系统所需而出的一种B-树的变型树。B+树在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</span></span></li><li><span class="name"><span class="innerContentContainer">B*书: 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3.</span></span></li><li><span class="name"><span class="innerContentContainer">B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。</span></span></li><li><span class="name"><span class="innerContentContainer">MySQL是基于B+树聚集索引组织表.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LSM 树</span></span><ul><li><span class="name"><span class="innerContentContainer">LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</span></span></li><li><span class="name"><span class="innerContentContainer">B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</span></span></li><li><span class="name"><span class="innerContentContainer">LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</span></span></li><li><span class="name"><span class="innerContentContainer">极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</span></span></li><li><span class="name"><span class="innerContentContainer">Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">BitSet</span></span><ul><li><span class="name"><span class="innerContentContainer">经常用于大规模数据的排重检查。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">图</span></span><ul><li><span class="name"><span class="innerContentContainer">连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</span></span></li><li><span class="name"><span class="innerContentContainer">强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</span></span></li><li><span class="name"><span class="innerContentContainer">连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</span></span></li><li><span class="name"><span class="innerContentContainer">生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</span></span></li><li><span class="name"><span class="innerContentContainer">最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">设计模式 <span class="contentTag" title="Filter #模型">#<span class="contentTagText">模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">生产者消费者模型的作用是什么?</span></span><ul><li><span class="name"><span class="innerContentContainer">通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。</span></span></li><li><span class="name"><span class="innerContentContainer">解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">是否设计过通用的组件？  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">请设计一个通用的 Dialog（弹出层）组件</span></span></li><li><span class="name"><span class="innerContentContainer">会提供什么接口？</span></span></li><li><span class="name"><span class="innerContentContainer">可能会遇到什么细节问题？</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DDD(Domain-driven Design - 领域驱动设计)</span></span><ul><li><span class="name"><span class="innerContentContainer">命令查询职责分离(CQRS)</span></span></li><li><span class="name"><span class="innerContentContainer">贫血，充血模型</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Actor 模式</span></span></li><li><span class="name"><span class="innerContentContainer">响应式编程</span></span><ul><li><span class="name"><span class="innerContentContainer">Reactor</span></span></li><li><span class="name"><span class="innerContentContainer">RxJava</span></span></li><li><span class="name"><span class="innerContentContainer">Vert.x</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DODAF2.0</span></span></li><li><span class="name"><span class="innerContentContainer">Serverless</span></span></li><li><span class="name"><span class="innerContentContainer">Service Mesh</span></span></li><li><span class="name"><span class="innerContentContainer">软件框架要解决的首要问题是什么？</span></span><ul><li><span class="name"><span class="innerContentContainer">为了区别变化和不变的部分提供工具支撑。</span></span></li><li><span class="name"><span class="innerContentContainer">COM如何做到这一点？</span></span><ul><li><span class="name"><span class="innerContentContainer">如果只是实现变化，接口不变，则无问题。如A调用B，A和B各自演进，且没有彼此的源代码；只要接口不变就无问题。</span></span></li><li><span class="name"><span class="innerContentContainer">如果接口变化，需要调用方适配新旧两种接口，保证向下兼容。在A和B中，旧A不可以调用新B，其它组合无问题。</span></span></li><li><span class="name"><span class="innerContentContainer">作为A，可以在运行时探测系统中存在哪个版本的B，并决定该用哪种接口，这是COM的强大之处，也是COM设计时要搞定的首要问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">hal体现了google对产业的理解力</span></span><ul><li><span class="name"><span class="innerContentContainer">linux基金会与硬件厂商的矛盾不可调和。</span></span></li><li><span class="name"><span class="innerContentContainer">hal将linux架空，解决了这个问题，也就释放了产业界的威力。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>设计模式的若干原则  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">单一职责原则: 就一个类而言，应该仅有一个引起它变化的原因。</span></span></li><li><span class="name"><span class="innerContentContainer">开闭原则：一个软件实体应当对扩展开放，对修改关闭。</span></span></li><li><span class="name"><span class="innerContentContainer">里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象。</span></span></li><li><span class="name"><span class="innerContentContainer">依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。</span></span></li><li><span class="name"><span class="innerContentContainer">接口隔离原则：客户端不应该依赖那些它不需要的接口。</span></span></li><li><span class="name"><span class="innerContentContainer">迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。</span></span></li><li><span class="name"><span class="innerContentContainer">重用发布等价原则: 重用的粒度就是发布的粒度.</span></span></li><li><span class="name"><span class="innerContentContainer">共用封闭原则: </span></span><ul><li><span class="name"><span class="innerContentContainer">包中的所有类对于同一类性质的变化应该是共同封闭的。</span></span></li><li><span class="name"><span class="innerContentContainer">一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">共同重用原则: 一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中所有类。</span></span></li><li><span class="name"><span class="innerContentContainer">稳定依赖原则: 朝着稳定的方向进行依赖。</span></span></li><li><span class="name"><span class="innerContentContainer">稳定抽象原则: 包的抽象程度应该和其稳定程度一致。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>23种常见设计模式</b></span></span><ul><li><span class="name"><span class="innerContentContainer">1995 年，GoF（Gang of Four，四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。</span></span></li><li><span class="name"><span class="innerContentContainer">根据目的对这23种模式进行分类, 如下:</span></span></li><li><span class="name"><span class="innerContentContainer">创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。</span></span><ul><li><span class="name"><span class="innerContentContainer">单例</span></span><ul><li><span class="name"><span class="innerContentContainer">Singleton</span></span></li><li><span class="name"><span class="innerContentContainer">某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">原型</span></span><ul><li><span class="name"><span class="innerContentContainer">Prototype</span></span></li><li><span class="name"><span class="innerContentContainer">将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工厂方法：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Factory Method</span></span></li><li><span class="name"><span class="innerContentContainer">定义一个用于创建产品的接口，由子类决定生产什么产品。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抽象工厂</span></span><ul><li><span class="name"><span class="innerContentContainer">Abstract Factory</span></span></li><li><span class="name"><span class="innerContentContainer">提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建造者</span></span><ul><li><span class="name"><span class="innerContentContainer">Builder</span></span></li><li><span class="name"><span class="innerContentContainer">将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">构型模式：用于描述如何将类或对象按某种布局组成更大的结构.</span></span><ul><li><span class="name"><span class="innerContentContainer">代理</span></span><ul><li><span class="name"><span class="innerContentContainer">Proxy</span></span></li><li><span class="name"><span class="innerContentContainer">为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适配器：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Adapter</span></span></li><li><span class="name"><span class="innerContentContainer">将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">桥接</span></span><ul><li><span class="name"><span class="innerContentContainer">Bridge</span></span></li><li><span class="name"><span class="innerContentContainer">将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">装饰</span></span><ul><li><span class="name"><span class="innerContentContainer">Decorator</span></span></li><li><span class="name"><span class="innerContentContainer">动态的给对象增加一些职责，即增加其额外的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">外观</span></span><ul><li><span class="name"><span class="innerContentContainer">Facade</span></span></li><li><span class="name"><span class="innerContentContainer">为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">享元</span></span><ul><li><span class="name"><span class="innerContentContainer">Flyweight</span></span></li><li><span class="name"><span class="innerContentContainer">运用共享技术来有效地支持大量细粒度对象的复用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">组合</span></span><ul><li><span class="name"><span class="innerContentContainer">Composite</span></span></li><li><span class="name"><span class="innerContentContainer">将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</span></span><ul><li><span class="name"><span class="innerContentContainer">模板方法：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Template Method</span></span></li><li><span class="name"><span class="innerContentContainer">定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">策略</span></span><ul><li><span class="name"><span class="innerContentContainer">Strategy</span></span></li><li><span class="name"><span class="innerContentContainer">定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">命令</span></span><ul><li><span class="name"><span class="innerContentContainer">Command</span></span></li><li><span class="name"><span class="innerContentContainer">将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">职责链</span></span><ul><li><span class="name"><span class="innerContentContainer">Chain of Responsibility</span></span></li><li><span class="name"><span class="innerContentContainer">把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">状态</span></span><ul><li><span class="name"><span class="innerContentContainer">State</span></span></li><li><span class="name"><span class="innerContentContainer">允许一个对象在其内部状态发生改变时改变其行为能力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">观察者</span></span><ul><li><span class="name"><span class="innerContentContainer">Observer</span></span></li><li><span class="name"><span class="innerContentContainer">多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中介者</span></span><ul><li><span class="name"><span class="innerContentContainer">Mediator</span></span></li><li><span class="name"><span class="innerContentContainer">定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">迭代器</span></span><ul><li><span class="name"><span class="innerContentContainer">Iterator</span></span></li><li><span class="name"><span class="innerContentContainer">提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">访问者</span></span><ul><li><span class="name"><span class="innerContentContainer">Visitor</span></span></li><li><span class="name"><span class="innerContentContainer">在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">备忘录</span></span><ul><li><span class="name"><span class="innerContentContainer">Memento</span></span></li><li><span class="name"><span class="innerContentContainer">在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">解释器：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Interpreter</span></span></li><li><span class="name"><span class="innerContentContainer">提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用场景</span></span></li><li><span class="name"><span class="innerContentContainer">单例模式</span></span></li><li><span class="name"><span class="innerContentContainer">责任链模式</span></span></li><li><span class="name"><span class="innerContentContainer">MVC模式-史前的模式</span></span><ul><li><span class="name"><span class="innerContentContainer">Model : Hold Your Application’s Data</span></span><ul><li><span class="name"><span class="innerContentContainer">通常可以理解为数据模型及其算法, 负责执行程序的核心运算与判断逻辑.</span></span></li><li><span class="name"><span class="innerContentContainer">通过 view获得用户 输入的数据,</span></span></li><li><span class="name"><span class="innerContentContainer">然后根据从数据库查询相关的信息,</span></span></li><li><span class="name"><span class="innerContentContainer">最后进行运算和判断, 将得到的结果交给 view来显示.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Controller: Binds the model and view together and is the application logic;&nbsp;Decides How to Handle the Users Inputs。</span></span><ul><li><span class="name"><span class="innerContentContainer">控制器,作为 model与 view之间的枢纽, 负责控制程序的执行流程以及对象之间的互动.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">View: the user can see&nbsp; and interact with it.</span></span><ul><li><span class="name"><span class="innerContentContainer">用户的操作接口, 就是 GUI,应该使用哪种接口组件,组件间的排列位置与顺序都需要设计.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">IOC</span></span></li><li><span class="name"><span class="innerContentContainer">AOP</span></span></li><li><span class="name"><span class="innerContentContainer">微服务思想</span></span><ul><li><span class="name"><span class="innerContentContainer">康威定律</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">UML</span></span><ul><li><span class="name"><span class="innerContentContainer">统一建模语言（Unified Modeling Language，UML）是用来做软件设计的可视化建模语言.</span></span></li><li><span class="name"><span class="innerContentContainer">1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。</span></span></li><li><span class="name"><span class="innerContentContainer">它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</span></span></li><li><span class="name"><span class="innerContentContainer">类图</span></span><ul><li><span class="name"><span class="innerContentContainer">类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。</span></span></li><li><span class="name"><span class="innerContentContainer">类使用包含类名、属性和操作且带有分隔线的矩形来表示。包括如下元素：</span></span></li><li><span class="name"><span class="innerContentContainer">类名（Name）是一个字符串，例如，Student。</span></span></li><li><span class="name"><span class="innerContentContainer">属性（Attribute）是指类的特性，即类的成员变量。格式如下：[可见性]属性名:类型[=默认值]</span></span><ul><li><span class="name"><span class="innerContentContainer">可见性：表示该属性对类外的元素是否可见</span></span><ul><li><span class="name"><span class="innerContentContainer">+ 公有</span></span></li><li><span class="name"><span class="innerContentContainer">- 私有</span></span></li><li><span class="name"><span class="innerContentContainer"># 受保护</span></span></li><li><span class="name"><span class="innerContentContainer">~ 朋友</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例如：-name:String</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。格式如下：[可见性]名称(参数列表)[:返回类型]</span></span></li><li><span class="name"><span class="innerContentContainer">例如：+display():void。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接口：接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。</span></span><ul><li><span class="name"><span class="innerContentContainer">它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。</span></span></li><li><span class="name"><span class="innerContentContainer">接口使用一个带有名称的小圆圈来进行表示。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类之间的关系</span></span><ul><li><span class="name"><span class="innerContentContainer">继承关系，is-a，空心三角剪头，实线，指向父类</span></span><ul><li><span class="name"><span class="innerContentContainer">也叫泛化（Generalization）关系。继承是对象之间耦合度最大的一种关系，是 is-a 的关系。</span></span></li><li><span class="name"><span class="innerContentContainer">泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关联关系，has-a，即包含关系，普通剪头，实线，指向被包含方</span></span><ul><li><span class="name"><span class="innerContentContainer">关联关系指一个类的对象作为另一个类的成员变量 这种情况。</span></span></li><li><span class="name"><span class="innerContentContainer">单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。</span></span></li><li><span class="name"><span class="innerContentContainer">双向的关联可以用带两个箭头或者没有箭头的实线来表示。</span></span></li><li><span class="name"><span class="innerContentContainer">也可以在关联线的两端标注角色名，代表两种不同的角色。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">聚合关系，尾部空心菱形剪头，实线，指向被包含的类</span></span><ul><li><span class="name"><span class="innerContentContainer">聚合（Aggregation）关系是强的关联关系，是整体和部分之间的关系。</span></span></li><li><span class="name"><span class="innerContentContainer">聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</span></span></li><li><span class="name"><span class="innerContentContainer">在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">组合关系，尾部实心菱形剪头，实线，指向被包含的类</span></span><ul><li><span class="name"><span class="innerContentContainer">组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种最强的聚合关系，是 contains-a 关系。</span></span></li><li><span class="name"><span class="innerContentContainer">在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，头和嘴的关系，没有了头，嘴也就不存在了。</span></span></li><li><span class="name"><span class="innerContentContainer">在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意，组合关系和聚合关系在一些场景下不分，都按 聚合关系 算。</span></span></li><li><span class="name"><span class="innerContentContainer">依赖关系，use-a，调用关系，普通剪头，虚线，指向被调用方</span></span><ul><li><span class="name"><span class="innerContentContainer">依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。</span></span></li><li><span class="name"><span class="innerContentContainer">在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</span></span></li><li><span class="name"><span class="innerContentContainer">依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实现关系，接口和实现之间，空心三角剪头，虚线，指向接口</span></span><ul><li><span class="name"><span class="innerContentContainer">实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</span></span></li><li><span class="name"><span class="innerContentContainer">在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">分布式设计</span></span><ul><li><span class="name"><span class="innerContentContainer">扩展性设计</span></span></li><li><span class="name"><span class="innerContentContainer">稳定性 &amp; 高可用</span></span><ul><li><span class="name"><span class="innerContentContainer">硬件负载均衡</span></span></li><li><span class="name"><span class="innerContentContainer">软件负载均衡</span></span></li><li><span class="name"><span class="innerContentContainer">限流</span></span></li><li><span class="name"><span class="innerContentContainer">应用层容灾</span></span></li><li><span class="name"><span class="innerContentContainer">跨机房容灾</span></span></li><li><span class="name"><span class="innerContentContainer">容灾演练流程</span></span></li><li><span class="name"><span class="innerContentContainer">平滑启动</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库扩展</span></span><ul><li><span class="name"><span class="innerContentContainer">读写分离模式</span></span></li><li><span class="name"><span class="innerContentContainer">分片模式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务治理</span></span><ul><li><span class="name"><span class="innerContentContainer">服务注册与发现</span></span></li><li><span class="name"><span class="innerContentContainer">服务路由控制</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分布式一致</span></span><ul><li><span class="name"><span class="innerContentContainer">CAP 与 BASE 理论</span></span></li><li><span class="name"><span class="innerContentContainer">分布式锁</span></span></li><li><span class="name"><span class="innerContentContainer">分布式一致性算法</span></span><ul><li><span class="name"><span class="innerContentContainer">PAXOS</span></span></li><li><span class="name"><span class="innerContentContainer">Zab</span></span></li><li><span class="name"><span class="innerContentContainer">Raft</span></span></li><li><span class="name"><span class="innerContentContainer">Gossip</span></span></li><li><span class="name"><span class="innerContentContainer">两阶段提交、多阶段提交</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">幂等</span></span></li><li><span class="name"><span class="innerContentContainer">分布式一致方案</span></span></li><li><span class="name"><span class="innerContentContainer">分布式 Leader 节点选举</span></span></li><li><span class="name"><span class="innerContentContainer">TCC(Try/Confirm/Cancel) 柔性事务</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分布式文件系统</span></span></li><li><span class="name"><span class="innerContentContainer">唯一ID 生成</span></span><ul><li><span class="name"><span class="innerContentContainer">全局唯一ID</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致性Hash算法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DevOps</span></span><ul><li><span class="name"><span class="innerContentContainer">Code + Operate 合一; </span></span></li><li><span class="name"><span class="innerContentContainer">Test + Deploy 高度自动化, 由一两个人负责, 并加入Code组.</span></span></li><li><span class="name"><span class="innerContentContainer">最彻底的方式是, Test + Deploy 由研发工程师轮流值日.</span></span></li><li><span class="name"><span class="innerContentContainer">Code + Test + Deploy + Operate, 四种角色, 使用统一的平台, 工具和质量体系.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">性能</span></span><ul><li><span class="name"><span class="innerContentContainer">性能优化方法论</span></span></li><li><span class="name"><span class="innerContentContainer">容量评估</span></span></li><li><span class="name"><span class="innerContentContainer">CDN 网络</span></span></li><li><span class="name"><span class="innerContentContainer">连接池</span></span></li><li><span class="name"><span class="innerContentContainer">性能调优</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">并发</span></span><ul><li><span class="name"><span class="innerContentContainer">多线程</span></span><ul><li><span class="name"><span class="innerContentContainer">缺点</span></span><ul><li><span class="name"><span class="innerContentContainer">线程安全：由于统一进程下的多个线程是共享同样的地址空间和数据的，又由于线程执行顺序的不可预知性，一个线程可能会修改其他线程正在使用的变量，这一方面是给数据共享带来了便利；另一方面，如果处理不当，会产生脏读，幻读等问题，好在Java提供了一系列的同步机制来帮助解决这一问题，例如内置锁。</span></span></li><li><span class="name"><span class="innerContentContainer">活跃性问题。可能会发生长时间的等待锁，甚至是死锁。</span></span></li><li><span class="name"><span class="innerContentContainer">性能问题。 线程的频繁调度切换会浪费资源，同步机制会导致内存缓冲区的数据无效，以及增加同步流量。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">线程安全</span></span><ul><li><span class="name"><span class="innerContentContainer">定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，则称这个类时线程安全的。线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</span></span></li><li><span class="name"><span class="innerContentContainer">线程安全产生的原因：正确性取决于多个线程的交替执行时序，产生了竞态条件。</span></span></li><li><span class="name"><span class="innerContentContainer">原子类： 应尽量使用原子类，这样会让你分析线程安全时更加方便，但需要注意的是用线程安全类构建的类并不能保证线程安全。例如，一个AtomicInteger get() 和&nbsp;AtomicInteger set() 是线程安全的，在一个类的一个方法 f()中同时用到了这两个方法，此时的f()就是线程不安全的，因为你不能保证这个复合操作中的get 和 set同时更新。</span></span></li><li><span class="name"><span class="innerContentContainer">达到线程安全的措施</span></span><ul><li><span class="name"><span class="innerContentContainer">加锁</span></span><ul><li><span class="name"><span class="innerContentContainer">锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。</span></span></li><li><span class="name"><span class="innerContentContainer">加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。</span></span></li><li><span class="name"><span class="innerContentContainer">加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不共享状态</span></span><ul><li><span class="name"><span class="innerContentContainer">无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。</span></span></li><li><span class="name"><span class="innerContentContainer">线程关闭： 仅在单线程环境下使用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不可变对象</span></span><ul><li><span class="name"><span class="innerContentContainer">可以使用 final 修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">充分挖掘多核性能资源  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">CPU由单核变成多核，理想情况是代码不改动，软件性能可以线性增长。</span></span></li><li><span class="name"><span class="innerContentContainer">多核性能优化涉及的元素包括：OS、编程语言、平台、软件。</span></span></li><li><span class="name"><span class="innerContentContainer">主流架构是SMP（对称多核），目标是代码不动，通过编译器优化指令流，达到平滑过渡。</span></span></li><li><span class="name"><span class="innerContentContainer">linux具有SMP能力，而c/c++不支持，需要用多线程库来重新实现。</span></span></li><li><span class="name"><span class="innerContentContainer">java等基于虚拟机；python、Ruby等动态语言；erlang函数式语言，在SMP方面较之c/c++都有天然的优势。</span></span></li><li><span class="name"><span class="innerContentContainer">另一个架构是AMP（非对称多核），即每个核跑一个OS，OS上再跑多个应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致性、事务</span></span><ul><li><span class="name"><span class="innerContentContainer">事务是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）</span></span></li><li><span class="name"><span class="innerContentContainer">事务的 ACID 特性</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库管理系统中事务(transaction)的四个特性：</span></span><ul><li><span class="name"><span class="innerContentContainer">原子性（Atomicity）</span></span><ul><li><span class="name"><span class="innerContentContainer">原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。可采用“A向B转账”这个例子来说明.</span></span></li><li><span class="name"><span class="innerContentContainer">在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致性（Consistency）</span></span><ul><li><span class="name"><span class="innerContentContainer">一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</span></span></li><li><span class="name"><span class="innerContentContainer">如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</span></span></li><li><span class="name"><span class="innerContentContainer">保障机制：</span></span><ul><li><span class="name"><span class="innerContentContainer">业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</span></span></li><li><span class="name"><span class="innerContentContainer">数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；</span></span></li><li><span class="name"><span class="innerContentContainer">数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">隔离性（Isolation）</span></span><ul><li><span class="name"><span class="innerContentContainer">多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</span></span></li><li><span class="name"><span class="innerContentContainer">在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">持久性（Durability）</span></span><ul><li><span class="name"><span class="innerContentContainer">持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）</span></span></li><li><span class="name"><span class="innerContentContainer">write ahead logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事务的隔离级别</span></span><ul><li><span class="name"><span class="innerContentContainer">未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</span></span></li><li><span class="name"><span class="innerContentContainer">读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</span></span></li><li><span class="name"><span class="innerContentContainer">可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</span></span></li><li><span class="name"><span class="innerContentContainer">序列化：所有事物串行处理（牺牲了效率）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MVCC</span></span><ul><li><span class="name"><span class="innerContentContainer">MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能.</span></span></li><li><span class="name"><span class="innerContentContainer">读锁：也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</span></span></li><li><span class="name"><span class="innerContentContainer">写锁：又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</span></span></li><li><span class="name"><span class="innerContentContainer">表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</span></span></li><li><span class="name"><span class="innerContentContainer">行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</span></span></li><li><span class="name"><span class="innerContentContainer">MVCC 会产生幻读问题（更新时异常）.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">锁</span></span><ul><li><span class="name"><span class="innerContentContainer">Java中的锁和同步类</span></span></li><li><span class="name"><span class="innerContentContainer">公平锁 &amp; 非公平锁</span></span></li><li><span class="name"><span class="innerContentContainer">悲观锁</span></span></li><li><span class="name"><span class="innerContentContainer">乐观锁 &amp; CAS</span></span></li><li><span class="name"><span class="innerContentContainer">ABA 问题</span></span></li><li><span class="name"><span class="innerContentContainer">CopyOnWrite容器</span></span></li><li><span class="name"><span class="innerContentContainer">RingBuffer</span></span></li><li><span class="name"><span class="innerContentContainer">可重入锁 &amp; 不可重入锁</span></span></li><li><span class="name"><span class="innerContentContainer">互斥锁 &amp; 共享锁</span></span></li><li><span class="name"><span class="innerContentContainer">死锁</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>AI</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #知识">#<span class="contentTagText">知识</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">在机器学习中，知识往往以统计模型的形式出现，因为多数知识都是可以统计的，比如所有人都会死，但只有4%是美国人。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #AI">#<span class="contentTagText">AI</span><span class="contentTagNub"></span></span> , <span class="contentTag" title="Filter #人工智能">#<span class="contentTagText">人工智能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">AI 即Artificial Intelligence, 也就是人工智能.</span></span></li><li><span class="name"><span class="innerContentContainer">一种旨在让计算机实现类似人类的智能，尤其是不能通过机械式计算完成的智能行为（智能本身也给出不准确的定义）的技术方案. 比如自动驾驶、文本处理、语言识别、图像识别等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #机器学习">#<span class="contentTagText">机器学习</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个程序可以在任务T上，随着经验E的增加，效果P也可以随之增加，则称这个程序可以从经验中学习。 </span></span></li><li><span class="name"><span class="innerContentContainer">from 卡耐基梅隆大学Mitchell教授，1997. 这个定义得到公认. </span></span></li><li><span class="name"><span class="innerContentContainer">其中, 经验E即训练集，效果P即模型的正确率。</span></span></li><li><span class="name"><span class="innerContentContainer">机器学习是“太阳底下的新鲜事”：一种能够构建自我的技术。在农业当中，我们播种，确保种子有足够的水分和营养，然后等待成熟, 最终收割成熟的作物。我们不需要控制作物生长的每一步。为什么技术不能这样？完全可以，而这也是机器学习的承诺。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b><span class="contentTag" title="Filter #深度学习">#<span class="contentTagText">深度学习</span><span class="contentTagNub"></span></span> , <span class="contentTag" title="Filter #deeplearning">#<span class="contentTagText">deeplearning</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">深度学习是机器学习的一个分支，即深层神经网络。一种通过多层非线性变换对高复杂性数据建模的算法的合集。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>深度学习属于联结主义，</b>它在模拟人类大脑的神经元的联结方式. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">训练相关的几个术语</span></span><ul><li><span class="name"><span class="innerContentContainer">训练（学习）：从数据中习得模型的过程。</span></span></li><li><span class="name"><span class="innerContentContainer">测试：学得模型后，使用其进行预测以检测其可信度的过程。</span></span></li><li><span class="name"><span class="innerContentContainer">数据集：在机器学习任务中使用的一组数据。一般包括训练集, 验证集, 测试集.</span></span></li><li><span class="name"><span class="innerContentContainer">样本：数据集中的每一个数据称为一个样本。</span></span></li><li><span class="name"><span class="innerContentContainer">训练集：训练过程中使用的数据集。</span></span></li><li><span class="name"><span class="innerContentContainer">验证集：用于调整参数。一般把原始数据拿出一小部分（10%-20%）作为验证数据。</span></span></li><li><span class="name"><span class="innerContentContainer">测试集：测试使用的另外一组数据集。测试集要和训练集隔离。</span></span></li><li><span class="name"><span class="innerContentContainer">特征：反映样本在某方面的表现或性质的事项或属性。样本由特征组成。</span></span></li><li><span class="name"><span class="innerContentContainer">特征向量（feature vector）：所有用于描述实体的数字的组合就是该实体的特征向量。是机器学习的输入.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>回归</b>：机器学习的两个主要用途之一。计算机会对输入预测输出数字。学习算法通常会输出一个函数：f: R^n-&gt;R。比如预测股票价格。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>分类</b>：机器学习的两个主要用途之一。即计算机会给出输入X属于k类中的哪一类。为了完成这个任务，学习算法通常会输出一个算法: f:R^n-&gt;{1, k}。比如图像分类就是一种分类任务。分类问题的本质是回归问题。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>泛化</b>：机器学习的目标是使学得的模型能够很好的适用于未知样本，而不是仅仅在已知样本上工作得很好。模型适用于新样本的能力称为“泛化”能力。</span></span></li><li><span class="name"><span class="innerContentContainer">归纳偏置：我们一般都假定问题存在某种形式。</span></span></li><li><span class="name"><span class="innerContentContainer">归纳学习假设：任一假设如果在足够大的训练集中很好的逼近目标函数，它也能在未见样本中很好的逼近目标函数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">误差及解决方案</span></span><ul><li><span class="name"><span class="innerContentContainer">误差：学得的模型在样本上的预测结果与样本的真实结果之间的差异称为误差。</span></span></li><li><span class="name"><span class="innerContentContainer">训练误差：在训练集上的误差。</span></span></li><li><span class="name"><span class="innerContentContainer">泛化误差：在新样本上的误差。我们希望得到泛化误差小的模型。</span></span></li><li><span class="name"><span class="innerContentContainer">过拟合（overfitting）：如果模型的训练误差小，而泛化误差大，则称为过拟合。</span></span></li><li><span class="name"><span class="innerContentContainer">欠拟合（underfitting）：如果训练误差和泛化误差都较大，则称为欠拟合。</span></span></li><li><span class="name"><span class="innerContentContainer">软饱和是指激活函数h(x)在取值趋于无穷大时，它的一阶导数趋于0。 <span class="contentTag" title="Filter #TODO">#<span class="contentTagText">TODO</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">硬饱和是指当|x| &gt; c时，其中c为常数，f '(x)=0。relu就是一类左侧硬饱和激活函数。  <span class="contentTag" title="Filter #TODO">#<span class="contentTagText">TODO</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">机器学习的性能评估指标（针对分类问题）：</span></span><ul><li><span class="name"><span class="innerContentContainer">True Negative(真负，TN)：将负类预测为负类的数量；</span></span></li><li><span class="name"><span class="innerContentContainer">True Positive(真正，TP)：将正类预测为正类的数量；</span></span></li><li><span class="name"><span class="innerContentContainer">False Positive(假正，FP)：将负类预测为正类的数量（误报，type 1 error）</span></span></li><li><span class="name"><span class="innerContentContainer">False Negative（假负，FP）：将负类预测为正类的数量（漏报，type 2 error）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">精确度（Prevision）： P = TP / (TP+FP)</span></span></li><li><span class="name"><span class="innerContentContainer">召回率（recall）：R = TP / (TP+TN)</span></span></li><li><span class="name"><span class="innerContentContainer">准确率（accuracy）：ACC = (TP+TN) / (TP+TN+FP+FN)</span></span></li><li><span class="name"><span class="innerContentContainer">F1值： F1 = 2TP / (2TP+FP+FN)</span></span></li><li><span class="name"><span class="innerContentContainer"><b>批标准化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">目的: 加大梯度. </span></span></li><li><span class="name"><span class="innerContentContainer">优点是:</span></span></li><li><span class="name"><span class="innerContentContainer">1. 加大检索的步长, 加快收敛;</span></span></li><li><span class="name"><span class="innerContentContainer">2. 更容易跳出局部最小值;</span></span></li><li><span class="name"><span class="innerContentContainer">3. 破坏原来的数据分布. 一定程度上缓解了过拟合. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">早期算法 (CNN之前)</span></span><ul><li><span class="name"><span class="innerContentContainer">线性回归（LR）：最简单的模型，但是效果不错，所以非常重要。对于 X=(x1, x2,&nbsp;…,xn)^T 属于 R^(n*p) 表示数据矩阵，其中 xi 属于 R^p 表示一个P维的数据样本； Y=(y1, y2,&nbsp;… ,yn)^T 属于 R^n 表示数组的label，这里只考虑每个样本一类的情况。线性回归的模型是：对于一个样本xi，它的输出值是其特征向量的线性组合：</span></span><ul><li><span class="name"><span class="innerContentContainer">其中 W0 为bias，即偏置。也可以通过x0=1 把W0纳入表达式中。总之，xi有P+1个维度。</span></span></li><li><span class="name"><span class="innerContentContainer">线性模型的最大特点是任意线性模型的组合仍然是线性模型。因此，只通过线性模型，任何层的全连通神经网络和单层神经网络的表达能力没有区别。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">最小均方误差法（LMS，least mean squares）：</span></span><ul><li><span class="name"><span class="innerContentContainer">我们要寻求一个策略，逐步改进V(b)的各权值，使E最小化。E又称为误差函数或损失函数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">支持向量机（SVM）：传统的机器学习的方法。90年代中期到20世纪头10年非常火，目前已式微。是一种二分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器。SVM包括核技巧，这使它成为实质上的非线性分类器。SVM是求解二次规划问题的最优算法。</span></span></li><li><span class="name"><span class="innerContentContainer">GMM模型：混合高斯模型。传统机器学习模型。目前已式微。</span></span></li><li><span class="name"><span class="innerContentContainer">决策树：较有效的决策树算法包括 ID3、C4.5、CART。</span></span></li><li><span class="name"><span class="innerContentContainer">朴素贝叶斯算法（Naive Bayes）：朴素即特征条件独立（正交）。贝叶斯定理：P(y|x) = P(x|y)*P(y) / P(x)。</span></span></li><li><span class="name"><span class="innerContentContainer">K近邻算法（KNN）：分类算法，较成熟和有效。该方案的思路是：如果一个样本在特征空间中的K个最相似（即在特征空间中最邻近）的样本中的大多数属于一个类别，则该样本也属于这个类别。</span></span></li><li><span class="name"><span class="innerContentContainer">感知器（Perceptron/PLA）：一种完成分类的模型，模拟人类大脑神经元结构，通过N个权重来计算N个输入值的加权和，然后通过一个阈值函数得到0或1的输出。感知器即单层神经网络，也即没有隐层的神经网络。目前已经势微。</span></span><ul><li><span class="name"><span class="innerContentContainer">感知器的优势在于自动通过学习来调整权重。它的弱点是只能把数据分为两类，而且数据必须是线性可分的。</span></span></li><li><span class="name"><span class="innerContentContainer">感知器可以表示为 f: R^n → {−1,1} 的映射函数。其中 f 的形式如下：f(x)=sign(w.x+b)</span></span></li><li><span class="name"><span class="innerContentContainer">x是输入数据。w 和 b 都是 N 维向量，是感知器的模型参数；其中W是权值，b是偏置（bias）。感知器的训练过程其实就是求解w 和 b 的过程。正确的 w 和 b 所构成的超平面 w.x+b=0 恰好将两类数据点分割在这个平面的两侧。此时-b可看成是正类的阈值。</span></span></li><li><span class="name"><span class="innerContentContainer">感知器最大的问题是无法模拟异或运算。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">AI世界的诸多角色</span></span><ul><li><span class="name"><span class="innerContentContainer">在信息处理这个生态系统中，学习算法是<b>顶级掠食者</b>。</span></span></li><li><span class="name"><span class="innerContentContainer">数据库、网络爬虫、索引器等相当于<b>食草动物</b>，耐心地对无限领域中的数据进行蚕食。食草动物有必要存在，因为没有它们，其他动物无法存活，但顶级掠食者有更为刺激的生活。</span></span></li><li><span class="name"><span class="innerContentContainer">数据库就像<b>大象</b>，又大又重，永远不会被忽略。</span></span></li><li><span class="name"><span class="innerContentContainer">数据爬虫就像一头<b>牛</b>，网页相当于它的草原，每个网页就是一根草。索引器做一个页面的列表，每个词都会出现在页面当中，很像一本书后的索引。</span></span></li><li><span class="name"><span class="innerContentContainer">统计算法、线上分析处理等则相当于<b>食肉动物</b>。</span></span></li><li><span class="name"><span class="innerContentContainer">在这些动物当中，耐心的野兽飞快运转统计和分析算法，压缩并进行选择，将数据变为信息。</span></span></li><li><span class="name"><span class="innerContentContainer">学习算法是<b>顶级掠食者</b>, 它将这些信息吞下、消化，然后将其变成知识。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AI五大学派. 注意, 深度学习属于联结学派</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #符号学派">#<span class="contentTagText">符号学派</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">符号学派将学习看作逆向演绎，并从哲学、心理学、逻辑学中寻求洞见。</span></span></li><li><span class="name"><span class="innerContentContainer">对于符号学派来说，所有的信息都可以简化为操作符号，知识可以通过符号演算而来。它的主算法是逆向演绎。逆向演绎致力于弄明白，为了使演绎进展顺利，哪些知识被省略了，然后弄明白是什么让主算法变得越来越综合。</span></span></li><li><span class="name"><span class="innerContentContainer">理性主义者喜欢在迈出第一步前，就提前规划好一切。笛卡儿、斯宾诺莎、莱布尼茨是理性主义的代表。</span></span></li><li><span class="name"><span class="innerContentContainer">经验主义者喜欢尝试新事物，然后看看结果会怎样。洛克、贝克莱、休谟则是经验主义的代表。其中休谟是最伟大的一个，他也是符号学派的守护神。</span></span></li><li><span class="name"><span class="innerContentContainer">归纳：在概括我们见过的东西以及没见过的东西时，怎样才能做到合理？（from 休谟）</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们只是假设未来和昨天一样，那么会怎样呢？这当然是一个有风险的假设。如果没有这样的假设，所有知识将不复存在，生活也是如此。虽然有很多不确定性，但我们还是宁可活下来。</span></span></li><li><span class="name"><span class="innerContentContainer">但是，困境依然存在：总有一些现象我们从未见过。这属于机器学习问题：将某结果推广到我们没有见过的事件中。</span></span></li><li><span class="name"><span class="innerContentContainer">大卫·沃尔珀特（DavidWolpert）赋予了这个问题优雅的数学形式。他的研究结果被人们称为“天下没有免费的午餐”定理，规定“怎样才算是好的学习算法”：没有哪个学习算法可以比得上随意猜测。</span></span></li><li><span class="name"><span class="innerContentContainer">这个定理告诉我们：不靠知识进行学习，这样的事不存在；只有数字也不够。</span></span></li><li><span class="name"><span class="innerContentContainer">预设观念对人类认知来说，也是必不可少的，这些观念是“直线布入”人脑的。对于它们，我们也觉得是理所当然的。超出那些观念的偏见才值得质疑。</span></span></li><li><span class="name"><span class="innerContentContainer">我们的目标是找到最简单的、我们能编写的程序，这样写好的程序就可以无限制地通过阅读数据来自行编程，直到该程序掌握所有能掌握的知识。</span></span></li><li><span class="name"><span class="innerContentContainer">如果所有两个因素组合的预测都失败了，你可以尝试任意个数因素的组合，机器学习者和心理学家称之为“合取概念”（conjunctiveconcept）。首先做有条件的假设，如果这样无法解释数据，再放松假设的条件，这就是典型的机器学习。这个过程通常由算法自行进行，不需要你的帮助。首先，算法会尝试所有单一因素，然后尝试所有两个因素的组合，之后就是所有三个因素的组合等。但现在我们遇到一个问题：合取概念太多，没有足够的时间对其逐个尝试。</span></span></li><li><span class="name"><span class="innerContentContainer">客观世界上的事物有个最大的特点就是涉及的因素很多，比如要做一个恋爱速配的算法，人的度量维度很容易就会扩展到100项（这算非常少的了），也就是组合关系有3的100次方种（是、否、无关）。做一次全排列电脑要计算到宇宙末日（其实远远超过宇宙末日）。</span></span></li><li><span class="name"><span class="innerContentContainer">这里有一种方法：暂且假设每个配对都合适，然后排除所有不含有某品质的搭配，对每种品质重复同样的做法，然后选择那个排除了最多不当搭配和最少适当搭配的选项。</span></span></li><li><span class="name"><span class="innerContentContainer">我们学习每个规则之后，会排除该规则包含的正面例子，因此下一个规则会尽可能多地包含剩下的正面例子，以此类推，直到所有的例子都被包含在内。</span></span></li><li><span class="name"><span class="innerContentContainer">记住“天下没有免费的午餐”：没有知识，你就无法进行学习。假设某概念能通过规则集来定义，相当于什么也没有假设。</span></span></li><li><span class="name"><span class="innerContentContainer">学习就意味着将细节遗忘，只记住重要部分。</span></span></li><li><span class="name"><span class="innerContentContainer">问题不限于记忆大量例子。每当算法在数据中找到现实世界世界中不存在的模型时，我们说它与数据过于拟合。过拟合问题是机器学习中的中心问题。在所有主题中，关于过拟合问题的论文最多。每个强大的学习算法，无论是符号学算法、联结学算法，或者其他别的学习算法，都不得不担忧幻觉模式这个问题。避免幻觉模式唯一安全的方法，就是严格限制算法学习的内容，例如要求学习内容是一个简短的合取概念。很遗憾，这种做法就像把孩子和洗澡水一起倒掉一样，会让学习算法无法看到多数真实的模型，这些模型在数据中是可见的。因此，好的学习算法永远在无知与幻觉的夹缝中行走。</span></span></li><li><span class="name"><span class="innerContentContainer">学习算法特别容易过拟合，因为它们拥有从数据中发现模型、近乎无限制的能力。人类发现一个模型所用的时间，计算机可以找到数百万个。在机器学习中，计算机最大的优势（处理大量数据以及不知疲倦不断重复同样步骤的能力）也是它的劣质所在。</span></span></li><li><span class="name"><span class="innerContentContainer">甚至曾有人说过，数据挖掘意味着“折磨数据，直到数据妥协”。</span></span></li><li><span class="name"><span class="innerContentContainer">当你有过多假设，而没有足够的数据将这些假设区分开来时，过拟合问题就发生了。</span></span></li><li><span class="name"><span class="innerContentContainer">在机器学习中，一个概念可能实例的数量，是其属性数量的指数函数：如果属性是布尔值，每种新的属性可能会是实例数量的两倍，方法就是引用之前的每个实例，然后为了那个新属性，对该实例以“是”或“非”来进行扩展。反过来，可能概念的数量是可能实例数量的指数函数：既然每个概念都把实例分成正面或者负面，加入一个实例，可能的概念就会翻倍。因此，概念的数量就是属性数量的指数函数的一个指数函数！换句话说，机器学习就是组合爆炸的组合爆炸。</span></span></li><li><span class="name"><span class="innerContentContainer">幸运的是，一个真实的数据可以排除指数数量的假设。</span></span></li><li><span class="name"><span class="innerContentContainer">总结：学习就是你拥有的数据的数量和你所做假设数量之间的较量。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一个随机定义准确匹配了1000个例子，那么这个概念不太有可能是错误的定义，或者至少它和正确的定义非常接近。而且如果一个定义和100万个例子相匹配，那么实际上它就是正确的定义。</span></span></li><li><span class="name"><span class="innerContentContainer">一般来说，如果学习算法只做了一个指数数量的假设（例如，所有可能的合取概念），那么该数据的指数报酬会将其取消，你毫无影响，只要你有许多例子，且属性不太多。</span></span></li><li><span class="name"><span class="innerContentContainer">如果算法做了一个双指数的假设（例如，所有可能的规则集），那么数据只会取消其中的一个指数，而且你仍会处于麻烦之中。</span></span></li><li><span class="name"><span class="innerContentContainer">哈佛大学的莱斯利·瓦利安特获得了图灵奖，因为他发明了这种分析方法，他在自己的书中将这种方法取名为“可能近似正确”（probably approximately correct），非常恰当。</span></span></li><li><span class="name"><span class="innerContentContainer">在实践中，瓦利安特式的分析方法需要的数据还是要比你拥有的多。那么如何信任算法告诉你的结论呢？很简单，理论必须做出新的预测，而且只有这些预测经过实验验证后，你才接受它们。</span></span></li><li><span class="name"><span class="innerContentContainer">你可以利用自己拥有的数据，将其分成一个训练集和一个测试集，然后前者交给学习算法，把后者隐藏起来不让学习算法发现，用来验证其准确度。留存数据的准确度就是机器学习中的“黄金标准”。</span></span></li><li><span class="name"><span class="innerContentContainer">对于机器学习来说，对不可见数据的测试是必不可少的，因为这是判断学习算法是否过拟合的唯一方法。</span></span></li><li><span class="name"><span class="innerContentContainer">运用统计显著性检验来确保我们看到的模型真实可靠。</span></span></li><li><span class="name"><span class="innerContentContainer">“分而治之”算法会含蓄地选择更简单的规则，因为它在一出现只有正面例子的情况时，就会停止添加条件；在一出现包含所有正面例子的情况时，就会停止添加规则。</span></span></li><li><span class="name"><span class="innerContentContainer">奥卡姆剃刀原理可能是错的。简单的理论更受欢迎，因为它们对于我们来说，花费的认知成本更低；对于我们的算法来说，花费的计算成本更低，这不是因为我们想让这些理论更准确。我们由“天下没有免费的午餐”这个定理，知道没有什么能够保证最简单的理论最擅长概括，而实际上，有些最佳的学习算法，比如推进和支持向量机，能了解那些看起来过于复杂的模型。</span></span></li><li><span class="name"><span class="innerContentContainer">如果得到的检测集不够准确，问题可能存在两方面：</span></span></li><li><span class="name"><span class="innerContentContainer">偏差：某座钟如果总是慢一个小时，那么它的偏差会很高，但方差会很低。</span></span></li><li><span class="name"><span class="innerContentContainer">反差：但如果这座钟走得时快时慢，时快时慢，最后平均下来准点了，那么它的方差会很高，但偏差会很低。</span></span></li><li><span class="name"><span class="innerContentContainer">你可以估算一种学习算法的偏差和方差，方法就是在掌握训练集的随机变量之后，对算法的预测进行对比。</span></span></li><li><span class="name"><span class="innerContentContainer">如果算法一直出错，那么问题就出在偏差上，而你需要一个更为灵活的学习算法（或者只和原来的不一样即可）。</span></span></li><li><span class="name"><span class="innerContentContainer">如果出现的错误无模式可循，问题就出在方差上，而你要么尝试一种不那么灵活的学习算法，要么获取更多的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">大多数学习算法都有一个“把手”，通过旋转“把手”，你可以调节这些算法的灵活度，例如，显著性检验的界限值，或者对于模型规模的惩罚方式。扭动“把手”是你尝试的第一个选择。</span></span></li><li><span class="name"><span class="innerContentContainer">更深层的问题是，多数学习算法开始时掌握的东西很少，即使转再多“把手”，也没法让这些算法到达终点。主算法应该能以大量的知识作为启动（无论这些知识由人类来提供，还是之前已经掌握），然后在对数据做出新概括时，用到这些知识。“分而治之”算法做不到这一点，但是有其它方法。问题的关键在于认识到，归纳仅仅是逆向演绎，就和减法是加法的逆运算，或者积分是微分的逆运算一样。</span></span></li><li><span class="name"><span class="innerContentContainer">演绎推理的一个典型例子就是：苏格拉底是人类。所有人类都会死。所以……</span></span></li><li><span class="name"><span class="innerContentContainer">相反，我们在归纳推理中会以最初事实和衍生事实作为开始，然后找一个规则，让我们由前者推出后者：苏格拉底是人类。……所以苏格拉底也会死。</span></span></li><li><span class="name"><span class="innerContentContainer">缺的那一环是：所有人类都会死。当然，仅通过苏格拉底就归纳出该规则过于草率，但对于其他人类，我们知道相似的事实：柏拉图是人类，他会死。亚里士多德是人类，他会死。以此类推……对于每个事实，我们构建这样的规则，让我们由第一个事实推出第二个事实，然后通过牛顿定律将其推广。当同一条通用规则一次又一次被归纳出来时，我们有信心说那条规则说的是真的。</span></span></li><li><span class="name"><span class="innerContentContainer">我们以越多的规则和事实作为开头，也就有越多的机会运用“逆向演绎”归纳新的规则。我们归纳的规则越多，我们能归纳的规则也就越多。这是知识创造的良性循环，只受过拟合风险和计算成本的限制。</span></span></li><li><span class="name"><span class="innerContentContainer">逆向演绎的另外一个局限性就在于，它涉及很密集的计算，因此很难扩展到海量数据集中。因为这些原因，符号学家选择的算法是决策树归纳。</span></span></li><li><span class="name"><span class="innerContentContainer">有一个方法，就是对规则进行排序，例如以准确率递减的顺序来排列，然后选择符合描述的第一条规则。另一个方法，就是让规则自己选择。决策树通常会保证，每个实例会准确对应一条规则。也就是说，在一次及以上的属性测试中，如果每对规则存在区别，这样的规则集将被组织成一棵决策树。</span></span></li><li><span class="name"><span class="innerContentContainer">看看以下这些规则：如果你支持削减税收，反对堕胎，那么你属于共和党。如果你反对削减税收，那么你属于民主党。如果你支持削减税收，提倡堕胎合法，反对枪械管制，那么你属于独立人士。如果你支持削减税收，提倡堕胎合法，支持枪械管制，那么你属于民主党。这些可以组成一些决策树。</span></span></li><li><span class="name"><span class="innerContentContainer">拥有这个属性的概念组被称为类集，而预测类集的算法称为分类器。单个概念隐含两类定义：概念本身及其反面。分类器是机器学习最为普遍的方式。</span></span></li><li><span class="name"><span class="innerContentContainer">有一个突出的问题，那就是如何挑选最佳属性以便在节点处进行测试。为了学习一棵好的决策树的优点，我们在每个节点选择这样这样的属性：在其所有分支中，产生的熵在平均值上属性最低，取决于每个分支上有多少例子。</span></span></li><li><span class="name"><span class="innerContentContainer">如果属性离散，属性的每个值都有一个分支，这没关系，但如果是数值属性该怎么办？如果连续变量的每个值都有一个分支，决策树将变得无限宽。一个简单的方法就是通过熵来选择几个临界值，然后使这些临界值起作用。</span></span></li><li><span class="name"><span class="innerContentContainer">决策树易于理解，可以快速掌握，而且通常无须太多调整就可以做到准确无误。所以决策树已经发展成为机器学习算法中应用最为广泛的方法。微软的Kinect利用决策树，通过其深度相机的输出信息，可以弄明白你身体的各个部位在哪里，然后利用这些部位的动作来控制Xbox游戏机。</span></span></li><li><span class="name"><span class="innerContentContainer">如何选择根？</span></span></li><li><span class="name"><span class="innerContentContainer">心理学家大卫·马尔称，每个信息处理系统应该经过三个不同水平的研究：该系统所解决问题的基本属性，用来解决问题的算法和表示方法，以及这些算法和表示方法如何实现。</span></span></li><li><span class="name"><span class="innerContentContainer">符号主义是通往终极算法的最短路程。它不要求我们弄明白进化论和大脑的工作原理，而且也避免了贝叶斯主义的数学复杂性。规则集合决策树易于理解，所以我们知道学习算法要做什么。这样它可以轻易算出自己做对或做错什么，找出故障，得出准确结果。</span></span></li><li><span class="name"><span class="innerContentContainer">尽管决策树很受欢迎，但逆向演绎是寻找主算法更好的出发点。因为逆向演绎具备这样的关键属性：可以轻易地将知识并入主算法中，而且我们知道休谟问题使这一点变得很有必要。</span></span></li><li><span class="name"><span class="innerContentContainer">把一棵决策树转变成一个规则集很容易：每条从“根部”到“叶子”的路线是一条规则，而且路线不会崩溃。</span></span></li><li><span class="name"><span class="innerContentContainer">联结学派对符号学派尤其不满。根据他们的观点，你能通过逻辑规则来定义的概念仅仅是冰山一角，其实表面之下还有很多东西是形式推理无法看到的。而同样的道理，我们脑子里所想的东西也是潜意识的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #联结学派">#<span class="contentTagText">联结学派</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">联结学派对大脑进行逆向分析，灵感来源于神经科学和物理学。</span></span></li><li><span class="name"><span class="innerContentContainer">对于联结学派来说，学习就是大脑所做的事情，因此我们要做的就是对大脑进行逆向演绎。大脑通过调整神经元之间连接的强度来进行学习，关键问题是找到哪些连接导致了误差，以及如何纠正这些误差。联结学派的主算法是反向传播学习算法，该算法将系统的输出与想要的结果相比较，然后连续一层一层地改变神经元之间的连接，目的是为了使输出的东西接近想要的东西。</span></span></li><li><span class="name"><span class="innerContentContainer">赫布律，是联结主义的奠基石。联结主义相信知识储存在神经元之间的联结关系中。</span></span></li><li><span class="name"><span class="innerContentContainer">在符号学派中，符号和它们代表的概念之间有一一对应的关系。相反，联结学派的代表方式却是分散式的：每个概念由许多神经元来表示，而每个神经元又会和其他神经元一起代表许多不同的概念。互相激发的神经元会形成赫布所称的“细胞集”。</span></span></li><li><span class="name"><span class="innerContentContainer">一个神经元就有数千个突触。</span></span></li><li><span class="name"><span class="innerContentContainer">每个神经元就像一棵小树，有数目惊人的根须（树突）还有细长蜿蜒的树干（轴突）。大脑就是由数十亿棵这样的树组成的森林，但这些树也有不同寻常的地方：每棵树的枝丫都会和其他数千棵树的根部有连接（突触），形成大片你没见过的纠缠状态。有些神经元有很短的轴突，而有些神经元的轴突则很长，可以从大脑的一边缠绕到另一边。你大脑里轴突的长度相当于地球到月亮的距离。</span></span></li><li><span class="name"><span class="innerContentContainer">感知器不能处理XOR（异或）关系。</span></span></li><li><span class="name"><span class="innerContentContainer">问题在于，没有明确的方法来改变“隐层”中神经元的权值，以减少输出层中神经元造成的误差。每个隐藏的神经元会通过多种路线来影响输出量，而且造成每个误差的原因也可能达到上千种。你该责怪谁？或者，相反，谁该因为正确的输入量而受到赞扬？这个问题在我们努力对一个复杂模型进行学习时随时会出现，而这个问题也是机器学习领域中的中心问题。</span></span></li><li><span class="name"><span class="innerContentContainer">霍普菲尔德注意到自旋玻璃和神经网络之间有趣的相似点：一个电子的自旋对其相邻电子的活动所做的反应和一个神经元的反应十分相似。在电子的情况中，如果相邻电子的加权和超过界限值，电子就会向上翻，反之则向下翻。受到这一点的启发，他确定了一种神经网络，和自旋玻璃一样随着时间的推移而演变，他还提出网络的最低值状态就是它的记忆。每个这样的状态都具备原始状态的“吸引盆”（basinofattraction），原始状态就收敛于该盆中，这样这个网络就可以进行模式识别了。例如，如果其中的一个记忆是由数字9形成的黑白像素模式，而网络看到一个扭曲了的9，它会收敛成“理想”的9，然后据此重新识别它。</span></span></li><li><span class="name"><span class="innerContentContainer">一台玻尔兹曼机器拥有混合的感官和隐藏神经元（分别类似于视网膜和大脑）。它通过清醒和睡眠两种交替状态进行学习，就像人类一样。</span></span></li><li><span class="name"><span class="innerContentContainer">玻尔兹曼机器原则上可以解决赞誉分布问题，但在实践中，学习这个行为非常缓慢且痛苦，对大多数应用来说，玻尔兹曼机器有点不切实际。</span></span></li><li><span class="name"><span class="innerContentContainer">学习算法的“视网膜”看到一张新的图片，这个信号就会在网络中传播，直到它产生输出信息。将这条输出信息和理想的输出信息相比，会发出错误信号，这个信号会穿过神经元层，然后反向传播回去，直到它到达视网膜。根据返回来的信号以及在前进过程中它接收到的输入信息，每个神经元会调整各自的权值。随着网络看到越来越多你祖母和其他人的照片，权值会逐渐收敛到能够让它区分两者的值中。反向传播，比感知器算法要强大很多。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>反向传播是联结学派的主算法。</b></span></span></li><li><span class="name"><span class="innerContentContainer">有了反向传播，你就不必从头开始弄明白怎样对每个神经元的权值进行微调，这样做起来会很慢。你可以一层一层来做，根据调整与其相连神经元的方法，来调整每个神经元。</span></span></li><li><span class="name"><span class="innerContentContainer">反向传播的弱点：反向传播随着渐进权值的变化，不知道该如何找到全局误差最小值，而局部误差值可能会很糟糕。</span></span></li><li><span class="name"><span class="innerContentContainer">但我们最好意识到的是，多数情况下局部最小值挺好的，不会有不良影响。</span></span></li><li><span class="name"><span class="innerContentContainer">更好的消息是，实际上，局部最小值可能更适合，因为它和全局最小值比，不太可能证明对我们的数据过拟合。</span></span></li><li><span class="name"><span class="innerContentContainer">如今联结学派又复活了。我们比现在掌握了更深层的网络，而且这些网络在视觉、语音识别、药物研制和其他领域都在设定新标准。</span></span></li><li><span class="name"><span class="innerContentContainer">往发动机盖下面看……惊喜：是值得信赖的老式反向传播发动机还在嗡嗡作响。什么发生改变了？评论家说，没什么大的改变：只是计算机变得更快了，数据变得更大了。</span></span></li><li><span class="name"><span class="innerContentContainer">下一个聪明的主意就是把稀疏自动编码器逐个堆积起来，就像一个多层三明治那样。第一个自动编码器的隐藏层变成第二个的输入或输出层，依此类推。因为神经元是非线性的，每个隐藏层会掌握输入层更为复杂的表达方式，在前一个隐藏层的基础上进行进行构建。给定大批的面部图片，第一个自动编码器会对局部特征，如棱角和斑点进行编码；第二个自动编码器利用这些信息来对诸如鼻尖、眼睛的虹膜这些面部特征进行编码；第三个掌握整个鼻子和眼睛的面部特征等。最终，最顶端的一层可以是一台传统的感知器，会通过下一层编码器提供的上层特征来识别你的祖母，这和只利用单个隐藏层提供的粗糙信息，以及对所有层进行反向传播相比，要简单得多。</span></span></li><li><span class="name"><span class="innerContentContainer">登上《纽约时报》的谷歌大脑网络是一个由自动编码器和其他材料组成的9层三明治，能够从视频网站YouTube的视频中识别出猫。它包含数十亿个连接，是当时能够进行学习的最大网络。不足为奇的是，吴恩达（该项目的主要负责人之一）也是支持“人类智能可以归结为单个算法”这个思想的主要人物。</span></span></li><li><span class="name"><span class="innerContentContainer">叠加自动编码器不是唯一的深度学习算法，另外一种以玻尔兹曼机器作为基础，还有一种——卷积神经网络，则把视皮质模型作为基础。</span></span></li><li><span class="name"><span class="innerContentContainer">我们不会通过对羽毛进行逆向工程来制造飞机。</span></span></li><li><span class="name"><span class="innerContentContainer">一些人认为，反向传播就是终极算法。但符号学派的人不认可，有很多人能做但是联结系统不能做的事。按照常识进行推理，这就涉及把之前从来没有被放在一起的信息组合在一起。玛丽午饭吃鞋子吗？不，因为玛丽是人，人类只吃能吃的东西，而鞋子不能吃。符号系统做到这些没有问题——它只会把相关规则串起来，但是多层感知器却做不到这一点。一旦完成学习，它只会不断计算同一个指定函数。神经网络不是组合出来的，而语意合成性是人类认知的一大部分。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一个大问题就是人类，以及诸如规则集和决策树之类的符号模型，可以对它们的推理进行解释，而神经网络是一大堆没人能看懂的数字。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #进化学派">#<span class="contentTagText">进化学派</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">进化学派在计算机上模拟进化，并利用遗传学和进化生物学知识。</span></span></li><li><span class="name"><span class="innerContentContainer">进化学派认为一切学习都源于自愿选择。选择造就我们，也造就一切。进化主义解决的关键问题是学习结构：不只是像反向传播那样调整参数，它还创造大脑，用来对参数进行微调。进化学派的主算法是基因编程，和自然使有机体交配和进化那样，基因编程也对计算机程序进行配对和提升。</span></span></li><li><span class="name"><span class="innerContentContainer">遗传算法的关键输入就是一个适应度函数。给定一个待定程序和某个设定的目标，适应度函数会给程序打分，反映它与目标的契合度。</span></span></li><li><span class="name"><span class="innerContentContainer">在自然选择当中，适应度是否能这样解释，值得怀疑：虽然翅膀对于飞行的适应度很高，这个说法很直观，但整个进化过程却没有已知的目标。即便如此，在机器学习中，掌握诸如适应度函数这样的事情还是很容易的。如果我们需要一个能够诊断疾病的程序，如果一种算法能够正确诊断我们数据库中60%的病人，这样的算法就比准确率仅为55%的算法要好，所以可行的适应度函数能够帮助准确诊断。</span></span></li><li><span class="name"><span class="innerContentContainer">就这一点而言，遗传算法就有点像选择育种。</span></span></li><li><span class="name"><span class="innerContentContainer">变量，无论在DNA序列中，还是在位串中，都可通过几种方法产生。最简单的方法就是点突变，即随意翻转位串中的一个比特值，或者改变一段DNA中的单个基本碱基。但对霍兰德来说，遗传算法的真正威力在于更为复杂的东西：性。</span></span></li><li><span class="name"><span class="innerContentContainer">遗传算法通过模拟这个过程发挥作用。它为每一代中两个适应力最强的个体进行配对，通过随机交叉父母位串中的一点，让每对父母生出两个后代。将点突变应用到新的位串后，算法让这些点突变在其虚拟世界中释放。每个点突变都会反馈适应度得分，然后重复这个过程。每一代都会比前一代的适应度更高，当达到理想的适应度或者时间用尽时，这个过程就会结束。</span></span></li><li><span class="name"><span class="innerContentContainer">遗传算法能够频繁作弊的方法，就是允许有永不灭亡的东西（现实生活中却不存在，太糟了）。在那种方法中，适应力很强的个体不仅会在它那一代中为了繁殖而竞争，还会跟它的“儿子”“孙子”“重孙”等竞争，只要在群体中还保留有其中一个适应力最强的个体。</span></span></li><li><span class="name"><span class="innerContentContainer">一旦算法达到适应度的局部最大值（适应度中的峰值），算法会在这一点停很长时间，直到某次幸运的变异或者交叉，让处于坡上的个体等到更高的峰顶，在这一点上该个体会进行大量繁殖，然后和过往的每一代来爬上这个坡。</span></span></li><li><span class="name"><span class="innerContentContainer">遗传算法的灵活之处就在于，每个字符串都暗含指数数量的构造块，被称为“基模”，因此该研究比它看起来的还要高效得多。</span></span></li><li><span class="name"><span class="innerContentContainer">霍兰德表明，和平均值相比，在某代中表示基模的字符串适应度越高——我们能期望的——在下一代中看中看到这些表示字符串的数量也越多。随着时间的流逝，适应度更高的基模会主导群体，所以不像醉汉那样，遗传算法能找到回家的路。</span></span></li><li><span class="name"><span class="innerContentContainer">机器学习中最重要的问题之一（也是关于生命最重要的问题之一），就是探索—利用困境。</span></span></li><li><span class="name"><span class="innerContentContainer">遗传算法还有一个很大的谜团没有解开：性在进化过程中所起的作用。演化新论者论者非常重视交叉行为，但其他学派的成员认为没有必要如此麻烦。霍兰德没有哪个理论结果表明，交叉行为能起作用。</span></span></li><li><span class="name"><span class="innerContentContainer">随着模块演变得越来越大，交叉行为也会越来越趋向于将这些模块解散。</span></span></li><li><span class="name"><span class="innerContentContainer">还有，一旦适应力强的个体出现，其后代很有可能快速掌管该群体，并有可能将更好的基模挤出，这些基模受到整体上不那么相配的个体的牵绊。</span></span></li><li><span class="name"><span class="innerContentContainer">消除性别对于演化新论者来说，就只剩下变异作为其理论的推动力。如果群体的规模大体上比基因的数量大，很有可能每个点突变都已体现在其中，而研究就变成爬山法的一种：尝试所有可能的单步变种，挑选最好的一个，然后重复这个步骤（或者挑选几个最好的变种，这种情况就被称为“定向搜索”）。</span></span></li><li><span class="name"><span class="innerContentContainer">应特别指出的是，符号学派一直用这种方法来掌握规则集，虽然他们不把它当成进化的一种形式。为了避免陷入局部最大值的陷阱，爬山法可以通过随机性（以某个概率做下坡移动）和随机重启（过一会儿后，跳到随机状态，然后从那儿继续）来得到加强。这样做已经足以找到解决问题的好办法。</span></span></li><li><span class="name"><span class="innerContentContainer">没人知道为什么性别在自然界中无处不在。人们已经提出几个理论，但没有一个被广泛接受。这方面的领先理论是“红皇后”假说，马特·里德利在同名书中向人们介绍该理论。在《爱丽丝镜中世界奇遇记》中，红桃皇后对爱丽丝说：“全力奔跑，这样你才能留在原地。”依照这个观点，有机体和寄生虫就会永远处在竞赛中，而性可以保持群体的多样性，这样单一微生物就不会感染整个群体了。如果这就是答案，那么性就和机器学习不相关。</span></span></li><li><span class="name"><span class="innerContentContainer">演化新论者和联结学派重要的共同点是：他们都因为受到自然启发而设计了学习算法，不过后来分道扬镳了。演化新论者关注的是学习架构，对他们来说，通过参数优化来对演化的架构进行微调，这是次重要的事情。相反，联结学派更喜欢用一个简单、手工编写的结构，加上许多连接行为，然后让权值学习来完成所有工作。</span></span></li><li><span class="name"><span class="innerContentContainer">这就是机器学习版本关于先天和后天的争论，而且双方都有很好的论据。</span></span></li><li><span class="name"><span class="innerContentContainer">在先天与后天之争中，两方都没有完整的答案，关键在于找到如何将两方结合起来。终极算法既不是遗传编程，也不是反向传播，但它得包含这两者的重要部分：结构学习和权值学习。在传统观点看来，先天自然完成第一部分（进化大脑），后天培育再将大脑填满信息。我们可以在学习算法中重复这个过程。</span></span></li><li><span class="name"><span class="innerContentContainer">新生大脑已经对环境的特点进行编码，但不是很明显，进化过程会将大脑优化，从预期的输入信息中提取那些特点。</span></span></li><li><span class="name"><span class="innerContentContainer">谁学得最快，谁就会赢。</span></span></li><li><span class="name"><span class="innerContentContainer">进化寻求好的结构，而神经学习则填满这些结构：这样的结合是我们走向终极算法最简单的一步。</span></span></li><li><span class="name"><span class="innerContentContainer">“自然”（先天）对计算机来说就是它运行的程序，而“人工”（后天）则是获取的数据。（说得太对了！）“这两个哪个重要”这样的问题明显有点荒唐。</span></span></li><li><span class="name"><span class="innerContentContainer">机器学习是地球上生命之间竞争的最新篇章，更加快速的硬件只是等式的一边，另一边是更加智能的软件。</span></span></li><li><span class="name"><span class="innerContentContainer">进化的产物有很多明显的错误。</span></span></li><li><span class="name"><span class="innerContentContainer">活细胞的分子生物学原理非常混乱，分子生物学家常常自嘲道，只有对分子生物学一点也不懂的人才会相信智能设计。</span></span></li><li><span class="name"><span class="innerContentContainer">与联结学派及演化新论者相反，符号学派和贝叶斯学派不相信“法自然”的说法。</span></span></li><li><span class="name"><span class="innerContentContainer">对于治疗癌症的问题，原则上，我们可以掌握细胞新陈代谢网络的完整模型，方法就是结合结构研究，利用或者不利用交叉，通过反向传播来进行参数学习，但有太多不利的局部最优陷阱。</span></span></li><li><span class="name"><span class="innerContentContainer">我们得利用更大块的数据来进行推理，根据需要集合或重新集合这些数据，然后利用逆向演绎来填补空缺。这就是贝叶斯方法。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #贝叶斯学派">#<span class="contentTagText">贝叶斯学派</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">贝叶斯学派认为学习是一种概率推理形式，理论根基在于统计学。</span></span></li><li><span class="name"><span class="innerContentContainer">贝叶斯学派最关注的问题是不确定性，所有掌握的知识都有不确定性，而且学习知识的过程也是一种不确定的推理形式。那么问题就变成，在不破坏信息的情况下，如何处理嘈杂、不完不完整甚至自相矛盾的信息。解决的办法就是运用概率推理，而主算法就是贝叶斯定理及其衍生定理。贝叶斯定理告诉我们，如何将新的证据并入我们的信仰中，而概率推理算法尽可能有效地做到这一点。</span></span></li><li><span class="name"><span class="innerContentContainer">贝叶斯定理：P(A∣B)=P(A)P(B∣A)/P(B)。</span></span></li><li><span class="name"><span class="innerContentContainer">贝叶斯定理之所以有用，是因为通常给定原因后，我们就会知道结果，但我们想知道的是已知结果，如何找出原因。</span></span></li><li><span class="name"><span class="innerContentContainer">贝叶斯公式本身没有什么问题。争议在于相信贝叶斯定理的人怎么知道推导该定理的各个概率，以及那些概率的含义是什么。</span></span></li><li><span class="name"><span class="innerContentContainer">贝叶斯学派的回答是：概率并非频率，而是一种主观程度上的信任。</span></span></li><li><span class="name"><span class="innerContentContainer">因此，用概率来做什么由你决定，而贝叶斯推理让你做的事就是：通过新证据来修正你之前相信的东西，得到后来相信的东西（也被人们称为“转动贝叶斯手柄”）。</span></span></li><li><span class="name"><span class="innerContentContainer">所有模型都是错的，但有些却有用。</span></span></li><li><span class="name"><span class="innerContentContainer">这时我们就与宿敌再次交锋：组合爆炸问题。</span></span></li><li><span class="name"><span class="innerContentContainer">如果学习算法利用贝叶斯定理，且给定原因时，假定结果相互独立，那么该学习算法被称为“朴素贝叶斯分类器”。</span></span></li><li><span class="name"><span class="innerContentContainer">彼得·诺尔维格（谷歌的研究主任）一度告诉我，这（指“朴素贝叶斯法”）是谷歌应用最为广泛的算法，谷歌的机器学习在每个角落都利用了该算法的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">在任意贝叶斯网络中也是同样的道理：为了获得完整状态的概率，只需将单个变量表格中相应行上的概率相乘。因此，只要条件独立性有效，转换到更加简洁的表示方法不会导致信息丢失。</span></span></li><li><span class="name"><span class="innerContentContainer">独立性：每个生命都相互关联，但只是间接关联。</span></span></li><li><span class="name"><span class="innerContentContainer">空间是所有事情没有都发生在你身上的原因。</span></span></li><li><span class="name"><span class="innerContentContainer">因为对于贝叶斯学派来说，学习只是另一种形式的概率推理。</span></span></li><li><span class="name"><span class="innerContentContainer">实际上，对于贝叶斯学派来说，没有所谓的真相。</span></span></li><li><span class="name"><span class="innerContentContainer">你有一个优先于假设的分布，在见到数据后，它变成了后验分布，这是贝叶斯定理给出的说法，也就是贝叶斯定理的全部。</span></span></li><li><span class="name"><span class="innerContentContainer">就像玩笑说的那样，加入贝叶斯学派意味着绝不用说你对某事很肯定。</span></span></li><li><span class="name"><span class="innerContentContainer">对于贝叶斯学者来说，概率是包含主观程度的信任，所以他可以自由地做有根据的猜测，而且推理演算会使他所有的猜想都一致。</span></span></li><li><span class="name"><span class="innerContentContainer">类推学派用这种推理方式得出其逻辑结论，正如我们在第七章将看到的那样。在21世纪的前10年，他们反过来接管NIPS。现在联结学派打着深度学习的旗号再次占据主导地位。</span></span></li><li><span class="name"><span class="innerContentContainer">逻辑无法处理不完整或包含嘈杂因素的信息，这在实验生物学中较普遍，但贝叶斯网络可以沉着地处理这个问题。</span></span></li><li><span class="name"><span class="innerContentContainer">逻辑和概率，把它们整合起来很困难。</span></span></li><li><span class="name"><span class="innerContentContainer">到目前为止，我们谈到的所有学派有一个共同点：共同点：他们都学习研究中的现象的显式模型，无论它是一组规则、一个多层感知器、一个基因计划，还是一个贝叶斯网络。当他们没有足够的数据来做这件事时，就会被难住。但类比学派可以从甚至小到一个例子的数据中学习，因为他们绝不会形成一种模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #类推学派">#<span class="contentTagText">类推学派</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">类推学派通过对相似性判断的外推来进行学习，并受心理学和数学最优化的影响。</span></span></li><li><span class="name"><span class="innerContentContainer">对于类推学派来说，学习的关键是从看似有很大差别的情形中认识到相似性，然后由此推导出其他相似性。如果两个病人有相似的症状，那么也许他们患有相同的疾病。问题的关键是，如何判断两个事物的相似程度。类推学派的主算法是支持向量机，主算法找出要记忆的经历，以及弄明白如何将这些经历结合起来，用来做新的预测。</span></span></li><li><span class="name"><span class="innerContentContainer">也许在未来10年，机器学习会被深度类比统治，在某种算法中，与最近邻法的高效、支持向量机的数学精密性、类比推理的力量和灵活性结合（瞧，我又泄露了自己的一个秘密研究计划）。</span></span></li><li><span class="name"><span class="innerContentContainer">通常科学家们利用线性回归来预测连续变量，但大多数现象是非线性的。幸运的是，从局部来看，它们是线性的，因为平滑曲线可以局部近似为直线。因此如果你只用直线来对查询点附近的点，而不是尝试对所有的数据都进行拟合，那么你现在就能拥有一个非常强大的非线性回归算法。懒惰也会有回报。</span></span></li><li><span class="name"><span class="innerContentContainer">如果肯尼迪需要一套完整的国际关系理论来决定该如何应对苏联在古巴部署的导弹，他可能会遇到麻烦。相反，他从这个危机与第一次世界大战的爆发之间找到相似点，而这个相似点指引他做了正确的决定。</span></span></li><li><span class="name"><span class="innerContentContainer">利用多个k最近邻而不仅一个近邻，这不是事情的结局。直观来看，与测试例子最接近的例子应该更重要。这让我们引出加权k最近邻算法。</span></span></li><li><span class="name"><span class="innerContentContainer">最近邻算法是史上第一个能够利用不限数量的数据来掌握任意复杂概念的算法。</span></span></li><li><span class="name"><span class="innerContentContainer">当今算法要掌握数千甚至数百万个属性并不稀奇。对于电子商务网站来说，它要掌握你的喜好，那么你每点击一下鼠标就算一种属性。网页上的每个词、图片上的每个像素也是如此。</span></span></li><li><span class="name"><span class="innerContentContainer">实际上，没有哪种算法能够幸免于维数灾难。这是机器学习中，继过拟合之后，第二个最糟糕的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">要处理弱相关的属性，一个选择就是掌握属性权值。我们不会让所有维度下相似性的重要性相等，而是“缩减”不那么相关的属性。</span></span></li><li><span class="name"><span class="innerContentContainer">平均数会被加权，而支持向量机只会记住那些用于确定边界的关键例子。</span></span></li><li><span class="name"><span class="innerContentContainer">这些例子被称为支持向量，因为它们是“支撑”边界的向量：移动一个向量，边界的一段就会滑向其他不同的地方。</span></span></li><li><span class="name"><span class="innerContentContainer">两个东西如果在一些方面意见一致，那么它们就是相似的。如果它们在一些方面意见一致，可能在其他方面也会意见一致，这就是类比的本质。它还表明了类比推理中的两大子问题：弄明白两个事物的相似度，确定由它们的相似度还能推导出什么。</span></span></li><li><span class="name"><span class="innerContentContainer">在任何类比学习算法中，最重要的问题就是如何度量相似性。</span></span></li><li><span class="name"><span class="innerContentContainer">类比推理的第二部分，就是弄明白在已经发现的相似点的基础上，如何推导出新的东西。</span></span></li><li><span class="name"><span class="innerContentContainer">如果科普是对的，创造性（最深不可测的东西）都可以归结为类比和重组。</span></span></li><li><span class="name"><span class="innerContentContainer">我们见过的所有学习算法，都需要一位老师来告诉它们正确答案。而人类会无师自通，从出生那天开始，就已经这么做了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">终极算法</span></span><ul><li><span class="name"><span class="innerContentContainer">终极算法依赖上述5种算法的综合。现有知识积累依赖符号学派予以数字化，让电脑能够理解；通过联结学派和进化学派寻找解决问题的基本框架；即使这样，我们的知识和面对的问题相比，还是非常不完整的，所以要依赖贝叶斯学派在不确定的局面下寻求方案；而在最困难的情况下，以上做法都失败了，我们还可以通过类推学派，在看似完全不相关的事物间寻找相似点，将彼之方案用于此上，以寻找突破点。</span></span></li><li><span class="name"><span class="innerContentContainer">我们需要一种能够自发将所有相似物体或者同一物体的不同图片集中起来的算法。这就是聚类问题，这在机器学习当中也是人们研究最多的主题之一。</span></span></li><li><span class="name"><span class="innerContentContainer">尽管这样的平均值很有用，但我们可以做得更好。的确，大数据和机器学习的全部要点在于避免粗糙的思考。</span></span></li><li><span class="name"><span class="innerContentContainer">因此罗比面临的是鸡和蛋的问题：如果它知道物体的类别，就可以通过数数的方式来掌握类别的模型；如果它知道模型，可以推断物体的类别。我们好像又遇到困难了，但远非如此：只要在开始时，以你喜欢的方式来猜测每个物体的类别（即使是随机的），然后你就有的忙了。从那些类别和数据中，你可以掌握类别模型；在这些模型的基础上，你可以重新推导类别，以此类推。乍一看，这看起来像一个疯狂的计划：它可能绝不会结束，而是处在由模型推断类别，到由类别推断模型的永恒循环中。即使它停止了，也没有理由相信会停在有意义的集群上。但1977年，来自哈佛大学的三个统计学家（亚瑟·邓普斯特、南·莱尔德、唐纳德·鲁宾）表明，这个疯狂的计划其实可以生效：每次我们绕着圈走时，集群模型就会变得更好，而当模型是可能性的一个局部最大值时，循环结束。他们称该计划为期望最大化演算法（ExpectationMaximization，EM算法），其中E表示期望（推断预期的概率），而M代表最大化（估算可能性最大的参数）。他们还表明，许多之前的算法都是EM的特殊情况。</span></span></li><li><span class="name"><span class="innerContentContainer">无论何时，当我们想掌握某个统计模型，但又缺乏一些关键信息时（例如，例子的类别），就可以利用EM。这使它在所有机器学习中成为最受欢迎的算法。</span></span></li><li><span class="name"><span class="innerContentContainer">一张脸大约有50块肌肉，因此50个数字足以用来描述所有可能的表情，而且还有很大的剩余空间。眼睛、鼻子、嘴巴等的样子（就是让你区分于别人的特点）的数量也不应该超过几十种。你可以添加几个数量，用来确定光线和姿态，这样就差不多了。因此如果你给我100多个数量，就已经足以重新构造一张脸部图片。</span></span></li><li><span class="name"><span class="innerContentContainer">机器学习算法称该过程为维数约简，因为该过程将大量的可见维度（像素）简化成几个隐性维度（表情、面部特征）。维数约简对于应对大数据（像每秒钟通过你的知觉而进入的数据）来说很关键。一张图可能抵得上1000个字，但要处理和记住所做的付出，却要高出100万倍。你的视觉皮质好歹把大数据削减为数量上可管理的信息，足以用来引导这个世界、识别人和物、记住你看见的东西。这是认知最伟大的奇迹之一，并且如此自然，你甚至意识不到自己正在做这些事。</span></span></li><li><span class="name"><span class="innerContentContainer">主要成分分析（principle–componentanalysis，PCA），是科学家的工具箱中关键的工具之一。</span></span></li><li><span class="name"><span class="innerContentContainer">心理学家已经发现，个性可以简化为5个维度（外向、随和、尽责、神经质、开放性），他们可以通过你的推特文章和博客帖子来进行推断。</span></span></li><li><span class="name"><span class="innerContentContainer">人类确实有稳定的向导：情感。我们追求快乐，躲避痛苦。</span></span></li><li><span class="name"><span class="innerContentContainer">棋盘游戏是强化学习问题的典范：你得走好多步棋，却得不到任何反馈，奖励或惩罚都在最后一刻揭晓，其形式也就是赢和输。IBM的塞缪尔的程序可以自学下棋，而且下得和大多数人一样好。它不会直接学棋盘上每步棋该怎么走，因为这太困难；相反，它会学习如何评价每个棋的位置（从该位置出发，赢的概率有多大），然后选择走能到达最佳棋位的那一步。起初，它知道如何进行评价的唯一位置就是最后的结果：赢、平局或是输。一旦它知道某个特定位置能赢，也就知道哪些位置有利于让它达到这个位置。</span></span></li><li><span class="name"><span class="innerContentContainer">（9）机器学习能干什么，不能干什么</span></span></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">例子1：看看曼彻斯特大学生物技术研究院的实验室，在那里，一个名叫亚当的机器人正在努力工作，目的是找到哪些基因在酵母中对哪些酶进行编码。亚当有一个酵母新陈代谢的模型，还掌握了基本的基因及蛋白质知识。它提出假设，设计实验验证假设，进行实地实验，分析结果，提出新的假设，直到它满意为止。</span></span></li><li><span class="name"><span class="innerContentContainer">例子2：奥巴马雇用了拉伊德·贾尼（机器学习专家，他是奥巴马竞选中的首席科学家）。贾尼研究的是如何整合最伟大的分析运算，并将其应用到政治史中。他们将所有选民的信息整合成单个数据库，然后将该数据库和他们能在社交网络、市场营销等领域找到的资源结合起来。之后着手对每个选民做四种预测：（1）支持奥巴马的可能性有多大；（2）会不会参加民意调查；（3）会不会回应竞选宣传并照做；（4）对特定问题进行对话之后，他们会不会改变选举决定。基于这些选民的例子，奥巴马团队每个晚上进行66000场选举模拟，并用这些结果指导奥巴马竞选的志愿者大军：该给谁打电话，该拜访谁，该说什么。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b><span class="contentTag" title="Filter #监督学习">#<span class="contentTagText">监督学习</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">利用已知类别的样本（即有标记的样本, labeled sample），训练学习得到一个<b>分类</b>模型，使其能将新的输入分类。</span></span></li><li><span class="name"><span class="innerContentContainer">就是提供一堆选择题及其标准答案给计算机；然后计算机调整自己的模型参数，以使自己推测到的答案和标准答案越一致越好；等模型足够好，计算机就给出新数据的分类了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b><span class="contentTag" title="Filter #非监督学习">#<span class="contentTagText">非监督学习</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">对于没有标记的样本，学习算法直接对输入数据进行建模，比如<b>聚类</b>，只要把相似度高的样本放在一起，对于新的数据样本计算其相似度后，安排相似度进行归类。</span></span></li><li><span class="name"><span class="innerContentContainer">算法不知道每一类是什么，但知道它们属于同类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b><span class="contentTag" title="Filter #半监督学习">#<span class="contentTagText">半监督学习</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">让计算机自动对大量未标记数据进行学习，并辅助以少量有标记数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b><span class="contentTag" title="Filter #强化学习">#<span class="contentTagText">强化学习</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">机器学习从环境到行为的学习，以使奖励信号（强化信号）函数最大化。</span></span></li><li><span class="name"><span class="innerContentContainer">强化学习不同于监督学习的地方在于强化信号是对<b>输出</b>信号的好坏的一种评价（通常称为标量信号），而不是作为输入数据的一部分。</span></span></li><li><span class="name"><span class="innerContentContainer">这里强调输入和输出意义不大, 实际上, 输入的结果就是输出. 真正的区别在于结果的形式: 监督学习给出的是对错的结果, 而强化学习给出的正确了百分之几这样的结果.</span></span></li><li><span class="name"><span class="innerContentContainer">打比方: 监督学习是选择题, 强化学习是问答题. 选择题只有对错. 问答题则可以对1%, 也可以对50%, 还可以对100%.</span></span></li><li><span class="name"><span class="innerContentContainer">和考试类似, 监督学习适用于基础知识, 强化学习适用于复杂场景. 监督学习快捷简单, 结论一目了然, 题目出好了, 老师水平高低几乎无所谓; 强化学习则如同一种艺术, 能适应所有知识场景, 但对老师的水平要求高.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #卷积神经网络">#<span class="contentTagText">卷积神经网络</span><span class="contentTagNub"></span></span>, <span class="contentTag" title="Filter #CNN">#<span class="contentTagText">CNN</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">深度：即深度神经网络的隐层的数量。理论上越深越好，即层数越多越好。</span></span></li><li><span class="name"><span class="innerContentContainer">学习率（learning rate）:参见梯度下降。</span></span></li><li><span class="name"><span class="innerContentContainer">神经网络（NN/ANN）：神经网络中的每个神经元的模型叫 Logistic回归模型，如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">其公式是：</span></span></li><li><span class="name"><span class="innerContentContainer">多层神经元组成神经网络。如下：</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">隐层：又叫隐藏层，神经网络中介入输入层和输出层之间的层统一称为隐层。</span></span></li><li><span class="name"><span class="innerContentContainer">激活函数：神经网络是通过海量（但还是有限个）的线性方程和简单非线性方程（比如x^2、x1x2、sin(x)等）来拟合复杂非线性关系。当然这里的海量是真海量，一般是10^10这种量级。但是很难数学证明这些方程具有正交性，所以要防备它们手拉手掉进坑里。</span></span><ul><li><span class="name"><span class="innerContentContainer">怎么办呢？加一个<b>非线性方程</b>，这个方程就叫激活函数，在大家都疲倦下来时由它提供跳出大坑（即局部最优解）的可能性。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>激活函数的选择: </b></span></span><ul><li><span class="name"><span class="innerContentContainer">当输入数据特征相差明显时，用 tanh 的效果会很好，且在循环过程中会不断扩大特征效果并显示出来。</span></span></li><li><span class="name"><span class="innerContentContainer">当特征相差不明显时，sigmoid 效果比较好。</span></span></li><li><span class="name"><span class="innerContentContainer">用sigmoid和tanh作为激活函数时，需要对输入进行规范化，否则激活后的值全部都进入平坦区，隐层的输出会全部趋同，丧失原有的特征表达。</span></span></li><li><span class="name"><span class="innerContentContainer">relu会好很多，有时可以不需要输入规范化来避免上述情况。</span></span></li><li><span class="name"><span class="innerContentContainer">估计大概有85%～90%的神经网络会采用ReLU，10%～15%的神经网络会采用tanh，尤其用在自然语言处理上。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">反向传播(BP): 将神经网络的输出信息和理想的输出信息相比，会得出误差信号，这个信号会穿过神经元层反向传播回去，直到它到达输入层。根据返回来的信号以及在前进过程中它接收到的输入信息，每个神经元会调整各自的权值。</span></span><ul><li><span class="name"><span class="innerContentContainer">有了反向传播，你就不必逐个对神经元的权值进行微调，这样很慢。你可以一层一层来做，根据调整与其相连神经元的方法，来调整每个神经元。其算法是：</span></span></li><li><span class="name"><span class="innerContentContainer">对于每一个训练样本&lt;x, t&gt;，使用当前权重计算输出o；</span></span></li><li><span class="name"><span class="innerContentContainer">对于每一个权重wi做如下的更新：</span></span></li><li><span class="name"><span class="innerContentContainer">wi = wi +&nbsp;Δwi； 其中Δwi =&nbsp;η [t - o]xi</span></span></li><li><span class="name"><span class="innerContentContainer">其中X为输入向量，W为权重向量，xi 和 wi 为X和W的第i个元素。T为目标值，O为当前权值下的输出，η 为学习率。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">损失函数(lost funciton)：反映神经网络预测输出和实际输出之间的误差。最常用的损失函数是L2.</span></span><ul><li><span class="name"><span class="innerContentContainer">其中：d为训练样本，D为训练集；td为预测输出，od为实际输出。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">梯度下降（Gradient Descent/GD）：即用迭代的方法以最小化模型误差的参数优化算法，用于解决反向传播的下降多少的问题。梯度下降法通过多次迭代，并在每一步中最小化损失函数来估计模型的参数（weights）。通俗说就是一次下一格，而不是一点点的挪动。其公式是：</span></span><ul><li><span class="name"><span class="innerContentContainer">ωj+1&nbsp;=&nbsp;ωj&nbsp;-&nbsp;λ&nbsp;∂F(ωj) /&nbsp;∂ωj</span></span></li><li><span class="name"><span class="innerContentContainer">ωj&nbsp;是模型参数， F(ωj)是损失函数， ∂F(ωj) /&nbsp;∂ωj&nbsp;是ωj&nbsp;&nbsp;的一阶导数，λ&nbsp;是学习率(确定每次“跳”的阶梯的高度)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果F(ωj)是单调函数，经过多次迭代会得到最小的成本函数；如果F(ωj)非单调，那么我们有可能陷入局部最优，一个简单的解决办法是通过多次尝试不同的ωj 初始值，对比不同估计参数下的成本函数的值是否一致，来发现是否陷入局部最优。</span></span></li><li><span class="name"><span class="innerContentContainer">梯度向量的方向指向损失函数增长最快的方向，负梯度向量-f则指向函数下降最快的方向。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">深度神经网络（DNN）</span></span><ul><li><span class="name"><span class="innerContentContainer">深度神经网络强大的原因是它的隐层天然具有提取特征的能力。层次越多，提取的特征维度越高，抽象能力越强。</span></span></li><li><span class="name"><span class="innerContentContainer">深度没有具体指标，一般问题超过4层就算“挺深的”，而图形识别中一般有20层以上。</span></span></li><li><span class="name"><span class="innerContentContainer">2006年，Hinton利用预训练方法缓解了局部最优解问题，将隐层推到了7层，开启了深度神经网络的大门。</span></span></li><li><span class="name"><span class="innerContentContainer">如果层次过多，“<b>梯度消失</b>”现象会非常严重。我们通常用sigmoid作为神经元的输入输出函数。对于幅度为1的信号，在BP方向梯度传播时，每多传递一层，梯度衰减为原来的25%。层次越多，梯度衰减得越厉害，越难受到有效的训练信号。</span></span></li><li><span class="name"><span class="innerContentContainer">2016年出现的高速公路网络和深度残缺学习则进一步避免了梯度消失的问题，层次超过了100多层（深度残缺学习达到了152层）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">卷积神经网络（CNN）：由一个或多个卷积层和顶端的全连通图（对应经典的神经网络）组成同时也包括关联权重和池化层（pooling layer）。这一结构使得CNN能够输入数据的二维结构，与其他算法相比，CNN在图像应用上更占优势。对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重，因为每个神经元的权重固定，所以可看做是一个恒定的滤波器filter，也叫卷积核）做内积（逐个元素相乘再求和）的操作就是“卷积”操作。如下图:</span></span><ul><li><span class="name"><span class="innerContentContainer">CNN的示意图  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">注意上图中3个矩阵的规模的关系:a=b+c-1。</span></span></li><li><span class="name"><span class="innerContentContainer">CNN的优势是保留局部秩序，既不影响特征提取（假设如此），又极大的降低了一般的深度神经网络（全连通图）的参数暴涨问题。CNN在图像、语音领域优势非常明显，因为这些领域的数据具有明显的局部秩序。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #循环神经网络">#<span class="contentTagText">循环神经网络</span><span class="contentTagNub"></span></span>, <span class="contentTag" title="Filter #RNN">#<span class="contentTagText">RNN</span><span class="contentTagNub"></span></span>,  <span class="contentTag" title="Filter #LSTP模型">#<span class="contentTagText">LSTP模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">换句话说，RNN是一个在时间上传播的神经网络，它的深度就是时间的长度（这个模型肯定能启发人类对时间的本质的认识）。</span></span></li><li><span class="name"><span class="innerContentContainer">深度神经网络存在一个问题，无法对时间序列上的变化进行建模。</span></span></li><li><span class="name"><span class="innerContentContainer">为解决这一点，需要让各神经元的输出在下一个时间戳上作用到自身，即第i层神经元在m时刻接受到的输入，除了i-1层神经元在m时刻的输出外，还包括自身在m-1时刻的输出。这就是RNN。</span></span></li><li><span class="name"><span class="innerContentContainer">LSTP至今都是自然语言处理、语音识别、机器翻译等领域的最好模型。</span></span></li><li><span class="name"><span class="innerContentContainer">长短时记忆单元（LSTM）：RNN会有梯度消失的问题，对于T时刻来说，它产生的梯度在时间轴向后传播几层就消失了，无法影响太久的将来。LSTM就是为了解决这个问题，通过开关实现记忆功能，防止梯度消失。</span></span></li><li><span class="name"><span class="innerContentContainer">LSTP模型：1991年提出，可有效对较长序列进行建模，比如一句话或一段文字。</span></span></li><li><span class="name"><span class="innerContentContainer">还有更有趣的，比如预测未来一定对认识现在有价值，所以就有了双向RNN、双向LSTM，同时利用历史和未来的信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #自然语言处理">#<span class="contentTagText">自然语言处理</span><span class="contentTagNub"></span></span>, <span class="contentTag" title="Filter #NLP">#<span class="contentTagText">NLP</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">word2vec: 词向量</span></span><ul><li><span class="name"><span class="innerContentContainer">目的: 找出词与词之间的关系. </span></span></li><li><span class="name"><span class="innerContentContainer">输出: 词料库中任意两个词出现在同一句话的概率, 比如 (中国, 韭菜) 的概率大于(中国, 蝈蝈). </span></span></li><li><span class="name"><span class="innerContentContainer">可选两个模型: CBOW 和 skip-Gram</span></span></li><li><span class="name"><span class="innerContentContainer">CBOW: 训练输入是特征词的上下文相关的词的对应的词向量, 输出是该词的词向量.</span></span></li><li><span class="name"><span class="innerContentContainer">CBOW 适用于小型词料库. </span></span></li><li><span class="name"><span class="innerContentContainer">skip-Gram的思路则相反, 输入是词向量, 输出是该词的上下文词向量.</span></span></li><li><span class="name"><span class="innerContentContainer">skip-Gram适用于大型词料库. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #P和NP问题">#<span class="contentTagText">P和NP问题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">如果我们能有效解决它，那么这个问题就属于P。</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们能有效找到其解决方案，那么这个问题属于NP。</span></span></li><li><span class="name"><span class="innerContentContainer">P=NP的问题就是，能有效找到的问题是否可以得到有效解决。很多问题我们知道我们最终可以解决，但是现在找不到一个时间、成本都可接受的解决方案。这也叫图灵可停机问题。</span></span></li><li><span class="name"><span class="innerContentContainer">我们感兴趣的问题往往都是NP问题。我们对不困难的问题兴趣都不大（贱啊！）。</span></span></li><li><span class="name"><span class="innerContentContainer">弄明白蛋白质如何折叠成特定形状；通过DNA来重新构建一系列物种的进化史；在命题逻辑中证明定理；利用交易成本来发现市场中的套利机会；从二维视图中推出三维形状；将数据压缩到磁盘上；在政治活动中组成稳定联盟；在剪切流中模拟湍流；按照给定回报率找出最安全的投资组合、到达几个城市的捷径、微芯片上元件的最佳布局方案、生态系统中传感器的最佳布局、自旋玻璃门最低的能量状态；安排好航班、课程、工厂工作；最优化资源分配、城市交通流、社会福利，以及提高你的俄罗斯方块分数——这些都是NP完全问题，意思是，如果你能有效解决其中的一个问题，就能有效解决所有NP类问题。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Android</b></span></span><ul><li><span class="name"><span class="innerContentContainer">HIDL流程图  <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Android log系统框图  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Activity生命周期图.  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Activity生命周期 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>onCreate&nbsp;</b>: Activity被创建时被回调，是生命周期第一个调用的方法，我们在创建Activity时一般会重写该方法做一些初始化的操作，如通过 setContentView 设置界面布局的资源，初始化所需要的组件信息等。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onStart&nbsp;</b>: Activity正在启动时回调，此时Activity已处于可见状态，但是还没有在前台显示，因此无法与用户进行交互。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onResume </b>: 当此方法回调时，则说明Activity已在前台可见，可与用户交互了, 即activity处于 Active/Running形态.</span></span><ul><li><span class="name"><span class="innerContentContainer">onResume与onStart的相同点是两者都表示Activity可见；</span></span></li><li><span class="name"><span class="innerContentContainer">不同点是onStart时Activity还在后台无法与用户交互，而onResume则表示已显示在前台，可与用户交互。</span></span></li><li><span class="name"><span class="innerContentContainer">当Activity停止后（ onPause 方法和 onStop方法被调用），重新回到前台时也会调用onResume方法.</span></span></li><li><span class="name"><span class="innerContentContainer">可以在onResume方法中初始化一些资源，比如重新初始化在 onPause 或者 onStop 方法中释放的资源。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>onPause </b>: Activity被切换到后台或停止的时候回调, 此时activity进入 Paused形态. 一般情况下 onStop方法接下来会马上被回调。</span></span><ul><li><span class="name"><span class="innerContentContainer">在onPause中我们可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示. <b>因为旧activity的 onPause方法执行完成后，新Activity的onResume方法才会被执行。</b></span></span></li><li><span class="name"><span class="innerContentContainer">onPause()和onStop()的区别是：前者是旧Activity还可见的状态；后者是旧Activity已经不可见。</span></span></li><li><span class="name"><span class="innerContentContainer">AlertDialog 和 PopWindow 不会触发onPause()和onStop().</span></span></li><li><span class="name"><span class="innerContentContainer">有一种极端情况是onPause方法执行后马上执行了onResume方法，一般是用户操作使当前Activity退居后台后又迅速切回来，此时onResume方法就会被回调。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>onStop </b>: 一般在onPause执行完成时回调，表示Activity即将停止进入Stopped形态，此时Activity不可见，仅在后台运行。在onStop方法可以做一些资源释放的操作（不能太耗时）。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onRestart </b>: 表示Activity正在重新启动，当Activity由<b>onStop</b>() 状态切换回前台时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onDestroy </b>: 此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做最终的资源释放。</span></span></li><li><span class="name"><span class="innerContentContainer">总结下: </span></span><ul><li><span class="name"><span class="innerContentContainer">Activity第一启动的时候执行: onCreate() -&gt; onStart() -&gt; onResume(). </span></span></li><li><span class="name"><span class="innerContentContainer">如果再有启动同一Activity的时候, 执行: onNewIntent() -&gt; onResart() -&gt; onStart() -&gt; onResume().</span></span></li><li><span class="name"><span class="innerContentContainer">如果android系统由于内存不足把已存在Activity释放掉了，那么再次调用的时候会重新启动Activity, 即执行: onCreate() -&gt; onStart() -&gt; onResume()。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity, PhoneWindow, DecorView, titleBar, contentView 之间关系的示意图  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">FAT32 system图示  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Tools</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Apple Watch3/4/5的技术指标    <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">人眼视神经连线  <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">眼球内部结构   <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软件工程</span></span><ul><li><span class="name"><span class="innerContentContainer">瀑布模型</span></span></li><li><span class="name"><span class="innerContentContainer">IPD流程</span></span><ul><li><span class="name"><span class="innerContentContainer">tr1: 需求基线。tr1后需求就要处在变更控制下。</span></span></li><li><span class="name"><span class="innerContentContainer">charter: 任务书。</span></span></li><li><span class="name"><span class="innerContentContainer">CDCP: 概念决策评审点。概念阶段完成。</span></span></li><li><span class="name"><span class="innerContentContainer">tr2: 功能基线。确定产品规格需求。</span></span></li><li><span class="name"><span class="innerContentContainer">tr3</span></span><ul><li><span class="name"><span class="innerContentContainer">分配基线。</span></span></li><li><span class="name"><span class="innerContentContainer">入口条件完成SRS。</span></span></li><li><span class="name"><span class="innerContentContainer">此时软件开始投入，t0单板到位，底层开始调试点亮t0单板。</span></span></li><li><span class="name"><span class="innerContentContainer">第一阶段最大的风险点是T1烧片。T1（V3）大约tr3之后的一个月.</span></span></li><li><span class="name"><span class="innerContentContainer">t1烧片</span></span><ul><li><span class="name"><span class="innerContentContainer">等t0单板调通，最重要是装备和射频启动投入，开始为t1烧片和产线试制准备。</span></span></li><li><span class="name"><span class="innerContentContainer">t1烧片要求最主要的频段要可以CBT、升级、nv备份恢复等关键功能能通，经过裁剪的MMI、经过裁剪的产线流程要ok。</span></span></li><li><span class="name"><span class="innerContentContainer">t1烧片版本只转测试给硬测。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">PICP: 计划决策评审点，计划阶段完成。</span></span></li><li><span class="name"><span class="innerContentContainer">tr4</span></span><ul><li><span class="name"><span class="innerContentContainer">交付基线。软件模块工作完成，联调完成。</span></span></li><li><span class="name"><span class="innerContentContainer">注意: HLD/LLC/Coding/UT/ST/BBIT都发生在tr3到tr4之间。</span></span></li><li><span class="name"><span class="innerContentContainer">tr4前会出第一个正式转测试版本，软测团队开始介入；</span></span></li><li><span class="name"><span class="innerContentContainer">定价和配置器启动。</span></span></li><li><span class="name"><span class="innerContentContainer">软件经理要关注国家入网测试、认证测试、运营商准入测试送测时间点。</span></span></li><li><span class="name"><span class="innerContentContainer">试制 T2（V4）和tr4同时. </span></span></li><li><span class="name"><span class="innerContentContainer">tr4的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">无致命问题。</span></span></li><li><span class="name"><span class="innerContentContainer">软件遗漏缺陷密度：目标是35，下限27，上限43；单位是“个/千行”。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tr4a</span></span><ul><li><span class="name"><span class="innerContentContainer">系统设计验证/SDV。</span></span></li><li><span class="name"><span class="innerContentContainer">系统测试完成，性能测试ok。</span></span></li><li><span class="name"><span class="innerContentContainer">tr4a后，软件稳定度达到一定水平，开始检查软件APR。</span></span></li><li><span class="name"><span class="innerContentContainer">BOM发布，并开始首次爬坡（大致时间）；</span></span></li><li><span class="name"><span class="innerContentContainer">批量物料采购，部分达到；</span></span></li><li><span class="name"><span class="innerContentContainer">资料开发完成；</span></span></li><li><span class="name"><span class="innerContentContainer">销售模型完成。</span></span></li><li><span class="name"><span class="innerContentContainer">试制PP1（VN1, 小批量，硬件设计固化））在tr4a之后.</span></span></li><li><span class="name"><span class="innerContentContainer">tr4a的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">内部问题单解决率85%;</span></span></li><li><span class="name"><span class="innerContentContainer">严重问题少于15个。</span></span></li><li><span class="name"><span class="innerContentContainer">底层软件的质量如果不能在tr4a之前稳定下来，产品的风险就比较大了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tr5</span></span><ul><li><span class="name"><span class="innerContentContainer">产品基线。</span></span></li><li><span class="name"><span class="innerContentContainer">此时有个活动，即beta test。</span></span></li><li><span class="name"><span class="innerContentContainer">内部测试完成；</span></span></li><li><span class="name"><span class="innerContentContainer">可少量早期发货。</span></span></li><li><span class="name"><span class="innerContentContainer">tr5的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">软件DI&lt;40</span></span><ul><li><span class="name"><span class="innerContentContainer">DI值的计算方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">致命问题10</span></span></li><li><span class="name"><span class="innerContentContainer">严重问题3</span></span></li><li><span class="name"><span class="innerContentContainer">一般问题1</span></span></li><li><span class="name"><span class="innerContentContainer">提示问题0.1</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">严重问题DI&lt;12。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tr6</span></span><ul><li><span class="name"><span class="innerContentContainer">发布基线。</span></span></li><li><span class="name"><span class="innerContentContainer">过了tr6，产品就转维护。</span></span></li><li><span class="name"><span class="innerContentContainer">试制PP2（VN2, 第二次小批量）应在tr6之前完成。</span></span></li><li><span class="name"><span class="innerContentContainer">试制LV=Line Verification, EMS量产确认。和tr6同时进行. LV之后一般还有两次试制:</span></span><ul><li><span class="name"><span class="innerContentContainer">RU=Ramp UP，爬坡</span></span></li><li><span class="name"><span class="innerContentContainer"> MP=Mass Production, 量产</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tr6的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">总DI&lt;30;</span></span></li><li><span class="name"><span class="innerContentContainer">严重问题DI=0</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">各tr点间的周期</span></span><ul><li><span class="name"><span class="innerContentContainer">总时间:</span></span><ul><li><span class="name"><span class="innerContentContainer">A类项目charter后190天发货；</span></span></li><li><span class="name"><span class="innerContentContainer">B类项目时150天发货。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tr3-tr4，一般2个月；</span></span></li><li><span class="name"><span class="innerContentContainer">tr4-tr4a，一般1.5-2个月；</span></span></li><li><span class="name"><span class="innerContentContainer">tr4a-tr5，两周；</span></span></li><li><span class="name"><span class="innerContentContainer">tr5-tr6，两-三周。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">试制的大致周期</span></span><ul><li><span class="name"><span class="innerContentContainer">每次试制间隔时间大约在1个月，不能少于20天，因为投板周期一般在两周左右。</span></span></li><li><span class="name"><span class="innerContentContainer">新产品投板次数不超过4次，非新产品一般2-3次。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">敏捷开发</span></span><ul><li><span class="name"><span class="innerContentContainer">敏捷宣言</span></span><ul><li><span class="name"><span class="innerContentContainer">2001年敏捷宣言发布。</span></span></li><li><span class="name"><span class="innerContentContainer">签字的人中有顶级程序员：Kent Beck, Robert C.Mortin, Marin Fowler。</span></span></li><li><span class="name"><span class="innerContentContainer">内容包括：</span></span></li><li><span class="name"><span class="innerContentContainer">个体和交互 胜过 过程和工具</span></span></li><li><span class="name"><span class="innerContentContainer">可以工作的软件 胜过 面面俱到的文档</span></span></li><li><span class="name"><span class="innerContentContainer">客户合作 胜过 合同谈判</span></span></li><li><span class="name"><span class="innerContentContainer">响应变化 胜过 遵循计划</span></span></li><li><span class="name"><span class="innerContentContainer">虽然右项也具有价值，但我们认为左项具有更大的价值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">敏捷可解决什么问题？变化。</span></span></li><li><span class="name"><span class="innerContentContainer">变化从哪里来？数据（DOD）显示，初期提出的45%的需求没有用。</span></span></li><li><span class="name"><span class="innerContentContainer">敏捷是帮助发现问题的，不是解决问题。敏捷的本质是尽早暴露问题，以便修正。</span></span></li><li><span class="name"><span class="innerContentContainer">软件系统的内在规律</span></span><ul><li><span class="name"><span class="innerContentContainer">复杂性几乎无法归约。系统不可能一蹴而就，人类在复杂系统前只能渐进迭代思考；</span></span></li><li><span class="name"><span class="innerContentContainer">软件缺陷有极大的相关性，如果不及时清理，就会指数级上升。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">敏捷经济学</span></span><ul><li><span class="name"><span class="innerContentContainer">争取每时每刻都在做最有价值的事情，低价值的事情要往后放、往下砍。</span></span></li><li><span class="name"><span class="innerContentContainer">小步快跑，每一步都做价值判断，减少风险成本。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>敏捷运动的两个具体实现是 SCRUM 和 XP</b></span></span></li><li><span class="name"><span class="innerContentContainer">SCRUM</span></span></li><li><span class="name"><span class="innerContentContainer">极限编程（XP）</span></span><ul><li><span class="name"><span class="innerContentContainer">完整团队</span></span><ul><li><span class="name"><span class="innerContentContainer">项目的所有参与者（开发人员、业务分析师、测试人员等等）一起工作在一个开放的场所中，他们是同一个团队的成员。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">计划游戏</span></span><ul><li><span class="name"><span class="innerContentContainer">计划是持续的，循序渐进的。</span></span></li><li><span class="name"><span class="innerContentContainer">每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。</span></span></li><li><span class="name"><span class="innerContentContainer">2-3周为一个周期；</span></span></li><li><span class="name"><span class="innerContentContainer">第一天确定了需求就可以编码；</span></span></li><li><span class="name"><span class="innerContentContainer">各个阶段并行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">客户测试</span></span><ul><li><span class="name"><span class="innerContentContainer">作为选择每个所期望的特性的一部分，客户定义出自动验收测试来表明该特性可以工作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">简单设计, user story</span></span><ul><li><span class="name"><span class="innerContentContainer">团队保持设计恰好和当前的系统功能相匹配，它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">建模的方法：workshop，笔、卡片、面对面。</span></span></li><li><span class="name"><span class="innerContentContainer">设计和实现不可分割。</span></span></li><li><span class="name"><span class="innerContentContainer">user story</span></span><ul><li><span class="name"><span class="innerContentContainer">只描述系统的外在特征。一般的形式是：</span></span><ul><li><span class="name"><span class="innerContentContainer">名称：***</span></span></li><li><span class="name"><span class="innerContentContainer">事件：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 用户做了什么；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 系统做了什么（仅限界面看到的部分）；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 用户又做了什么；</span></span></li><li><span class="name"><span class="innerContentContainer">4. 系统又做了什么</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件需要持续的细化,&nbsp;一直到把内涵说明完毕为止。</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">名称：买饮料</span></span></li><li><span class="name"><span class="innerContentContainer">事件：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 用户投进一些钱；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 售货机显示用户已经投入了多少钱；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 如果钱够，则饮料对应的按钮会亮；</span></span></li><li><span class="name"><span class="innerContentContainer">4. 用户按下某个亮的按钮；</span></span></li><li><span class="name"><span class="innerContentContainer">5. 售货机“吐”出对应的饮料；</span></span></li><li><span class="name"><span class="innerContentContainer">6. 售货机找零给他。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ser story有啥用?</span></span><ul><li><span class="name"><span class="innerContentContainer">主要用来评估工作量，并进一步评估进度和发布时间。</span></span></li><li><span class="name"><span class="innerContentContainer">收集完所有的user story，我们评估最简单的那个，将其设为1点，其它 story 也各有点数。点数是相对的，所以可以很粗糙。</span></span></li><li><span class="name"><span class="innerContentContainer">为了准确的评估点数对应的工作量，一般敏捷团队会用2周时间摸索自己的能力基线。</span></span></li><li><span class="name"><span class="innerContentContainer">两周就是一个相当常见的迭代周期。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发布周期不满足要求怎么办？</span></span><ul><li><span class="name"><span class="innerContentContainer">把一些story弄到下一个发布周期去；</span></span></li><li><span class="name"><span class="innerContentContainer">把一些story分解为多个，用户认为缺不可少的放进来，不是很紧急的放出去。</span></span></li><li><span class="name"><span class="innerContentContainer">后一种较受认可。</span></span></li><li><span class="name"><span class="innerContentContainer">加人更多的人力.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">user story的载体: CRC卡片</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">结对编程</span></span><ul><li><span class="name"><span class="innerContentContainer">所有的产品软件都是由两个程序员，并排坐在一起在同一台电脑上构建的。</span></span></li><li><span class="name"><span class="innerContentContainer">一般经验较少的人负责编码，经验较多的人负责评审。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">测试驱动开发</span></span><ul><li><span class="name"><span class="innerContentContainer">程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。</span></span></li><li><span class="name"><span class="innerContentContainer">不实施TDD，持续集成就没有效果，进而破坏迭代，导致敏捷化为乌有。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改进设计</span></span><ul><li><span class="name"><span class="innerContentContainer">随时改进糟糕的代码。保持代码尽可能的干净，具有表达力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">持续集成</span></span><ul><li><span class="name"><span class="innerContentContainer">团队总是使系统完整地被集成。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">集体代码所有权</span></span><ul><li><span class="name"><span class="innerContentContainer">任何结对的程序员都可以在任何时候改进任何代码。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">编码标准</span></span><ul><li><span class="name"><span class="innerContentContainer">系统中所有的代码看起来就好像是被单独一个--非常值得胜任的--人编写的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">隐喻</span></span><ul><li><span class="name"><span class="innerContentContainer">团队提出一个程序工作原理的公共景像。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可持续的速度</span></span><ul><li><span class="name"><span class="innerContentContainer">团队只有持久才有获胜的希望，他们以能够长期维持的速度努力工作，他们保存精力，他们把项目看作是马拉松长袍，而不是全速短跑。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;&lt;敏捷软件开发&gt;&gt;读书笔记</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 测试是如何驱动设计，驱动编码，驱动重构的？</span></span><ul><li><span class="name"><span class="innerContentContainer">看第6章，一个好例子。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 软件可以分为哪几个层面？三个层面：</span></span><ul><li><span class="name"><span class="innerContentContainer">“外衣”，即人机接口；所有用户可以看见的部分（性能也能“看”见，但是不算外衣吧）。</span></span><ul><li><span class="name"><span class="innerContentContainer">这部分本来应该比逻辑层更“软”，但是很不幸，现代操作系统和软件平台（指java或类似的东西）的发展，导致这部分完全不受程序员控制，也就是说，一旦选定操作系统和软件平台，如何使用界面元素就定死了，必须按它的游戏规则玩。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">逻辑层，不属于第一层和第三层的其它的一切，包括业务逻辑，安全性，性能，并发，日志等。</span></span></li><li><span class="name"><span class="innerContentContainer">基础设施，包括硬件、操作系统、文件系统、数据库、编译器和库，也就是说，所有在你的流程中不可能更改的那些部分。除了按它们的游戏规则玩别无他法。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，我这里不是指硬件、操作系统、数据库本身，这些东西也不需要你去做测试。我指的是，你的软件对这些东西的封装那一层逻辑，即软件和这些基础设施的接口层。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有这个接口层，逻辑层直接访问基础设施，那么整个代码就无法ut了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. “外衣”层如何 ut？</span></span><ul><li><span class="name"><span class="innerContentContainer">目前可以说，不能，只有系统测试，或者说是验收测试。为什么，因为这部分不受程序员左右，纯粹是os和平台厂商的舞台，而他们一般都是最慢的一群人。</span></span></li><li><span class="name"><span class="innerContentContainer">好的测试框架，比如google的 monkey。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 逻辑层，此为ut的绝大部分领域。</span></span><ul><li><span class="name"><span class="innerContentContainer">泛观众敏捷、TDD、重构书，这个是没有说出口的秘密。</span></span></li><li><span class="name"><span class="innerContentContainer">明白这一点，就知道把大师的宏论落地，真是我纭纭众生的苦差事啊。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 基础设施层。其实也是要ut 的，但方法还处在不靠谱阶段。</span></span><ul><li><span class="name"><span class="innerContentContainer">目前这部分ut 的办法是Mock Object模式。即打桩。创建合适的桩类，传给需要ut 的对象，然后测之。</span></span></li><li><span class="name"><span class="innerContentContainer">桩函数要特别简单，绝大部分直接返回ok、fail即可（否则成本就太高了）。但是往往从桩类的设计中，可以得出构架层面的设计，比如要不要分层，分为几层，是否有特定硬件的依赖，要不要使用xml，要不要支持多线程等等。</span></span></li><li><span class="name"><span class="innerContentContainer">是的，我们找到银弹了。我们是特别幸运的一代人。---没有任何讽刺之意。原因详见第八条。我恨不得马上解释一下，但是后面还有一个强有力的观点要表达，所以不得不推迟一点）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7.  这里所说的测试，包括非自动化测试吗？</span></span><ul><li><span class="name"><span class="innerContentContainer">不包括。所有的非自动化测试，都不是测试。因为它们收不到驱动设计、驱动编码、驱动重构的益处。</span></span></li><li><span class="name"><span class="innerContentContainer">非自动化测试，可以称之为绝望的呐喊。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 测试为什么可以驱动设计，驱动编码，驱动重构的？---关于这个问题的心理学解释</span></span><ul><li><span class="name"><span class="innerContentContainer">软件，涉及3个角色，用户，程序员，电脑。程序员负责把用户的需求“翻译”给电脑“听”。</span></span></li><li><span class="name"><span class="innerContentContainer">之前的软件过程（我是指ut之前），认为最大的问题是程序员没听懂用户的话，导致“翻译”失败。他们认为之所以有那么多的软件失败，是因为程序员都太geek了。</span></span></li><li><span class="name"><span class="innerContentContainer">但这不是真的。用户和程序员都是人，人与人沟通其实没那么难，尤其是在用户给程序员发工资的情况下。</span></span></li><li><span class="name"><span class="innerContentContainer">问题其实出在程序员到电脑这个阶段的沟通失败。</span></span></li><li><span class="name"><span class="innerContentContainer">从人脑角度看需求的物件特别多了，比如需求文档，设计文档，验收测试，原型，uml，结构图，数据流图等等，甚至会议也算。（因为大家都觉得这块是问题嘛，所以拼命发明新东西，从不同角度来考验它。）</span></span></li><li><span class="name"><span class="innerContentContainer">但是，从电脑角度看需求的物件只有一个，就是代码。</span></span></li><li><span class="name"><span class="innerContentContainer">凡是只有一个的地方，最容易出问题，最容易掩盖问题。独木难支啊。</span></span></li><li><span class="name"><span class="innerContentContainer">ut，是另一个从电脑角度看需求的物件。</span></span></li><li><span class="name"><span class="innerContentContainer">将来，可能还会发明很多从电脑角度看需求的物件来，但是目前，ut是唯一的第二个。</span></span></li><li><span class="name"><span class="innerContentContainer">因此，用好了，它能改变一切。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 编码即重构</span></span><ul><li><span class="name"><span class="innerContentContainer">重构并不是有了一堆代码后重新整理它的过程。</span></span></li><li><span class="name"><span class="innerContentContainer">你写下第一行代码的过程也叫重构。那时你重构的是空白代码。c程序员应该能理解我在说什么。世间万物，从0开始，是我们的哲学。</span></span></li><li><span class="name"><span class="innerContentContainer">并不存在一个重构之外的编码阶段。重构和编码过程完全重合，两者等义。</span></span></li><li><span class="name"><span class="innerContentContainer">有人会问，那我现在到底是在重构，还是在编码？</span></span></li><li><span class="name"><span class="innerContentContainer">你会问你的父亲，“到底是该叫你父亲，还是该叫你爸爸？”吗？</span></span></li><li><span class="name"><span class="innerContentContainer">如果你已经在重构了，那这番话就直接pass掉吧。我想告知的是那些无限期的拖延重构、一直到项目结束的人们。你们并不是如同想象的那样在拖延一件可有可无的叫重构的事，其实你已经在重构了，已经在糟糕的重构了，而且越来越糟。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统工程与项目管理的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">前者：设计质量决定系统质量；后者：软件生命周期</span></span></li><li><span class="name"><span class="innerContentContainer">前者：信息隐藏；后者：清晰的需求管理</span></span></li><li><span class="name"><span class="innerContentContainer">前者：持续集成；后者：测试策略；</span></span></li><li><span class="name"><span class="innerContentContainer">前者：重视复杂度；后者：重视组织成熟度</span></span></li><li><span class="name"><span class="innerContentContainer">前者：成功取决于是否有精于技术的领导；后者：是否有完美的管理流程。</span></span></li><li><span class="name"><span class="innerContentContainer">前者：团队每阶段的自反馈；后者：项目时间点控制</span></span></li><li><span class="name"><span class="innerContentContainer">前者：设计与实现不分离；后者：成本、设计和视野决定成功。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">杜军--编程能力</span></span><ul><li><span class="name"><span class="innerContentContainer">编程能力一定是为某个业务服务的，因此，程序员要想清楚自己希望朝哪个业务领域发展；</span></span></li><li><span class="name"><span class="innerContentContainer">凡是依赖倒置的，都是面向对象的；反之则是面向过程的。</span></span></li><li><span class="name"><span class="innerContentContainer">从编程角度，面向过程即面向编辑器；面向对象，即面向现实世界。</span></span></li><li><span class="name"><span class="innerContentContainer">敏捷唯一指的是软件团队的应变能力。</span></span></li><li><span class="name"><span class="innerContentContainer">简单的代码不等于篇幅简短的代码，也不等于拒绝运用技巧。</span></span></li><li><span class="name"><span class="innerContentContainer">各种度量工具给出的都是工程指标，好的代码至少有一半是无法度量的，只能在需求快速变化中得到检验。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">需求管理</span></span><ul><li><span class="name"><span class="innerContentContainer">IR：原始需求，价值，竞品</span></span></li><li><span class="name"><span class="innerContentContainer">实例化为:</span></span></li><li><span class="name"><span class="innerContentContainer">SR：关键点是 工作量 和 第三方依赖. SR写作：</span></span><ul><li><span class="name"><span class="innerContentContainer">特性：</span></span><ul><li><span class="name"><span class="innerContentContainer">as a 用户</span></span></li><li><span class="name"><span class="innerContentContainer">I want to</span></span></li><li><span class="name"><span class="innerContentContainer">In order to</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">场景：</span></span><ul><li><span class="name"><span class="innerContentContainer">Given</span></span></li><li><span class="name"><span class="innerContentContainer">When</span></span></li><li><span class="name"><span class="innerContentContainer">Then</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">方案设计为:</span></span></li><li><span class="name"><span class="innerContentContainer">AR：方案和接口设计</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码规范</span></span><ul><li><span class="name"><span class="innerContentContainer">代码文件头注释</span></span><ul><li><span class="name"><span class="innerContentContainer">/*******************************************************************</span></span><ul><li><span class="name"><span class="innerContentContainer">*Copyright(C),&nbsp;Your&nbsp;Company</span></span></li><li><span class="name"><span class="innerContentContainer">*FileName:&nbsp;文件名</span></span></li><li><span class="name"><span class="innerContentContainer">*Author: 作者</span></span></li><li><span class="name"><span class="innerContentContainer">*Version: 版本</span></span></li><li><span class="name"><span class="innerContentContainer">*Date: 完成日期</span></span></li><li><span class="name"><span class="innerContentContainer">*Description:&nbsp; 用于主要说明此程序文件完成的主要功能</span></span><ul><li><span class="name"><span class="innerContentContainer">与其他模块或函数的接口、输出值、取值范围、</span></span><ul><li><span class="name"><span class="innerContentContainer">含义及参数间的控制、顺序、独立及依赖关系</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">*Others:</span></span></li><li><span class="name"><span class="innerContentContainer">*History:&nbsp; 修改历史记录列表，每条修改记录应包含修改日期、修改者及修改内容简介</span></span><ul><li><span class="name"><span class="innerContentContainer">1.&nbsp;2020-1-4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duangan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Init.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">******************************************************************/</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">代码 Review</span></span></li><li><span class="name"><span class="innerContentContainer">RUP</span></span></li><li><span class="name"><span class="innerContentContainer">看板管理</span></span></li><li><span class="name"><span class="innerContentContainer">代码质量度量</span></span><ul><li><span class="name"><span class="innerContentContainer">CC：圈复杂度</span></span><ul><li><span class="name"><span class="innerContentContainer">计算公式为：V(G)=n+1。其中，n表示判定节点的数量，指if...else 和 switch...case分支的数量。</span></span></li><li><span class="name"><span class="innerContentContainer">cyclomatic complexity。是一种代码复杂度的衡量标准。</span></span></li><li><span class="name"><span class="innerContentContainer">业界标准&lt;10，华为无线软件平均是19.82，最大为1274。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Depth：嵌套深度</span></span><ul><li><span class="name"><span class="innerContentContainer">主要指条件及循环嵌套的层次。</span></span></li><li><span class="name"><span class="innerContentContainer">业界标准无此项数据；华为无线软件平均3.66，最大为17。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Fan-out：扇出数</span></span><ul><li><span class="name"><span class="innerContentContainer">指一个函数直接调用其它函数的数目。这个值越小维护性、代码可读性越好。</span></span></li><li><span class="name"><span class="innerContentContainer">业界数据&lt;7，华为无线软件为27.8，最大为2006。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Avg CC/Depth/Fan-out</span></span><ul><li><span class="name"><span class="innerContentContainer">例如：avg CC=sum(CC*state)/sum(state)，state表示代码行数。</span></span></li><li><span class="name"><span class="innerContentContainer">对这三个指标进行加权，权重为每个函数的语句占比.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MI</span></span><ul><li><span class="name"><span class="innerContentContainer">MI指可维护性系数，MI=avg CC + avg depths + avg Fan-out。它是相对值。</span></span></li><li><span class="name"><span class="innerContentContainer">为什么需要MI这个值？</span></span></li><li><span class="name"><span class="innerContentContainer">因为CC、depths、Fan-out这三个指标不能互相替代，各有其代表性。从实践上看，随着版本演进，depths和Fan-out有明显的恶化趋势。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何统计重复代码？</span></span><ul><li><span class="name"><span class="innerContentContainer">simian可以统计。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">重构</span></span></li><li><span class="name"><span class="innerContentContainer">PDCA 循环质量管理</span></span></li><li><span class="name"><span class="innerContentContainer">FMEA管理模式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">IT行业的安全的概念范畴:</span></span><ul><li><span class="name"><span class="innerContentContainer">保密性（数据加密, 这是基础）</span></span></li><li><span class="name"><span class="innerContentContainer">完整性</span></span></li><li><span class="name"><span class="innerContentContainer">可靠性（不可篡改）</span></span></li><li><span class="name"><span class="innerContentContainer">可用性（不可失去能力）</span></span></li><li><span class="name"><span class="innerContentContainer">不可抵赖性</span></span></li><li><span class="name"><span class="innerContentContainer">可控性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">加密算法 (完成保密性)</span></span><ul><li><span class="name"><span class="innerContentContainer">对称算法</span></span><ul><li><span class="name"><span class="innerContentContainer">又叫传统密码方法，是n多种算法的统称。</span></span></li><li><span class="name"><span class="innerContentContainer">基于秘钥。</span></span></li><li><span class="name"><span class="innerContentContainer">主要特征是加密和解密用的秘钥一样。</span></span></li><li><span class="name"><span class="innerContentContainer">由于安全系数比较低，二战后长期普遍不用，直到DES出现。</span></span></li><li><span class="name"><span class="innerContentContainer">DES</span></span><ul><li><span class="name"><span class="innerContentContainer">全称为Data Encryption Standard，即数据加密标准。</span></span></li><li><span class="name"><span class="innerContentContainer">1977年被美国政府确定为联邦资料处理标准，开始流行。</span></span></li><li><span class="name"><span class="innerContentContainer">优点是速度较快，适用于加密大量数据的场合。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是不安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">DES设计中使用了分组密码设计的两个原则：混淆（confusion）和扩散(diffusion)，其目的是抗击敌手对密码系统的统计分析。</span></span><ul><li><span class="name"><span class="innerContentContainer">混淆是使密文的统计特性与密钥的取值之间的关系尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的。</span></span></li><li><span class="name"><span class="innerContentContainer">扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DES算法的入口参数有三个：Key、Data、Mode。</span></span><ul><li><span class="name"><span class="innerContentContainer">Key为7个字节共56位，是DES算法的工作密钥；</span></span></li><li><span class="name"><span class="innerContentContainer">Data为8个字节64位，是要被加密或被解密的数据；</span></span></li><li><span class="name"><span class="innerContentContainer">Mode为DES的工作方式,有两种:加密或解密。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">AES</span></span><ul><li><span class="name"><span class="innerContentContainer">高级加密标准（Advanced Encryption Standard）。取代DES。</span></span></li><li><span class="name"><span class="innerContentContainer">AES使用的是区块置换-组合架构。</span></span></li><li><span class="name"><span class="innerContentContainer">区块长度固定为128位，密钥长度则可以是128，192或256位。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">代码：</span></span><ul><li><span class="name"><span class="innerContentContainer">crypto_aes_init()</span></span></li><li><span class="name"><span class="innerContentContainer">crypto_aes_encrypt_block()：块加密，输入必须为块长的整数倍</span></span></li><li><span class="name"><span class="innerContentContainer">crypto_aes_deencrypt_block()：块解密</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">非对称算法</span></span><ul><li><span class="name"><span class="innerContentContainer">主要特征是加密、解密分别用不同的密钥。其中解密的叫公钥，可以公开，因此又叫公开密钥算法。</span></span></li><li><span class="name"><span class="innerContentContainer">加密的叫私钥，不能公开。</span></span></li><li><span class="name"><span class="innerContentContainer">RSA</span></span><ul><li><span class="name"><span class="innerContentContainer">RSA是最有影响力的非对称算法，业界公认它能抵抗迄今为止已知的所有的攻击方法。</span></span></li><li><span class="name"><span class="innerContentContainer">RSA于1978年发明。</span></span></li><li><span class="name"><span class="innerContentContainer">其优势是公钥公开，适应网络的开放性要求，同时同一算法可支持签名和加密。</span></span></li><li><span class="name"><span class="innerContentContainer">缺点是算法复杂，效率较低。</span></span></li><li><span class="name"><span class="innerContentContainer">为了保证安全，请使用 1024、2048位。</span></span></li><li><span class="name"><span class="innerContentContainer">RSA的安全性依赖大数分解。</span></span><ul><li><span class="name"><span class="innerContentContainer">公钥和私钥都是两个大素数（大于100个二进制位）的函数。</span></span></li><li><span class="name"><span class="innerContentContainer">据推测，从一个密钥和密文推断出明文的难度等同于分解两个素数的积。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RSA可用于签名，即私钥加密，公钥解密。</span></span></li><li><span class="name"><span class="innerContentContainer">也可用于加密，公钥加密，私钥解密。</span></span></li><li><span class="name"><span class="innerContentContainer">代码</span></span><ul><li><span class="name"><span class="innerContentContainer">rsa_public_decrypt：公钥解密</span></span></li><li><span class="name"><span class="innerContentContainer">ras_private_encrypt：私钥加密</span></span></li><li><span class="name"><span class="innerContentContainer">有反过来用的api。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">DSA</span></span><ul><li><span class="name"><span class="innerContentContainer">1024位。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是安全的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PH</span></span><ul><li><span class="name"><span class="innerContentContainer">1024、2048位。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是安全的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ECC</span></span><ul><li><span class="name"><span class="innerContentContainer">椭圆曲线加密</span></span></li><li><span class="name"><span class="innerContentContainer">192、216位。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是安全的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ECDSA</span></span><ul><li><span class="name"><span class="innerContentContainer">椭圆曲线加密</span></span></li><li><span class="name"><span class="innerContentContainer">192、216位。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是安全的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>公钥加密，私钥签名。</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">签名和数字证书 (完成除保密性之前的其它内容)</span></span><ul><li><span class="name"><span class="innerContentContainer">加密签名都要求接受信息的一方获得正确的公钥，这就是数字证书的作用了。</span></span></li><li><span class="name"><span class="innerContentContainer">签名算法</span></span><ul><li><span class="name"><span class="innerContentContainer">数字签名有两种功效：</span></span><ul><li><span class="name"><span class="innerContentContainer">1是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</span></span></li><li><span class="name"><span class="innerContentContainer">2是数字签名能确定消息的完整性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">做法是对一段明文做 SHA/MD5 等算法；要求得到的值要短，且尽可能是唯一的。</span></span></li><li><span class="name"><span class="innerContentContainer">一个高效的数字签名技术 = 消息摘要技术 + 非对称加密技术（RSA算法）。</span></span></li><li><span class="name"><span class="innerContentContainer">CRC</span></span><ul><li><span class="name"><span class="innerContentContainer">循环冗余校验。</span></span></li><li><span class="name"><span class="innerContentContainer">算法历史较长，版本多样，应用很广泛。</span></span></li><li><span class="name"><span class="innerContentContainer">通讯领域用得最多的是CRC32，它由不限长的数据，生成一个32位的校验值。</span></span></li><li><span class="name"><span class="innerContentContainer">优势是简单，速度快，缺点是很容易碰撞，只能针对小数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MD5</span></span><ul><li><span class="name"><span class="innerContentContainer">90年代由MIT发明，经由md2、md3、md4发展起来。</span></span></li><li><span class="name"><span class="innerContentContainer">将任意上的字符串变换成一个128位的整数，不可逆，即无法由密文转为明文。</span></span></li><li><span class="name"><span class="innerContentContainer">MD5的典型应用时对一段数据产生指纹，以防止被“篡改”，这就是数字签名。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是不安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">代码</span></span><ul><li><span class="name"><span class="innerContentContainer">hash_md5_init：初始化</span></span></li><li><span class="name"><span class="innerContentContainer">hash_md5_update：喂数据进去，可多次调用</span></span></li><li><span class="name"><span class="innerContentContainer">hash_md5_final：给出结果</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SHA1 / SHA224 / SHA256 / SHA384 / SHA512</span></span><ul><li><span class="name"><span class="innerContentContainer">与CRC、MD5类似，都是一种散列算法。</span></span></li><li><span class="name"><span class="innerContentContainer">它产生的签名长，更为安全，是散列算法的发展方向。</span></span></li><li><span class="name"><span class="innerContentContainer">SHA1有160位，其它几种即以位宽命名。</span></span></li><li><span class="name"><span class="innerContentContainer">SHA1被认为是不安全的。其它几种安全。</span></span></li><li><span class="name"><span class="innerContentContainer">目前主要用于数字签名。</span></span></li><li><span class="name"><span class="innerContentContainer">代码</span></span><ul><li><span class="name"><span class="innerContentContainer">hash_sha1_init：初始化</span></span></li><li><span class="name"><span class="innerContentContainer">hash_sha1_update：update数据进去</span></span></li><li><span class="name"><span class="innerContentContainer">hash_sha1_final：给出结果</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">HMAL-SHA（带密钥）</span></span><ul><li><span class="name"><span class="innerContentContainer">强度同SHA。</span></span></li><li><span class="name"><span class="innerContentContainer">被认为是安全的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">数字证书可以保证数字证书里面的公钥确实是这个证书所有者的，这样就可以解决公钥的安全发放了。</span></span></li><li><span class="name"><span class="innerContentContainer">如何保证这一点呢？这就用到了一种约定。我们理论上认为某些有公信力的机构发放的证书是安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">这些发放证书的机构叫做<b>CA</b>（Certificate Authority）。</span></span></li><li><span class="name"><span class="innerContentContainer">CA用自己的私钥对申请证书的人的公钥和一些基本信息，做签名，然后把申请者的公钥，基本信息，和数字签名放到一起组成一个证书。</span></span></li><li><span class="name"><span class="innerContentContainer">CA本身也会生成一个证书，是自签名的，也叫根证书，会内置在操作系统里面。</span></span></li><li><span class="name"><span class="innerContentContainer">一个数字证书包括如下内容：</span></span><ul><li><span class="name"><span class="innerContentContainer">证书持有者的信息</span></span></li><li><span class="name"><span class="innerContentContainer">持有者的公钥</span></span></li><li><span class="name"><span class="innerContentContainer">证书签发机构（CA）的信息</span></span></li><li><span class="name"><span class="innerContentContainer">CA机构对证书本身的签名信息</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数字证书主要用于解决公钥的安全发放问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Web 安全</span></span><ul><li><span class="name"><span class="innerContentContainer">XSS</span></span></li><li><span class="name"><span class="innerContentContainer">CSRF</span></span></li><li><span class="name"><span class="innerContentContainer">SQL 注入</span></span></li><li><span class="name"><span class="innerContentContainer">Hash Dos</span></span></li><li><span class="name"><span class="innerContentContainer">脚本注入</span></span></li><li><span class="name"><span class="innerContentContainer">漏洞扫描工具</span></span></li><li><span class="name"><span class="innerContentContainer">验证码</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DDoS 防范</span></span></li><li><span class="name"><span class="innerContentContainer">用户隐私信息保护</span></span></li><li><span class="name"><span class="innerContentContainer">序列化漏洞</span></span></li><li><span class="name"><span class="innerContentContainer">服务器安全</span></span></li><li><span class="name"><span class="innerContentContainer">数据安全</span></span><ul><li><span class="name"><span class="innerContentContainer">数据备份</span></span></li><li><span class="name"><span class="innerContentContainer">容灾</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络隔离</span></span><ul><li><span class="name"><span class="innerContentContainer">内外网分离</span></span></li><li><span class="name"><span class="innerContentContainer">登录跳板机</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">授权、认证</span></span><ul><li><span class="name"><span class="innerContentContainer">RBAC</span></span></li><li><span class="name"><span class="innerContentContainer">OAuth2.0</span></span></li><li><span class="name"><span class="innerContentContainer">双因素认证（2FA）</span></span></li><li><span class="name"><span class="innerContentContainer">单点登录(SSO)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">测试&amp;运维</span></span><ul><li><span class="name"><span class="innerContentContainer">软件测试</span></span><ul><li><span class="name"><span class="innerContentContainer">FS 模块的UT 代码  <span class="contentTag" title="Filter #TODO">#<span class="contentTagText">TODO</span><span class="contentTagNub"></span></span>  比较经典的UT例子</span></span></li><li><span class="name"><span class="innerContentContainer">用例设计方法  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">白盒测试</span></span><ul><li><span class="name"><span class="innerContentContainer">语句覆盖</span></span></li><li><span class="name"><span class="innerContentContainer">分支覆盖</span></span></li><li><span class="name"><span class="innerContentContainer">条件覆盖</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">黑盒测试</span></span><ul><li><span class="name"><span class="innerContentContainer">等价类方法: 把用例空间划分为若干个集合, 集合内的元素具有统计一致性, 因此只需要测试一个用例即可代表其它所有.</span></span></li><li><span class="name"><span class="innerContentContainer">边界值</span></span></li><li><span class="name"><span class="innerContentContainer">因果图: 用图表示输入的组合关系.</span></span></li><li><span class="name"><span class="innerContentContainer">判定表: 用图标表示输出的组合关系.</span></span></li><li><span class="name"><span class="innerContentContainer">正交实验法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灰盒测试</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用例设计例子 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">测试场景: 登录页面 ，上面有两个输入框：用户名，密码，下面是一个登录按钮。 </span></span></li><li><span class="name"><span class="innerContentContainer">1. 参考依据: 严格按照产品设计规格测试用例</span></span></li><li><span class="name"><span class="innerContentContainer">2. 必答项</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 不同分辨率，样式符合ui设计.</span></span></li><li><span class="name"><span class="innerContentContainer">2. 用户名输入框内容的校验： 空串的提示, 特殊字符，长度 ，超长或换行后ui的显示，校验的时机（失焦或点击登录）.</span></span></li><li><span class="name"><span class="innerContentContainer">3. 密码框的校验：空串的提示, 特殊字符的校验，长度的检验，是否阻止拷贝粘贴, 密码的显示，校验的时机（失焦或点击登录）.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 登录按钮ui展示正常，可以正常点击，点击后的行为符合规格，正常发起登录请求.</span></span></li><li><span class="name"><span class="innerContentContainer">5. 对请求返回的数据正常响应，正常跳转或相关提示符合ui设计(包括正确输入和错误输入).</span></span></li><li><span class="name"><span class="innerContentContainer">6. 输入框回车键后的行为需要统一定义.</span></span></li><li><span class="name"><span class="innerContentContainer">7. 是否保存历史记录.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 加分项</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 使用脚本或其它手段多次点击登录按钮，页面行为无异常</span></span></li><li><span class="name"><span class="innerContentContainer">2. 使用抓包工具查看密码是否加密</span></span></li><li><span class="name"><span class="innerContentContainer">3. 尝试sql注入是否可以绕过校验</span></span></li><li><span class="name"><span class="innerContentContainer">4. 使用moc工具伪造数据回包，是否对页面产生影响</span></span></li><li><span class="name"><span class="innerContentContainer">5. 日志中查看开发是否输出了敏感信息</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TDD 理论</span></span></li><li><span class="name"><span class="innerContentContainer">单元测试, UT</span></span><ul><li><span class="name"><span class="innerContentContainer">UT用例的设计方法</span></span><ul><li><span class="name"><span class="innerContentContainer">规格导出法</span></span><ul><li><span class="name"><span class="innerContentContainer">顾名思义，就是将规格切分为一个个的用例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">等价类法</span></span><ul><li><span class="name"><span class="innerContentContainer">等价类法需要较强的业务能力。</span></span></li><li><span class="name"><span class="innerContentContainer">基于对输入、输出集合中的等价子集; 每个子集只找一个作为用例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">边界值法</span></span><ul><li><span class="name"><span class="innerContentContainer">这个方法是对等价类法的补充。因为边界最容易出问题。</span></span></li><li><span class="name"><span class="innerContentContainer">边界包括上边界和下边界.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">UT属于白盒测试, 属于研发自验证范畴.</span></span></li><li><span class="name"><span class="innerContentContainer">UT工具</span></span><ul><li><span class="name"><span class="innerContentContainer">单元测试现在已经成为标准的编程实践. 但是UT和编程语言以及业务模型强相关.</span></span></li><li><span class="name"><span class="innerContentContainer">C++缺少Java和.Net平台语言的反射机制，所以无法枚举测试方法，必须手工添加，或者使用一些特别的宏，弄得代码非常难看。</span></span></li><li><span class="name"><span class="innerContentContainer">Java语言单元测试是JUnit的天下.</span></span></li><li><span class="name"><span class="innerContentContainer">C#基本上都用NUnit.</span></span></li><li><span class="name"><span class="innerContentContainer">C++则群花怒放，单元测试框架非常多.</span></span><ul><li><span class="name"><span class="innerContentContainer">推荐 CxxTest和TUT。</span></span></li><li><span class="name"><span class="innerContentContainer">JUnit移植过来的 CppUnit，Boost::test，CppTest，CxxTest， TUT等等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CxxTest</span></span><ul><li><span class="name"><span class="innerContentContainer">无须写额外的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">采用的方法比较特殊，用Perl分析C++的源文件，从中抽取测试方法，创建 TestSuite。</span></span></li><li><span class="name"><span class="innerContentContainer">语法与JUnit非常相似，没有使用高级的C++特性，也没有定义特别的宏.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TUT</span></span><ul><li><span class="name"><span class="innerContentContainer">结构框架简单。添加新的测试工作量小；无须注册测试；可移植性好（因其只需两个头文件，就可以完成测试工作）；便于装卸；提供接口可以扩展其输出方式等。</span></span></li><li><span class="name"><span class="innerContentContainer">最大的优点：轻量级，便于装卸和可扩展其输出方式；</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：断言似乎不是很好，只用了一个ensure()函数，不知道对复杂的测试是否支持；输出的测试结果较为简单。</span></span></li><li><span class="name"><span class="innerContentContainer">TUT利用了高级C++&nbsp;Template功能，必须比较新的编译器才支持，<a class="contentLink" target="_blank" rel="noreferrer" href="http://比如VC6和VS.NET">比如VC6和VS.NET</a>&nbsp;2002就不支持，<a class="contentLink" target="_blank" rel="noreferrer" href="http://必须VS.NET">必须VS.NET</a>&nbsp;2003以上或者Intel C++ Complier 8.1以上。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Boost::test</span></span><ul><li><span class="name"><span class="innerContentContainer">结构框架较为复杂。添加新的测试工作量也不大；提供多种测试方法，可注册测试用例，也可不注册；可移植性一般；装卸不易；在控制异常、崩溃方面的能力胜过其它所有对手；拥有良好的断言功能；大概能支持多种输出方式，但更改输出方式不易；支持测试套件。</span></span></li><li><span class="name"><span class="innerContentContainer">最大的优点：控制异常崩溃的能力、良好的断言、输出结果较为详细、编写测试的方法灵活；</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：结构框架较为复杂，更改输出方式不易，装卸不易。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CXXTest</span></span><ul><li><span class="name"><span class="innerContentContainer">结构框架的复杂性处于TUT与boost::test之间。添加新的测试工作量非常小；无须注册测试用例；可移植性很好；便于装卸；控制异常、崩溃方面的能力也不错；拥有良好的断言功能；支持多种输出方式；支持测试套件。</span></span></li><li><span class="name"><span class="innerContentContainer">最大的优点：编译即测试方式，并且可以双击结果行立即定位到相应的源代码，相当吸引人；支持多种输出，输出结果较为详细；编写测试简单；</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：需要用到perl对测试代码进行文法扫描，生成可执行代码，需要用到makefile文件（不是必须）；准备工作比较麻烦。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMocker</span></span><ul><li><span class="name"><span class="innerContentContainer">cmockery 是google发布的用于C单元测试的一个轻量级的框架。</span></span></li><li><span class="name"><span class="innerContentContainer">主要特点：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 免费且开源，google提供技术支持；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 轻量级的框架，使测试更加快速简单；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</span></span></li><li><span class="name"><span class="innerContentContainer">4. 并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取源码：</span></span></li><li><span class="name"><span class="innerContentContainer">直接下载：http://code.<a class="contentLink" target="_blank" rel="noreferrer" href="http://google.com/p/cmockery/downloads/list">google.com/p/cmockery/downloads/list</a></span></span></li><li><span class="name"><span class="innerContentContainer">svn地址：svn checkout <a class="contentLink" target="_blank" rel="noreferrer" href="http://cmockery.googlecode.com/svn/trunk/">http://cmockery.googlecode.com/svn/trunk/</a> cmockery-read-only</span></span></li><li><span class="name"><span class="innerContentContainer">编译方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">windows</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 打开使用VS2003/2005/2008 提供的 命令提示窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">2. cd 到CMockery的目录的window目录</span></span></li><li><span class="name"><span class="innerContentContainer">3. 运行 nmake 命令</span></span><ul><li><span class="name"><span class="innerContentContainer">E:</span></span></li><li><span class="name"><span class="innerContentContainer">cd E:\OpenSource\c\cMockery</span></span></li><li><span class="name"><span class="innerContentContainer">cd windows</span></span></li><li><span class="name"><span class="innerContentContainer">nmake</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">cmockery.lib文件以及一些测试代码都在 Windows目录下；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">linux</span></span><ul><li><span class="name"><span class="innerContentContainer">cd 到 cMockery 源码目录</span></span></li><li><span class="name"><span class="innerContentContainer">sudo ./configure</span></span></li><li><span class="name"><span class="innerContentContainer">sudo make</span></span></li><li><span class="name"><span class="innerContentContainer">sudo make install</span></span></li><li><span class="name"><span class="innerContentContainer">库文件安装到：/usr/local/lib</span></span></li><li><span class="name"><span class="innerContentContainer">头文件安装到：/usr/local/include/google</span></span></li><li><span class="name"><span class="innerContentContainer">注意此时还应该加载一下CMockery库：</span></span></li><li><span class="name"><span class="innerContentContainer">cd /usr/local/lib</span></span></li><li><span class="name"><span class="innerContentContainer">sudo ldconfig</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">压力测试</span></span></li><li><span class="name"><span class="innerContentContainer">全链路压测</span></span></li><li><span class="name"><span class="innerContentContainer">A/B 、灰度、蓝绿测试</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件测评测试</span></span><ul><li><span class="name"><span class="innerContentContainer">稳定性测试</span></span><ul><li><span class="name"><span class="innerContentContainer">统计指标是Monkey测试1000小时（或10部手机各100小时），死机、冻屏、重启多少次。</span></span></li><li><span class="name"><span class="innerContentContainer">指标:</span></span><ul><li><span class="name"><span class="innerContentContainer">tr4a：大T 2%，其它 4%。</span></span></li><li><span class="name"><span class="innerContentContainer">tr5：统一为1%。</span></span></li><li><span class="name"><span class="innerContentContainer">tr6：大T 0.2%，其它 0.4%。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">FFR的概念</span></span><ul><li><span class="name"><span class="innerContentContainer">现场失效率，指产品故障数占市场在保量的比例。</span></span></li><li><span class="name"><span class="innerContentContainer">故障率涵盖所有用户送来维修的问题手机，包括未复现。</span></span></li><li><span class="name"><span class="innerContentContainer">从诺基亚引入。</span></span></li><li><span class="name"><span class="innerContentContainer">FFR的公式: FFR=12 * 月度故障量 / 产品在保量。</span></span><ul><li><span class="name"><span class="innerContentContainer">这是个年化值;</span></span></li><li><span class="name"><span class="innerContentContainer">度故障率是采用三个月的平滑数据，所以上市头两个月没有数据。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">NFF</span></span><ul><li><span class="name"><span class="innerContentContainer">无故障返修率。即问题没有复现。</span></span></li><li><span class="name"><span class="innerContentContainer">在欧美甚多，因为欧美多采用直接换机策略，维修放在后台集中做，服务代表看不到客户，加大了复现问题的难度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常规手机测试</span></span><ul><li><span class="name"><span class="innerContentContainer">软件压力测试: 用自动测试软件连续给手机拨打1000个电话,检查手机是否会发生故障.</span></span></li><li><span class="name"><span class="innerContentContainer">抗摔性测试</span></span><ul><li><span class="name"><span class="innerContentContainer">抗摔性测试由专门的PRT可靠性实验来进行. </span></span></li><li><span class="name"><span class="innerContentContainer">半米的微跌落测试要做300/面(手机有6个面). </span></span></li><li><span class="name"><span class="innerContentContainer">2米的跌落测试每个面需各做一次.</span></span></li><li><span class="name"><span class="innerContentContainer">以及模拟人把手机扔到桌面的测试，要测试100次。</span></span></li><li><span class="name"><span class="innerContentContainer">电池要在4m高度，连续抛下100次后不能有断裂。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">高温低温测试</span></span><ul><li><span class="name"><span class="innerContentContainer">让手机处于高低不同的温度来检测手机的适应性。</span></span></li><li><span class="name"><span class="innerContentContainer">一般低温为-20度，高温80度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">高湿度测试</span></span><ul><li><span class="name"><span class="innerContentContainer">用一个专门的箱子来操作滴水测试, 模拟人出汗的情况(水里面掺有一定比例的盐)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">百格测试</span></span><ul><li><span class="name"><span class="innerContentContainer">用专用刀片在手机的外壳画100个格子10*10；</span></span></li><li><span class="name"><span class="innerContentContainer">用专用胶带粘其表面，以及用常见化妆品反复涂抹外壳，看会不会掉漆。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">翻盖测试</span></span><ul><li><span class="name"><span class="innerContentContainer">对翻盖手机进行翻盖10万次,检查壳体的损耗情况.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">扭矩测试</span></span><ul><li><span class="name"><span class="innerContentContainer">用夹具夹住两头,一头左拧,一头右拧.</span></span></li><li><span class="name"><span class="innerContentContainer">测试壳体和手机里面大型器件的强度.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静电测试</span></span><ul><li><span class="name"><span class="innerContentContainer">冬季手摸金属的东西容易产生静电, 可能击穿手机电路.</span></span></li><li><span class="name"><span class="innerContentContainer">有专门的静电枪（10-15kV高压，低电流）和铜板来测试，持续时间之300ms到2s。</span></span></li><li><span class="name"><span class="innerContentContainer">充电器也要做。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">按键测试: 借助机器以给定的力量击打键盘10万次.</span></span></li><li><span class="name"><span class="innerContentContainer">沙尘测试</span></span><ul><li><span class="name"><span class="innerContentContainer">手机放入特定的箱子,细小的沙子被鼓吹起来.</span></span></li><li><span class="name"><span class="innerContentContainer">数小时后,察看手机里面是否有沙子进入.</span></span></li><li><span class="name"><span class="innerContentContainer">如果是,那么手机密闭性不好,结构设计有待重新调整.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">兼容性测试</span></span><ul><li><span class="name"><span class="innerContentContainer">sd卡兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">usb兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">蓝牙兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">wifi兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">sim卡兼容性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它测试项</span></span><ul><li><span class="name"><span class="innerContentContainer">电池反接看是否有异常；</span></span></li><li><span class="name"><span class="innerContentContainer">靠近铁板、日光灯、心脏起搏器等打电话看是否有异常；</span></span></li><li><span class="name"><span class="innerContentContainer">长时间打电话，看发热情况。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">温升测试: 一次温升测试至少要4天，由硬测完成。</span></span></li><li><span class="name"><span class="innerContentContainer">射频测试: 一次简单射频指标的测试为1-2天；复杂指标要一周以上。</span></span></li><li><span class="name"><span class="innerContentContainer">dfx: 生产流程相关设计</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">认证测试</span></span><ul><li><span class="name"><span class="innerContentContainer">GCF测试</span></span><ul><li><span class="name"><span class="innerContentContainer">GCF：全球认证论坛。</span></span></li><li><span class="name"><span class="innerContentContainer">高通可以帮助我们做；MTK也可以。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FCC测试</span></span><ul><li><span class="name"><span class="innerContentContainer">主要用于测试射频。</span></span></li><li><span class="name"><span class="innerContentContainer">北美、南美需要这个测试。</span></span></li><li><span class="name"><span class="innerContentContainer">周期长，需要1.5到2个月才能拿到报告。</span></span></li><li><span class="name"><span class="innerContentContainer">关键点是改芯片或天线后，必须重新送测，即硬件不能改动过大。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3C认证</span></span><ul><li><span class="name"><span class="innerContentContainer">即国家入网证，中国需要。</span></span></li><li><span class="name"><span class="innerContentContainer">拿报告比较简单。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">google TA认证</span></span><ul><li><span class="name"><span class="innerContentContainer">即CTS测试。</span></span></li><li><span class="name"><span class="innerContentContainer">广义的CTS 包括CTS/GTS/VTS 等6种测试套件.</span></span></li><li><span class="name"><span class="innerContentContainer">测试周期较长。CTS 现在有100多万条case (2019-12-15), 测试一次要3天.</span></span></li><li><span class="name"><span class="innerContentContainer">测试目的是保证android平台的兼容性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMC测试: 静电相关的测试</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常规监控</span></span></li><li><span class="name"><span class="innerContentContainer">APM</span></span></li><li><span class="name"><span class="innerContentContainer">统计分析</span></span></li><li><span class="name"><span class="innerContentContainer">持续集成(CI/CD)</span></span><ul><li><span class="name"><span class="innerContentContainer">Jenkins</span></span></li><li><span class="name"><span class="innerContentContainer">环境分离</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自动化运维</span></span><ul><li><span class="name"><span class="innerContentContainer">Ansible</span></span></li><li><span class="name"><span class="innerContentContainer">puppet</span></span></li><li><span class="name"><span class="innerContentContainer">chef</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DevOps</span></span></li><li><span class="name"><span class="innerContentContainer">文档管理</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开源</span></span><ul><li><span class="name"><span class="innerContentContainer">微软对於万圣节备忘录事件的反应 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">万圣节文件I   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">万圣节文件II   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">万圣节文件 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">Unix版权史 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">为什么GPL是更好的开源许可证?   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">微软向自由软件宣战 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #OS">#<span class="contentTagText">OS</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><b>开源协议</b></span></span><ul><li><span class="name"><span class="innerContentContainer">一共有多少license: 1800种以上，最常见的有9种，覆盖了90%以上的开源项目。</span></span></li><li><span class="name"><span class="innerContentContainer">80%的开源代码是企业贡献的。</span></span></li><li><span class="name"><span class="innerContentContainer">License的种类 </span></span><ul><li><span class="name"><span class="innerContentContainer">BSD：商业友好. 可随意使用，包括闭源. </span></span><ul><li><span class="name"><span class="innerContentContainer">BSD比较有特点的是，要求将涉及到源码库的开发者（个人、公司）的版权声明写到修改后代码文件中，或附带在产品的文本中（例如：说明书等）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MPL，只需公开修改的部分</span></span><ul><li><span class="name"><span class="innerContentContainer">其它和GPL一样, 就是允许修改者修改MPL的开源代码，形成一个二进制接口，然后再外部通过这个接口来扩展原MPL的开源代码库功能。</span></span></li><li><span class="name"><span class="innerContentContainer">此时，只需要开放二进制接口设计的这部分代码，而不需要开放扩展的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPL：全部公开（具有传染性）</span></span><ul><li><span class="name"><span class="innerContentContainer">要求在GPL许可下的开源代码进行修改后，必须再次以GPL许可公开修改后的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">使用静态方式链接GPL许可证的开源代码库，则这个产品将必须以GPL许可方式开放源码。</span></span></li><li><span class="name"><span class="innerContentContainer">如果使用动态方式链接，则产品只需要开发和GPL许可代码库相关的那部分就可以。</span></span></li><li><span class="name"><span class="innerContentContainer">如果系统只能支持静态链接，且又使用了一个GPL许可的代码（哪怕只有一个文件），则这个系统就必须开放源码。这就是所谓“传染性”。</span></span></li><li><span class="name"><span class="innerContentContainer">LGPL，Less GPL，是在GPL上允许静态链接LGPL的开源代码库。所以成为“弱”GPL。</span></span></li><li><span class="name"><span class="innerContentContainer">Linxu 用的就是 LGPL.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">开源协议的分布比例: </span></span><ul><li><span class="name"><span class="innerContentContainer">截至到2012年底，约50%的开源项目使用GPL V2，</span></span></li><li><span class="name"><span class="innerContentContainer">约25%的使用GPL V3，</span></span></li><li><span class="name"><span class="innerContentContainer">剩下25%的使用其它协议（主要是Apache、BSP）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPL V2规定的两种例外情况</span></span><ul><li><span class="name"><span class="innerContentContainer">独立进程间通讯的调用，动态链接集成.</span></span></li><li><span class="name"><span class="innerContentContainer">系统调用，即syscall。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开源义务的履行方式</span></span><ul><li><span class="name"><span class="innerContentContainer">written offer模式, 就是提出请求, 就寄光盘. 最常见。优势是受众可控。</span></span></li><li><span class="name"><span class="innerContentContainer">直接把代码放在网上. 使用不广。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Apache开源协议的特点</span></span><ul><li><span class="name"><span class="innerContentContainer">简称ASL, 属于商业友好的开源协议.</span></span></li><li><span class="name"><span class="innerContentContainer">以ASL发布的代码，可以被合并入闭源的专有软件，并且在各种各样的限制性条件下发布。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">公共域: Public Domain&nbsp;— 可供任何人以任何目的使用和修改的软件，甚至可以将其并入商业软件的分发。公共域软件不保留版权，作者也不保留任何权利。</span></span></li><li><span class="name"><span class="innerContentContainer">开源官司的诉讼情况:  开源公司已经由好几百起了，商业公司从未胜诉。FSF（自由软件基金会）是业界最大的开源软件维权组织，全部胜诉。</span></span></li><li><span class="name"><span class="innerContentContainer">专利方面: </span></span><ul><li><span class="name"><span class="innerContentContainer">GPL、LGPL对代码中的专利有非常严格限制。即，不允许有专利相关的代码在开源库中。</span></span></li><li><span class="name"><span class="innerContentContainer">MPL对专利就有一点不同。虽然不允许有专利相关代码在开源代码中，但是如果开发者是专利权人，并公开书面声明免费授予使用这个开源代码的专利权。则可以把专利相关的代码放入代码库中。另外，如果先声明代码为MPL许可后，又去申请其中的专利，这是不允许的。</span></span></li><li><span class="name"><span class="innerContentContainer">Apache、BSD、MIT则对专利没有任何申明。因此自由也是有“风险”的。我们在使用这些开源代码时，还需要评估其中的专利问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">免责声明: 所有的开源代码许可证都有“免责声明”。通俗点说，如果你用了开源代码，而最后发现这些代码的问题导致各种意外（严重事故、出人命、设备罢工、等等），源码的开发者不负任何责任。</span></span></li><li><span class="name"><span class="innerContentContainer">著名开源软件列表: http://zh.wikipedia.org/wiki/开放源代码软件列表&nbsp;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">如何避开GPL感染？&nbsp;&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">区隔。即用接口层将GPL代码和非GPL之间隔离。</span></span></li><li><span class="name"><span class="innerContentContainer">最著名的是android。</span></span></li><li><span class="name"><span class="innerContentContainer">目前似乎只有嵌入式用得通。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用内核头文件，进行系统调用的程序，算不算衍生？&nbsp;&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">不算。运行于用户态且只使用系统调用的程序不受GPL约束。</span></span></li><li><span class="name"><span class="innerContentContainer">这一点是Linus反复申明且写入linux readme文件中的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">链接使用GPL授权的代码，算不算衍生？</span></span><ul><li><span class="name"><span class="innerContentContainer">算。这就是引起无数争议的GPL“传染性”。</span></span></li><li><span class="name"><span class="innerContentContainer">链接了开源的库，自身就需要开源。</span></span></li><li><span class="name"><span class="innerContentContainer">链接的情况需要细分：</span></span><ul><li><span class="name"><span class="innerContentContainer">静态链接，主程序必须开源；</span></span></li><li><span class="name"><span class="innerContentContainer">动态连接，还有一条细缝，即当可以证明主程序和库之间具有独立性，就可以不开源。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内核动态载入的模块，算不算衍生？</span></span><ul><li><span class="name"><span class="innerContentContainer">未定。这是硬件厂商和社区间持续争议的中心.</span></span></li><li><span class="name"><span class="innerContentContainer">最著名的莫过于图形开发商ATI/NVidia，他们把自己设备的驱动做成ko文件。</span></span></li><li><span class="name"><span class="innerContentContainer">社区经常愤怒的批评，但是一般并不会上升到法律层面，所以胜负未知。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GNU GPL 只要求使用代码的客户可以获得修改后的代码。它不要求将所有修改后的代码都发布给公众。</span></span></li><li><span class="name"><span class="innerContentContainer">在云计算时代, GPL （2.x ~ 3.x） 协议出现了一个非常大的“漏洞”，就是软件“发布” 才必须开源。如果我的软件不发布，即使使用 GPL (2.x ~ 3.x) 也可以不用开源。托管软件或云端上的软件，很多就是利用这个漏洞.  于是AGPL 协议产生了。</span></span></li><li><span class="name"><span class="innerContentContainer">GPL V3的四大特点</span></span><ul><li><span class="name"><span class="innerContentContainer">不能回头，凡以GPL V3授权的成果将永远以GPL V3发行；</span></span></li><li><span class="name"><span class="innerContentContainer">最惠“国”条款。凡就GPL授权的成果达成的任何协议，如果优于GPL，则自动适用于任何第三方。</span></span></li><li><span class="name"><span class="innerContentContainer">硬件要保证用户修改软件的权利，以防止Tivo化（Tivo化即当用某种方式发现软件被修改，硬件就不正常运行）；</span></span></li><li><span class="name"><span class="innerContentContainer">用户可开关DRM。GPL不禁止DRM进入自由软件，而且要给予用户关闭它的自由。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何看待GPL3？</span></span><ul><li><span class="name"><span class="innerContentContainer">GPL V3不能和GPL V2兼容；但可以和apache兼容。</span></span></li><li><span class="name"><span class="innerContentContainer">商业公司似乎正在主导GPL内涵的解释, 在GPL V3的修订委员会中，商业公司占据了半数以上的席位。</span></span></li><li><span class="name"><span class="innerContentContainer">&nbsp;v3 比较大的隐忧是可能导致开源界的分裂，起码现在分裂的风险比任何时候都大了。最引人注目的就是rms和 Linus 关于v3的分歧了。</span></span></li><li><span class="name"><span class="innerContentContainer">v3 的初衷，就rms重申过的而言，是希望推动硬件开源。</span></span></li><li><span class="name"><span class="innerContentContainer">这个理想本身有无必要性另说，目前一个眼面前的风险就是可能导致linux 生态环境受到较大的破坏。尤其是正方兴未艾的android。</span></span></li><li><span class="name"><span class="innerContentContainer">GPL v2就有传染性，但这个传染性是受限的。象android推行4年没有诉讼，基本上确立了v2 传染性的两个边界：</span></span></li><li><span class="name"><span class="innerContentContainer">1. 核心态的开源代码，不会传染到用户态；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 使用gcc库，不管什么方式，都不会传染。（当然，这点从开源一开始就是这样的，和android关系不大）。</span></span></li><li><span class="name"><span class="innerContentContainer">而在v3上，是否还是这样，就非常不确定了。现在连gcc都切换到v3，不免让人怀疑rms的目的。</span></span></li><li><span class="name"><span class="innerContentContainer">对商业公司而言，最怕的就是不确定的风险。尤其是和rms 这种又臭又硬、又有办法、还占着理的人打官司的风险。</span></span></li><li><span class="name"><span class="innerContentContainer">现在Linus顶着不用v3，危机还不会很快爆发。以后就不一定了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">日志框架</span></span><ul><li><span class="name"><span class="innerContentContainer">Log4j、Log4j2</span></span></li><li><span class="name"><span class="innerContentContainer">Logback</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ORM</span></span></li><li><span class="name"><span class="innerContentContainer">网络框架</span></span></li><li><span class="name"><span class="innerContentContainer">Web 框架</span></span><ul><li><span class="name"><span class="innerContentContainer">Spring 家族</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工具框架</span></span><ul><li><span class="name"><span class="innerContentContainer">JetBrain公司和它的产品 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">支付宝使用的30多个开源软件 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">史上最全的开发和设计资源大全 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">专利与创新</span></span><ul><li><span class="name"><span class="innerContentContainer">专利的3个特点</span></span><ul><li><span class="name"><span class="innerContentContainer">新颖性：以前没有；</span></span></li><li><span class="name"><span class="innerContentContainer">创造性：强调这是智慧的成果；</span></span></li><li><span class="name"><span class="innerContentContainer">有用性：有用。</span></span></li><li><span class="name"><span class="innerContentContainer">第二点是本质。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">专利交底书的结构</span></span><ul><li><span class="name"><span class="innerContentContainer">现有技术</span></span><ul><li><span class="name"><span class="innerContentContainer">现有技术写得恰当，对专利的通过益处极大，这一点经常被忽略。</span></span></li><li><span class="name"><span class="innerContentContainer">要寻找和本案最接近但又不同的技术，不同点要一目了然，且有害。</span></span></li><li><span class="name"><span class="innerContentContainer">比如，本案有5个步骤，现有技术只有头3个。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">技术方案</span></span><ul><li><span class="name"><span class="innerContentContainer">技术方案是保护重点。</span></span></li><li><span class="name"><span class="innerContentContainer">将每个功能步骤都虚拟成一个功能单元（不论是软件还是硬件）。</span></span></li><li><span class="name"><span class="innerContentContainer">先介绍各自的功能，再串起来介绍如何通过这些功能完成本发明方案。</span></span></li><li><span class="name"><span class="innerContentContainer">技术方案的撰写特点</span></span><ul><li><span class="name"><span class="innerContentContainer">要在抽象和新颖性之间求得最佳的折衷。</span></span></li><li><span class="name"><span class="innerContentContainer">越抽象，别人就越不可绕过，保护范围越广。</span></span></li><li><span class="name"><span class="innerContentContainer">但方案越抽象，新颖性就很难保证。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">实施例</span></span><ul><li><span class="name"><span class="innerContentContainer">由于比较细节，保护访问比较小，但也要被保护。</span></span></li><li><span class="name"><span class="innerContentContainer">实施例即技术方案的具体实现方式。</span></span></li><li><span class="name"><span class="innerContentContainer">可以写多个，并要多层保护，这个不行有那个。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TRIZ理论--创新方法</span></span><ul><li><span class="name"><span class="innerContentContainer">分割原则</span></span><ul><li><span class="name"><span class="innerContentContainer">将物体分成独立的部分。</span></span></li><li><span class="name"><span class="innerContentContainer">使物体成为可拆卸的。</span></span></li><li><span class="name"><span class="innerContentContainer">增加物体的分割程度。</span></span></li><li><span class="name"><span class="innerContentContainer">例：货船分成同型的几个部分，必要时，可将船加长些或变短些．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拆出原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从物体中拆出"干扰'部分("干扰"特性)或者相反，分出唯一需要的部分或需要的特性。与上述把物体分成几个相同部分的技法相反，这里是要把物体分成几个不同的部分．</span></span></li><li><span class="name"><span class="innerContentContainer">例，一般小游艇的照明和其他用电是艇上发动机带动发电机供给的．为了停泊时能继续供电，要安装一个由内燃机传动的辅助发电机．发动机必然造成噪音和振动。建议将发动机和发电机分置于距游艇不远的两个容器里，用电缆连接．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">局部性质原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从物体或外部介质(外部作用)的一致结构过渡到不一致结构。</span></span></li><li><span class="name"><span class="innerContentContainer">物体的不同部分应当具有不同的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">物体的每一部分均应具备最适于它工作的条件。 例：为了防治矿山坑道里的粉尘，向工具(钻机和料车的工作机构)呈锥体状喷洒小水珠。水珠愈小，除尘效果愈好．但小水珠容易形成雾，这使工作困难．解决办法：环绕小水珠锥体外层再造成一层大水珠。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不对称原则</span></span><ul><li><span class="name"><span class="innerContentContainer">物体的对称形式转为不对称形式。</span></span></li><li><span class="name"><span class="innerContentContainer">如果物体不是对称的，则加强它的不对称程度。</span></span></li><li><span class="name"><span class="innerContentContainer">例：防撞汽车轮胎具有一个高强度的侧缘，以抵抗人行道路缘石的碰撞。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">组合原则</span></span><ul><li><span class="name"><span class="innerContentContainer">把相同的物体或完成类似操作的物体组合合起来。</span></span></li><li><span class="name"><span class="innerContentContainer">把时间上相同或类似的操作联合起来。</span></span></li><li><span class="name"><span class="innerContentContainer">例：双联显微镜组；由一个人操作，另一个人观察和记录。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多功能原则</span></span><ul><li><span class="name"><span class="innerContentContainer">一个物体执行多种不同功能，因而不需要其他物体。</span></span></li><li><span class="name"><span class="innerContentContainer">例：提包的提手可同时作为拉力器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">‘玛特廖什卡'原则</span></span><ul><li><span class="name"><span class="innerContentContainer">一个物体位于另一物体之内，而后者又位于第三个物体之内，等等。</span></span></li><li><span class="name"><span class="innerContentContainer">一个物体通过另一个物体的空腔。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重量补偿原则</span></span><ul><li><span class="name"><span class="innerContentContainer">将物体与具有上升力的另一物体结合以抵消其重量。例：氢气球吊起广告牌。</span></span></li><li><span class="name"><span class="innerContentContainer">将物体与介质(最好是气动力和液动力)相互作用以抵消其重量。</span></span></li><li><span class="name"><span class="innerContentContainer">总的设想是，如果需要改变转动物体的质量，而其质量又不能按照一定的要求改变，那么应使该物体成为翼状的，改变翼片运动方向的倾斜角度，便可获得需要方向的附加力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">预先反作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">如果按课题条件必须完成某种作用，则应提前完成反作用。一般是为了对冲原功能的消极作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">预先作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">预先完成要求的作用(整个的或部分的)。</span></span></li><li><span class="name"><span class="innerContentContainer">预先将物体安放妥当，使它们能在现场和最方便地点立即完成所需要的作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">"予先放枕头"原则</span></span><ul><li><span class="name"><span class="innerContentContainer">以事先准备好的应急手段补偿物体的底可靠性。</span></span></li><li><span class="name"><span class="innerContentContainer">例：树枝在锯掉之前套上一个紧箍环，树木感该处有" 病"，于是向那里输送营养物质和治疗物质。这样，在树枝被锯之前这些物质便积聚起来，锯后锯口会迅速愈合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">等势原则</span></span><ul><li><span class="name"><span class="innerContentContainer">改变工作条件，使物体上升或下降．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">"相反"原则</span></span><ul><li><span class="name"><span class="innerContentContainer">不实现课题条件规定的作用而实现相反的作用．</span></span></li><li><span class="name"><span class="innerContentContainer">使物体或外部介质的活动部分成为不动的，而使不动的成为可动的．</span></span></li><li><span class="name"><span class="innerContentContainer">将物体颠倒．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">球形原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从直线部分过渡到曲线部分，从平面过渡到球面，从正六面体或平行六面体过渡到球形结构。</span></span></li><li><span class="name"><span class="innerContentContainer">利用棍子、球体、螺旋。</span></span></li><li><span class="name"><span class="innerContentContainer">从直线运动过浑到旋转运动，利用离心力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态原则</span></span><ul><li><span class="name"><span class="innerContentContainer">物体(或外部介质）的特性的变化应当在每一工作阶段都是最佳的。</span></span></li><li><span class="name"><span class="innerContentContainer">将物体分成彼此相对移动的几个部分。</span></span></li><li><span class="name"><span class="innerContentContainer">使不动的物体成为动的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">局部作用或过量作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">如果难于取得百分之百所要求的功效，则应当取得略小或略大的功效。此时可能把课题大大简化。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">向另一维度过渡的原则</span></span><ul><li><span class="name"><span class="innerContentContainer">如果物体作线性运动（或分布）有困难，则使物体在二维度(即平面)上移动。相应地，在一个平面上的运动(或分布)可以过渡到三维空间。</span></span></li><li><span class="name"><span class="innerContentContainer">利用多层结构替代单层结构。</span></span></li><li><span class="name"><span class="innerContentContainer">将物体倾斜或侧置．</span></span></li><li><span class="name"><span class="innerContentContainer">利用指定面的反面．</span></span></li><li><span class="name"><span class="innerContentContainer">利用投向相邻面或反面的光流。代表技术系统总发展趋势的链：从点到线，然后到面，到体，最后到许多个物体的共存．</span></span></li><li><span class="name"><span class="innerContentContainer">例： "越冬圆木在圆形停泊场水中存放，其特征是，为了增大停泊场的单位容积，和减小受冻木材的体积，将圆木扎成捆，其横截面的宽和高超过圆木的长度，然后立着放"。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">机械振动原则</span></span><ul><li><span class="name"><span class="innerContentContainer">使物体振动。</span></span></li><li><span class="name"><span class="innerContentContainer">如果巳在振动，则提高它的振动频率(达到超声波频率)。</span></span></li><li><span class="name"><span class="innerContentContainer">利用共振频率。</span></span></li><li><span class="name"><span class="innerContentContainer">用压电振动器替代机械振动器。</span></span></li><li><span class="name"><span class="innerContentContainer">利用超声波振动同电磁场配合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">周期作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从连续作用过渡到周期作用(脉冲)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果作用已经是周期的，则改变周期性。</span></span></li><li><span class="name"><span class="innerContentContainer">利用脉冲的间歇完成其他作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">连续有益作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">连续工作(物体的所有部分均应一直满负荷工作)。</span></span></li><li><span class="name"><span class="innerContentContainer">消除空转和间歇运转。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">跃过原则</span></span><ul><li><span class="name"><span class="innerContentContainer">高速跃过某过程或其个别阶段(如有害的或危险的)。</span></span></li><li><span class="name"><span class="innerContentContainer">例：产胶合板时用烘烤法加工木材，其特征是，为保持木材的本性，在生产胶合板的过程中直接用300～600·C 的燃气火焰短时作用于烘烤木材。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">变害为利原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用有害因素(特别是介质的有害作用)获得有益的效果。</span></span></li><li><span class="name"><span class="innerContentContainer">通过有害因素与另外几个有害因素的组合来消除有害因素。</span></span></li><li><span class="name"><span class="innerContentContainer">将有害因素加强到不再是有害的程度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">反向联系原则</span></span><ul><li><span class="name"><span class="innerContentContainer">进行反向联系。</span></span></li><li><span class="name"><span class="innerContentContainer">如果已有反向联系，则改变它。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">"中介"原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用可以迁移或有传送作用的中间物体。</span></span></li><li><span class="name"><span class="innerContentContainer">把另一个(易分开的)物体暂时附加给某一物体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自我服务原则</span></span><ul><li><span class="name"><span class="innerContentContainer">物体应当为自我服务，完成辅助和修理工作。</span></span></li><li><span class="name"><span class="innerContentContainer">利用废料(能的和物质的)。</span></span></li><li><span class="name"><span class="innerContentContainer">例，一般都是利用专门装置供给电焊枪中的电焊条．建议利用电焊电流工作的螺旋管供给电焊条。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复制原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用简单而便宜的复制品代替难以得到的、复杂的、昂贵的、不方便的或易损坏的物体。</span></span></li><li><span class="name"><span class="innerContentContainer">用光学拷贝(图像）代替物体或物体系统。此时要改变比例(放大或缩小复制品)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果利用可见光的复制品，则转为红外线的或紫外线的复制。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用廉价的不持久性代替昂贵的持久性原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用一组廉价物体代替一个昂贵物体，放弃某些品质(如持久性)。</span></span></li><li><span class="name"><span class="innerContentContainer">比如：一次性针管。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代替力学原理原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用光学，声学、 ‘味学"等设计原理代替力学设计原理。</span></span></li><li><span class="name"><span class="innerContentContainer">用电场．磁场和电磁场同物体相互作用。</span></span></li><li><span class="name"><span class="innerContentContainer">由恒定场转向不定场，由时间固定的场转向时间变化的场，由无结构的场转向有一定结构的场。</span></span></li><li><span class="name"><span class="innerContentContainer">利用铁磁颗粒组成的场．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用气动和液压结构的原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用气体结构和液体结构代替物体的固体的部分，如充气和充液的结构，气枕，静液的和液体反冲的结构．</span></span></li><li><span class="name"><span class="innerContentContainer">如果需要短时间使一种 物体与另一种物体紧紧靠住，则应用"气袋"法．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用软壳和薄膜原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用软壳和薄膜代替一般的结构。</span></span></li><li><span class="name"><span class="innerContentContainer">用软壳和薄膜使物体同外部介质隔离。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用多孔材料原则</span></span><ul><li><span class="name"><span class="innerContentContainer">把物体作成多孔的或利用附加多孔元件(镶嵌，覆盖，等等)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果物体是多孔的，事先用某种物质填充空孔。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改变颜色原则</span></span><ul><li><span class="name"><span class="innerContentContainer">改变物体或外部介质的颜色。</span></span></li><li><span class="name"><span class="innerContentContainer">改变物体或外部介质的透明度。</span></span></li><li><span class="name"><span class="innerContentContainer">为了观察难以看到的物体或过程，利用染色添加剂。</span></span></li><li><span class="name"><span class="innerContentContainer">如果已采用了这种添加剂，则采用荧光粉。</span></span></li><li><span class="name"><span class="innerContentContainer">例：透明绷带不必取掉便可观察伤情。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致原则</span></span><ul><li><span class="name"><span class="innerContentContainer">同指定物体相互作用的物体应当用同一(或性质相近的)材料制成．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">部分剔除和再生原则</span></span><ul><li><span class="name"><span class="innerContentContainer">已完成自己的使命或已无用的物体部分应当剔除(溶解．蒸发等)或在工作过程中直接变化。</span></span></li><li><span class="name"><span class="innerContentContainer">消除的部分应当在工作过程中直接再生。</span></span></li><li><span class="name"><span class="innerContentContainer">例："检查焊接过程的高压区的方法是向高温区加入光导探头。其特征是，为改善在电弧焊和电火花焊接过程中检查高温区的可能性，利用可熔化的探头．它以不低于自己熔化速度的速度被不断地送人检查的高温区"。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改变物体聚合态原则</span></span><ul><li><span class="name"><span class="innerContentContainer">这里包括的不仅是简单的过渡，例如从固态过渡到液态，还有向"假态"(假液态)和中间状态的过渡，例如采用弹性固体。</span></span></li><li><span class="name"><span class="innerContentContainer">例：降落跑道的减速地段建成"浴盆"形式，里面充满粘性液体，上面再铺上厚厚一层弹性物质。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">相变原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用相变时发生的现象，例如体积改变，放热或吸热，</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用热膨胀原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用材料的热膨胀(或热收缩)。</span></span></li><li><span class="name"><span class="innerContentContainer">利用一些热膨胀系数不同的材料。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用强氧化剂原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用富氧空气代替普通空气。</span></span></li><li><span class="name"><span class="innerContentContainer">用氧气替换富氧空气。</span></span></li><li><span class="name"><span class="innerContentContainer">用电离辐射作用于空气或氧气。</span></span></li><li><span class="name"><span class="innerContentContainer">用臭氧化了的氧气．</span></span></li><li><span class="name"><span class="innerContentContainer">用臭氧替换臭氧化的(或电离的)氧气。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">采用惰性介质原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用惰性介质代替普通介质。</span></span></li><li><span class="name"><span class="innerContentContainer">在真空中进行某过程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用混合材料原则</span></span><ul><li><span class="name"><span class="innerContentContainer">由同种材料转为混合材料。</span></span></li></ul></li></ul></li></ul></li></ul>
  </body>
</html>