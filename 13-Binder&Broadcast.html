<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>13-Binder&amp;Broadcast</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.cnblogs.com/samchen2009/p/3316001.html">https://www.cnblogs.com/samchen2009/p/3316001.html</a>  图解Android - Binder 和 Service</span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://www.mysixue.com/?p=137">http://www.mysixue.com/?p=137</a>  Binder详解  <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Binder是Android系统中的进程间通讯方式之一. </span></span></li><li><span class="name"><span class="innerContentContainer">Binder和传统IPC对比  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">传统IPC有如下方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">socket: 通用接口, 传输效率低, 多用于跨网络或本机的低速通讯。</span></span></li><li><span class="name"><span class="innerContentContainer">消息队列 / 管道, 采取存储-转发方式, 至少需要两次拷贝. </span></span><ul><li><span class="name"><span class="innerContentContainer">消息队列 / 管道需要共享内存地址, 所以只能用于同进程的两个线程间通信。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">共享内存无需拷贝, 但是控制复杂, 难以使用和扩展.</span></span></li><li><span class="name"><span class="innerContentContainer">它们的缺点是: 主要是没有安全机制, 无法获得访问线程的可靠的UID/PID, 无法鉴别访问者身份. 而且传统IPC访问接入点是开放的, 无法建立私有通道.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder的优势有:</span></span><ul><li><span class="name"><span class="innerContentContainer">性能高(数据只拷贝1次, 消息队列和管道至少两次).</span></span></li><li><span class="name"><span class="innerContentContainer">安全(通过UID/PID可校验访问者身份, 并支持匿名Binder).</span></span></li><li><span class="name"><span class="innerContentContainer">和共享内存比, 读写两方各自管理自己的数据, 控制较简单. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder的缺点: 只能单向由Client发起请求，而Service无法主动传输数据. 这个限制了它的使用场景.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder 5要素</span></span><ul><li><span class="name"><span class="innerContentContainer">提供业务能力的server.  它同时要提供访问接入点, 类似于: ip地址+端口号</span></span></li><li><span class="name"><span class="innerContentContainer">使用业务的client;  它需要具有探测访问接入点的能力;</span></span></li><li><span class="name"><span class="innerContentContainer">双方的通讯协议. IBinder的扩展类. 分别为 server 和 client 继承。</span></span></li><li><span class="name"><span class="innerContentContainer">Native层的 ServiceManager (SMgr)</span></span><ul><li><span class="name"><span class="innerContentContainer">它的功能类似于互联网的域名服务器DNS, 作用是将字符串格式的Binder名字转化为Client中对Binder server的应用, 以完成寻址.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核态的Binder驱动: 位于核心态. </span></span><ul><li><span class="name"><span class="innerContentContainer">设备节点是 /dev/Binder, 主要通过 ioctl() 接口对上提供能力.  </span></span></li><li><span class="name"><span class="innerContentContainer">代码在 drivers/misc/binder.c.</span></span></li><li><span class="name"><span class="innerContentContainer">跨进程能力就是由 Binder驱动提供.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>和系统service的通讯过程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">先看数据结构: server/client/Binder驱动, 三方都使用 binder_tansaction_data 结构来封装信息. 包括如下字段: </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>code</b>, 整数, Binder方法的句柄.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>data_buffer</b>, 存放参数.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>traget, 这个字段比较复杂. 它是一个联合体, 在server侧, 它是 ptr, 指向被调用的Binder对象的地址. 在client端, 它是handle, 指向BinderProxy对象的句柄.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">server侧注册过程</span></span><ul><li><span class="name"><span class="innerContentContainer">Service 可以运行在native 层(C/C++)，也可以运行在Java 层。</span></span></li><li><span class="name"><span class="innerContentContainer">先定义一个抽象接口类封装 server 的所有功能, 其中包含一系列纯虚函数, 待server和client分别实现.</span></span></li><li><span class="name"><span class="innerContentContainer">使用AIDL, client可自动生成(因为client只是一个影子类, 目的是编译通过), server则必须得自己实现.</span></span></li><li><span class="name"><span class="innerContentContainer">server 创建Binder实体, 命名, 并实现其业务能力; </span></span></li><li><span class="name"><span class="innerContentContainer">然后server需要写一个实现 IBinder接口的 Remote class，来处理client的Binder请求, 其中最重要的是函数是 <b>onTransact</b>(). 它负责按请求来调用server端的实体函数. </span></span></li><li><span class="name"><span class="innerContentContainer">最后，调用 ServiceManager.<b>AddService</b>() 把自己注册到 ServiceManager。</span></span><ul><li><span class="name"><span class="innerContentContainer">ServiceManager.AddService(string Name, IBinder Service);</span></span></li><li><span class="name"><span class="innerContentContainer">可将一个IBinder与name字符串绑定。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ServiceManager 向 Binder驱动注册该server.</span></span></li><li><span class="name"><span class="innerContentContainer">Binder驱动为这个 Binder创建位于内核的实体节点, 以及 ServiceManager对实体节点的引用. 并把这些信息返回给ServiceManager.</span></span><ul><li><span class="name"><span class="innerContentContainer">对驱动而言, 引用就是0,1,2,...这样的整数, 相当于是函数的序号. </span></span></li><li><span class="name"><span class="innerContentContainer">所以server和client要事先约定好函数顺序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ServiceManager 收到信息后, 把名称和引用填入查找表. </span></span></li><li><span class="name"><span class="innerContentContainer">至此，server初始化工作完成了。系统的server，比如ams，wms也是这样一个流程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">client侧调用过程</span></span><ul><li><span class="name"><span class="innerContentContainer">由于client 持有 IBinder 的影子类, 所以尽管自身代码中有调用service接口的代码, 并无实现, 也可以编译通过. </span></span></li><li><span class="name"><span class="innerContentContainer">在Client 进程中, 先调用 ServiceManager.GetService(string Name) 获取系统service对象, 参数为字符串, 然后获取到Name对应的Server线程的编号(handle), 后者是个32位的正整数(0有其它用途), 值随机.</span></span></li><li><span class="name"><span class="innerContentContainer">IBinder对象的最重要的一个函数是 IBinder.<b>TransAct</b>(int code, Parcel data, Parcel reply, int flag);  其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">code 是要调用的函数;</span></span></li><li><span class="name"><span class="innerContentContainer">data 是函数参数; binder引用地址写入 traget.handle. </span></span></li><li><span class="name"><span class="innerContentContainer">reply 是返回值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过调用 <b>TransAct(), </b>Client告知server端自己想调用对方的哪个函数, </span></span></li><li><span class="name"><span class="innerContentContainer"><b>命令发出后, 如果是同步调用(一般是), client端线程会被阻塞, 直到收到 reply。</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">server侧响应调用过程</span></span><ul><li><span class="name"><span class="innerContentContainer">该命令首先发给 <b>Binder驱动</b>, 驱动会根据 traget.handle 往 traget<b>.</b>ptr 字段中填写Binder对象的地址. 并把它转给server. </span></span></li><li><span class="name"><span class="innerContentContainer">server收到命令后, 取出traget.ptr指针, reinterpret_cast 强转为Binder抽象类, 然后调用它的 onTransact() 方法. 在该方法中根据code调用具体的binder方法.</span></span></li><li><span class="name"><span class="innerContentContainer">server的执行结果会通过binder驱动返回给 client.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">具体代码是:</span></span><ul><li><span class="name"><span class="innerContentContainer">server端代码</span></span><ul><li><span class="name"><span class="innerContentContainer">Class myService extends Binder {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected boolean OnTransact (int code, Parcel data, Parcel reply, int flags) throws RemoteException {...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关键是实现OnTransact(), 根据code实现逻辑分发.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Client端代码</span></span><ul><li><span class="name"><span class="innerContentContainer">IBinder myBinder = getService(Context.ACCESSIBILITY_SERVICE);   // 参数是字符串</span></span></li><li><span class="name"><span class="innerContentContainer">myBinder.transact(code, data, reply, 0);    // 执行完这一步, 线程会挂起</span></span></li><li><span class="name"><span class="innerContentContainer">reply.readException();</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Native层的binder</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/binder/<b>ProcessState</b>.cpp, 支持的接口是:</span></span><ul><li><span class="name"><span class="innerContentContainer">ProcessState::self()&nbsp;:&nbsp;主要目的是open(/dev/binder), Server/Client都会用到,&nbsp;因为它们都得打开内核设备节点.</span></span></li><li><span class="name"><span class="innerContentContainer">ProcessState::startThreadPool()&nbsp;: Server进程会用到,&nbsp;主要目的是创建一个线程,&nbsp;在线程里面while循环,&nbsp;监听是否有数据写入设备节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/binder/<b>IPCThreadState</b>.cpp, 主要目的是通过ioctl与/dev/binder交互,&nbsp;也就是说它负责读写设备节点,完成用户空间与内核空间的数据交互.</span></span><ul><li><span class="name"><span class="innerContentContainer">&nbsp;IPCThreadState::transact()&nbsp;: Client进程会用到,&nbsp;目的是往设备节点写入数据.</span></span><ul><li><span class="name"><span class="innerContentContainer">transact里面会分 waitForResponse(reply) 和 waitForResponse(NULL) 这两种情况,&nbsp;前者的意思是Client发送一个数据（请求/命令…）给Server后,&nbsp;需要等待Server的执行结果,&nbsp;结果存储在reply中;&nbsp;后者的意思是Client只是发送个请求,&nbsp;不需要等待对应的执行结果.</span></span></li><li><span class="name"><span class="innerContentContainer">两个 waitForResponse() 都会调用talkWithDriver,&nbsp;后者会调用 ioctl与 /dev/binder 交互.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IPCThreadState::joinThreadPool&nbsp;: Server进程会用到,&nbsp;ProcessState::startThreadPool()最终就是调用的IPCThreadState::joinThreadPool,&nbsp;目的就是监听设备节点.&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">joinThreadPool会调用getAndExecuteCommand(),&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">后者会调用talkWithDriver()监听设备节点,&nbsp;当收到一个数据后,&nbsp;就解析并执行相应的操作(ExecuteCommand).</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">上面这两个类主要用于通讯, 下面4个类主要用于binder数据封装.</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/<b>IBinder</b>.h, IBinder是一个接口类,&nbsp;也就是C++中的纯虚基类.&nbsp;它是BBinder和BpBinder的基类,&nbsp;它里面定义的一个重要接口函数是transact.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>BpBinder: 客户端</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/BpBinder.h</span></span></li><li><span class="name"><span class="innerContentContainer">实现文件&nbsp;:&nbsp;frameworks/native/libs/binder/BpBinder.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BpBinder继承了IBinder,&nbsp;实现了IBinder中定义的transact函数.</span></span></li><li><span class="name"><span class="innerContentContainer">BpBinder用于Client端, BpBinder::transact()会调用IPCThreadState::transact(),&nbsp;继而往 /dev/binder节点写入数据,&nbsp;完成封装动作.</span></span></li><li><span class="name"><span class="innerContentContainer">Client端的代码会继承BpBinder,&nbsp;当Client想往Server发送数据时,&nbsp;直接调用BpBinder::&nbsp;transact() 即可?&nbsp;但实际上并不是这样, Client端的代码实际上会继承BpRefBase,&nbsp;通过BpRefBase调用BpBinder::&nbsp;transact().&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BpRefBase: 客户端封装类</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/Binder.h</span></span></li><li><span class="name"><span class="innerContentContainer">实现文件&nbsp;:&nbsp;frameworks/native/libs/binder/Binder.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BpRefBase里面定义了一个变量&nbsp;:&nbsp;IBinder* const&nbsp;mRemote;&nbsp;这个mRemote实际上指的就是BpBinder.</span></span></li><li><span class="name"><span class="innerContentContainer">BpRefBase用于Client端, Client端的代码会继承BpRefBase,&nbsp;当Client端想往Server发送数据时,&nbsp;会使用mRemote-&gt;transact()的形式,&nbsp;实际上也就是调用BpBinder::&nbsp;transact().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>BBinder: 服务器端</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/Binder.h</span></span></li><li><span class="name"><span class="innerContentContainer">实现文件&nbsp;:&nbsp;frameworks/native/libs/binder/Binder.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BBinder继承了IBinder,&nbsp;也实现了IBinder中定义的transact函数.前文我们说过Server端会开启一个线程,&nbsp;监听/dev/binder节点.&nbsp;当收到数据时, Server端的这个线程会调用BBinder::transact.</span></span></li><li><span class="name"><span class="innerContentContainer">BBinder用于Server端, BBinder除了继承了IBinder中的transact接口,&nbsp;它自己也定义了一个onTransact接口, Server端的代码一般会实现onTransact接口. </span></span></li><li><span class="name"><span class="innerContentContainer">BBinder::transact里面会调用onTransact函数,&nbsp;继而把Client端通过内核传递过来的数据交给Server端的代码进行处理,&nbsp;从而完成一次进程间通信.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">binder驱动在以misc设备进行注册，作为虚拟字符设备，但是这个设备没有操作硬件，只是对内存的处理。</span></span></li><li><span class="name"><span class="innerContentContainer">操作一个Binder，相当于打开 “/dev/binder”，然后通过该节点的 ioctl 接口传入命令。</span></span></li><li><span class="name"><span class="innerContentContainer">对 /dev/binder 的访问, 即是进行系统调用(syscall), 此时代码会陷入内核态. 陷入流程是:</span></span><ul><li><span class="name"><span class="innerContentContainer">比如, 打开Binder驱动方法的调用链为： open-&gt; __open() -&gt; binder_open()。</span></span></li><li><span class="name"><span class="innerContentContainer">其中, open()为用户空间的方法;</span></span></li><li><span class="name"><span class="innerContentContainer">__open()便是系统调用中相应的处理方法;</span></span></li><li><span class="name"><span class="innerContentContainer">对应调用到内核binder驱动的binder_open()方法.</span></span></li><li><span class="name"><span class="innerContentContainer">其它接口也是大同小异.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>接口:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">代码在：binder_module.h。</span></span></li><li><span class="name"><span class="innerContentContainer">open/close</span></span></li><li><span class="name"><span class="innerContentContainer">ioctl: 这是主要的接口.</span></span><ul><li><span class="name"><span class="innerContentContainer">参数包括三个：</span></span><ul><li><span class="name"><span class="innerContentContainer">fd，文件句柄；</span></span></li><li><span class="name"><span class="innerContentContainer">cmd，命令字；</span></span><ul><li><span class="name"><span class="innerContentContainer">BINDER_WRITE_READ，Binder读写（主要命令）；</span></span><ul><li><span class="name"><span class="innerContentContainer">由于有返回值，所以一旦write之后，必须有read操作，所以这两个动作放在一个命令中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER_SET_IDLE_TIMEOUT，设置请求超时；</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER_SET_REPALY_TIMEOUT，设置reply超时；</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER_SET_MAX_THREADS，设置线程池容量。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在：binder.h。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">args，参数和返回值。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel space中，/dev/binder 有如下接口：</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_open: 进行初始化</span></span></li><li><span class="name"><span class="innerContentContainer">binder_ioctl: 对命令字进行解析和分发</span></span></li><li><span class="name"><span class="innerContentContainer">binder_mmap: 内存映射，将Binder对象从内核空间映射到用户空间</span></span></li><li><span class="name"><span class="innerContentContainer">binder_flush: 将处在等待中的进程唤醒并返回</span></span></li><li><span class="name"><span class="innerContentContainer">代码在：binder.c。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>binder_ioctl() 处理流程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">如果传入的cmd是 BINDER_WRITE_READ, 则调用 binder_thread_write().</span></span></li><li><span class="name"><span class="innerContentContainer">后者对命令进一步解析，发现cmd为 bcTransaction，即发起IPC transaction，则将参数 binder_transaction_data 复制到内核空间。</span></span></li><li><span class="name"><span class="innerContentContainer">binder_transaction() 根据 binder_transaction_data 中的target字段可寻出被调者的进程，从该进程的缓冲区中<b>选择一个处在wait for ioctl的线程，将 binder_transaction_data 复制给它，并唤醒它。</b></span></span></li><li><span class="name"><span class="innerContentContainer">被调者用户线程执行相应指令。然后将执行结果写入新的 binder_transaction_data 中，通过ioctl发给内核，即发起一个新的transaction。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>内核将结果写入调用者线程的buffer中，并唤醒该线程。调用者得到结果。</b></span></span></li><li><span class="name"><span class="innerContentContainer">Binder可以传递对象引用。传递过程中，内核负责将其添加到对象映射表中。</span></span></li><li><span class="name"><span class="innerContentContainer">server进程收到rpc调用，则从线程池中选择一个线程处理rpc请求，包括cmd和reply两个过程。内核收到reply后，将其传给client。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder内存机制</span></span><ul><li><span class="name"><span class="innerContentContainer">由binder_mmap() 完成. 主要功能是:</span></span></li><li><span class="name"><span class="innerContentContainer">首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；</span></span></li><li><span class="name"><span class="innerContentContainer">然后再申请1个page大小的物理内存，</span></span></li><li><span class="name"><span class="innerContentContainer">再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">和第三方service的通讯过程</span></span><ul><li><span class="name"><span class="innerContentContainer">第三方service和系统service大同小异, 就是要定义唯一的字符串来作为service的名称, server和client要一致.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AIDL</span></span><ul><li><span class="name"><span class="innerContentContainer">AIDL相当于Binder脚本. 目的是</span></span></li><li><span class="name"><span class="innerContentContainer">RPC系统一般都会定义自己的接口定义语言（IDL），android上的叫aidl.</span></span></li><li><span class="name"><span class="innerContentContainer">aidl语法和java类似。例如:</span></span><ul><li><span class="name"><span class="innerContentContainer">interface IMyInterface {</span></span><ul><li><span class="name"><span class="innerContentContainer">int getData(int a);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AIDL文件如何编译？</span></span><ul><li><span class="name"><span class="innerContentContainer">用tools 目录下的aidl.exe编译.</span></span></li><li><span class="name"><span class="innerContentContainer">编译结果是 IMyInterface，以及内镶类 proxy和stub。</span></span></li><li><span class="name"><span class="innerContentContainer">IMyInterface 拷贝到 client 工程中使用.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">server 和 client 如何和 SMgr 通讯呢? </span></span><ul><li><span class="name"><span class="innerContentContainer">这种情况下, SMgr是server, 而各server 和 client 都是client. </span></span></li><li><span class="name"><span class="innerContentContainer">它们之前的Binder的引用固定为0, 不需要寻址. </span></span></li><li><span class="name"><span class="innerContentContainer">当一个进程建立Binder时, 使用 BINDER_SET_CONTEXT_MGR 来发起和SMgr的通讯, 完成注册自己. </span></span></li><li><span class="name"><span class="innerContentContainer">既然servicemanager作为所有Server进程/Client进程的服务端,&nbsp;那是不是应该提供相应的客户端的封装,&nbsp;以便客户端能方便与servicemanager通信呢? Android系统确实提供了这样的封装,&nbsp;它就是 frameworks/native/libs/binder/IServiceManager.cpp.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">匿名Binder</span></span><ul><li><span class="name"><span class="innerContentContainer">不向ServiceManager注册名字的Binder即位匿名Binder.</span></span></li><li><span class="name"><span class="innerContentContainer">其通讯方式是：通过已经建立的Binder连接将新的Binder实体传递给client. </span></span></li><li><span class="name"><span class="innerContentContainer">也就是说，它要求server和client之间至少已经存在了一个实名Binder.</span></span></li><li><span class="name"><span class="innerContentContainer">匿名Binder无法被第三方破解, 比较安全.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder与service类</span></span></li><li><span class="name"><span class="innerContentContainer">Binder与intent</span></span></li></ul>
  </body>
</html>