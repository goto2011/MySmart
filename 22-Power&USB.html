<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">22-Power&amp;USB</span></span><ul><li><span class="name"><span class="innerContentContainer">充电芯片</span></span><ul><li><span class="name"><span class="innerContentContainer">双回路机制</span></span><ul><li><span class="name"><span class="innerContentContainer">充电时，充电芯片有两个回路，一路给电池充电，一路给手机供电。</span></span></li><li><span class="name"><span class="innerContentContainer">一般充电过程中, 电池不给手机供电。</span></span></li><li><span class="name"><span class="innerContentContainer">如果手机有大电流需求，则用充电器和电池一起供电。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">充电器</span></span><ul><li><span class="name"><span class="innerContentContainer">智能手机电池一般都在3000毫安以上. </span></span></li><li><span class="name"><span class="innerContentContainer">为适应大电池，充电器都切换为1A/5V, 或者2A/5V的大功率充电器。</span></span></li><li><span class="name"><span class="innerContentContainer">第三方PD充电器更高, 达到18W、30W甚至65W。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电池指标</span></span><ul><li><span class="name"><span class="innerContentContainer">循环放电400次后，满充容量不少于标称的80%。</span></span></li><li><span class="name"><span class="innerContentContainer">倍率放电测试，要求放电电流和放电时间满足倍率关系。</span></span></li><li><span class="name"><span class="innerContentContainer">高温测试，要求在-30到130度测试下，电池不燃烧。</span></span></li><li><span class="name"><span class="innerContentContainer">60度存放7天，剩余电量大于90%；70度存放一天，剩余电量大于90%。</span></span></li><li><span class="name"><span class="innerContentContainer">过充测试，要求4.6V充电保持7小时电池不燃烧。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电池校准</span></span><ul><li><span class="name"><span class="innerContentContainer">电量表、温度曲线。一个产品一套.</span></span></li><li><span class="name"><span class="innerContentContainer">如果使用多种电芯，就需要多种电量表（同时需要提供识别它们的方法）。</span></span></li><li><span class="name"><span class="innerContentContainer">校准方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">电池校准发生在产线步骤CT中.</span></span></li><li><span class="name"><span class="innerContentContainer">程控电源设定n个电压（3.4v、3.7v、4.2v），分别读取ADC值5次，取平均值，保持到nv中。</span></span></li><li><span class="name"><span class="innerContentContainer">测试: 在BT和MT中，对电压校准值进行测试，如果差距大于0.03V（一个ADC raw值的偏差），则认为电池校准失败。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">充电类型</span></span><ul><li><span class="name"><span class="innerContentContainer">标充</span></span><ul><li><span class="name"><span class="innerContentContainer">5V2A, 2.5-3小时充满.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">快速充电</span></span><ul><li><span class="name"><span class="innerContentContainer">9V2A, 1.5小时充满.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">超级快充</span></span><ul><li><span class="name"><span class="innerContentContainer">低压: 5V 4.5A, 1.5小时充满.</span></span></li><li><span class="name"><span class="innerContentContainer">高压: 10V 4A, 1小时充满.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无线充电</span></span><ul><li><span class="name"><span class="innerContentContainer">无线充电芯片, 负责从电磁波中获取能量.</span></span></li><li><span class="name"><span class="innerContentContainer">功率一般7.5瓦.</span></span></li><li><span class="name"><span class="innerContentContainer">2020-01-14, 功率最高27瓦.</span></span></li><li><span class="name"><span class="innerContentContainer">90%以上是有效能量.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">反向无线充电</span></span><ul><li><span class="name"><span class="innerContentContainer">5V 1A, 可支持非华为手机</span></span></li><li><span class="name"><span class="innerContentContainer">15瓦. 最大40瓦(2020-01-14). </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>充电方案(充电步骤)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">设计充电方案的主要考虑点  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">确保绝对安全. 锂电池是存在安全风险的, 所以必须留够buffer.</span></span></li><li><span class="name"><span class="innerContentContainer">在安全的前提下，最大限度充满电，物尽其用;</span></span></li><li><span class="name"><span class="innerContentContainer">在1和2都满足的前提下，充电时间尽可能短。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电过程中，充电电压不变，保持5v;</span></span></li><li><span class="name"><span class="innerContentContainer">充电电流一直在变化。</span></span></li><li><span class="name"><span class="innerContentContainer">电池电压一直在升高, 通过电压估计电池电量。电池电压作为充电流程控制的主变量。</span></span></li><li><span class="name"><span class="innerContentContainer">充电基本步骤</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 涓流充电</span></span><ul><li><span class="name"><span class="innerContentContainer">开始充电时，如果电池电压低，必须用小电流充电，即涓流充电。</span></span></li><li><span class="name"><span class="innerContentContainer">因为电池电压低的情况下，大电流充电，电池内阻会急剧升高，结果一是充不进去，二是发热伤害电池。</span></span></li><li><span class="name"><span class="innerContentContainer">涓流充电门限</span></span><ul><li><span class="name"><span class="innerContentContainer">充电电压5V，电流100mA；</span></span></li><li><span class="name"><span class="innerContentContainer">电池电压2.8v-3.2v（3，2v相当于电池电量0%）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">涓流充电时间一般为10分钟。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 恒流充电</span></span><ul><li><span class="name"><span class="innerContentContainer">电池电压在3.2v以上，开始用大电流充电，即采用允许的最大电流充，以节省时间。</span></span></li><li><span class="name"><span class="innerContentContainer">恒流是充电的主要区间。</span></span></li><li><span class="name"><span class="innerContentContainer">充电电压5v，恒流充电电流门限：</span></span><ul><li><span class="name"><span class="innerContentContainer">标准充电器800mA-1A;</span></span></li><li><span class="name"><span class="innerContentContainer">usb充电器450mA；</span></span></li><li><span class="name"><span class="innerContentContainer">非标充电器450-500mA。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">恒流充电在1-3个小时左右。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 恒压充电</span></span><ul><li><span class="name"><span class="innerContentContainer">电池电压到了4.2v时，电池接近充满，此时转入恒压充电，保持电池电压基本不变，逐步减小充电电流，以避免过充。</span></span></li><li><span class="name"><span class="innerContentContainer">恒压充电门限: 充电电压5v，充电电流逐步减小。电池电压由4.2v-》4.25v。</span></span></li><li><span class="name"><span class="innerContentContainer">恒压充电时间一般在1个小时左右。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">限流处理</span></span><ul><li><span class="name"><span class="innerContentContainer">华为标配充电器限流1A或800mA，标配的条件是D+、D-短接；</span></span></li><li><span class="name"><span class="innerContentContainer">非标充电器限流400-500mA。</span></span></li><li><span class="name"><span class="innerContentContainer">USB充电限流: 按spec规定，USB充电必须限流。其中USB插入协商阶段，限流100mA，正常充电时限流400-450mA。</span></span></li><li><span class="name"><span class="innerContentContainer">USB充电时，不能进入tx_wait状态. 原因是防止电流倒灌，在usb睡眠时可能发生。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LDO充电模式（传统）</span></span><ul><li><span class="name"><span class="innerContentContainer">充电器变大后，传统LDO充电的问题就暴露了：电流容易过载、发热量大、充电时间过长。</span></span></li><li><span class="name"><span class="innerContentContainer">取而代之的是DCDC方式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DCDC充电模式</span></span><ul><li><span class="name"><span class="innerContentContainer">DCDC充电管理芯片；</span></span></li><li><span class="name"><span class="innerContentContainer">通过I2C总线进行参数设置和状态输出。</span></span></li><li><span class="name"><span class="innerContentContainer">支持涓流、恒流、恒压三种模式;</span></span></li><li><span class="name"><span class="innerContentContainer">当输入电压过高或过低时自动进入保护模式，停止充电。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>放电过程和电量显示</b></span></span><ul><li><span class="name"><span class="innerContentContainer">容量为3200毫安时（简称毫安）的电池，满电情况下以160mA的电流放电，可持续工作20小时。</span></span></li><li><span class="name"><span class="innerContentContainer">另一个电量单位是瓦时（wH）。</span></span><ul><li><span class="name"><span class="innerContentContainer">由于手机锂电池的标准发电电压是3.7v，所以瓦时和毫安时等价。</span></span></li><li><span class="name"><span class="innerContentContainer">换算公式为：1wH = 3.6AH。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电池的放电区间</span></span><ul><li><span class="name"><span class="innerContentContainer">区间在 3.4v-4.2v，其中大部分电流分布在 3.5v-3.6v 之间。</span></span></li><li><span class="name"><span class="innerContentContainer">低于3.4v，电量极少。</span></span></li><li><span class="name"><span class="innerContentContainer">低于3.2v，手机会自动关机。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当前充电流程控制中，通过<b>电池电压</b>估计电量。</span></span><ul><li><span class="name"><span class="innerContentContainer">电池电压从哪里来？ 通过ADC采样获得。</span></span></li><li><span class="name"><span class="innerContentContainer">更优的方法是使用库仑计（电量计），直接测量电池电荷量，精度高，没有增压问题。但是电量计贵，只有iPhone用得起。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在非充电状态下，这种方案精度有保障。</span></span></li><li><span class="name"><span class="innerContentContainer">但在充电模式下，则有增压问题。</span></span><ul><li><span class="name"><span class="innerContentContainer">在充电时，由于电池内阻，电压上升得比较快，电压和电量的关系变得非线性，精度偏差较大。</span></span></li><li><span class="name"><span class="innerContentContainer">一般会采用经验值做一定的平滑，即<b>电量表</b>。</span></span></li><li><span class="name"><span class="innerContentContainer">电量表是一个数组，第一个数据是1%电量对应的电压值，第二个是2%电量的电压值，如此类推。</span></span></li><li><span class="name"><span class="innerContentContainer">一般有四张电量表，分别对应放电、充电器充电、usb充电、非标充电器充电。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电池电压读取周期</span></span><ul><li><span class="name"><span class="innerContentContainer">当电量为0、1、2格时，15秒读一次；</span></span></li><li><span class="name"><span class="innerContentContainer">3、4、5格时，30秒读一次；</span></span></li><li><span class="name"><span class="innerContentContainer">开机时，第5秒读第一次。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">0格电压门限： 3.46V</span></span></li><li><span class="name"><span class="innerContentContainer">电池放电平滑算法： 本次结果 = 0.875 *上次结果 + 0.125 * 本次ADC采样值</span></span></li><li><span class="name"><span class="innerContentContainer">开机时特殊处理： 电池电压读数不准，所以把前两次都丢弃掉。只使用第65秒的值。</span></span></li><li><span class="name"><span class="innerContentContainer">电量显示：满格占40%电量，1格占的极少。其它基本均分。</span></span></li><li><span class="name"><span class="innerContentContainer">电量显示存在学习过程. 因为电池容量是变化的, 要根据充放电的数据进行学习.</span></span></li><li><span class="name"><span class="innerContentContainer">启动学习的条件:</span></span><ul><li><span class="name"><span class="innerContentContainer">电量在20%以下;</span></span></li><li><span class="name"><span class="innerContentContainer">充电时间在半小时以上;</span></span></li><li><span class="name"><span class="innerContentContainer">电池温度在10-45度之间.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">关机充电</span></span><ul><li><span class="name"><span class="innerContentContainer">关机充电时，手机启动到recovery（即kernel），但不进Android。</span></span></li><li><span class="name"><span class="innerContentContainer">而modem侧都启动了。所以不做处理的话，是可以被打通电话的，只是无法接。</span></span></li><li><span class="name"><span class="innerContentContainer">进关机充电条件的判断是在oemsbl中。什么条件:</span></span><ul><li><span class="name"><span class="innerContentContainer">电池和充电器是否都在位；</span></span></li><li><span class="name"><span class="innerContentContainer">是否为正常开机，包括闹钟开机、按power键开机、用户重启开机；</span></span></li><li><span class="name"><span class="innerContentContainer">是否为异常开机，包括watchdog reset开机和瞬间掉电开机；</span></span></li><li><span class="name"><span class="innerContentContainer">misc分区中的充电使能标志的值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关机充电动画处理</span></span><ul><li><span class="name"><span class="innerContentContainer">recovery中有一套基于framebuffer的图形接口，在 bootable/recovery/miniui/graphices 中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">misc分区中的充电使能标志的功能: </span></span><ul><li><span class="name"><span class="innerContentContainer">给app使用. </span></span></li><li><span class="name"><span class="innerContentContainer">当他们想重启，而不是关机时，去使能这个标志，以避免不开机而进关机充电界面。</span></span></li><li><span class="name"><span class="innerContentContainer">可通过 cat /proc/app_info/charge_flag 来查看。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">按键处理: 进入充电前，recovery启动一个叫 charge_input_thread 的线程处理按键，其中音量上下键只起唤醒作用，power键起关机作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电过程的常见异常  <span class="contentTag" title="Filter #问题功耗">#<span class="contentTagText">问题功耗</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">涓流无法转恒流;</span></span></li><li><span class="name"><span class="innerContentContainer">恒流无法转恒压；</span></span></li><li><span class="name"><span class="innerContentContainer">充电不截止；</span></span></li><li><span class="name"><span class="innerContentContainer">零星脉冲充电；</span></span></li><li><span class="name"><span class="innerContentContainer">二次充电（已经充满停止充电后, 再自动开始充电. 和增压问题有关）.</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">USB Type-C</span></span><ul><li><span class="name"><span class="innerContentContainer">和Type-C早出现的usb client 接口叫 USB-A.</span></span></li><li><span class="name"><span class="innerContentContainer">Type-C的新特性:</span></span><ul><li><span class="name"><span class="innerContentContainer">支持正反插入</span></span></li><li><span class="name"><span class="innerContentContainer">支持更强的电力传输（最大功率 100W, 即USB-PD）</span></span></li><li><span class="name"><span class="innerContentContainer">更快的传输速度（最高 10Gbps ）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从 2017年开始, Apple 的 Macbook 仅支持type-c接口.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PD 快充</span></span><ul><li><span class="name"><span class="innerContentContainer">其它快充技术</span></span><ul><li><span class="name"><span class="innerContentContainer">MTK 的 PE+ (Pump Express)</span></span></li><li><span class="name"><span class="innerContentContainer">高通的 QC 4+</span></span><ul><li><span class="name"><span class="innerContentContainer">在QC1．0时代，5V的充电电压没有改变，将电流增大到了2A，这也使得充电效率提升了40％。</span></span></li><li><span class="name"><span class="innerContentContainer">QC2．0在原来5V的基础上新增了9V和12V的电压，增加了电压，也就增大了功率，QC2．0的最大充电功率可达18W。</span></span></li><li><span class="name"><span class="innerContentContainer">QC3．0中引入了INOV（Intelligent negotiation optimal voltage智能协商最佳电压）技术，可以动态地调节输出的电压，可根据终端的功率需求输出最佳的功率，电压调节范围3．6V～20V，步进200mV，充电效率比QC2．0提升38％，速度提升27％，发热降低45％。</span></span></li><li><span class="name"><span class="innerContentContainer">QC4．0中，高通加入了对 USB－PD的支持，并且最大充电功率也提升至了27W。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">OPPO 的 VOOC（DASH）</span></span><ul><li><span class="name"><span class="innerContentContainer">VOOC作为OPPO独立研发的快充技术，另辟蹊径采用大电流的充电方案，并且将充电电路转移到适配器中，来减少手机的发热，在国内可以说是一项非常有新意的创新了，VOOC的充电功率为20W（5V4A）.</span></span></li><li><span class="name"><span class="innerContentContainer">升级版SuperVOOC，最高充电功率可达55W。</span></span></li><li><span class="name"><span class="innerContentContainer">“充电两分钟，通话两小时”便出自OPPO的广告。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">华为的 FCP （穿着马甲的 QC 2.0 ）</span></span></li><li><span class="name"><span class="innerContentContainer">华为的 SCP</span></span><ul><li><span class="name"><span class="innerContentContainer">SCP（SuperCharge）输出达到了4.5V 5A和5V 4.5A，功率22.5W，业内也叫低压直充。</span></span></li><li><span class="name"><span class="innerContentContainer">2018年10月，推出了10V 4A的40W超级快充.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">USB Power Delivery. USB-PD 将快充技术标准进行了统一化.</span></span></li><li><span class="name"><span class="innerContentContainer">PD快充的充电头即Type-C规范的. 不过有的 Type-C不一定支持 PD协议.</span></span></li><li><span class="name"><span class="innerContentContainer">PD 快充协议，最大的优势是最大功率 100W输出. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>USB协议</b></span></span><ul><li><span class="name"><span class="innerContentContainer">端点</span></span><ul><li><span class="name"><span class="innerContentContainer">位于USB设备或主机上的一个数据缓冲区，用来存放和发送USB的各种数据，每一个端点都有惟一的确定地址，有不同的传输特性（如输入端点、输出端点、配置端点、批量传输端点）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">帧</span></span><ul><li><span class="name"><span class="innerContentContainer">时间概念，在USB中，一帧就是1MS，它是一个独立的单元，包含了一系列总线动作，USB将1帧分为好几份，每一份中是一个USB的传输动作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">上行、下行</span></span><ul><li><span class="name"><span class="innerContentContainer">设备到主机为上行，主机到设备为下行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB的传输线结构是如何的呢？</span></span><ul><li><span class="name"><span class="innerContentContainer">一条USB的传输线分别由地线、电源线、D+、D-四条线构成，D+和D-是差分输入线.</span></span></li><li><span class="name"><span class="innerContentContainer">使用的是3.3V的电压，而电源线和地线可向设备提供5V电压.</span></span></li><li><span class="name"><span class="innerContentContainer">最大电流为500MA（可以在编程中设置的，至于硬件的实现机制，就不要管它了）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB的编码方案</span></span><ul><li><span class="name"><span class="innerContentContainer">数据在USB线里传送是由低位到高位发送的。</span></span></li><li><span class="name"><span class="innerContentContainer">USB采用不归零取反来传输数据，当传输线上的差分数据输入0时就取反，输入1时就保持原值.</span></span></li><li><span class="name"><span class="innerContentContainer">为了确保信号发送的准确性，当在USB总线上发送一个包时，传输设备就要进行位插入***作（即在数据流中每连续6个1后就插入一个0），从而强迫NRZI码发生变化。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB的数据格式是怎么样的呢？</span></span><ul><li><span class="name"><span class="innerContentContainer">USB数据是由二进制数字串 构成的，首先数字串构成域（有七种），域再构成包，包再构成事务（IN、OUT、SETUP），事务最后构成传输（中断传输、并行传输、批量传输和控制传 输）。</span></span></li><li><span class="name"><span class="innerContentContainer">域：是USB数据最小的单位，由若干位组成（至于是多少位由具体的域决定），域可分为七个类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">同步域（SYNC），八位，值固定为0000 0001，用于本地时钟与输入同步</span></span></li><li><span class="name"><span class="innerContentContainer">标识域（PID），由四位标识符+四位标识符反码构成，表明包的类型和格式，这是一个很重要的部分，这里可以计算出，USB的标识码有16种，具体分类请看问题五。</span></span></li><li><span class="name"><span class="innerContentContainer">地址域（ADDR）：七位地址，代表了设备在主机上的地址，地址000 0000被命名为零地址，是任何一个设备第一次连接到主机时，在被主机配置、枚举前的默认地址，由此可以知道为什么一个USB主机只能接127个设备的原因。</span></span></li><li><span class="name"><span class="innerContentContainer">端点域（ENDP），四位，由此可知一个USB设备有的端点数量最大为16个。</span></span></li><li><span class="name"><span class="innerContentContainer">帧号域（FRAM），11位，每一个帧都有一个特定的帧号，帧号域最大容量0x800，对于同步传输有重要意义（同步传输为四种传输类型之一，请看下面）。</span></span></li><li><span class="name"><span class="innerContentContainer">数据域（DATA）：长度为0~1023字节，在不同的传输类型中，数据域的长度各不相同，但必须为整数个字节的长度</span></span></li><li><span class="name"><span class="innerContentContainer">校验域（CRC）：对令牌包和数据包（对于包的分类请看下面）中非PID域进行校验的一种方法，CRC校验在通讯中应用很泛，是一种很好的校验方法，至于具体的校验方法这里就不多说，请查阅相关资料，只须注意CRC码的除法是模2运算，不同于10进制中的除法。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">包：由域构成的包有四种类型，分别是令牌包、数据包、握手包和特殊包，前面三种是重要的包，不同的包的域结构不同，介绍如下:</span></span><ul><li><span class="name"><span class="innerContentContainer">令牌包：可分为输入包、输出包、设置包和帧起始包（注意这里的输入包是用于设置输入命令的，输出包是用来设置输出命令的，而不是放据数的）</span></span><ul><li><span class="name"><span class="innerContentContainer">其中输入包、输出包和设置包的格式都是一样的： SYNC+PID+ADDR+ENDP+CRC5（五位的校验码）</span></span></li><li><span class="name"><span class="innerContentContainer">帧起始包的格式：SYNC+PID+11位FRAM+CRC5（五位的校验码）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据包：分为DATA0包和DATA1包，当USB发送数据的时候，当一次发送的数据长度大于相应端点的容量时，就需要把数据包分为好几个包，分批发送， DATA0包和DATA1包交替发送，即如果第一个数据包是 DATA0，那第二个数据包就是DATA1。</span></span><ul><li><span class="name"><span class="innerContentContainer">但也有例外情况，在同步传输中（四类传输类型中之一），所有的数据包都是为DATA0.</span></span></li><li><span class="name"><span class="innerContentContainer">数据格式如下：SYNC+PID+0~1023字节+CRC16</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">握手包：结构最为简单的包，格式如下: SYNC+PID</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事务: 分别有IN事务、OUT事务和SETUP事务三大事务.</span></span><ul><li><span class="name"><span class="innerContentContainer">每一种事务都由令牌包、数据包、握手包三个阶段构成，这里用阶段的意思是因为这些包的发送是有一定的时间先后顺序的.</span></span></li><li><span class="name"><span class="innerContentContainer">事务的三个阶段如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">令牌包阶段：启动一个输入、输出或设置的事务</span></span></li><li><span class="name"><span class="innerContentContainer">数据包阶段：按输入、输出发送相应的数据</span></span></li><li><span class="name"><span class="innerContentContainer">握手包阶段：返回数据接收情况，在同步传输的IN和OUT事务中没有这个阶段，这是比较特殊的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事务的三种类型如下:</span></span><ul><li><span class="name"><span class="innerContentContainer">IN事务：</span></span><ul><li><span class="name"><span class="innerContentContainer">令牌包阶段——主机发送一个PID为IN的输入包给设备，通知设备要往主机发送数据；</span></span></li><li><span class="name"><span class="innerContentContainer">数据包阶段——设备根据情况会作出三种反应（要注意：数据包阶段也不总是传送数据的，根据传输情况还会提前进入握手包阶段）</span></span></li><li><span class="name"><span class="innerContentContainer">1） 设备端点正常，设备往入主机里面发出数据包（DATA0与DATA1交替）；</span></span></li><li><span class="name"><span class="innerContentContainer">2） 设备正在忙，无法往主机发出数据包就发送NAK无效包，IN事务提前结束，到了下一个IN事务才继续；</span></span></li><li><span class="name"><span class="innerContentContainer">3） 相应设备端点被禁止，发送错误包STALL包，事务也就提前结束了，总线进入空闲状态。</span></span></li><li><span class="name"><span class="innerContentContainer">握手包阶段——主机正确接收到数据之后就会向设备发送ACK包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">OUT事务：</span></span><ul><li><span class="name"><span class="innerContentContainer">令牌包阶段——主机发送一个PID为OUT的输出包给设备，通知设备要接收数据；</span></span></li><li><span class="name"><span class="innerContentContainer">数据包阶段——比较简单，就是主机会设备送数据，DATA0与DATA1交替</span></span></li><li><span class="name"><span class="innerContentContainer">握手包阶段——设备根据情况会作出三种反应</span></span></li><li><span class="name"><span class="innerContentContainer">1）设备端点接收正确，设备往入主机返回ACK，通知主机可以发送新的数据，如果数据包发生了CRC校验错误，将不返回任何握手信息；</span></span></li><li><span class="name"><span class="innerContentContainer">2） 设备正在忙，无法往主机发出数据包就发送NAK无效包，通知主机再次发送数据；</span></span></li><li><span class="name"><span class="innerContentContainer">3） 相应设备端点被禁止，发送错误包STALL包，事务提前结束，总线直接进入空闲状态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SETUT事务：</span></span><ul><li><span class="name"><span class="innerContentContainer">令牌包阶段——主机发送一个PID为SETUP的输出包给设备，通知设备要接收数据；</span></span></li><li><span class="name"><span class="innerContentContainer">数据包阶段——比较简单，就是主机会设备送数据，注意，这里只有一个固定为8个字节的DATA0包，这8个字节的内容就是标准的USB设备请求命令.</span></span></li><li><span class="name"><span class="innerContentContainer">握手包阶段——设备接收到主机的命令信息后，返回ACK，此后总线进入空闲状态，并准备下一个传输（在SETUP事务后通常是一个IN或OUT事务构成的传输）</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">传输: 传输由OUT、IN、SETUP事务其中的若干事务构成.</span></span><ul><li><span class="name"><span class="innerContentContainer">传输有四种类型，中断传输、批量传输、同步传输、控制传输.</span></span></li><li><span class="name"><span class="innerContentContainer">其中中断传输和批量转输的结构一样，</span></span></li><li><span class="name"><span class="innerContentContainer">同步传输有最简单的结构，</span></span></li><li><span class="name"><span class="innerContentContainer">而控制传输是最重要的也是最复杂的传输。</span></span></li><li><span class="name"><span class="innerContentContainer">中断传输：由OUT事务和IN事务构成，用于键盘、鼠标等HID设备的数据传输中.</span></span></li><li><span class="name"><span class="innerContentContainer">批量传输：由OUT事务和IN事务构成，用于大容量数据传输，没有固定的传输速率，也不占用带宽，当总线忙时，USB会优先进行其他类型的数据传输，而暂时停止批量转输。</span></span></li><li><span class="name"><span class="innerContentContainer">同步传输：由OUT事务和IN事务构成，有两个特殊地方，第一，在同步传输的IN和OUT事务中是没有返回包阶段的；第二，在数据包阶段所有的数据包都为DATA0.</span></span></li><li><span class="name"><span class="innerContentContainer">控制传输：最重要的也是最复杂的传输，</span></span><ul><li><span class="name"><span class="innerContentContainer">控制传输由三个阶段构成（初始设置阶段、可选数据阶段、状态信息步骤），每一个阶段可以看成一个的传输，也就是说控制传输其实是由三个传输构成的.</span></span></li><li><span class="name"><span class="innerContentContainer">控制传输用来于USB设备初次加接到主机之后，主机通过控制传输来交换信息，设备地址和读取设备的描述符，使得主机识别设备，并安装相应的驱动程序，这是每一个USB开发者都要关心的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">1、初始设置步骤：就是一个由SET事务构成的传输</span></span></li><li><span class="name"><span class="innerContentContainer">2、可选数据步骤：就是一个由IN或OUT事务构成的传输，这个步骤是可选的，要看初始设置步骤有没有要求读/写数据（由SET事务的数据包阶段发送的标准请求命令决定）</span></span></li><li><span class="name"><span class="innerContentContainer">3、 状态信息步骤：顾名思义，这个步骤就是要获取状态信息，由IN或OUT事务构成构成的传输，但是要注意这里的IN和OUT事务和之前的INT和OUT事务有两点不同：</span></span></li><li><span class="name"><span class="innerContentContainer">1） 传输方向相反，通常IN表示设备往主机送数据，OUT表示主机往设备送数据；在这里，IN表示主机往设备送数据，而OUT表示设备往主机送数据，这是为了和可选数据步骤相结合；</span></span></li><li><span class="name"><span class="innerContentContainer">2） 在这个步骤里，数据包阶段的数据包都是0长度的，即SYNC+PID+CRC16</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">标识码有哪些？</span></span><ul><li><span class="name"><span class="innerContentContainer">如同前面所说的标识码由四位数据组成，因此最多可以表示十六种标识码，在USB1.1规范里面，只用了十种标识码，USB2.0使用了十六种标识码. </span></span></li><li><span class="name"><span class="innerContentContainer">标 识码的作用是用来说明包的属性的，标识码是和包联系在一起的，数据包分为令牌包、数据、握手包和特殊包四种. 标识码分别有以下十六种：</span></span></li><li><span class="name"><span class="innerContentContainer">令牌包 :</span></span><ul><li><span class="name"><span class="innerContentContainer">0x01 输出(OUT）启动一个方向为主机到设备的传输，并包含了设备地址和标号</span></span></li><li><span class="name"><span class="innerContentContainer">0x09 输入 (IN) 启动一个方向为设备到主机的传输，并包含了设备地址和标号</span></span></li><li><span class="name"><span class="innerContentContainer">0x05 帧起始（SOF）表示一个帧的开始，并且包含了相应的帧号</span></span></li><li><span class="name"><span class="innerContentContainer">0x0d 设置（SETUP）启动一个控制传输，用于主机对设备的初始化</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据包 :</span></span><ul><li><span class="name"><span class="innerContentContainer">0x03 偶数据包（DATA0）.</span></span></li><li><span class="name"><span class="innerContentContainer">0x0b 奇数据包（DATA1）.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">握手包:</span></span><ul><li><span class="name"><span class="innerContentContainer">0x02 确认接收到无误的数据包（ACK）</span></span></li><li><span class="name"><span class="innerContentContainer">0x0a 无效，接收（发送）端正在忙而无法接收（发送）信息</span></span></li><li><span class="name"><span class="innerContentContainer">0x0e 错误，端点被禁止或不支持控制管道请求</span></span></li><li><span class="name"><span class="innerContentContainer">特殊包 0x0C 前导，用于启动下行端口的低速设备的数据传输</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">USB主机是如何识别USB设备的？</span></span><ul><li><span class="name"><span class="innerContentContainer">当USB设备插上主机时，主机就通过一系列的动作来对设备进行枚举配置（配置是属于枚举的一个态，态表示暂时的状态），这这些态如下：</span></span></li><li><span class="name"><span class="innerContentContainer">1、接入态（Attached）：设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入；</span></span></li><li><span class="name"><span class="innerContentContainer">2、供电态（Powered）：就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值（按数据中要求的最大值，可通过编程设置）</span></span></li><li><span class="name"><span class="innerContentContainer">3、缺省态（Default）：USB在被配置之前，通过缺省地址0与主机进行通信；</span></span></li><li><span class="name"><span class="innerContentContainer">4、地址态（Address）：经过了配置，USB设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；</span></span></li><li><span class="name"><span class="innerContentContainer">5、配置态（Configured）：通过各种标准的USB请求命令来获取设备的各种信息，并对设备的某此信息进行改变或设置。</span></span></li><li><span class="name"><span class="innerContentContainer">6、挂起态（Suspended）：总线供电设备在3ms内没有总线***作，即USB总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过280UA。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">标准的USB设备请求命令究竟是什么？</span></span><ul><li><span class="name"><span class="innerContentContainer">标准的USB设备请求命令是用在控制传输中的“初始设置步骤”里的数据包阶段（即DATA0，由八个字节构成），请看回问答四的内容。标准USB设 备请求命令共有11个，大小都是8个字节，具有相同的结构，由5 个字段构成（字段是标准请求命令的数据部分），结构如下（括号中的数字表示字节数，首字母bm,b,w分别表示位图、字节，双字节）：</span></span></li><li><span class="name"><span class="innerContentContainer">bmRequestType(1) + bRequest（1）+wvalue（2）+wIndex（2）+wLength（2）</span></span></li><li><span class="name"><span class="innerContentContainer">各字段的意义如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">bmRequestType：D7D6D5D4D3D2D1D0</span></span><ul><li><span class="name"><span class="innerContentContainer">D7=0主机到设备, =1设备到主机；</span></span></li><li><span class="name"><span class="innerContentContainer">D6D5=00标准请求命令; =01 类请求命令; =10用户定义的命令; =11保留值</span></span></li><li><span class="name"><span class="innerContentContainer">D4D3D2D1D0=00000 接收者为设备. =00001 接收者为设备; =00010 接收者为端点; =00011 接收者为其他接收者; =其他 其他值保留</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bRequest：请求命令代码，在标准的USB命令中，每一个命令都定义了编号，编号的值就为字段的值，编号与命令名称如下（要注意这里的命令代码要与 其他字段结合使用，可以说命令代码是标准请求命令代码的核心，正是因为这些命令代码而决定了11个USB标准请求命令）：</span></span><ul><li><span class="name"><span class="innerContentContainer">0） 0 GET_STATUS：用来返回特定接收者的状态</span></span></li><li><span class="name"><span class="innerContentContainer">1） 1 CLEAR_FEATURE：用来清除或禁止接收者的某些特性</span></span></li><li><span class="name"><span class="innerContentContainer">2） 3 SET_FEATURE：用来启用或激活命令接收者的某些特性</span></span></li><li><span class="name"><span class="innerContentContainer">3） 5 SET_ADDRESS：用来给设备分配地址</span></span></li><li><span class="name"><span class="innerContentContainer">4） 6 GET_DEscriptOR：用于主机获取设备的特定描述符</span></span></li><li><span class="name"><span class="innerContentContainer">5） 7 SET_DEscriptOR：修改设备中有关的描述符，或者增加新的描述符</span></span></li><li><span class="name"><span class="innerContentContainer">6） 8 GET_CONFIGURATION：用于主机获取设备当前设备的配置值（注同上面的不同）</span></span></li><li><span class="name"><span class="innerContentContainer">7） 9 SET_CONFIGURATION：用于主机指示设备采用的要求的配置</span></span></li><li><span class="name"><span class="innerContentContainer">8） 10 GET_INTERFACE：用于获取当前某个接口描述符编号</span></span></li><li><span class="name"><span class="innerContentContainer">9） 11 SET_INTERFACE：用于主机要求设备用某个描述符来描述接口</span></span></li><li><span class="name"><span class="innerContentContainer">10） 12 SYNCH_FRAME：用于设备设置和报告一个端点的同步帧</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">以上的11个命令要说得明白真的有一匹布那么长，请各位去看书吧，这里就不多说了，控制传输是USB的重心，而这11个命令是控制传输的重心，所以这11个命令是重中之重，这个搞明白了，USB就算是入门了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Descriptor, 即描述符</span></span><ul><li><span class="name"><span class="innerContentContainer">是一个完整的数据结构，可以通过C语言等编程实现，并存储在USB设备中，用于描述一个USB设备的所有属性， USB主机是通过一系列命令来要求设备发送这些信息的。</span></span></li><li><span class="name"><span class="innerContentContainer">它的作用就是通过如问答节中的命令***作来给主机传递信息，从而让主机知道设备具有什么功能、属 于哪一类设备、要占用多少带宽、使用哪类传输方式及数据量的大小.</span></span></li><li><span class="name"><span class="innerContentContainer">只有主机确定了这些信息之后，设备才能真正开始工作。</span></span></li><li><span class="name"><span class="innerContentContainer">标准的描述符有5种，USB为这些描述符定义了编号：</span></span></li><li><span class="name"><span class="innerContentContainer">设备描述符</span></span><ul><li><span class="name"><span class="innerContentContainer">struct _DEVICE_DEscriptOR_STRUCT {</span></span><ul><li><span class="name"><span class="innerContentContainer">BYTE bLength; //设备描述符的字节数大小，为0x12</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDescriptorType; //描述符类型编号，为0x01</span></span></li><li><span class="name"><span class="innerContentContainer">WORD bcdUSB; //USB版本号</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDeviceClass; //USB分配的设备类代码，0x01~0xfe为标准设备类，0xff为厂商自定义类型</span></span></li><li><span class="name"><span class="innerContentContainer">//0x00不是在设备描述符中定义的，如HID</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDeviceSubClass; //usb分配的子类代码，同上，值由USB规定和分配的</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDeviceProtocl; //USB分配的设备协议代码，同上</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bMaxPacketSize0; //端点0的最大包的大小</span></span></li><li><span class="name"><span class="innerContentContainer">WORD idVendor; //厂商编号</span></span></li><li><span class="name"><span class="innerContentContainer">WORD idProduct; //产品编号</span></span></li><li><span class="name"><span class="innerContentContainer">WORD bcdDevice; //设备出厂编号</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE iManufacturer; //描述厂商字符串的索引</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE iProduct; //描述产品字符串的索引</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE iSerialNumber; //描述设备序列号字符串的索引</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bNumConfiguration; //可能的配置数量</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">配置描述符</span></span><ul><li><span class="name"><span class="innerContentContainer">struct _CONFIGURATION_DEscriptOR_STRUCT {</span></span><ul><li><span class="name"><span class="innerContentContainer">BYTE bLength; //设备描述符的字节数大小，为0x12</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDescriptorType; //描述符类型编号，为0x01</span></span></li><li><span class="name"><span class="innerContentContainer">WORD wTotalLength; //配置所返回的所有数量的大小</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bNumInterface; //此配置所支持的接口数量</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bConfigurationVale; //Set_Configuration命令需要的参数值</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE iConfiguration; //描述该配置的字符串的索引值</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bmAttribute; //供电模式的选择</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE MaxPower; //设备从总线提取的最大电流</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符描述符</span></span><ul><li><span class="name"><span class="innerContentContainer">struct _STRING_DEscriptOR_STRUCT {</span></span><ul><li><span class="name"><span class="innerContentContainer">BYTE bLength; //设备描述符的字节数大小，为0x12</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDescriptorType; //描述符类型编号，为0x01</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE SomeDescriptor[36];  //UNICODE编码的字符串</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接口描述符</span></span><ul><li><span class="name"><span class="innerContentContainer">struct _INTERFACE_DEscriptOR_STRUCT {</span></span><ul><li><span class="name"><span class="innerContentContainer">BYTE bLength; //设备描述符的字节数大小，为0x12</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDescriptorType; //描述符类型编号，为0x01</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bInterfaceNunber; //接口的编号</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bAlternateSetting;//备用的接口描述符编号</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bNumEndpoints; //该接口使用端点数，不包括端点0</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bInterfaceClass; //接口类型</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bInterfaceSubClass;//接口子类型</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bInterfaceProtocol;//接口所遵循的协议</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE iInterface; //描述该接口的字符串索引值</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">端点描述符</span></span><ul><li><span class="name"><span class="innerContentContainer">struct _ENDPOIN_DEscriptOR_STRUCT {</span></span><ul><li><span class="name"><span class="innerContentContainer">BYTE bLength; //设备描述符的字节数大小，为0x12</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bDescriptorType; //描述符类型编号，为0x01</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bEndpointAddress; //端点地址及输入输出属性</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bmAttribute; //端点的传输类型属性</span></span></li><li><span class="name"><span class="innerContentContainer">WORD wMaxPacketSize; //端点收、发的最大包的大小</span></span></li><li><span class="name"><span class="innerContentContainer">BYTE bInterval; //主机查询端点的时间间隔</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">上面的描述符之间有一定的关系，一个设备只有一个设备描述符，而一个设备描述符可以包含多个配置描述符，而一个配置描述符可以包含多个接口描述符，一个接口使用了几个端点，就有几个端点描述符。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">USB autorun方案</span></span><ul><li><span class="name"><span class="innerContentContainer">方案的主要思想是自动安装驱动和后台软件.</span></span></li><li><span class="name"><span class="innerContentContainer">它要解决的核心问题是手机侧如何知道pc上是否安装了usb 驱动。</span></span></li><li><span class="name"><span class="innerContentContainer">有两种方案:</span></span><ul><li><span class="name"><span class="innerContentContainer">由手机来判断pc是否安装驱动.</span></span><ul><li><span class="name"><span class="innerContentContainer">优缺点: 便利. 但是受制于windows的实现.</span></span></li><li><span class="name"><span class="innerContentContainer">方案也有两种:</span></span><ul><li><span class="name"><span class="innerContentContainer">延迟判断法</span></span><ul><li><span class="name"><span class="innerContentContainer">usb驱动按照modem、diag口（串口）、光盘来设计，第一个口是modem。</span></span></li><li><span class="name"><span class="innerContentContainer">手机插入后，先报唯一一个光盘。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，如果pc安装过驱动，则pc会认为第一个端口为modem，它不会发命令查看光盘的内容。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有安装驱动，pc会加载标准光盘启动，并查看光盘内容。</span></span></li><li><span class="name"><span class="innerContentContainer">经验表明，这个时间大约是3秒。3秒内，pc没查询光盘内容，则表明它安装过驱动，此时手机自动切换为三端口。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">set feature判断法</span></span><ul><li><span class="name"><span class="innerContentContainer">这个方案的本质和延迟判断法基本一样，根据pc在两种情况下的行为不同来判断。</span></span></li><li><span class="name"><span class="innerContentContainer">但是判断的是set feature命令。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有安装驱动，pc会加载光盘驱动，不会发set feature命令；</span></span></li><li><span class="name"><span class="innerContentContainer">如果相反，则会发。</span></span></li><li><span class="name"><span class="innerContentContainer">所以当收到set feature时，就切换三端口。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">由手机光盘中的exe程序自动启动后从windows系统中判断是否安装驱动。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android手机上, 没有使用 autorun方案, 仅保留光盘.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB spec</span></span><ul><li><span class="name"><span class="innerContentContainer">device</span></span><ul><li><span class="name"><span class="innerContentContainer">对应物理设备本身。</span></span></li><li><span class="name"><span class="innerContentContainer">device descriptor包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">USB版本号</span></span></li><li><span class="name"><span class="innerContentContainer">设备类型</span></span></li><li><span class="name"><span class="innerContentContainer">子类型</span></span></li><li><span class="name"><span class="innerContentContainer">协议类型（这三个字段在多设备中是空的）</span></span></li><li><span class="name"><span class="innerContentContainer">EP包大小</span></span></li><li><span class="name"><span class="innerContentContainer">vendor id及字符串</span></span></li><li><span class="name"><span class="innerContentContainer">产品id及字符串</span></span></li><li><span class="name"><span class="innerContentContainer">支持的配置数量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">configuration</span></span><ul><li><span class="name"><span class="innerContentContainer">一个device至少有个一个配置，一般就一个。</span></span></li><li><span class="name"><span class="innerContentContainer">config des包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">支持的interface数量</span></span></li><li><span class="name"><span class="innerContentContainer">是否直供电</span></span></li><li><span class="name"><span class="innerContentContainer">是否支持远程唤醒</span></span></li><li><span class="name"><span class="innerContentContainer">需要的最大总线电量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">interface</span></span><ul><li><span class="name"><span class="innerContentContainer">一个配置至少一个接口；</span></span></li><li><span class="name"><span class="innerContentContainer">多用途设备会有多个接口；接口数量和端口数量一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">interface des中包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">设备类型</span></span></li><li><span class="name"><span class="innerContentContainer">子类型</span></span></li><li><span class="name"><span class="innerContentContainer">协议类型</span></span></li><li><span class="name"><span class="innerContentContainer">支持的EP数量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EP</span></span><ul><li><span class="name"><span class="innerContentContainer">EP是位于usb设备或主机上的一个数据缓冲区。一个端口至少有一对端点。</span></span></li><li><span class="name"><span class="innerContentContainer">EP des包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">EP地址</span></span><ul><li><span class="name"><span class="innerContentContainer">EP地址包括ID和方向。每个EP是编号和方向唯一确定的.</span></span></li><li><span class="name"><span class="innerContentContainer">EP地址的结构是：0-3为EP id，即最多有16对。</span></span></li><li><span class="name"><span class="innerContentContainer">方向</span></span><ul><li><span class="name"><span class="innerContentContainer">IN（device-&gt;host）</span></span></li><li><span class="name"><span class="innerContentContainer">OUT（hos-&gt;device）。</span></span></li><li><span class="name"><span class="innerContentContainer">第7位为方向：out=0，in=1.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">传输类型</span></span><ul><li><span class="name"><span class="innerContentContainer">control: 用于控制，专指EP0</span></span><ul><li><span class="name"><span class="innerContentContainer">host发起的配置命令等，专用EP0通道。</span></span></li><li><span class="name"><span class="innerContentContainer">EP0为短向的，其它都是单向的。</span></span></li><li><span class="name"><span class="innerContentContainer">可分配10%带宽，如不用则分配给bulk传输。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bulk: 块传输. 比如U盘.</span></span><ul><li><span class="name"><span class="innerContentContainer">支持大量数据，但无时间要求。</span></span></li><li><span class="name"><span class="innerContentContainer">块传输没有保留带宽，但可使用当前总线所有空闲带宽，最高可达90%。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">interrupt: 中断传输. 比如键盘鼠标.</span></span><ul><li><span class="name"><span class="innerContentContainer">响应时间受限的少量数据，如事件通知、键盘、鼠标设备等。</span></span></li><li><span class="name"><span class="innerContentContainer">中断传输在初始化时就会申请足够的带宽，如果当前系统满足不了，则初始化失败。</span></span></li><li><span class="name"><span class="innerContentContainer">申请的带宽会一直保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同步传输: 比如USB语音.</span></span><ul><li><span class="name"><span class="innerContentContainer">响应时间受限的大量数据，如语音通话。同步传输可分配90%的带宽。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EP 0为控制通道，不需要EP des。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows系统usb识别的特殊问题</span></span><ul><li><span class="name"><span class="innerContentContainer">windows用vid、pid、interface id来区分一个usb设备</span></span><ul><li><span class="name"><span class="innerContentContainer">如果3者都一样，则被认为是同一个设备。</span></span></li><li><span class="name"><span class="innerContentContainer">windows会保存EP number到注册表中, 而不从驱动配置文件中获取.</span></span></li><li><span class="name"><span class="innerContentContainer">如果某个设备修改了EP，则需要更新这三个中的至少一个，否则会通讯失败。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows识别设多端口备的另一个要求</span></span><ul><li><span class="name"><span class="innerContentContainer">该设备各端口的interface id必须是从0开始，连续排列的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">如何区分usb host还是usb充电器？</span></span><ul><li><span class="name"><span class="innerContentContainer">当前高通方案是，有usb插入，先识别为usb，然后在usb中断中识别是不是充电器。</span></span></li><li><span class="name"><span class="innerContentContainer">方法是给D+、D-上电，usb host会给D+、D-加下拉电阻，外部上电，内部状态不变。</span></span></li><li><span class="name"><span class="innerContentContainer">而充电器是D+、D-短接的，外部上电，内部就上拉。如此就识别到了。</span></span></li><li><span class="name"><span class="innerContentContainer">非官方充电器，如果没做短接，有两个选择，1是分别上拉看情况；2是就认为是usb，反正后续usb协商无响应，对系统没影响。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输的发起者</span></span><ul><li><span class="name"><span class="innerContentContainer">除了中断传输，允许device发起外，其中传输都是host发起。</span></span></li><li><span class="name"><span class="innerContentContainer">正是这个原因，所以网卡、modem等都需要interrupt EP，因为它们需要device发起的传输。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输的物理单位</span></span><ul><li><span class="name"><span class="innerContentContainer">帧，时间概念。</span></span></li><li><span class="name"><span class="innerContentContainer">1毫秒为1帧，usb传输按帧来组织传输。</span></span></li><li><span class="name"><span class="innerContentContainer">对usb2.0，大约是12K大小。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输的逻辑单位</span></span><ul><li><span class="name"><span class="innerContentContainer">传输。一次请求的发起和结束。</span></span></li><li><span class="name"><span class="innerContentContainer">事务。一个传输包括一个或多个事务。</span></span><ul><li><span class="name"><span class="innerContentContainer">事务由3段组成：标记、数据和握手。</span></span></li><li><span class="name"><span class="innerContentContainer">每段由1-2个包组成，分别叫标记包、数据包和握手包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">包</span></span><ul><li><span class="name"><span class="innerContentContainer">只有数据包中有数据，最长不超过64B。</span></span></li><li><span class="name"><span class="innerContentContainer">包由PID、帧编号、地址、CRC和数据组成。</span></span></li><li><span class="name"><span class="innerContentContainer">特色包包括帧同步包，包含SOF记号标示帧起始；</span></span></li><li><span class="name"><span class="innerContentContainer">还有低速向导包。</span></span></li><li><span class="name"><span class="innerContentContainer">不同传输模式下，包结构不同。</span></span></li><li><span class="name"><span class="innerContentContainer">块传输的包大小</span></span><ul><li><span class="name"><span class="innerContentContainer">1.1协议是 64B;</span></span></li><li><span class="name"><span class="innerContentContainer">2.0协议是 512B。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">著名的零包问题</span></span><ul><li><span class="name"><span class="innerContentContainer">usb协议中规定，小于size的包表示transfer结束.</span></span></li><li><span class="name"><span class="innerContentContainer">所以如果数据大小正好整除，那么就需要传输一个零包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB远程唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">suspend的目的是为了节能。</span></span></li><li><span class="name"><span class="innerContentContainer">当device处在挂起状态时，它从总线上吸取的电流在500uA到2.5mA之间。</span></span></li><li><span class="name"><span class="innerContentContainer">当host检测总线没有活动一段时间后（大约3-5秒），就会把总线置为低电模式，并不再发帧开始包。</span></span></li><li><span class="name"><span class="innerContentContainer">当device 3ms没有收到帧开始包后，就应该进入挂起状态，10ms后必须进入此状态。</span></span></li><li><span class="name"><span class="innerContentContainer">此外，host端在必要的情况下，可随时通过set_prot_feather请求来挂起device。</span></span></li><li><span class="name"><span class="innerContentContainer">设备处在挂起状态时，两种情况可以使它resume:</span></span><ul><li><span class="name"><span class="innerContentContainer">一是总线上的任何活动都导致resume；</span></span></li><li><span class="name"><span class="innerContentContainer">二是如果device有远程唤醒机制，那么device可在任何情况下请求恢复。</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">双U盘方案</span></span><ul><li><span class="name"><span class="innerContentContainer">驱动: androdi_usb_pdata{} 之 nluns = 2，即可。</span></span></li><li><span class="name"><span class="innerContentContainer">挂载点: system/etc/vold.conf，volume_usb2 之 media_path = /devices/platform/msm_hsusb_host/usb2。</span></span></li><li><span class="name"><span class="innerContentContainer">FWK: vold模块的修改较多.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">USB线的物理结构</span></span><ul><li><span class="name"><span class="innerContentContainer">一条usb线分别有地线、电源线、D+、D- 4条线构成。</span></span></li><li><span class="name"><span class="innerContentContainer">其中D+、D-为差分输入线，使用3.3V电压。</span></span></li><li><span class="name"><span class="innerContentContainer">而电源线可向设备提供5V、最高500mA的电流。</span></span></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">U盘的serial number问题    <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">windows对U盘的识别策略是：</span></span><ul><li><span class="name"><span class="innerContentContainer">如果串号为空，则只识别第一个U盘；</span></span></li><li><span class="name"><span class="innerContentContainer">如果不为空，但相同，则多个U盘插入，windows会重启；</span></span></li><li><span class="name"><span class="innerContentContainer">如果不为空，且不同，则可分别识别。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对u盘sn号的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">google模式下用蓝牙地址；</span></span></li><li><span class="name"><span class="innerContentContainer">CTS模式下用字符串“hw_smart_phone”的asc码（因为CTS需要在linux下测试，需要串号）。</span></span></li><li><span class="name"><span class="innerContentContainer">normal等其它模式都没有sn号。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">USB传输速率的优化经验（MTP）  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">没有并行的使用usb，而是采用传输--处理--传输的方式。改为改为并行方式，最佳情况下速率可提高一倍。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡写操作是一个瓶颈，可以绕开vfs接口，直接用驱动接口（要先从vfs上unmount sd卡）。</span></span></li><li><span class="name"><span class="innerContentContainer">更新sql，要和其它逻辑并行，因为这些sql数据，都是被动收到的信息，不影响后续逻辑，缓存起来慢慢写没有问题。</span></span></li><li><span class="name"><span class="innerContentContainer">各层buffer都使用乒乓buffer，两个满了再等待。或者用buffer队列。</span></span></li><li><span class="name"><span class="innerContentContainer">buffer放大到64K。</span></span></li><li><span class="name"><span class="innerContentContainer">上层直接用底层buffer，可减少若干次memcpy。要注意，上层要及时读走数据。</span></span></li><li><span class="name"><span class="innerContentContainer">收到的文件放在底层写。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通讯问题必须先分清是链路层问题还是应用层问题  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">链路层不问数据内容，主要收到正确即返回ACK；这个响应很快。</span></span></li><li><span class="name"><span class="innerContentContainer">应用层要解析数据内容后，再根据内容是否正确做适当响应；这个响应很慢。</span></span></li><li><span class="name"><span class="innerContentContainer">Response 是链路层，还是应用层? 如果是链路层，则只要收到就会ACK；如果是应用层，则必须识别后才能response.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设计通讯协议的关注项  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">字节序。x86和arm正好相反，需要注意。</span></span></li><li><span class="name"><span class="innerContentContainer">4字节对齐；非常容易出问题。</span></span></li><li><span class="name"><span class="innerContentContainer">常见错误是字段类型的预期不一致。length字段的宽度要统一，4字节还是2字节；</span></span></li><li><span class="name"><span class="innerContentContainer">字符串编码，是utf8还是ascii/GBT。</span></span></li><li><span class="name"><span class="innerContentContainer">字符串是用C字符串，还是Pascal字符串；</span></span></li><li><span class="name"><span class="innerContentContainer">数组的实现，比如MTP数组在开始有4字节的长度。</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">功耗管理</span></span><ul><li><span class="name"><span class="innerContentContainer">android的功耗管理只要通过锁和定时器来切换系统状态，使功耗降低到最低。</span></span></li><li><span class="name"><span class="innerContentContainer">应用层的两种 wakelock.</span></span><ul><li><span class="name"><span class="innerContentContainer">一种是 partial wakeup，申请了这种，即使按power键，系统也不进sleep，比如music player。</span></span></li><li><span class="name"><span class="innerContentContainer">其它类型的 wakeup，按power键，系统进sleep。</span></span></li><li><span class="name"><span class="innerContentContainer">各自锁的定义常见 newWakeLock.c。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">fwk client端代码在：frameworks/base/core/java/android/os/PowerManager.java</span></span><ul><li><span class="name"><span class="innerContentContainer">它定义了一个wakelock基类，有两个成员，acquire 和 release。</span></span></li><li><span class="name"><span class="innerContentContainer">需要进行睡眠控制的类，会定义 wakelock成员. </span></span><ul><li><span class="name"><span class="innerContentContainer">通过qcquire接口来禁止睡眠，</span></span></li><li><span class="name"><span class="innerContentContainer">通过release接口来允许睡眠。</span></span></li><li><span class="name"><span class="innerContentContainer">要成对使用，否则导致系统无法进睡眠。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">fwk service端的代码在 powermanager_service.java, 是核心。</span></span><ul><li><span class="name"><span class="innerContentContainer">power.java 为接口io层，访问jni层。</span></span></li><li><span class="name"><span class="innerContentContainer">jni层代码主要是 android_os_power.cpp。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">hal层代码是 power.c，通过sys文件系统，syscall， 调用driver。</span></span></li><li><span class="name"><span class="innerContentContainer">driver层代码在 kernel/kernel/power</span></span><ul><li><span class="name"><span class="innerContentContainer">wakelock模块主要维护两个链表。应用申请lock，在调用wakelock()中插入active_wake_locks链表。</span></span></li><li><span class="name"><span class="innerContentContainer">被释放的 lock ，调用 wakeunlock(),会将其移动到 inactive_locks 队列中去。</span></span></li><li><span class="name"><span class="innerContentContainer">在调用 wakeunlock() 中，以及定时器到时间时，会调用 has_wake_lock_locked()来看是否有active的lock，如果没有，则启动 suspend_unlock 工作队列，执行睡眠流程。</span></span></li><li><span class="name"><span class="innerContentContainer">有3个suspend_work_queue队列</span></span><ul><li><span class="name"><span class="innerContentContainer">睡眠准备：early_suspend_work</span></span><ul><li><span class="name"><span class="innerContentContainer">通常会把LCD和背光驱动注册为early_suspend_work，以便第一阶段被关闭。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">睡眠：suspend_work</span></span></li><li><span class="name"><span class="innerContentContainer">睡眠恢复：late_resume_work</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel会去查看 wakelock是否全部释放，如果是，则启动suspend_work队列，让所有设备进入suspend状态，并停止时钟。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用如果要保持屏幕亮， 调用链是：</span></span><ul><li><span class="name"><span class="innerContentContainer">TimerOutTask(screen) </span></span></li><li><span class="name"><span class="innerContentContainer">setPowerState() </span></span></li><li><span class="name"><span class="innerContentContainer">Power.setScreenState()</span></span></li><li><span class="name"><span class="innerContentContainer">set_screen_state() // jni</span></span></li><li><span class="name"><span class="innerContentContainer">write("/sys/power/state") </span></span></li><li><span class="name"><span class="innerContentContainer">state_store()   // driver</span></span></li><li><span class="name"><span class="innerContentContainer">state_store()；后面分为两支，MEM 则进入 early_syspend(), ON 则进入 late_resueme().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用如果要禁止进待机，调用链是：</span></span><ul><li><span class="name"><span class="innerContentContainer">PowerManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">Power.java</span></span></li><li><span class="name"><span class="innerContentContainer">acquire_wake_lock()</span></span></li><li><span class="name"><span class="innerContentContainer">write "/sys/power/wake_lock"</span></span></li><li><span class="name"><span class="innerContentContainer">wake_lock_store()</span></span></li><li><span class="name"><span class="innerContentContainer">wake_lock() </span></span></li><li><span class="name"><span class="innerContentContainer">wake_lock_time_out()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">待机：DRX周期</span></span><ul><li><span class="name"><span class="innerContentContainer">非连续接收周期。进入睡眠后，大约每2.56秒，手机会醒来查看是否有呼入。此时也会检查是否有用户输入。</span></span></li><li><span class="name"><span class="innerContentContainer">手机用这个机制来省电。</span></span></li><li><span class="name"><span class="innerContentContainer">比如 GSM drx周期为1.18秒，WCDMA为2.56秒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">手机器件的典型功耗（不是太准确） <span class="contentTag" title="Filter #问题功耗">#<span class="contentTagText">问题功耗</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">SDRAM读写刷新：60-65mA（＊2，有两块）；静态电流：200uA（＊2）</span></span></li><li><span class="name"><span class="innerContentContainer">Nand flash工作：10-20mA；静态：&lt;1mA</span></span></li><li><span class="name"><span class="innerContentContainer">camera工作：100mA；静态：uA级</span></span></li><li><span class="name"><span class="innerContentContainer">LCD工作：50mA；静态：30uA</span></span></li><li><span class="name"><span class="innerContentContainer">LCD背灯工作：75mA；静态：uA级</span></span></li><li><span class="name"><span class="innerContentContainer">EL灯片工作：70mA；静态：uA级</span></span></li><li><span class="name"><span class="innerContentContainer">RF+PA发射（高通套片）工作（GSM）2.35mA；静态：nil</span></span></li><li><span class="name"><span class="innerContentContainer">RF+PA接受（高通套片）工作（GSM）2.15mA；静态：nil</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动整机功耗优化的思路  <span class="contentTag" title="Filter #问题功耗">#<span class="contentTagText">问题功耗</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">临区测量对待机的影响；</span></span></li><li><span class="name"><span class="innerContentContainer">搜网时间间隔；小区切换频繁的定位方案、优化方案；</span></span></li><li><span class="name"><span class="innerContentContainer">通话和待机时CPU主频的优化；</span></span></li><li><span class="name"><span class="innerContentContainer">周期位置更新周期和每次时长的记录，及优化方案；</span></span></li><li><span class="name"><span class="innerContentContainer">背光、马达等的设置，功耗和业界方案对比。</span></span></li><li><span class="name"><span class="innerContentContainer">声音播放过程中的优化。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动整机功耗调试经验  <span class="contentTag" title="Filter #问题功耗">#<span class="contentTagText">问题功耗</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">BT电源是功耗大户，拔器件看功耗有没有改善。</span></span></li><li><span class="name"><span class="innerContentContainer">board id相关的gpio要细调，有时候会有四五mA的漏电。</span></span></li><li><span class="name"><span class="innerContentContainer">常见问题包括：PA开关、TF卡电源、mac bias电源。</span></span></li><li><span class="name"><span class="innerContentContainer">rf电源如果有问题，功耗会差很多。包括rftx、rfrx1、rfrx2、s2、s3、wlan等。先看能不能关，不能关看有没有省电模式。</span></span></li><li><span class="name"><span class="innerContentContainer">调整好软件流程。系统有中断马上会启动tcxo，电流起码40mA。</span></span></li><li><span class="name"><span class="innerContentContainer">上拉电阻的阻值要尽量大一些，保证静态电流尽量小。</span></span></li><li><span class="name"><span class="innerContentContainer">慎用三极管做开关，因为管子本身电流大。</span></span></li><li><span class="name"><span class="innerContentContainer">外围芯片中，对于提供shutdown状态的芯片要尽量提供控制电路，软件要确保待机前使之进入shutdown。</span></span></li><li><span class="name"><span class="innerContentContainer">射频发射功耗大，尽量做到高效率，减少不必要的延迟和重传，当然要懂这块之后再调。</span></span></li><li><span class="name"><span class="innerContentContainer">I2C关闭时，要作为GPIO来关，否则关不彻底。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用功耗管理  <span class="contentTag" title="Filter #问题功耗">#<span class="contentTagText">问题功耗</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">功耗精灵之类.</span></span></li><li><span class="name"><span class="innerContentContainer">考虑要素:</span></span><ul><li><span class="name"><span class="innerContentContainer">系统状态: 开屏, 锁屏3分钟, 锁屏10分钟, 锁屏1小时.</span></span></li><li><span class="name"><span class="innerContentContainer">应用状态: 前台, 后台.</span></span></li><li><span class="name"><span class="innerContentContainer">应用优先级: 超级应用, 比如 微信. QQ.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对应用的处理措施</span></span><ul><li><span class="name"><span class="innerContentContainer">冻结. </span></span></li><li><span class="name"><span class="innerContentContainer">kill, 进程杀掉, 但是资源还在.</span></span></li><li><span class="name"><span class="innerContentContainer">stop</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用功耗排行</span></span><ul><li><span class="name"><span class="innerContentContainer">实时统计 CPU, 基带, WiFi, GPS 等设备的功耗, 然后按应用对器件的使用占比来计算功耗排行.</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">热方案</span></span><ul><li><span class="name"><span class="innerContentContainer">充电时用电池的热敏电阻，放电时用cpu的热敏电阻。</span></span></li><li><span class="name"><span class="innerContentContainer">放电时，通过CPU旁边的热敏电阻监控CPU温度，超过门限（43℃左右）就降频。</span></span></li><li><span class="name"><span class="innerContentContainer">充电时，通过充电芯片旁边的热敏电阻监控充电芯片的温度，超过门限（48℃左右）就限流。</span></span></li><li><span class="name"><span class="innerContentContainer">充电时，如果用户玩大型游戏，或者长时间通话，CPU温升可能超过充电芯片，导致方案（2）失效。所以在充电时需要监控两个数据。</span></span></li><li><span class="name"><span class="innerContentContainer">CPU有过热保护，高通平台是85℃手机就自动关机。</span></span></li><li><span class="name"><span class="innerContentContainer">从业界看环境温度25度下，要求不超过43度是一个业界基本采用的标准（刚好温升18度）。</span></span></li><li><span class="name"><span class="innerContentContainer">从人体接触体验来说，40度以上温度刺激明显，45度以上可能受伤。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Power键处理</span></span><ul><li><span class="name"><span class="innerContentContainer">power键直接接到PMIC的KPDPWR_IN脚上。</span></span></li><li><span class="name"><span class="innerContentContainer">当它被拉低后，PM将启动，并给CPU供电，启动CPU。</span></span></li></ul></li></ul>
  </body>
</html>