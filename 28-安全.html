<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">28-安全</span></span><ul><li><span class="name"><span class="innerContentContainer">应用层安全方案</span></span><ul><li><span class="name"><span class="innerContentContainer">代码安全</span></span><ul><li><span class="name"><span class="innerContentContainer">代码混淆</span></span></li><li><span class="name"><span class="innerContentContainer">反编译</span></span><ul><li><span class="name"><span class="innerContentContainer">apk反编译就是通过使用apk编译工具，将apk文件中的源文件和资源反编译出来，得到的源文件和资源文件可以进行处理后再进行编译，以达到个性化定制、汉化apk等目的。</span></span></li><li><span class="name"><span class="innerContentContainer">最典型的apk编译工具的核心是apktool，但是因为操作需要调用cmd命令，所以出现了很多具有可视化界面的各种编译工具，像easyapk、apkdb、doapk。</span></span></li><li><span class="name"><span class="innerContentContainer">方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">获取apk（在/system/app下），和dex文件（在/data/dalvik-cache下）。</span></span></li><li><span class="name"><span class="innerContentContainer">用dex2jar，将dex文件转为jar文件。</span></span></li><li><span class="name"><span class="innerContentContainer">用jd-gui，将jar转化为java代码。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">进程隔离  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">通过进程UID进行进程隔离。</span></span></li><li><span class="name"><span class="innerContentContainer">继承于linux.</span></span></li><li><span class="name"><span class="innerContentContainer">每个apk都有各自不同的UID. </span></span></li><li><span class="name"><span class="innerContentContainer">由于私有目录只能由同一uid应用访问, 就保证了进程隔离和数据安全.</span></span></li><li><span class="name"><span class="innerContentContainer">多个app可通过shareuid的方式可以使用同一个userid，这样就可以访问别人的私有目录.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">签名 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">签名是权限系统的重要组成部分。常用于如下场景：</span></span><ul><li><span class="name"><span class="innerContentContainer">apk文件必须被开发者数字签名后才可以被安装。</span></span></li><li><span class="name"><span class="innerContentContainer">当apk升级时，需要检查新版应用的数字签名与已安装的应用程序的签名是否相同，不同会被当做一个新的应用程序。</span></span></li><li><span class="name"><span class="innerContentContainer">同一开发者可指定不同的应用程序共享UID，进而它们运行于同一进程空间，共享资源。</span></span></li><li><span class="name"><span class="innerContentContainer">permission在设置/自定义其权限时也经常会使用到签名。</span></span></li><li><span class="name"><span class="innerContentContainer">对于系统签名的应用，会有一些特殊的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">签名的作用：</span></span><ul><li><span class="name"><span class="innerContentContainer">识别代码的作者。</span></span></li><li><span class="name"><span class="innerContentContainer">检测应用程序是否发生了改变。</span></span></li><li><span class="name"><span class="innerContentContainer">在应用程序之间建立信任，以便于应用程序可以安全地共享代码和数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Keystore &amp; Keytool</span></span><ul><li><span class="name"><span class="innerContentContainer">keystore叫做key(密钥)store(仓库)。顾名思义里面的存放的是密钥，分为公钥和私钥。</span></span></li><li><span class="name"><span class="innerContentContainer">类似于 sqlite 文件的一张表，每一条记录都是一个公私钥对和一些相关信息。</span></span></li><li><span class="name"><span class="innerContentContainer">Keytool 是jdk提供的一个把钥匙和证书储存到keystore中的工具。</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>-genkey：</b>在用户主目录中创建密钥库（Keystore），后缀名为.keystore。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-alias</b> [alias]：产生别名，后面跟别名内容。若未指定，则别名默认为mykey.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-keystore：</b>指定.keystore文件的名称，如：</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -genkey -keystore dmkf.keystore</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">常用 Keytool 指令操作</span></span><ul><li><span class="name"><span class="innerContentContainer">创建Keystore文件，生成一个别名为dmkf，名为dmkf.keystore的文件。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -genkey -alias dmkf -keystore dmkf.keystore -keyalg RSA</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看Keystore文件，查看名为dmkf.keystore的Keystore文件信息。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -list -v -keystore dmkf.keystore</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">输出Keystore证书，密钥库dmkf.keystore中导出别名为dmkf的证书到dmkf.crt文件中（导出的证书中包括主体信息和公钥）。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -export -alias dmkf -keystore dmkf.keystore -file dmkf.crt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看导出的证书信息，查看导出并保存在dmkf.crt文件中的证书信息。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -printcert -file dmkf.crt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导入证书，从名为dmkf.crt文件中取出别名为dmkf的证书信息导入到名为truststore.keystore密钥库中。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -import -alias dmfk -keystore truststore.keystore -file dmkf.crt</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">签名方案V1</span></span><ul><li><span class="name"><span class="innerContentContainer">最先生成私有、公共密钥和公共密钥证书（仅需要生成一次）。</span></span></li><li><span class="name"><span class="innerContentContainer">首先对apk里面的所有文件计算hash（使用SHA1算法计算文件的摘要信息，然后用Base64进行编码），然后保存在 MANIFEST.MF，</span></span></li><li><span class="name"><span class="innerContentContainer">然后再对这些hash计算hash，保存到 CERT.SF，</span></span></li><li><span class="name"><span class="innerContentContainer">最后再通过 keystore里面的私钥进行加密并保存到 CERT.RSA，这个文件就是证书文件。</span></span></li><li><span class="name"><span class="innerContentContainer">可以用 openssl 来查看RSA文件中的证书信息和公钥信息。</span></span></li><li><span class="name"><span class="innerContentContainer"> 证书是自签名的，并不需要由第三方权威机构发布或者认证的。</span></span></li><li><span class="name"><span class="innerContentContainer">Android中的签名有两种方式：jarsigner和signapk。这两种方式的区别是：</span></span><ul><li><span class="name"><span class="innerContentContainer">jarsigner签名时，需要的是keystore文件，而signapk签名的时候是pk8.x509.pem文件。</span></span></li><li><span class="name"><span class="innerContentContainer">jarsigner签名之后的SF和RSA文件名默认是keystore的别名，而signapk签名之后文件名是固定的:CERT。</span></span></li><li><span class="name"><span class="innerContentContainer">keystore文件和pk8.x509.pem文件之间可以互相转化。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">签名方案V2</span></span><ul><li><span class="name"><span class="innerContentContainer">v2是一种全文件签名方案，对整个zip文件（包括zip元数据）进行签名；</span></span></li><li><span class="name"><span class="innerContentContainer">v2下，zipalign需要在签名之前执行；</span></span></li><li><span class="name"><span class="innerContentContainer">v2的签名工具-apksigner，位于sdk的build-tools目录下，但由于v2是Android7.0之后才推出的，所以只有版本&gt;25的sdk中才能找到apksigner.jar。</span></span></li><li><span class="name"><span class="innerContentContainer">为了兼容7.0以下设备，需要同时使用v1和v2签名。此时，在7.0及以上设备中只会验证v2签名，在7.0以下设备中，则只会验证v1签名；</span></span></li><li><span class="name"><span class="innerContentContainer">如果试图删除v2签名保留v1签名，系统同样会验证不通过，即“防回滚保护”。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">权限控制 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Android应用通过权限字符串来控制权限。权限字符串通过签名来保证不被篡改。</span></span></li><li><span class="name"><span class="innerContentContainer">安装位置会影响权限</span></span><ul><li><span class="name"><span class="innerContentContainer">在 system/app下面安装的应用是 system level，能获得一些危险权限，比如静默安装权限。</span></span></li><li><span class="name"><span class="innerContentContainer">在 data/app 下面安装的应用是&nbsp;app level.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在AndroidManifest中定义Permission</span></span><ul><li><span class="name"><span class="innerContentContainer">系统会根据应用在AndroidManifest.xml中声明的use-permission而在访问相应api或资源时判断其是否有访问权限，比如常用的android.permission.INTERNET等。</span></span></li><li><span class="name"><span class="innerContentContainer">这个是最主要的权限控制，一般开发者开发应用主要是接触这个.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">安全模式</span></span><ul><li><span class="name"><span class="innerContentContainer">android4.1支持安全模式。</span></span></li><li><span class="name"><span class="innerContentContainer">在这种模式下，手机界面上显示“safe mode”，并停用所有第三方应用，以方便对问题手机进行检查和维护。</span></span></li><li><span class="name"><span class="innerContentContainer">进入方式：默认为长按power键，一直到“进入安全模式”菜单出现，然后选择即进入。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">框架层安全方案</span></span><ul><li><span class="name"><span class="innerContentContainer">数字证书</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android运行时</span></span><ul><li><span class="name"><span class="innerContentContainer">SSL（网络安全库）</span></span></li><li><span class="name"><span class="innerContentContainer">SQLite（数据库安全）</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟机（安全沙箱）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel层</span></span><ul><li><span class="name"><span class="innerContentContainer">root 权限</span></span><ul><li><span class="name"><span class="innerContentContainer">如果没有root权限，则 /system/bin/su 文件不存在.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件访问控制</span></span><ul><li><span class="name"><span class="innerContentContainer">修改文件访问权限：</span></span><ul><li><span class="name"><span class="innerContentContainer">system/core/include/private/android_filesystem_config.h，有 android_dirs[], android_files[]。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SELinux  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">SELinux之前</span></span><ul><li><span class="name"><span class="innerContentContainer">在 SELinux 出现之前，Linux 上的安全模型叫 DAC。</span></span></li><li><span class="name"><span class="innerContentContainer">DAC，Discretionary Access Control，自主访问控制。</span></span></li><li><span class="name"><span class="innerContentContainer">DAC 的思想是：进程理论上所拥有的权限与执行它的用户的权限相同。比如，以 root 用户启动 Browser，那么 Browser 就有 root 用户的权限。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SELinux之后</span></span><ul><li><span class="name"><span class="innerContentContainer">SELinux之后，DAC进化为MAC。</span></span></li><li><span class="name"><span class="innerContentContainer">MAC，Mandatory Access Control，强制访问控制。</span></span></li><li><span class="name"><span class="innerContentContainer">MAC 的理论也很简单，任何进程想在 SELinux 系统上干任何事情，都必须在“安全策略文件”中赋予权限，凡是没有出现在安全策略文件中的权限，就不行。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux 系统先做 DAC 检查。如果没有通过 DAC 权限检查，则操作直接失败。通过 DAC 检查之后，再做 MAC 权限检查。</span></span></li><li><span class="name"><span class="innerContentContainer">SELinux 有自己的一套规则来编写安全策略文件，这套规则被称之为 SELinux Policy 语言。</span></span></li><li><span class="name"><span class="innerContentContainer">SELinux 按照默认拒绝的原则运行：任何未经明确允许的行为都会被拒绝。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MAC的本质: 没有MAC, 则有root 权限后就可以访问所有文件. 有了MAC, root也不能随便访问文件.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SELinux的两种模式</span></span><ul><li><span class="name"><span class="innerContentContainer">宽容模式(permissive)：权限拒绝事件会被记录到Log中，但不会被强制执行。</span></span></li><li><span class="name"><span class="innerContentContainer">强制模式(enforcing)：权限拒绝事件会被记录下来并强制执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">权限标签。重要</span></span><ul><li><span class="name"><span class="innerContentContainer">SELinux依靠标签来匹配任何访问操作和政策。</span></span></li><li><span class="name"><span class="innerContentContainer">标签在启动过程中给定。</span></span></li><li><span class="name"><span class="innerContentContainer">打标签的对象包括文件、进程和socket等。</span></span></li><li><span class="name"><span class="innerContentContainer">标签存放在te 文件中。</span></span></li><li><span class="name"><span class="innerContentContainer">路径在 /device/&lt;company&gt;/common/sepolicy 及 /device/&lt;company&gt;/$DEVICE/sepolicy 中。</span></span></li><li><span class="name"><span class="innerContentContainer">定义语法是 “user:role:type:mls_level ”形式（如u:r:init:s0），其中type是关键信息。</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们需要某些进程对某些目标具有操作权限，需要用这种：allow domains types:classes permissions的形式</span></span><ul><li><span class="name"><span class="innerContentContainer">Domain：一个进程或一组进程的标签。也称为域类型，因为它只是指进程的类型。</span></span></li><li><span class="name"><span class="innerContentContainer">Type：一个对象（例如，文件、套接字）或一组对象的标签。</span></span></li><li><span class="name"><span class="innerContentContainer">Class：要访问的对象（例如，文件、套接字）的类型。</span></span></li><li><span class="name"><span class="innerContentContainer">Permission：要执行的操作（例如，读取、写入）。</span></span></li><li><span class="name"><span class="innerContentContainer">比如 allow init ipa_dev:chr_file open，表示init进程可以对chr_file类型的ipa_dev具有open权限。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意： te文件必须以空行结束。建议在文件末尾放三四个空行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">权限拒绝事件的log</span></span><ul><li><span class="name"><span class="innerContentContainer">在dmesg&nbsp;和&nbsp;logcat&nbsp;都有。</span></span></li><li><span class="name"><span class="innerContentContainer">关键字：avc-denied</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何查看进程的标签？</span></span><ul><li><span class="name"><span class="innerContentContainer">标签又叫context，包括如下几种：</span></span><ul><li><span class="name"><span class="innerContentContainer">file_contexts    // 文件的安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">seapp_contexts  // app安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">property_contexts   // 属性的安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">service_contexts &nbsp; &nbsp;  // service文件安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">genfs_contexts    // 虚拟文件系统安全上下文</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb shell ls –Z，可查看文件的sContext。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell ps -Z，可查看进程的sContext。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">临时关闭SELinux</span></span><ul><li><span class="name"><span class="innerContentContainer">setenforce 0</span></span></li><li><span class="name"><span class="innerContentContainer">修改的是 /sys/fs/selinux/enforce 节点的值。断电之后，节点值会复位。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">永久关闭SELinux</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel 关闭 selinux：SECURITY_SELINUX 设置为 false，重新编译 kernel</span></span></li><li><span class="name"><span class="innerContentContainer">设置 ro.boot.selinux=permissive 属性，并且修改在 system/core/init/Android.mk 中设置用于 user 版本下 selinux 模式为 permissive。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">FDE，全盘加密</span></span><ul><li><span class="name"><span class="innerContentContainer">Full Disk Encryption。从Android 4.4开始。Android 5.0开始必须打开。</span></span></li><li><span class="name"><span class="innerContentContainer">对 /data/和sdcard 进行数据加密。</span></span></li><li><span class="name"><span class="innerContentContainer">基于文件的加密。</span></span></li><li><span class="name"><span class="innerContentContainer">加密感知型应用：</span></span></li><li><span class="name"><span class="innerContentContainer">功能</span></span><ul><li><span class="name"><span class="innerContentContainer">在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：</span></span></li><li><span class="name"><span class="innerContentContainer">ce（user/0）：凭据加密 (CE) 存储空间。这是默认存储位置，只有在用户解锁设备后才可用。</span></span><ul><li><span class="name"><span class="innerContentContainer">加密方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">EXT4 加密</span></span><ul><li><span class="name"><span class="innerContentContainer">FBF使用了EXT4文件系统的加密机制，配置为：</span></span><ul><li><span class="name"><span class="innerContentContainer">采用 XTS 模式的 AES-256 算法加密文件内容；</span></span></li><li><span class="name"><span class="innerContentContainer">采用 CBC-CTS 模式的 AES-256 算法加密文件名</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">de（user_de/0）：设备加密 (DE) 存储空间。在直接启动模式（direct boot）期间以及用户解锁设备后均可用。</span></span></li><li><span class="name"><span class="innerContentContainer">在开机未解锁的场景，ce目录被锁定，只能访问de目录，但是有些应用场景，例如闹钟，即使开机未解锁也需要提供服务，因此需要适配FBE。</span></span></li><li><span class="name"><span class="innerContentContainer">这种区分能够使工作资料更加安全。</span></span></li><li><span class="name"><span class="innerContentContainer">应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动FDE</span></span><ul><li><span class="name"><span class="innerContentContainer">将 fileencryption 标记添加到 userdata 分区最后一列的 fstab 行，即可。</span></span></li><li><span class="name"><span class="innerContentContainer">必须在可信执行环境 (TEE) 中实现 Keymaster/Keystore 和 Gatekeeper，以便为 DE 密钥提供保护。</span></span></li><li><span class="name"><span class="innerContentContainer">内核加密性能必须要在使用 AES XTS 时至少达到 50MB/s，以确保良好的用户体验。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">检查FDE状态</span></span><ul><li><span class="name"><span class="innerContentContainer">检查&nbsp;ro.crypto.state&nbsp;是否存在，确认&nbsp;ro.crypto.state&nbsp;是否已加密。</span></span></li><li><span class="name"><span class="innerContentContainer">检查&nbsp;ro.crypto.type&nbsp;是否存在，确认&nbsp;ro.crypto.type&nbsp;是否已设为&nbsp;file。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">android系统秘钥源 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">密钥源 = imei + bt mac + wifi mac + psn</span></span></li><li><span class="name"><span class="innerContentContainer">其中：psn即emmc的psn号。</span></span><ul><li><span class="name"><span class="innerContentContainer">该值为4字节随机数，出厂前写入，无法用软件修改。</span></span></li><li><span class="name"><span class="innerContentContainer">已确认各供应商都支持该值。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">OEMINFO</span></span><ul><li><span class="name"><span class="innerContentContainer">数据存储方式</span></span><ul><li><span class="name"><span class="innerContentContainer">数据按type分，一个type至少占据一块，可以不连续分布。</span></span></li><li><span class="name"><span class="innerContentContainer">oeminfo分区中，有数据的每块都有一个头，记录该地的type id。</span></span></li><li><span class="name"><span class="innerContentContainer">因此，可实现不连续存储。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">type</span></span><ul><li><span class="name"><span class="innerContentContainer">otp：RSA公钥A和B。</span></span></li><li><span class="name"><span class="innerContentContainer">oem_id</span></span><ul><li><span class="name"><span class="innerContentContainer">即手机的密钥源。</span></span></li><li><span class="name"><span class="innerContentContainer">目前有如下几种数据：emei、蓝牙地址、wifi地址、emmc psn号码。</span></span></li><li><span class="name"><span class="innerContentContainer">所有这些数据，用私钥B加密过，存放在oeminfo中的是密文。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock数据</span></span><ul><li><span class="name"><span class="innerContentContainer">key[5]，5组密码</span></span></li><li><span class="name"><span class="innerContentContainer">flag：使能标志</span></span></li><li><span class="name"><span class="innerContentContainer">data：plmn id list。</span></span></li><li><span class="name"><span class="innerContentContainer">这三部分数据都有不同的加密方式。</span></span></li><li><span class="name"><span class="innerContentContainer">使用AES加密，可解码成明文。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock_alterable</span></span><ul><li><span class="name"><span class="innerContentContainer">simlock数据中的可修改部分，包括：</span></span></li><li><span class="name"><span class="innerContentContainer">simlock_dck_count：规定解锁次数</span></span></li><li><span class="name"><span class="innerContentContainer">simlock_feature_inds</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">nv_backup：rfnv备份数据</span></span></li><li><span class="name"><span class="innerContentContainer">err_times：nck密码试错的次数（最多5次，5次后手机将锁定，无法搜网）</span></span></li><li><span class="name"><span class="innerContentContainer">wifi_test：wifi校准数据。</span></span></li><li><span class="name"><span class="innerContentContainer">prl_roaming_list：prl数据，CDMA用。</span></span></li><li><span class="name"><span class="innerContentContainer">Type值只能增加，不能减少。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">头结构</span></span><ul><li><span class="name"><span class="innerContentContainer">头结构占据每个block的第一个page，长度有三种：</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc和小page nand为512字节，</span></span></li><li><span class="name"><span class="innerContentContainer">2k nand为2k，</span></span></li><li><span class="name"><span class="innerContentContainer">4k nand为4k，</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">有效数据则不变，为28字节，由6个字段组成。剩余空间填0xFFFF。</span></span></li><li><span class="name"><span class="innerContentContainer">头结构包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">字段1，8字节长，为migic number，为“oem_info”的asc码值，即 0x5F4D454F 0x4F464849。</span></span></li><li><span class="name"><span class="innerContentContainer">字段2，version，目前最大为4。表示为4K nand的oeminfo。1表示小块nand，2表示emmc，3没有用。</span></span></li><li><span class="name"><span class="innerContentContainer">字段3，info_type，数据类型，即oeminfo_info_type_enum_type，目前有大约30多种。</span></span></li><li><span class="name"><span class="innerContentContainer">字段4，total_blck，本类型共占据多少block；</span></span></li><li><span class="name"><span class="innerContentContainer">字段5，curr_logical_blck，当前为第多少个block，从1开始；</span></span></li><li><span class="name"><span class="innerContentContainer">字段6，total_byte，该类型的实际大小，以byte为单位。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SimLock</span></span><ul><li><span class="name"><span class="innerContentContainer">simlock_key[5]，2组共10个密码。</span></span><ul><li><span class="name"><span class="innerContentContainer">第一组5个即 nck密码，用于simlock解锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">nck密码解锁：解密时，用户输入一个16位10进制数，经md5加密后和oeminfo中的密文对比。</span></span></li><li><span class="name"><span class="innerContentContainer">如果匹配，即simlock解锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二组，第一个为uck密码，第二个用于diag鉴权.</span></span><ul><li><span class="name"><span class="innerContentContainer">nck解锁失败：nck解锁失败10次，手机就锁定了，必须用uck来解。</span></span></li><li><span class="name"><span class="innerContentContainer">uck可以使用无限次。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">diag鉴权</span></span><ul><li><span class="name"><span class="innerContentContainer">没有鉴权的状态下，diag端口只支持3个鉴权相关的握手命令和一个升级命令。</span></span></li><li><span class="name"><span class="innerContentContainer">步骤是手机侧生成随机数，传给pc侧私钥加密，然后把密文发给手机侧，手机侧解密后和原来的随机数对比，如吻合则鉴权通过。</span></span></li><li><span class="name"><span class="innerContentContainer">pc端需要加密狗才可以。</span></span></li><li><span class="name"><span class="innerContentContainer">鉴权通过后，密码会被置换为16个0.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它三套不用。</span></span></li><li><span class="name"><span class="innerContentContainer">密码的生成方式</span></span><ul><li><span class="name"><span class="innerContentContainer">这5套密码均为imei+随机数，并经过md5加密后保存到手机上，即手机上没有保存明文。</span></span></li><li><span class="name"><span class="innerContentContainer">生产线会在数据库中保存明文，用 emei 可查询。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">flag：simlock使能标志</span></span><ul><li><span class="name"><span class="innerContentContainer">当值为imei+“disable”，并经过md5加密后的值时，将去使能simlock；</span></span></li><li><span class="name"><span class="innerContentContainer">其它值，或无值，均为使能simlock。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock_data：simlock数据</span></span><ul><li><span class="name"><span class="innerContentContainer">imei号的长度：11字节，8字节有效数据，1字节有效数据长度，2字节crc值。</span></span></li><li><span class="name"><span class="innerContentContainer">蓝牙地址：6字节蓝牙地址，和2字节crc值。</span></span></li><li><span class="name"><span class="innerContentContainer">MEID：9字节，7字节有效数据+2字节crc。&nbsp; ESN：6字节，4字节有效数据+2字节crc。</span></span></li><li><span class="name"><span class="innerContentContainer">simlock_data数据会用imei做加密。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IMSI 数据结构（关键点）</span></span><ul><li><span class="name"><span class="innerContentContainer">sim卡中的数据。IMSI共有15位，其结构为 PLMN+MSIN。</span></span></li><li><span class="name"><span class="innerContentContainer">PLMN</span></span><ul><li><span class="name"><span class="innerContentContainer">Public Land Mobile Network，公共陆地移动网络。</span></span></li><li><span class="name"><span class="innerContentContainer">另外，固定电话系统叫公用交换电话网络（PSTN）。</span></span></li><li><span class="name"><span class="innerContentContainer">PLMN=MCC+MNC。</span></span><ul><li><span class="name"><span class="innerContentContainer">MCC</span></span><ul><li><span class="name"><span class="innerContentContainer">Mobile Country Code，移动国家码，共3位十进制数字。</span></span></li><li><span class="name"><span class="innerContentContainer">中国为460。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MNC</span></span><ul><li><span class="name"><span class="innerContentContainer">Mobile Network Code，移动网络码，2-3位十进制数字。</span></span></li><li><span class="name"><span class="innerContentContainer">中国移动00和02</span></span></li><li><span class="name"><span class="innerContentContainer">中国联通01</span></span></li><li><span class="name"><span class="innerContentContainer">中国电信03。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MSIN</span></span><ul><li><span class="name"><span class="innerContentContainer">MSIN = HLR + simcode</span></span></li><li><span class="name"><span class="innerContentContainer">HLR：子网ID，2字节</span></span></li><li><span class="name"><span class="innerContentContainer">simcode：&lt;=8字节</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GID1 / GID2：sim/usim卡上的两个文件，用来标识卡用户的文件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock分5级（根据IMSI的数据结构）</span></span><ul><li><span class="name"><span class="innerContentContainer">第一级：锁PLMN。解锁码是NCK（网络码）。</span></span></li><li><span class="name"><span class="innerContentContainer">第二级；锁运营商子网HLR。解锁码：NSCK（子网码）。</span></span></li><li><span class="name"><span class="innerContentContainer">第三级：锁运营商码GID1。解锁码：SPCK（运营商码）。比较少用。</span></span></li><li><span class="name"><span class="innerContentContainer">第四级：锁社区、社群。一般不用。</span></span></li><li><span class="name"><span class="innerContentContainer">第五级：锁指定sim。即只能用指定号。一般不用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock方案</span></span><ul><li><span class="name"><span class="innerContentContainer">简而言之，就是将simlock_data与sim卡上的IMSI进行匹配，通过了才可以搜网。</span></span></li><li><span class="name"><span class="innerContentContainer">simlock数据即运营商ID list，和SIM卡的IMSI卡号匹配。</span></span></li><li><span class="name"><span class="innerContentContainer">匹配方法是：前3位为国家码MCC，后面2-3位为运营商码MNC（具体2位3位取决于MCC），两个字段都匹配上即ok。</span></span></li><li><span class="name"><span class="innerContentContainer">比如中国移动的运营商ID list包括46000，那么手机IMSI包含这个字符串的手机就只能上中国移动。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是锁HLR和NDC，即锁子网，即只能用运营商指定区域内的网络。很少用。</span></span></li><li><span class="name"><span class="innerContentContainer">子网定义由运营商自己做，一般由区域码和范围码组成。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sim卡上有pin码、puk码</span></span><ul><li><span class="name"><span class="innerContentContainer">pin码类似开机密码，用户可以开关其功能，也可以设置其pin码。</span></span></li><li><span class="name"><span class="innerContentContainer">pin码三次输错，需要用puk码解。</span></span></li><li><span class="name"><span class="innerContentContainer">puk10次输错，则sim卡自毁。</span></span></li><li><span class="name"><span class="innerContentContainer">puk码一般在购买sim卡时运营商会告知。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>