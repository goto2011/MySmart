<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">16-Memory</span><ul><li><span class="name">Linux内存管理和windows的区别</span><ul><li><span class="name">在Linux中经常发现空闲内存很少，似乎所有的内存都被系统占用了，表面感觉是内存不够用了，其实不然。这是Linux内存管理的一个优秀特性.</span></li><li><span class="name">无论物理内存有多大，Linux都将其充份利用，将一些程序调用过的硬盘数据读入内存，利用内存读写的高速特性来提高Linux系统的数据访问性能。每增加一些物理内存，Linux都能利用起来，充分发挥了硬件投资带来的好处.</span></li><li><span class="name">而Windows是只在需要内存时，才为应用程序分配内存，并不能充分利用大容量的内存空间。</span></li></ul></li><li><span class="name">Android的内存机制</span><ul><li><span class="name">我们在用安卓手机的时候不用太在意剩余内存. </span></li><li><span class="name">android上, 每开一个应用就会打开一个独立的虚拟机。其实和java的垃圾回收机制类似，系统有一个规则来回收内存。</span></li><li><span class="name">进行内存调度有个阀值，只有低于这个值系统才会按一个列表来关闭用户不需要的东西。</span></li><li><span class="name">当然这个值默认设置得很小，所以你会看到内存老在很少的数值徘徊。但事实上他并不影响速度。相反加快了下次启动应用的速度。这本来就是&nbsp;android标榜的优势之一，如果人为去关闭进程，没有太大必要。特别是使用自动关进程的软件。</span></li><li><span class="name">为什么内存少的时候运行大型程序会慢呢，原因是：在内存剩余不多时打开大型程序时会触发系统自身的调进程调度策略，这是十分消耗系统资源的操作，特别是在一个程序频繁向系统申请内存的时候。这种情况下系统并不会关闭所有打开的进程，而是选择性关闭，频繁的调度自然会拖慢系统。</span></li><li><span class="name">如果不关程序是不是会耗电? android的应用在被切换到后台时，它其实已经被暂停了,并不会消耗cpu资源只保留了运行状态。所以为什么有的程序切出去重进会到主界面。</span></li><li><span class="name">一个程序如果想要在后台处理些东西，如音乐播放，它就会开启一个服务。服务可在后台持续运行，<b>所以在后台耗电的只有带服务的应用了。</b></span></li><li><span class="name">malloc 分配的内存需要高地址释放完后再释放低地址空间, 释放是串行的, 会导致虚拟地址分支很高. 相机连拍时易发生. </span></li></ul></li><li><span class="name">Android进程种类</span><ul><li><span class="name">前台进程（foreground）</span><ul><li><span class="name">目前正在屏幕上显示的进程和一些系统进程。举例来说，Dialer，Storage，Google Search等系统进程就是前台进程；再举例来说，当你运行一个程序，如浏览器，当浏览器界面在前台显示时，浏览器属于前台进程（foreground），但一旦你按home回到主界面，浏览器就变成了后台程序（background）。</span></li><li><span class="name">我们最不希望终止的进程就是前台进程。</span></li></ul></li><li><span class="name">可见进程（visible）</span><ul><li><span class="name">可见进程是一些不再前台，但用户依然可见的进程，举个例来说：widget、输入法等，都属于visible。</span></li><li><span class="name">这部分进程虽然不在前台，但与我们的使用也密切相关，我们也不希望它们被终止.</span></li></ul></li><li><span class="name">桌面进程（home app）</span><ul><li><span class="name">即launcher，保证在多任务切换之后，可以快速返回到home界面而不需重新加载.</span></li></ul></li><li><span class="name">次要服务（secondary server）</span><ul><li><span class="name">&nbsp;目前正在运行的一些服务（主要服务，如拨号等，是不可能被进程管理终止的，故这里只谈次要服务），举例来说：谷歌企业套件，Gmail内部存储，联系人内部存储等。</span></li><li><span class="name">这部分服务虽然属于次要服务，但很一些系统功能依然息息相关，我们时常需要用到它们，所以也太希望他们被终止.</span></li></ul></li><li><span class="name">后台进程（hidden）</span><ul><li><span class="name">即是后台进程（background），就是我们通常意义上理解的启动后被切换到后台的进程，如浏览器，阅读器等。当程序显示在屏幕上时，他所运行的进程即为前台进程（foreground），一旦我们按home返回主界面（注意是按home，不是按back），程序就驻留在后台，成为后台进程（background）。</span></li><li><span class="name">后台进程的管理策略有多种：</span></li><li><span class="name">有较为积极的方式，一旦程序到达后台立即终止，这种方式会提高程序的运行速度，但无法加速程序的再次启动；</span></li><li><span class="name">也有较消极的方式，尽可能多的保留后台程序，虽然可能会影响到单个程序的运行速度，但在再次启动已启动的程序时，速度会有所提升。</span></li><li><span class="name">这里就需要用户根据自己的使用习惯找到一个平衡点.</span></li></ul></li><li><span class="name">内容供应节点（content provider）</span><ul><li><span class="name">没有程序实体，进提供内容供别的程序去用的，比如日历供应节点，邮件供应节点等。在终止进程时，这类程序应该有较高的优先权.</span></li></ul></li><li><span class="name">空进程（empty）</span><ul><li><span class="name">没有任何东西在内运行的进程，有些程序，比如BTE，在程序退出后，依然会在进程中驻留一个空进程，这个进程里没有任何数据在运行，作用往往是提高该程序下次的启动速度或者记录程序的一些历史信息。</span></li><li><span class="name">这部分进程无疑是应该最先终止的。</span></li></ul></li></ul></li><li><span class="name">Android程序内存被分为2部分：native和dalvik.</span><ul><li><span class="name">dalvik就是我们平常说的java堆，我们创建的对象是在这里面分配的.</span></li><li><span class="name">而bitmap是直接在native上分配的.</span></li><li><span class="name">对于内存的限制是 native+dalvik 不能超过最大限制; android程序一般限制在16M，也有24M的。</span></li></ul></li><li><span class="name">Swap分区管理</span><ul><li><span class="name">为了缓解物理内存不足的问题, 在磁盘上开辟一块空间虚拟为一块内存区, 这个叫swap分区. Windows和 Linux上都用. </span></li><li><span class="name">当物理内存不足时, 内核会将暂时不用的内存块写到swap分区, 然后释放该内存块. 当需要使用之前的内存块时, 这些信息会被重新交换到物理内存中.</span></li><li><span class="name">内核根据"最近最常使用"的调度算法, 仅将最久不使用的页交换到swap空间.</span></li><li><span class="name">Linux系统会不时进行页交换, 即使物理内存够用, 目的是提高内存页交换性能. 经常出现的一种现象是, 物理内存还有很多, 但是交换空间也用了很多, 这是正常的. </span></li><li><span class="name">Android系统上, 由于外存使用的FLASH/EMMC, 其读写次数远小于PC上用的磁盘, 所以不能把外存做swap空间. </span></li><li><span class="name">Android系统的办法是把一部分内存作为swap分区. 页交换是在两个内存区之间发生. </span></li><li><span class="name">对于存放在swap中的内存页, 会先压缩再交换(否则就没有意义). 回写时要解压缩再交换到物理内存. 交换区叫 zram.</span></li><li><span class="name">查询 swap 的命令</span><ul><li><span class="name">cat /proc/sys/vm/swappiness, 返回:</span><ul><li><span class="name">0: 最大限度使用物理内存;</span></li><li><span class="name">60: Linux默认值</span></li><li><span class="name">100: 积极使用swap分区.</span></li></ul></li><li><span class="name">cat /proc/sys/wm/drop_caches, 是否自动释放swap. 返回:</span><ul><li><span class="name">0: 不释放</span></li><li><span class="name">1: 释放页缓存</span></li><li><span class="name">2: 释放dentries 和 inodes</span></li><li><span class="name">3: 释放所有缓存</span></li></ul></li></ul></li><li><span class="name">关闭 swap</span><ul><li><span class="name">echo 0 &gt; /proc/sys/vm/swappiness</span></li><li><span class="name">echo 0 &gt; /proc/sys/vm/direct_swappiness</span></li><li><span class="name">还有一种方法:</span><ul><li><span class="name">adb shell sysctl -w vm.swappiness=0</span></li></ul></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">标准Linux的OOM Killer机制</span><ul><li><span class="name">在mm/oom_kill.c中实现，且会被__alloc_pages_may_oom调用(在分配内存时，即mm/page_alloc.c中)。</span></li><li><span class="name">核心函数是out_of_memory，它选择一个bad进程Kill，Kill的方法同样是通过发送SIGKILL信号。</span></li><li><span class="name">在out_of_memory中通过调用select_bad_process来选择一个进程Kill，选择的依据在badness函数中实现，基于多个标准来给每个进程评分，评分最高的被选中并Kill。</span></li><li><span class="name">一般而言，占用内存越多，oom_adj就越大，也就越有可能被选中。</span></li></ul></li><li><span class="name">Android LMK (Low Memory Killer)</span><ul><li><span class="name">执行条件</span><ul><li><span class="name">剩余内存小于应用定义的APP_MEM值，开始查看adj值列表，kill相应程序。</span></li></ul></li><li><span class="name">实现机制</span><ul><li><span class="name">Low Memory Killer的源代码在kernel/drivers/staging/android/lowmemorykiller.c中.</span></li><li><span class="name">发现优先级底的进程, 就发送SIGKILL信息，杀掉该进程。</span></li></ul></li><li><span class="name">在init.rc中，init进程的pid为1，omm_adj被配置为-16，永远不会被杀死。</span></li><li><span class="name">进程omm_adj的大小跟进程的类型以及进程被调度的次序有关。</span></li><li><span class="name">ActivityManagerService定义各种进程的oom_adj. 其中: </span><ul><li><span class="name">static final int CORE_SERVER_ADJ = -12;   // 表一些核心的服务的omm_adj, 这类进程永远也不会被杀死。</span></li><li><span class="name">static final int SYSTEM_ADJ = -16;</span></li></ul></li></ul></li><li><span class="name">一般情况下, 发生OOM 都是在做一些跟图片相关的操作. 优化方法有: </span><ul><li><span class="name">1. decode bitmap 的时候，尽量配置下Options，例如：inSameSize</span></li><li><span class="name">2. Bitmap使用完以后，调用 bitmap.recycle()来释放内存</span></li><li><span class="name">3.如果应用是基于图片的应用，尽量采用LazyLoad和DymanicRecycle</span></li><li><span class="name">4. decode bitmap 的时候，将decode代码 try catch 出来，catch oom error，避免程序crash，可以在catch里面做一些释放内存操作</span></li></ul></li><li><span class="name">定位应用内存泄露</span><ul><li><span class="name"><b>反复抓取 dumpsys meminfo</b> 输出, 看 Total 是否一直增大, 如果是, 肯定是内存泄漏.</span></li><li><span class="name">Activities泄漏: </span><ul><li><span class="name">查看 <b>meminfo</b> 输出中的Activities. 如果有异常, 比如camera应用是单activity应用, 如果这个值大于2, 一般就是activity泄露. </span></li><li><span class="name">activity泄露的原因是有长周期的对象持有了指定的 activity的 context. </span></li></ul></li><li><span class="name">其它内存泄漏问题, 就需要hprof 文件了. 方法如下:</span><ul><li><span class="name">1. 抓 hprof 文件: 手机要 remount. 然后使用:adb shell am dumpheap com.oppo.camera /data/1.hprof</span></li><li><span class="name">2. 如果用 MAT 分析 hprof文件, 则需要把文件转换下:</span><ul><li><span class="name">进入进入&nbsp;android-sdk-windows\tools目录,  hprof_conv 1.hprof 1-1.hprof</span></li></ul></li><li><span class="name">3. eclipse上安装MAT: help - install new software - Search "MAT"</span></li><li><span class="name">4. 打开MAT：在Eclipse中点击 Windows-&gt;Open Perspective-&gt;Other-&gt;Memory Analysis</span></li><li><span class="name">5. 导入.hprof文件: 在MAT中点击&nbsp;File-&gt;Open File打开刚刚转换而得到的yyyyy.hprof文件，并Cancel掉自动生成报告,点击Dominator Tree，并按Package分组，选择自己所定义的Package类点右键，在弹出菜单中选择List objects-&gt;With incoming references。</span></li><li><span class="name">6. 分析报告: 这时会列出所有可疑类，右键点击某一项，并选择Path to GC Roots-&gt;exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。</span></li></ul></li></ul></li><li><span class="name"><b>meminfo</b> 数据含义  ***</span><ul><li><span class="name">查看内存占用情况: adb shell dumpsys meminfo com.oppo.camera -d</span></li><li><span class="name">列字段:</span><ul><li><span class="name">Pss total: Proportional set size是内核的度量，包括共享内存。</span><ul><li><span class="name">私有内存页按100%计算. 共享内存则按比例计算.</span></li><li><span class="name">系统会将共享内存的总大小除以参与共享的进程数。例如，一个在两个进程间共享的内存页, 每个进程更占一半。</span></li><li><span class="name">按照这种方式, 就可以将所有进程的Pss数据相加得到总共的RAM消耗。</span></li><li><span class="name">在进程间比较Pss也能够大致比较两者权重。</span></li></ul></li><li><span class="name">Private Dirty: 最有意思和最昂贵的度量应该是Private Dirty，这部分代表着进程内不能用磁盘上的数据备份，所以不能被分页到硬盘，也不能和其他的进程共享的内存。另一个角度理解，就是这部分的消耗内存只有当应用被销毁的时候才会被系统回收。</span></li><li><span class="name">Private  Clean: Android会在几个进程（例如公共框架）之间共享内存页。只要一个页内的内存改变，系统必须要写入而且将内存块标记为脏。然而，clean memory代表当从磁盘载入的时候还没有改变的内存。只有发生改变，内存标记成脏内存。</span></li><li><span class="name">Swapped Dirty:  交换空间.</span><ul><li><span class="name">Android设备使用FLASH做磁盘, FLASH不支持交换区机制，所以Android上的Swap 空间也是放到RAM中.</span></li><li><span class="name">Swapped Dirty只有当应用退出的时候才会被释放。</span></li><li><span class="name">Android使用 ZRAM 压缩内存页，先压缩再放入Swap 空间，需要的时候先解压再交换回去。</span></li></ul></li><li><span class="name">Heap size:  size是需要的内存</span></li><li><span class="name">Heap Alloc:  allocated是分配了的内存.</span></li><li><span class="name">Heap Free:  free 是未使用的内存.</span></li></ul></li><li><span class="name">行字段:</span><ul><li><span class="name"><b>Native </b>Heap: 原生堆. 进程自身使用的内存，C\C++代码. 从mallinfo usmblks获得，代表最大总共分配空间. 例如Unity Engine Code， Native C malloc， 和 Mono VM。其中:</span><ul><li><span class="name">Size = Alloc + Free</span></li><li><span class="name">Alloc: 从mallinfo uorblks获得，总共分配空间</span></li><li><span class="name">Free: 从mallinfo fordblks获得，代表总共剩余空间</span></li></ul></li><li><span class="name"><b>Dalvik </b>Heap : 代表Dalvik虚拟机分配的内存.  Java代码. 从Runtime totalMemory()获得，Dalvik Heap总共的内存大小。其中: </span><ul><li><span class="name">Size = Alloc + Free</span></li><li><span class="name">Alloc: Runtime totalMemory()-freeMemory() ，Dalvik Heap分配的内存大小。</span></li><li><span class="name">Free:从Runtime freeMemory()获得，Dalvik Heap剩余的内存大小。</span></li></ul></li><li><span class="name">Dalvik Other：类数据结构和索引占据内存</span></li><li><span class="name">Stack：栈内存</span></li><li><span class="name">Ashmem：不以dalvik- 开头的内存区域，匿名共享内存用来提供共享内存通过分配一个多个进程可以共享的带名称的内存块。匿名共享内存（Anonymous Shared Memory-Ashmem。Android匿名共享内存是基于Linux共享内存的，都是在tmpfs文件系统上新建文件，并将其映射到不同的进程空间，从而达到共享内存的目的，只是，Android在Linux的基础上进行了改造，并借助Binder+fd文件描述符实现了共享内存的传递。</span></li><li><span class="name">Other dev：内部driver占用的内存</span></li><li><span class="name">.so mmap: C库代码占用的内存</span></li><li><span class="name">.jar mmap: java文件代码占用的内存</span></li><li><span class="name">.apk mmap: apk代码占用的内存</span></li><li><span class="name">.ttf mmap: ttf文件代码占用的内存</span></li><li><span class="name">.dex mmap: dex文件代码占用内存。类函数的代码和常量占用的内存，dex mmap是映射classex.dex文件，Dalvik虚拟机从dex文件加载类信息和字符串常量等。Dex文件有索引区和Data区</span></li><li><span class="name">Other mmap: 其它文件占用的内存</span></li><li><span class="name">EGL mtrack: 这个部分是gralloc的内存使用。主要是SurfaceView和TextureView的总和。它也包括了帧缓冲区，因此大小也会取决于framebuffers的尺寸。支持的屏幕分辨率越高，EGL mtrack的数目越高。在这个测试中，帧缓冲区的分辨率被降低了来确保比较好的性能。降低帧缓存的大小也会降低这些缓存需要的内存量。</span></li><li><span class="name">GL mtrack &amp; Gfx dev: GL和Gfx是驱动反馈的GPU内存，主要是GL纹理大小的总和，GL命令缓冲区，固定的全局驱动RAM消耗以及Shader。需要指出，这些不会出现在旧的Android版本上。注意：客户空间驱动和内核空间驱动共享同一个内存空间。在某些Android版本上，这个部分会被重复计算两次，因此Gfx dev要比实际上使用的数值更大。</span></li><li><span class="name">Unknown: Unknown值得是系统不能确定分页属于上面的那种。这个部分包括原生分配或者运行时metadata，因为Adress Space Layout Randomization，这个工具没办法确定内存。Private Dirty是只用于自己应用的未知RAM。</span></li><li><span class="name">Objects and SQL 信息都是从Android Debug信息中获得。</span></li><li><span class="name">Total: 总计. 当 total 超过单个程序内存的最大限制时，OOM就可能出现。</span></li></ul></li><li><span class="name">还有一些统计数据:</span><ul><li><span class="name">Objects</span></li><li><span class="name">Views:&nbsp; &nbsp; &nbsp; &nbsp;90&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ViewRootImpl:&nbsp; &nbsp; &nbsp; &nbsp; 1</span></li><li><span class="name">AppContexts:&nbsp; &nbsp; &nbsp; &nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>Activities</b>:&nbsp; &nbsp; &nbsp; &nbsp; 1</span></li><li><span class="name">Assets:&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; AssetManagers:&nbsp; &nbsp; &nbsp; &nbsp; 2</span></li><li><span class="name">Local Binders:&nbsp; &nbsp; &nbsp; &nbsp;21&nbsp; &nbsp; &nbsp; &nbsp; Proxy Binders:&nbsp; &nbsp; &nbsp; &nbsp;28</span></li><li><span class="name">Parcel memory:&nbsp; &nbsp; &nbsp; &nbsp;18&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Parcel count:&nbsp; &nbsp; &nbsp; &nbsp;74</span></li><li><span class="name">Death Recipients:&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; &nbsp; OpenSSL Sockets:&nbsp; &nbsp; &nbsp; &nbsp; 2</span></li></ul></li></ul></li><li><span class="name"><b>procrank </b>数据含义</span><ul><li><span class="name">adb shell procrank，这个工具可以查看所有进程使用的内存量，从高到低列出每个进程使用的内存使用量。不是每个手机都有. </span><ul><li><span class="name">每个进程列出Vss，Rss，Pss，和Uss 这4个数据。</span></li></ul></li><li><span class="name">Vss - Virtual Set Size, 一个进程总共可以获取的寻址空间。这个指标表明一个进程关联的虚拟内存空间。</span></li><li><span class="name">Rss - Resident Set Size, 一个进程分配到的物理内存页。被多个进程共享的内存页被计算多次。</span></li><li><span class="name">Pss - Proportional Set Size, 和Rss类似，只不过将共享的内存页处理共享的进程数来计算。</span></li><li><span class="name">Uss - Unique Set Size, = Private Dirty的概念，表明进程内不能被分页到硬盘的数据，不能被其他进程共享的内存部分。</span></li></ul></li><li><span class="name"><b>Android Malloc Debug: native代码内存调试工具</b></span><ul><li><span class="name">工具代码在: bionic/libc/bionic/malloc_debug_common.c/h/cpp. 下面说实操.</span></li><li><span class="name">准备一个userdebug或eng版本手机，尽量选择32bit机器，64bit设备会非常卡.</span></li><li><span class="name"><b>下述命令, 请在使用前后关开java虚拟机.</b></span></li><li><span class="name">打开系统的malloc debug</span><ul><li><span class="name">adb shell setprop libc.debug.malloc &lt;配置项&gt;. 配置项有:</span></li><li><span class="name">0: 这是默认的等级，仅作最基本的判断</span></li><li><span class="name">1: 在malloc记录调用栈, 检测内存泄漏</span></li><li><span class="name">5: 分配的内存用0xeb填充，释放的内存用0xef填充, 可检测内存的overruns</span></li><li><span class="name">10: 内存分配打 pre-和 post- 的桩子，记录调用栈, 也可检测内存的overruns</span></li><li><span class="name">20: SDK模拟器上检测内存用</span></li></ul></li><li><span class="name">打开指定app的malloc debug, 有两种方式:</span><ul><li><span class="name">一种是: setprop wrap.com.oppo.camera "LIBC_DEBUG_MALLOC_OPTIONS=baketrace"</span></li><li><span class="name">另外一种是: setprop libc.debug.malloc.program "com.oppo.camera"</span></li></ul></li><li><span class="name">定位方法1: adb logcat | findstr "malloc_debug"</span></li><li><span class="name">定位方法2: 通过ddms来看内存泄漏. </span><ul><li><span class="name">先要配置ddms: 在~\.android\&nbsp;ddms.cfg&nbsp;文件后面添加native=true, 然后打开ddms, 就可以看到Native Heap了.</span></li><li><span class="name">在启动ddms前, 需要把 arm-linux-androideabi-addr2linux 所在的路径加到PATH环境变量中.</span></li><li><span class="name">点击 snapshot current native heap usageke, 根据提示在 symbol search path里输入相应库的符号表路径就行了.</span></li><li><span class="name">找到泄漏后，根据提示的backtrace地址，可以用NDK中的 arm-linux-androideabi-addr2line 工具算出对应的函数地址，也可以排列成用 tombstone 的格式，用 stacktrace 工具求出函数调用关系。</span></li></ul></li></ul></li><li><span class="name">如果对GC有疑问, 在类中重写 finalize() 方法会非常有用.</span><ul><li><span class="name">@ override</span></li><li><span class="name">public void finalize() throws Throwable {</span><ul><li><span class="name">try {</span><ul><li><span class="name">Log.e(Tag, "finalize(): " + this);</span></li></ul></li><li><span class="name">} finally {</span><ul><li><span class="name">super.finalize();</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li></ul>
  </body>
</html>