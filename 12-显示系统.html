<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>12-显示系统</b></span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕物理结构（一般是三层）</span></span><ul><li><span class="name"><span class="innerContentContainer">最外面是玻璃</span></span><ul><li><span class="name"><span class="innerContentContainer">康宁Gorilla玻璃</span></span><ul><li><span class="name"><span class="innerContentContainer">俗称大猩猩，比塑料硬30倍，比塑料韧性好20倍，防刮耐磨。</span></span></li><li><span class="name"><span class="innerContentContainer">硬度在6.5-7之间。也就是说</span></span></li><li><span class="name"><span class="innerContentContainer">高端智能机基本都用了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">中间是TP</span></span><ul><li><span class="name"><span class="innerContentContainer">in-cell技术，即tp模组玻璃和前面板玻璃融为一体，也叫单玻璃（OGS）技术。</span></span><ul><li><span class="name"><span class="innerContentContainer">只有三家厂商有这个技术：LG Display、夏普以及Japan Display Inc。</span></span></li><li><span class="name"><span class="innerContentContainer">其产能基本被苹果垄断。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电阻屏</span></span><ul><li><span class="name"><span class="innerContentContainer">三层膜都是透明的。</span></span></li><li><span class="name"><span class="innerContentContainer">利用压力感应来控制。</span></span></li><li><span class="name"><span class="innerContentContainer">原理很简单，两层导电膜之间隔一层电阻膜，后者布满了小孔（孔径小于1/1000英寸）。</span></span></li><li><span class="name"><span class="innerContentContainer">如果手指按下，两层导电膜会导通，通电位置不同电阻不同，于是就可以算出坐标。</span></span></li><li><span class="name"><span class="innerContentContainer">常用的电阻屏是四线电阻屏，每层导电膜各有两个线，一个竖直方向，一个水平方向，加5v恒定电压。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电容屏</span></span><ul><li><span class="name"><span class="innerContentContainer">当手指触摸时，人体的静电流入产生微弱的电流，电流会引起电压的变化，根据电压变化可计算触点的位置。</span></span></li><li><span class="name"><span class="innerContentContainer">电容屏把人体作为一个电极使用。</span></span></li><li><span class="name"><span class="innerContentContainer">当人体没接触屏时，面板各处电压都相同，没有电流通过。</span></span></li><li><span class="name"><span class="innerContentContainer">电容屏的优势</span></span><ul><li><span class="name"><span class="innerContentContainer">电容屏中，压力值无效。</span></span></li><li><span class="name"><span class="innerContentContainer">方便，用手指即可；</span></span></li><li><span class="name"><span class="innerContentContainer">操作流畅；</span></span></li><li><span class="name"><span class="innerContentContainer">屏的透光性好。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">最里面是屏幕. 主要有LCD和 OLED 两种：</span></span></li><li><span class="name"><span class="innerContentContainer">LCD (Liquid Crystal Display)，即液晶显示器。包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">TFT</span></span><ul><li><span class="name"><span class="innerContentContainer">TFT(Thin Film Transistor) 即薄膜场效应晶体管，它可以“主动地”对屏幕上的各个独立的像素进行控制，这样可以大大提高反应时间。</span></span></li><li><span class="name"><span class="innerContentContainer">一般TFT的反应时间比较快，约80毫秒。</span></span></li><li><span class="name"><span class="innerContentContainer">而且可视角度大，一般可达到130度左右。</span></span></li><li><span class="name"><span class="innerContentContainer">成本低廉。</span></span></li><li><span class="name"><span class="innerContentContainer">基于TFT屏幕的改进面板技术包括：IPS、ASV、NOVA</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IPS</span></span><ul><li><span class="name"><span class="innerContentContainer">IPS是一种基于TFT屏幕的改进面板技术。</span></span></li><li><span class="name"><span class="innerContentContainer">这种LCD已经存在有一段时间了，但在苹果平板电脑之前一直没有大规模使用。</span></span></li><li><span class="name"><span class="innerContentContainer">IPS能提供更广阔的视角，更好的色彩还原。</span></span></li><li><span class="name"><span class="innerContentContainer">IPS仍然属于LCD范畴，最大生产商是LG。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SLCD</span></span><ul><li><span class="name"><span class="innerContentContainer">SLCD，全名Super clear LCD，是由三星研制。</span></span></li><li><span class="name"><span class="innerContentContainer">其拥有Super AMOLED的艳丽对比度，色彩更暖，更自然，适合人眼观看，屏幕清晰。</span></span></li><li><span class="name"><span class="innerContentContainer">SLCD是一种液晶屏幕，不是自发光的。可看成TFT的一个超级版。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">OLED (Organic Light-Emitting Diode)，即有机发光二极管。</span></span><ul><li><span class="name"><span class="innerContentContainer">三星引以为傲AMOLED系列屏幕属于OLED，被称誉为“梦幻显示器”。</span></span></li><li><span class="name"><span class="innerContentContainer">OLED显示技术与传统的LCD显示方式不同，无需背光灯。</span></span></li><li><span class="name"><span class="innerContentContainer">它采用非常薄的有机材料涂层和玻璃基板。当电流通过时，有机材料就会发光。</span></span></li><li><span class="name"><span class="innerContentContainer">在显示黑色时，相应的像素点无需发光，可以减少电量消耗，提升手机续航. </span></span></li><li><span class="name"><span class="innerContentContainer">而且OLED屏幕可以做得更轻更薄，可视角度更大，并能显著的节省耗电。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">摩氏矿物硬度表</span></span><ul><li><span class="name"><span class="innerContentContainer">硬度可以分为10个等级：</span></span><ul><li><span class="name"><span class="innerContentContainer">1 滑石</span></span></li><li><span class="name"><span class="innerContentContainer">2 石膏</span></span></li><li><span class="name"><span class="innerContentContainer">3 方解石</span></span></li><li><span class="name"><span class="innerContentContainer">4 萤石</span></span></li><li><span class="name"><span class="innerContentContainer">5 磷灰石</span></span></li><li><span class="name"><span class="innerContentContainer">6 正长石</span></span></li><li><span class="name"><span class="innerContentContainer">7 石英</span></span></li><li><span class="name"><span class="innerContentContainer">8 黄玉</span></span></li><li><span class="name"><span class="innerContentContainer">9 刚玉</span></span></li><li><span class="name"><span class="innerContentContainer">10 金刚石</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬度高的可以刮花硬度低的。</span></span></li><li><span class="name"><span class="innerContentContainer">普通玻璃的硬度是6-7左右，而钢的硬度仅为5，所以即使是普通的玻璃，用刀也是刮不花的。</span></span></li><li><span class="name"><span class="innerContentContainer">真正刮花手机屏幕的是沙子，沙子里包含了石英，摩氏硬度为7.5左右。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LCD连接方式：RGB</span></span><ul><li><span class="name"><span class="innerContentContainer">数据位传输有6位，16位，18位，24位之分。</span></span></li><li><span class="name"><span class="innerContentContainer">连线有：</span></span><ul><li><span class="name"><span class="innerContentContainer">VSYNC</span></span></li><li><span class="name"><span class="innerContentContainer">HSYNC</span></span></li><li><span class="name"><span class="innerContentContainer">DOTCLK</span></span></li><li><span class="name"><span class="innerContentContainer">CS</span></span></li><li><span class="name"><span class="innerContentContainer">RESET，有的也需要RS</span></span></li><li><span class="name"><span class="innerContentContainer">剩下都是数据线</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">它的优缺点:</span></span><ul><li><span class="name"><span class="innerContentContainer">不耗费GRAM. 可以支持大屏.</span></span></li><li><span class="name"><span class="innerContentContainer">控制复杂.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">LCD常见问题  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">包括白屏、黑屏、花屏、冻屏。</span></span></li><li><span class="name"><span class="innerContentContainer">LCD初始化流程, 包括寄存器和sleep wakeup的配置，以及配置EBI2总线的LCD控制器，这个时序经常出问题。</span></span></li><li><span class="name"><span class="innerContentContainer">花屏的原因: </span></span></li><li><span class="name"><span class="innerContentContainer">MDP和ARM同时控制显示。ARM控制显示一般是为了调节亮度等的时候。此时就需要保护机制。</span></span></li><li><span class="name"><span class="innerContentContainer">MDP刷屏对时序要求很严格。发现花屏时，可通过LCD_CFG0寄存器来调节时序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TP代码</span></span><ul><li><span class="name"><span class="innerContentContainer">核心态代码</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/input/eventdev.c: 事件处理</span></span></li><li><span class="name"><span class="innerContentContainer">atml_imc.c: 驱动代码</span></span></li><li><span class="name"><span class="innerContentContainer">input.c: input子系统，包括电阻屏、电容屏、键盘、鼠标、游戏杆等设备都算input设备</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用户态代码：hal层</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化过程</span></span><ul><li><span class="name"><span class="innerContentContainer">register</span></span></li><li><span class="name"><span class="innerContentContainer">Probe</span></span></li><li><span class="name"><span class="innerContentContainer"> I2C check -&gt; 取X轴、Y轴，Max_x,Max_y </span></span></li><li><span class="name"><span class="innerContentContainer">read_PDT(寄存器种event的buffer地址) </span></span></li><li><span class="name"><span class="innerContentContainer">固件更新，/sys</span></span></li><li><span class="name"><span class="innerContentContainer">proc，数据处理</span></span></li><li><span class="name"><span class="innerContentContainer">创建工作队列线程</span></span></li><li><span class="name"><span class="innerContentContainer">创建工作队列</span></span></li><li><span class="name"><span class="innerContentContainer">配置中断，低电平触发</span></span></li><li><span class="name"><span class="innerContentContainer">申请中断；如果非中断，则启动timer</span></span></li><li><span class="name"><span class="innerContentContainer">注册 early syspend / resume 函数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据处理</span></span><ul><li><span class="name"><span class="innerContentContainer">input子系统中，在中断或timer触发下，读取event_table[]，数组下标即设备号，获取当前evnet；</span></span></li><li><span class="name"><span class="innerContentContainer">通过主设备号，获取input-&gt;fops（event处理函数）处理该event。</span></span></li><li><span class="name"><span class="innerContentContainer">处理逻辑就是上报键值和坐标。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">键值上报</span></span><ul><li><span class="name"><span class="innerContentContainer">hal层device_poll()读取 /dev/input/event_x，x即设备号，然后上报给framework层。</span></span></li><li><span class="name"><span class="innerContentContainer">数据结构即 sensor_event_t，包括type、handle、value（union类似，可适配多种input设备）。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">分辨率相关概念  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">坐标原点:</span></span><ul><li><span class="name"><span class="innerContentContainer">Android 定义屏幕的左上角为坐标原点(0, 0), 向右为x轴, 向下为y轴, 向上为z轴. 都是正数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dp(dip):&nbsp;device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。</span></span></li><li><span class="name"><span class="innerContentContainer">px: pixels(像素). 不同设备显示效果相同.</span></span></li><li><span class="name"><span class="innerContentContainer">pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业.</span></span></li><li><span class="name"><span class="innerContentContainer">sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。size和dp相同.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">刷新率相关概念  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">FPS: 每秒刷新帧数, frames per second. 即屏幕刷新率，也叫帧率。</span></span><ul><li><span class="name"><span class="innerContentContainer">单位是Hz, 赫兹. </span></span></li><li><span class="name"><span class="innerContentContainer">通常, 要避免动作不流畅的最低FPS是 30. 最佳体验是 60或以上.</span></span></li><li><span class="name"><span class="innerContentContainer">人有视觉暂停的特性，对于连续远动的静态图片，当超过16帧/秒时，就感觉到运动是连贯的。</span></span></li><li><span class="name"><span class="innerContentContainer">这是视频、动画的原理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一般场合下合理的帧率</span></span><ul><li><span class="name"><span class="innerContentContainer">电影 24Hz</span></span></li><li><span class="name"><span class="innerContentContainer">电视 25Hz</span></span></li><li><span class="name"><span class="innerContentContainer">电视(NTSL)  29.9Hz</span></span></li><li><span class="name"><span class="innerContentContainer">CRT显示  75Hz</span></span></li><li><span class="name"><span class="innerContentContainer">液晶显示  60Hz</span></span></li><li><span class="name"><span class="innerContentContainer">游戏中</span></span><ul><li><span class="name"><span class="innerContentContainer">超过75帧无感觉。</span></span></li><li><span class="name"><span class="innerContentContainer">帧率（FPS）&lt;30，游戏性就下降。</span></span></li><li><span class="name"><span class="innerContentContainer">30以上，则可以接受。</span></span></li><li><span class="name"><span class="innerContentContainer">如果升至60帧则交互性和逼真感大大加强.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>流量 = 分辨率 * 刷新率</b></span></span><ul><li><span class="name"><span class="innerContentContainer">比特率: 是指每秒传递的比特数(bit), 单位为 bps.</span></span></li><li><span class="name"><span class="innerContentContainer">码流: data rate, 指视频文件在单位时间内使用的数据流量, 也叫码率.  码流的单位 KB/s, 等于 比特率 / 8.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>图像处理能力 = 分辨率 * 刷新率</b></span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">Android颜色值</span></span><ul><li><span class="name"><span class="innerContentContainer">16位整数。</span></span></li><li><span class="name"><span class="innerContentContainer">一般写成16进制数形式。</span></span></li><li><span class="name"><span class="innerContentContainer">前2位为透明度(alpha)。00表示全透明(即隐藏了)，FF表示全不透明。7F表示半透。</span></span></li><li><span class="name"><span class="innerContentContainer">后6位为颜色值。000000表示白色，FFFFFF 表示黑色。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>60帧, 丢帧, 跳帧   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">UI渲染是指从App生成帧并显示在屏幕上的行为。</span></span></li><li><span class="name"><span class="innerContentContainer">60 fps是手机app性能的衡量标准, 这个标准的来历是: 人眼与大脑之前的协作无法感知超过60 FPS的画面, 所以超过60 FPS 没有意义.</span></span></li><li><span class="name"><span class="innerContentContainer">对于60 fps, 1帧即 1000 / 60 = 16ms. </span></span></li><li><span class="name"><span class="innerContentContainer">Android系统每隔16ms, 会发一次 VSync 信息来通知重绘界面. </span></span></li><li><span class="name"><span class="innerContentContainer">当一个操作超过 16 ms, 系统在得到 VSync 信息时就无法进行绘制, 只能重新刷之前一帧. 这种情况叫丢帧.</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种情况叫跳帧. 即在一次VSync周期内, 应用产生了超过1帧的数据.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UI渲染的流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的 EventThread 唤醒了应用程序UI线程，表明现在是渲染新帧的时候了。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序使用CPU和GPU资源在UI线程，RenderThread 和 hwuiTasks 中渲染帧。这部分占UI的大部分。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序通过binder将绘制好的帧发送到SurfaceFlinger并进入睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的第二个EventThread 负责唤醒SurfaceFlinger来触发组合和显示输出。</span></span></li><li><span class="name"><span class="innerContentContainer">如果SurfaceFlinger确定没有任何工作要完成，它将返回睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过HWC / HWC2或GL处理组合。 HWC / HWC2组合更快，更低的功耗，但会受到SOC的限制。这一步通常需要4-6ms，但是可以与步骤2重叠，因为Android应用程序总是三重缓冲。 （虽然应用程序总是三重缓冲，但在SurfaceFlinger中只能有一个待处理帧，因此和双重缓存差不多。）</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过驱动程序调度最终输出，并返回睡眠状态，等待EventThread唤醒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">帧率和刷新频率不一致问题</span></span><ul><li><span class="name"><span class="innerContentContainer">Refresh Rate: 屏幕在1秒内刷新屏幕的次数, 这取决于硬件的固定参数, 比如 60Hz.</span></span></li><li><span class="name"><span class="innerContentContainer">Frame Rate: 代表GPU在1秒内绘制操作的帧数, 比如30 FPS.</span></span></li><li><span class="name"><span class="innerContentContainer">GPU 获取图形数据进行渲染, 然后硬件负责把渲染的内容呈现到屏幕上, 他们两者不停的进行协作.</span></span></li><li><span class="name"><span class="innerContentContainer">如果发生帧率和刷新频率不一致的情况, 就会出现Tearing 现象, 画面上下两部分显示内容断裂, 来自不同的两帧数据发生重叠. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">双缓冲机制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">多数系统都会使用双缓冲机制. 即一个buffer用于显示当前帧, 另一个buffer 用于缓存下一帧的数据. 其过程是:</span></span></li><li><span class="name"><span class="innerContentContainer">1. 屏幕显示缓冲A中的第0帧; </span></span></li><li><span class="name"><span class="innerContentContainer">2. CPU和GPU在缓冲B中构建第1帧; 构建好后, 并不会马上绘制, 而是必须等待系统的VSync信号.</span></span></li><li><span class="name"><span class="innerContentContainer">3. 系统发出VSync信号, 屏幕向缓冲B请求第1帧的数据, 如成功, 则绘制它;</span></span></li><li><span class="name"><span class="innerContentContainer">4. 此时, 缓冲A中的数据被清除, CPU和GPU开始构建第2帧.</span></span></li><li><span class="name"><span class="innerContentContainer">在第三步, 如果此时缓冲B的第1帧数据没有准备好, 屏幕只好继续显示缓冲A中的第0帧, 这种情况就叫丢帧, 也叫"Jank".</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">三缓冲机制</span></span><ul><li><span class="name"><span class="innerContentContainer">在缓冲A在显示中, 缓冲B数据已经准备好时, 此时时间会被浪费掉. </span></span></li><li><span class="name"><span class="innerContentContainer">可以再加一个缓冲C, 来准备下一帧数据. 这就是三缓冲机制.</span></span></li><li><span class="name"><span class="innerContentContainer">三缓冲不能根本上解决卡顿问题, 但是会缓解.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动画  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">逐帧动画</span></span><ul><li><span class="name"><span class="innerContentContainer">逐帧动画的原理就是让一系列的静态图片依次播放，利用人眼“视觉暂留”的原理，实现动画。</span></span></li><li><span class="name"><span class="innerContentContainer">逐帧动画通常是采用 XML 资源进行定义的，需要在 &lt;animation-list .../&gt; 标签下使用 &lt;item .../&gt; 子元素标签定义动画的全部帧，并指定各帧的持续时间。</span></span></li><li><span class="name"><span class="innerContentContainer">定义帧动画的方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">// res/drawable/frame_animation.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true|false"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;item android:drawable="@drawable/frame01" android:duration="100"/&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item android:drawable="@drawable/frame02" android:duration="100"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/animation-list&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">android:oneshot 控制该动画是否循环播放。如果为true，动画将不会循环播放， 否则该动画将会循环播放.</span></span></li><li><span class="name"><span class="innerContentContainer">android:drawable 为图片资源. 一般会有多张.</span></span></li><li><span class="name"><span class="innerContentContainer">android:duration 为持续时间, 单位为毫秒.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">使用该帧动画的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">在layout 中将 AnimationDrawable 对象直接作为背景.</span></span><ul><li><span class="name"><span class="innerContentContainer">// res/layout/activity_frame_animation.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;ImageView</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>android:background</b>="@drawable/frame_animation"</span></span></li><li><span class="name"><span class="innerContentContainer">/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity 中控制播放与停止</span></span><ul><li><span class="name"><span class="innerContentContainer">public class FrameAnimation extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView frame_image;</span></span></li><li><span class="name"><span class="innerContentContainer">AnimationDrawable animationDrawable;</span></span></li><li><span class="name"><span class="innerContentContainer">@ Override</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(@ Nullable Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_frame_animation);</span></span></li><li><span class="name"><span class="innerContentContainer">frame_image = findViewById(R.id.frame_image);</span></span></li><li><span class="name"><span class="innerContentContainer">// 获取 AnimationDrawable 对象</span></span><ul><li><span class="name"><span class="innerContentContainer">animationDrawable = (AnimationDrawable) frame_image.getBackground();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void start(View view){</span></span><ul><li><span class="name"><span class="innerContentContainer">// 开始播放</span></span></li><li><span class="name"><span class="innerContentContainer">animationDrawable.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void stop(View view){</span></span><ul><li><span class="name"><span class="innerContentContainer">//停止播放</span></span></li><li><span class="name"><span class="innerContentContainer">animationDrawable.stop();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">补间动画 (过场动画)</span></span><ul><li><span class="name"><span class="innerContentContainer">补间动画就是指开发者指定动画的开始、动画的结束的"关键帧"，而动画变化的"中间帧"由系统计算，并补齐。</span></span></li><li><span class="name"><span class="innerContentContainer">补间动画一般通过 xml 来实现，对于 xml 形式补间动画的定义，也是需要在 res/anim/ 文件夹下定义动画资源.</span></span></li><li><span class="name"><span class="innerContentContainer">补间动画有4种. 定义方法见内.</span></span><ul><li><span class="name"><span class="innerContentContainer">淡入淡出： alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">// alpha_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:duration="1000"</span></span></li><li><span class="name"><span class="innerContentContainer">android:fromAlpha="1.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:interpolator="@android:anim/accelerate_decelerate_interpolator"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toAlpha="0.0" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中: interpolator 代表插值器，主要作用是可以控制动画的变化速率，可以通过 @ android:anim 来选择不同的插值器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">位移：translate</span></span><ul><li><span class="name"><span class="innerContentContainer">// translate_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:fromDegree="0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toDegree="1800"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotX = "50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotY="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:duration = "3000" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中: pivot 这个属性主要是在translate 和 scale 动画中，这两种动画都牵扯到view 的“物理位置“发生变化，所以需要一个参考点。而pivotX和pivotY就共同决定了这个点；它的值可以是float或者是百分比数值。</span></span></li><li><span class="name"><span class="innerContentContainer">以 pivotX 为例，说明其取不同的值的含义：</span></span></li><li><span class="name"><span class="innerContentContainer">10:距离动画所在view自身左边缘10像素</span></span></li><li><span class="name"><span class="innerContentContainer">10% :距离动画所在view自身左边缘 的距离是整个view宽度的10%</span></span></li><li><span class="name"><span class="innerContentContainer">10%p:距离动画所在view父控件左边缘的距离是整个view宽度的10%</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缩放：scale</span></span><ul><li><span class="name"><span class="innerContentContainer">// scale_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;scale xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:duration="1000"</span></span></li><li><span class="name"><span class="innerContentContainer">android:fromXScale="0.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:fromYScale="0.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotX="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotY="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toXScale="1.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toYScale="1.0"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">旋转： rotate</span></span><ul><li><span class="name"><span class="innerContentContainer">// rotate_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;rotate</span></span><ul><li><span class="name"><span class="innerContentContainer">android:fromDegrees="float"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toDegrees="float"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotX="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotY="50%" /&gt;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">这4种动画形式可作用于同一个动画.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用该补间动画的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">利用 AnimationUtils 工具类来加载指定动画资源，加载成功后返回一个 Animation，该对象可以控制图片或者视图播放动画。</span></span></li><li><span class="name"><span class="innerContentContainer">public class tweenAnimation extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">Button tween_start;</span></span></li><li><span class="name"><span class="innerContentContainer">@ Override</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(@ Nullable Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_tween_animation);</span></span></li><li><span class="name"><span class="innerContentContainer">final ImageView  tween_image = findViewById(R.id.tween_image);</span></span></li><li><span class="name"><span class="innerContentContainer">tween_start = findViewById(R.id.tween_start);</span></span></li><li><span class="name"><span class="innerContentContainer">// 加载动画资源</span></span></li><li><span class="name"><span class="innerContentContainer">final Animation anim = AnimationUtils.loadAnimation(this, R.anim.alpha_anim);</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置动画结束后保留结束状态</span></span></li><li><span class="name"><span class="innerContentContainer">anim.setFillAfter(true);</span></span></li><li><span class="name"><span class="innerContentContainer">tween_start.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View view) {</span></span><ul><li><span class="name"><span class="innerContentContainer">tween_image.startAnimation(anim);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动画监听</span></span><ul><li><span class="name"><span class="innerContentContainer">为了实现一些需求，如动画结束后开始另一个动画或者页面跳转，这时候就需要监听动画。</span></span></li><li><span class="name"><span class="innerContentContainer">Animation.addListener(new AnimatorListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onAnimationStart(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画开始时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onAnimationRepeat(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画重复时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">public void onAnimationCancel()(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画取消时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onAnimationEnd(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画结束时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画</span></span><ul><li><span class="name"><span class="innerContentContainer">属性动画可以看作是补间动画的升级版，不同之处在：</span></span><ul><li><span class="name"><span class="innerContentContainer">补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</span></span></li><li><span class="name"><span class="innerContentContainer">补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">与补间动画类似的是，属性动画也需要定义几个方面的属性：</span></span><ul><li><span class="name"><span class="innerContentContainer">动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</span></span></li><li><span class="name"><span class="innerContentContainer">动画插值方式。通过 android:interploator 指定。</span></span></li><li><span class="name"><span class="innerContentContainer">动画重复次数。通过 android:repeatCount 指定。</span></span></li><li><span class="name"><span class="innerContentContainer">重复行为。通过 android:repeatMode 指定。</span></span></li><li><span class="name"><span class="innerContentContainer">动画集。在属性资源文件中通过 &lt;set .../&gt; 来组合。</span></span></li><li><span class="name"><span class="innerContentContainer">帧刷新率。指定多长时间播放一帧。默认为 10 ms。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画 API</span></span><ul><li><span class="name"><span class="innerContentContainer">Animator: 提供创建属性动画的基类，基本不会直接使用这个类。</span></span></li><li><span class="name"><span class="innerContentContainer">ValueAnimator:属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</span></span></li><li><span class="name"><span class="innerContentContainer">ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</span></span></li><li><span class="name"><span class="innerContentContainer">AnimatorSet：Animator 的子类，用于组合多个 Animator。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">除了这些 API,属性动画还提供了一个 Evaluator ，用来控制属性动画如何计算属性值。</span></span><ul><li><span class="name"><span class="innerContentContainer">IntEvaluator:计算 int 类型属性值的计算器。</span></span></li><li><span class="name"><span class="innerContentContainer">FloatEvaluator: 用于计算 float 类型属性值的计算器。</span></span></li><li><span class="name"><span class="innerContentContainer">ArgbEvaluator: 用于计算十六进制形式表示的颜色值的计算器。</span></span></li><li><span class="name"><span class="innerContentContainer">TypeEvaluator: 可以自定义计算器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用 ValueAnimator 创建动画的步骤：</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 ValueAnimator 的 ofInt()、ofFloat() 或者 ofObject() 静态方法创建 ValueAnimator 实例。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 ValueAnimator 的 setXxx() 等方法设置持续时间，插值方式、重复次数等。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 ValueAnimator 的 start() 方法启动动画。</span></span></li><li><span class="name"><span class="innerContentContainer">为 ValueAnimator 注册 AnimatorUpdateListener 监听器，在该监听器中可以监听 ValueAnimator 计算出来的值改变，并将这些值应用到指定对象上。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画的一般使用：</span></span></li><li><span class="name"><span class="innerContentContainer">定义属性动画和补间动画等类似，有两种方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。</span></span></li><li><span class="name"><span class="innerContentContainer">使用资源文件来定义动画。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画的使用：</span></span><ul><li><span class="name"><span class="innerContentContainer">创建 ValueAnimator 或 ObjectAnimator 对象 —— 即可以从 XML 资源文件加载该动画也可以直接调用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。</span></span></li><li><span class="name"><span class="innerContentContainer">根据需要为 Animator 对象设置属性。</span></span></li><li><span class="name"><span class="innerContentContainer">如果需要监听 Animator 的动画开始事件，动画结束事件、动画重复事件、动画值改变事件，并根据事件提供响应处理代码，需要为Animator 对象设置监听器。</span></span></li><li><span class="name"><span class="innerContentContainer">如果有多个动画需要同时播放，需要使用 AnimatorSet 组合这些动画。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 Animator 对象的 start 启动动画。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">夜间模式方案</span></span><ul><li><span class="name"><span class="innerContentContainer">在夜间弱光环境下我们长时间注视屏幕，会引起视疲劳。</span></span></li><li><span class="name"><span class="innerContentContainer">为了解决这个问题，厂商推出了夜间模式，它可以降低屏幕亮度，缩小屏幕显示内容与环境光强度的差距，让你在夜间看屏幕时不会太刺眼。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AOD(息屏显示)方案</span></span><ul><li><span class="name"><span class="innerContentContainer">现在大多数旗舰手机使用的都是OLED屏幕.</span></span></li><li><span class="name"><span class="innerContentContainer">其自发光特性是LCD屏所不具备的，在显示黑色时，相应的像素点无需发光，可以减少电量消耗，提升手机续航.</span></span></li><li><span class="name"><span class="innerContentContainer">安卓厂商也基于此原理推出了息屏显示AOD (Always On Display)功能。</span></span></li><li><span class="name"><span class="innerContentContainer">AOD都是黑色的.</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">Canvas</span></span><ul><li><span class="name"><span class="innerContentContainer">普通view渲染时不用 OpenGL, 用 skia, 不用硬件加速, 依赖CPU性能.</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceView/TextureView 用 OpenGL, 用硬件加速.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Skia（2D图形引擎, 又叫 SGL）</span></span><ul><li><span class="name"><span class="innerContentContainer">Canvas 底层用 skia库实现. </span></span></li><li><span class="name"><span class="innerContentContainer">Android系统用 skia 来画普通的图形元素，包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">image</span></span></li><li><span class="name"><span class="innerContentContainer">shap</span></span></li><li><span class="name"><span class="innerContentContainer">color</span></span></li><li><span class="name"><span class="innerContentContainer">pre-defined 动画.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">OpenGL（3D图形引擎）</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceManager/Surfaceflinger</span></span></li></ul>
  </body>
</html>