<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>07-Debug</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android log系统框图  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Log模板 <span class="contentTag" title="Filter #template">#<span class="contentTagText">template</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>dumpsys</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>窗口列表: adb shell dumpsys&nbsp;window. Log内容说明: </b></span></span><ul><li><span class="name"><span class="innerContentContainer">lastanr:&nbsp;最后一次anr。如果有。</span></span></li><li><span class="name"><span class="innerContentContainer">policy： 系统Window策略。很多。</span></span><ul><li><span class="name"><span class="innerContentContainer">LockScreen: 锁屏相关</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">animator: 动画栈</span></span><ul><li><span class="name"><span class="innerContentContainer">所有动画是单独于window管理的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sessions： 刷新任务列表</span></span></li><li><span class="name"><span class="innerContentContainer">displays: 内容很多</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕分辨率</span></span></li><li><span class="name"><span class="innerContentContainer">task及其包含的activityRecord 列表</span></span></li><li><span class="name"><span class="innerContentContainer">display属性</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏属性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows: window 栈</span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys window windows | grep windows: 返回当前window栈。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Input 设备信息: adb shell dumpsys input</span></span></li><li><span class="name"><span class="innerContentContainer">进程列表: adb shell dumpsys activity processes</span></span></li><li><span class="name"><span class="innerContentContainer">获取Activity信息: adb shell dumpsys activity activities</span></span><ul><li><span class="name"><span class="innerContentContainer">获取当前界面的Activity信息：adb shell dumpsys activity top</span></span></li><li><span class="name"><span class="innerContentContainer">要获取当前界面的Activity：adb shell dumpsys activity top | findstr ACTIVITY</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印当前系统所有service信息: adb shell dumpsys activity services</span></span><ul><li><span class="name"><span class="innerContentContainer">打印指定服务的信息: adb shell dumpsys service ***(指定服务名)</span></span></li><li><span class="name"><span class="innerContentContainer">列出当前运行的服务： adb shell dumpsys | findstr DUMP</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Provider列表: adb shell dumpsys activity providers</span></span></li><li><span class="name"><span class="innerContentContainer">获取package状态: adb shell dumpsys package, 可指定包名</span></span></li><li><span class="name"><span class="innerContentContainer">获取通知列表: adb shell dumpsys notification. 返回值是:</span></span><ul><li><span class="name"><span class="innerContentContainer">NotificationRecord(0x44217920: pkg=com.sohu.newsclient useron=0x7f0201b5 / com.tencent.news:drawable/icon</span></span></li><li><span class="name"><span class="innerContentContainer">pri=0 score=0</span></span></li><li><span class="name"><span class="innerContentContainer">contentIntent=PendingIntent{4294d748: PendingIntentRecord{44088e90 com.tencent.news startActivity}}</span></span></li><li><span class="name"><span class="innerContentContainer">deleteIntent=null</span></span></li><li><span class="name"><span class="innerContentContainer">tickerText=null</span></span></li><li><span class="name"><span class="innerContentContainer">contentView=android.widget.RemoteViews@441fc810</span></span></li><li><span class="name"><span class="innerContentContainer">defaults=0x00000001 flags=0x00000010</span></span></li><li><span class="name"><span class="innerContentContainer">sound=null</span></span></li><li><span class="name"><span class="innerContentContainer">vibrate=null</span></span></li><li><span class="name"><span class="innerContentContainer">led=0x00000000 onMs=0 offMs=0</span></span></li><li><span class="name"><span class="innerContentContainer">extras={</span></span><ul><li><span class="name"><span class="innerContentContainer">android.title=农业部:中国超级稻亩产超1吨</span></span></li><li><span class="name"><span class="innerContentContainer">android.subText=null</span></span></li><li><span class="name"><span class="innerContentContainer">android.showChronometer=false</span></span></li><li><span class="name"><span class="innerContentContainer">android.icon=2130837941</span></span></li><li><span class="name"><span class="innerContentContainer">android.text=农业部今日通报称,经专家测产,袁隆平领衔培育的中国“超级稻”亩产过千公斤,创造1026.7公斤新纪录。详情&gt;&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">android.progress=0</span></span></li><li><span class="name"><span class="innerContentContainer">android.progressMax=0</span></span></li><li><span class="name"><span class="innerContentContainer">android.showWhen=true</span></span></li><li><span class="name"><span class="innerContentContainer">android.infoText=null</span></span></li><li><span class="name"><span class="innerContentContainer">android.progressIndeterminate=false</span></span></li><li><span class="name"><span class="innerContentContainer">android.scoreModified=false</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取广播: adb shell dumpsys activity broadcasts</span></span></li><li><span class="name"><span class="innerContentContainer">获取intents消息: adb shell dumpsys activity intents</span></span></li><li><span class="name"><span class="innerContentContainer">提醒列表: adb shell dumpsys alarm</span></span></li><li><span class="name"><span class="innerContentContainer">获取内存状态:  adb shell dumpsys meminfo</span></span><ul><li><span class="name"><span class="innerContentContainer">要获取具体应用的内存信息，可加上包名:  adb shell dumpsys meminfo PACKAGE_NAME</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看camera属性和状态: adb shell dumpsys media.camera</span></span><ul><li><span class="name"><span class="innerContentContainer">注意 stream[0], [1]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取位置状态: adb shell dumpsys location</span></span></li><li><span class="name"><span class="innerContentContainer">获取电话状态: adb shell dumpsys telephony.registry. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">mCallState值为0，表示待机状态、1表示来电未接听状态、2表示电话占线状态</span></span></li><li><span class="name"><span class="innerContentContainer">mCallForwarding=false   # 是否启用呼叫转移</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionState=2 #0：无数据连接 1：正在创建数据连接 2：已连接</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionPossible=true   # 是否有数据连接</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionApn=   # APN名称</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取CPU信息:  adb shell dumpsys cpuinfo</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Logcat</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: logcat</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 包括4种log, 应用 + fwk log, event log, 射频通话log (暂不关注)</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 可分析应用和fwk层的所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 原生, 不依赖.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">adb logcat **。支持如下参数：</span></span></li><li><span class="name"><span class="innerContentContainer">默认值 = main + system</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-b main</b></span></span><ul><li><span class="name"><span class="innerContentContainer">默认, 主程序log. </span></span></li><li><span class="name"><span class="innerContentContainer">一般用户空间log将写入设备节点 /dev/log/main，包括 System.out.print 及 System.erro.print 等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-b system</span></span><ul><li><span class="name"><span class="innerContentContainer">fwk层log信息和debugging.</span></span></li><li><span class="name"><span class="innerContentContainer">为了防止mian缓存区溢出, 而从其中分离出来.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-b radio</span></span><ul><li><span class="name"><span class="innerContentContainer">射频通话相关信息.</span></span></li><li><span class="name"><span class="innerContentContainer">tag 为"HTC_RIL" "RILJ" "RILC" "RILD" "RIL" "AT" "GSM" "STK"的log信息将写入此节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>-c: 清除log缓存</b></span></span></li><li><span class="name"><span class="innerContentContainer">-v: 指定Log前缀格式, 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">brief: 默认</span></span></li><li><span class="name"><span class="innerContentContainer">process: 只有PID.</span></span></li><li><span class="name"><span class="innerContentContainer">tag: 只有优先级和PID</span></span></li><li><span class="name"><span class="innerContentContainer">time: 有日期时间, 优先级, 标签和PID</span></span></li><li><span class="name"><span class="innerContentContainer">threadtime: 仅time + thread id</span></span></li><li><span class="name"><span class="innerContentContainer">raw: 不显示前缀</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-d: 打印当前log后退出.</span></span></li><li><span class="name"><span class="innerContentContainer">-g: 打印缓冲区大小</span></span></li><li><span class="name"><span class="innerContentContainer"><b>过滤关键字</b>: adb logcat | findstr "***"</span></span><ul><li><span class="name"><span class="innerContentContainer">过滤多个关键字: findstr 后用空格分开.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">过滤关键字.方法2 --更好</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell 进入adb模式；</span></span></li><li><span class="name"><span class="innerContentContainer">logcat | grep ***</span></span></li><li><span class="name"><span class="innerContentContainer">支持正则表达式，所以推荐。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logcat 遇到 read: unexpected EOF!. 解决办法是:</span></span><ul><li><span class="name"><span class="innerContentContainer">adb logcat -G 16m</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: 自定义, 一般是 main-log, event-log等.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 每行log包括如下6个部分:</span></span><ul><li><span class="name"><span class="innerContentContainer">Tag</span></span></li><li><span class="name"><span class="innerContentContainer">时间戳</span></span></li><li><span class="name"><span class="innerContentContainer">PID, 进程ID</span></span></li><li><span class="name"><span class="innerContentContainer">TID, 线程ID</span></span></li><li><span class="name"><span class="innerContentContainer">log level</span></span></li><li><span class="name"><span class="innerContentContainer">log信息(代码中写入)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: 参见 log关键字 分类.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">App通过导入android.util.Log包来引入Log类，然后通过log方法写不同优先级的相关信息到log。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/base/core/java/android/util/Log.java</span></span></li><li><span class="name"><span class="innerContentContainer">主要方法有：</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.v();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.d();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.w();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.e();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.a();</span></span></li><li><span class="name"><span class="innerContentContainer">分别对应log级别：Assert，ERROR，WARN，INFO，DEBUG，VERBOSE。</span></span></li><li><span class="name"><span class="innerContentContainer">VERBOSE除了开发期间，是不应该被编译进APP的，DEBUG应该编译但在runtime被忽略，ERROR，WARN和INFO logs则一直被保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">jni层: frameworks/base/core/jni/android_util_Log.cpp, 关键函数是 android_util_Log_println_native()</span></span></li><li><span class="name"><span class="innerContentContainer">Native层: system/core/logcat/logcat.cpp. </span></span></li><li><span class="name"><span class="innerContentContainer">Native层打印log的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">包含system/core/include/cutils/log.h</span></span></li><li><span class="name"><span class="innerContentContainer">在模块Android.mk中添加：LOCAL_SHARED_LIBRARIES := liblog libcutils</span></span></li><li><span class="name"><span class="innerContentContainer">打印接口是: </span></span></li><li><span class="name"><span class="innerContentContainer">ALOGV</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGD</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGI</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGW</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGE</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logd 服务: 在开机过程中被init进程启动. </span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 system/core/logd</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\CommandListener.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\LogBuffer.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">底层: logging的kernel driver部分被称作”logger”</span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 kernel/drivers/staging/android/logger.c</span></span></li><li><span class="name"><span class="innerContentContainer">生成4个设备节点:</span></span><ul><li><span class="name"><span class="innerContentContainer">/dev/log/main</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/events</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/radio</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/system</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>logcat -b </b>events</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: event, 系统事件log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: Event logs 文件存储在system/etc/event-log-tags中，通过cat system/etc/event-log-tags能查看其信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: Event logs是在 android.util.EventLog 中创建二进制log信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Traces - ANR - 应用稳定性</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: trace, 也即ANR, Application Not Responding</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用和framework</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 应用稳定性问题, 以ANR为主. </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">旧版本系统(&lt;=8.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">adb pull data/anr/traces.txt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">新版本系统(&gt;=9.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">一次anr一个log文件</span></span></li><li><span class="name"><span class="innerContentContainer">/data/anr/目录中有多个 anr_XXX文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置ANR路径文件的位置：</span></span><ul><li><span class="name"><span class="innerContentContainer">读取: getprop dalvik.vm.stack -trace -file</span></span></li><li><span class="name"><span class="innerContentContainer">配置: setprop dalvik.vm.stack -trace -file /tmp/stack-traces.txt</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: traces.txt</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 以ANR堆栈为核心. Traces的主要问题是只能分析典型问题, 大部分问题单靠traces是分析不出来的, 还是要考 logcat.</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog发现系统30秒不响应, 就会打印 traces.txt .</span></span></li><li><span class="name"><span class="innerContentContainer">超过一分钟不响应则会打印类似如下的log, 名字如 races_SystemServer_WDT_${time}.txt  的文件,并重启 system_server.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">Android ANR问题（一）-基本分析方法 https://www.jianshu.com/p/082045769443 --还可以</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Trace文件分析过程   参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/28c7c7faaf64">https://workflowy.com/#/28c7c7faaf64</a></b></span></span></li><li><span class="name"><span class="innerContentContainer">https://www.jianshu.com/p/18f16aba79dd  --好文章</span></span></li><li><span class="name"><span class="innerContentContainer">Android卡顿分析中常见的log: <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html">https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html</a>  --比较全面</span></span></li><li><span class="name"><span class="innerContentContainer">系统定义的ANR超时门限  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">用户输入5S.  logKey：Input event dispatching timed out</span></span></li><li><span class="name"><span class="innerContentContainer">广播：前台10S，后台60S.  logKey：Timeout of broadcast BroadcastRecord</span></span></li><li><span class="name"><span class="innerContentContainer">服务：前台20S，后台200S.  logKey：Timeout executing service</span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider：10S.  logKey：timeout publishing content providers</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ANR出现的原因  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">主线程频繁进行耗时的操作：如数据库读写</span></span></li><li><span class="name"><span class="innerContentContainer">多线程操作的死锁，主线程被block；</span></span><ul><li><span class="name"><span class="innerContentContainer">关键字：waiting to lock</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主线程被Binder server block；</span></span><ul><li><span class="name"><span class="innerContentContainer">在 traces.txt 文件中确认，client端的main线程卡在 BinderPorxy.transactNative；</span></span></li><li><span class="name"><span class="innerContentContainer">通过binderinfo 文件查找 server端的进程号。</span></span></li><li><span class="name"><span class="innerContentContainer">然后再在traces.txt 文件中确认server端在干什么， 常见的情况是卡在 Android.os.MessageQueue.nativePollOnce, 即事件处理卡住了，这种一般需要驱动继续排查。</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种情况是server端进程出现WatchDog导致ANR.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">service binder的连接达到上线无法和和System Server通信</span></span></li><li><span class="name"><span class="innerContentContainer">系统资源已耗尽（CPU、IO、内存）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务启动时出现ANR 的原因</span></span><ul><li><span class="name"><span class="innerContentContainer">Service创建之前会延迟发送一个消息，而这个消息就是ANR的起源；</span></span></li><li><span class="name"><span class="innerContentContainer">Service创建完毕，在规定的时间之内执行完毕 onCreate()方法就移除这个消息，就不会产生ANR了；</span></span></li><li><span class="name"><span class="innerContentContainer">在规定的时间之内没有完成onCreate()的调用，消息被执行，ANR发生。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ANR in: 表明发生 anr 的模块.</span></span></li><li><span class="name"><span class="innerContentContainer">PID: 进程号。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Reason</b>: 表示ANR直接原因. 有时候有用, 有时候没用.  包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口暂停: Waiting because the [targetType] window is paused.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长].</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">targetType: 取值为”focused”或者”touched”</span></span></li><li><span class="name"><span class="innerContentContainer">Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE”</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>CPU占用率</b>: Load: 5.15 / 3.68 / 3.38, 表明, 5分钟，10分钟，15分钟内的 平均分别为：5.15 , 3.68 , 3.38</span></span><ul><li><span class="name"><span class="innerContentContainer">现在cpu一般是8核的, 所以累计的CPU占用率最高为 800%.</span></span></li><li><span class="name"><span class="innerContentContainer">一般占用率超过 400% 系统会比较卡顿, 超过 600%会出现反复的进程crash 和应用anr.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU usage from 602ms to -6091ms ago: .   后面一堆数据, cpu从602毫秒到6091毫秒之间的各进程的CPU使用情况。</span></span></li><li><span class="name"><span class="innerContentContainer">以上是系统概况信息, 一般价值不大, 定位原因主要看anr时的堆栈.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>anr堆栈的分析方法</b></span></span><ul><li><span class="name"><span class="innerContentContainer">搜 Dalvik Threads 可直接定位到堆栈区.</span></span></li><li><span class="name"><span class="innerContentContainer">一般看 main 线程，即前台window所在的应用的主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">Blocked in handler on foreground thread (android.fg)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on main thread (main)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on display thread (android.display)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on ActivityManager (ActivityManager)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">main堆栈一般处在两种状态：</span></span><ul><li><span class="name"><span class="innerContentContainer">blocked状态。即在等锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，不要一看到等锁就是死锁问题。死锁是两个线程互相持有对方等的锁。</span></span></li><li><span class="name"><span class="innerContentContainer">单方面等锁非但不是死锁状态，反而是正常状态，而且非常常见。</span></span></li><li><span class="name"><span class="innerContentContainer">通过锁对象的hash可以判断是否是死锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">nativepollonce状态。即等待唤醒状态。</span></span><ul><li><span class="name"><span class="innerContentContainer">处在这种状态就是正常状态。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">main线程如果没有明显的异常，就要看其它线程的异常了。</span></span></li><li><span class="name"><span class="innerContentContainer">找对应的binder进程的堆栈. 比如 主线程id是8277,  则搜 Binder:8277_</span></span></li><li><span class="name"><span class="innerContentContainer">如果binder线程没也没有异常，那么trace文件就没啥价值了，应该回到 main log去分析。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">写anr log的代码在 ActivityManagerService.dumpStackTraces()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel Log</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Kernel Log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 底层所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell cat /proc/kmsg；kernel日志,每cat一次会清零</span></span></li><li><span class="name"><span class="innerContentContainer">adb dmesg -n 8，配置打印级别, 8是所有都打。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell dmesg: ernel日志,开机信息.(通过var/log/demsg)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: 自定义</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">格式较简单: 时间戳, 进程ID, 线程ID, 级别, Log内容</span></span></li><li><span class="name"><span class="innerContentContainer">其中时间戳为开始的毫秒数, 并不是年月日时分秒.</span></span></li><li><span class="name"><span class="innerContentContainer">例子: 2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">使用 printk()函数 进行Log输出。</span></span></li><li><span class="name"><span class="innerContentContainer">日志级别</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel log日志级别在 include/linux/kern_levels.h 定义. 字符串表示为一个尖括号中的整数，0-7，值越小优先级越高。</span></span></li><li><span class="name"><span class="innerContentContainer">优先级小于 console_loglevel 这个整数变量的消息才会打印。</span></span></li><li><span class="name"><span class="innerContentContainer">获取当前日志级别: cat /system/sys/kernel/printk, 有4个数字，第一个表示当前日志级别。</span></span></li><li><span class="name"><span class="innerContentContainer">刷新系统日志级别: echo 8 &gt; /system/sys/kernel/printk</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">换行符，log行尾一定要加换行符。否则不会输出到控制台。</span></span></li><li><span class="name"><span class="innerContentContainer">如果系统运行了 klogd 和 syslogd，则所有内核消息都会被追加到 /var/log/messages 中。</span></span></li><li><span class="name"><span class="innerContentContainer">Log buffer 大小是写在代码中的，这个宏:LOG_BUF_SHIFT，所在文件为 /kernel/init/Kconfig。</span></span></li><li><span class="name"><span class="innerContentContainer">打印速度: printk_ratelimit().</span></span></li><li><span class="name"><span class="innerContentContainer">打印主次设备号: print_dev_t(), format_dev_t().</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">printk(KERN_ALERT "This is the log printed by printk in linux kernel space.");</span></span></li><li><span class="name"><span class="innerContentContainer">printk(KERN_ERR "%s: Invalid parameter\n", __func__);</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">bugreport</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: bugreport</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用和fwk</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 稳定性问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: adb bugreport &gt; bugreport.log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">log中包含有dmesg，dumpstate和dumpsys: </span></span><ul><li><span class="name"><span class="innerContentContainer">dmesg: kernel log</span></span></li><li><span class="name"><span class="innerContentContainer">dumpstate: 系统状态信息，里面比较全</span></span></li><li><span class="name"><span class="innerContentContainer">dumpsys: 系统所有进程Process的基本属性.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Tombstones - 底层稳定性</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Tombstones</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 系统重启问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: 当系统 crash 的时候，会保存一个 tombstone 文件到 /data/tombstones目录下。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: tombstone</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 以死机堆栈为主体. 主要关注 backtrace 下面的内容, 它保存了发生 crash 时的堆栈。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">包含发生问题的进程ID信息：</span></span></li><li><span class="name"><span class="innerContentContainer">I/DEBUG   (  241): pid: 244, tid: 244, name: mediaserver  &gt;&gt;&gt; /system/bin/mediaserver &lt;&lt;&lt;</span></span></li><li><span class="name"><span class="innerContentContainer">当 tid == pid 时，问题发生在父进程，反之问题发生在子进程。</span></span></li><li><span class="name"><span class="innerContentContainer">以及错误类型：</span></span></li><li><span class="name"><span class="innerContentContainer">F/libc    (  244): Fatal signal 11 (<b>SIGSEGV</b>), code 1, fault addr 0xdeadbaad in tid 244 (mediaserver)</span></span></li><li><span class="name"><span class="innerContentContainer">说明出现进程 Crash 的原因是因为程序产生了段错误的信号，访问了非法的内存空间，而访问的非法地址是 0xdeadbaad。</span></span></li><li><span class="name"><span class="innerContentContainer">系统支持的错误类型有：</span></span><ul><li><span class="name"><span class="innerContentContainer">SIGSEGV	Invalid memory reference.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGBUS	 Access to an undefined portion of a memory object.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGFPE	Arithmetic operation error, like divide by zero.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGILL	Illegal instruction, like execute garbage or a privileged instruction</span></span></li><li><span class="name"><span class="innerContentContainer">SIGSYS	Bad system call.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXCPU	CPU time limit exceeded.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXFSZ	File size limit exceeded.</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型定义在prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.8/sysroot/usr/include/bits/signum.h</span></span></li><li><span class="name"><span class="innerContentContainer">Preftch Abort：程序指针跑飞；</span></span></li><li><span class="name"><span class="innerContentContainer">Data Abort：内存指针跑飞；（最常见）</span></span></li><li><span class="name"><span class="innerContentContainer">Div by Zero：发生除零错误；</span></span></li><li><span class="name"><span class="innerContentContainer">Unknown sig：某个task收到未定义的信号；</span></span></li><li><span class="name"><span class="innerContentContainer">Error Fatal：代码进入error FATAL分支</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SysTrace - 性能</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: SysTrace</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用, framework, 驱动. systrace负责收集系统各进程的各个线程的运行信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 性能</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">AS 进入Tools &gt; Android &gt; Monitor 抓取。</span></span></li><li><span class="name"><span class="innerContentContainer">或者使用 monitor.bat , 选择线程。</span></span></li><li><span class="name"><span class="innerContentContainer">选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。</span></span></li><li><span class="name"><span class="innerContentContainer">然后复现问题，抓对应的 systrace.</span></span></li><li><span class="name"><span class="innerContentContainer">设置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件），比如32M。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: SysTrace***</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">在R之前, chrome中打开 <a class="contentLink" target="_blank" rel="noreferrer" href="chrome://tracing">chrome://tracing</a>,  把文件拖进去即可.</span></span></li><li><span class="name"><span class="innerContentContainer">在R之后, 要用&nbsp;<a class="contentLink" target="_blank" rel="noreferrer" href="https://ui.perfetto.dev/">https://ui.perfetto.dev</a>&nbsp;打开。左侧3个按钮, 使用第二个按钮导入文件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">遍历使用的快捷键:</span></span><ul><li><span class="name"><span class="innerContentContainer">数字0: 恢复到最初状态</span></span></li><li><span class="name"><span class="innerContentContainer">数字1 表选中。可用鼠标选中一段操作，在屏幕下方看其细节。</span></span></li><li><span class="name"><span class="innerContentContainer">数字2 表示用鼠标上下左右浏览。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>f: 直接放大当前帧</b></span></span></li><li><span class="name"><span class="innerContentContainer">w: 放大</span></span></li><li><span class="name"><span class="innerContentContainer">s: 缩小</span></span></li><li><span class="name"><span class="innerContentContainer">a: 后退</span></span></li><li><span class="name"><span class="innerContentContainer">d: 前进</span></span></li><li><span class="name"><span class="innerContentContainer">方向键: 四处遍历</span></span></li><li><span class="name"><span class="innerContentContainer">m: 高亮当前</span></span></li><li><span class="name"><span class="innerContentContainer">v: 高亮整个 vsync</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">先找目标进程;</span></span></li><li><span class="name"><span class="innerContentContainer">再看UI Tread, 一般在第一个. 每个"F"都是一帧, 绿色表示不卡, 其它颜色表示卡.</span></span></li><li><span class="name"><span class="innerContentContainer">按下数字1, 用鼠标选中 UI thread 所在的绿条, 可以查看该段时间的执行细节, 比如 UI 线程执行了多久, 时间占比多少等等信息. 如果主要在UI线程执行, 那么需要进程自身代码优化性能. </span></span></li><li><span class="name"><span class="innerContentContainer">如果UI thread 主要在休眠, 那么就要往下找看哪个线程在执行. </span></span></li><li><span class="name"><span class="innerContentContainer">如果代码中打过点, 则会在该线程的横条的下方显示该函数的执行起止. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">在java代码中加 systrace 打点的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();</span></span></li><li><span class="name"><span class="innerContentContainer">必须成对出现, 且在同一个线程.</span></span></li><li><span class="name"><span class="innerContentContainer">在 release 版本中也生效.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systrace模块代码由3部分组成：</span></span><ul><li><span class="name"><span class="innerContentContainer">内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</span></span></li><li><span class="name"><span class="innerContentContainer">数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分析工具：<a class="contentLink" target="_blank" rel="noreferrer" href="http://Android提供一个systrace.py">Android提供一个systrace.py</a>（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用 Trace类来使用 Systrace.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">hprof - 内存性能</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">traceView - 性能</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tcpdump - 网络</span></span><ul><li><span class="name"><span class="innerContentContainer">TCP/IP协议相关的log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell tcpdump -s 10000 -w /sdcard/capture.pcap</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer"><b>通用调试桩方案</b></span></span><ul><li><span class="name"><span class="innerContentContainer">调试fwk的代码，可以在 PhoneWindowManager.java 的 interceptKeyBeforeQueueing(), 拦截音量上下键。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>硬件基本速度指标 <span class="contentTag" title="Filter @iPanorama">@<span class="contentTagText">iP</span><span class="contentTagNub"></span></span></b><span class="contentTag" title="Filter @iPanorama"><span class="contentTagText">anorama</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">执行一条指令：1 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从L1 cache中获取一个字：2 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从内存中读一个字：10 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘连续位置取一个字：200 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘任意位置取一个字：8000,000 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">双通道DDR4内存: 30GB/s</span></span></li><li><span class="name"><span class="innerContentContainer">PCIe SSD：3600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SATA SSD：600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">机械硬盘：200MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡：读写速度差异大，主流大约是读100MB/s, 写30MB/s.</span></span></li><li><span class="name"><span class="innerContentContainer">Nor FLASH 和 Nand FLASH 的速度对比</span></span><ul><li><span class="name"><span class="innerContentContainer">以美光（Micron）的NAND和NOR对比, 速度数据如下:</span></span></li><li><span class="name"><span class="innerContentContainer">读: Nor: 41MB/s;   Nand: 37MB/s (基本差不多)</span></span></li><li><span class="name"><span class="innerContentContainer">写: Nor: 0.178MB/s;   Nand: 5MB/s (<b>Nand 快了28倍</b>)</span></span></li><li><span class="name"><span class="innerContentContainer">擦一个块的时间: Nor: 750ms;   Nand: 2ms (<b>Nand 快了375倍</b>)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>性能问题优化经验  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">性能问题, 首先要找到参照物. 和谁对比慢? 参照物的合理性在哪里?</span></span></li><li><span class="name"><span class="innerContentContainer">其次, 要找对目标. 性能问题没有尽头, 不可能无限优化下去. 比如: 华为应用启动速度目标：500ms，从点击图标到 activity ouResume的时间。</span></span></li><li><span class="name"><span class="innerContentContainer">基本做法是: 主流程砍几刀, 分别打点, 找出最耗时的操作, 确认哪些步骤水分最大，谁在等待、在等谁. 继续这个动作, 逐步深入.</span></span></li><li><span class="name"><span class="innerContentContainer">首先, 去掉非必要的步骤；</span></span></li><li><span class="name"><span class="innerContentContainer">合并步骤，批量处理；</span></span></li><li><span class="name"><span class="innerContentContainer">预处理；预读. <b>用户感知的动作</b>, 要提前准备数据, 必要时可读入无效数据, 冗余数据.</span></span></li><li><span class="name"><span class="innerContentContainer">按需处理。<b>用户无感知的动作</b>放在后面处理. 延迟读, 延迟写。</span></span></li><li><span class="name"><span class="innerContentContainer">大流程搞成多线程的, 串行改并行, 往往有奇效.</span></span></li><li><span class="name"><span class="innerContentContainer">buffer管理: </span></span><ul><li><span class="name"><span class="innerContentContainer">双buffer，或多buffer ，保证并发；</span></span></li><li><span class="name"><span class="innerContentContainer">更大的 buffer.</span></span><ul><li><span class="name"><span class="innerContentContainer">经验: 读写buffer 超过 64K 就价值不大了; 复杂计算buffer超过一帧就价值不大了.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">同一个处理, 底层和应用都可以做, 那就放在底层做. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>界面刷新速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">setAlpha() 要特别小心. 因为如果界面上有多个Alpha值, 绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作. </span></span></li><li><span class="name"><span class="innerContentContainer">减少页面 layout布局层级.</span></span></li><li><span class="name"><span class="innerContentContainer">减少过度绘制.   --参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/5d3ed8a3ec39">https://workflowy.com/#/5d3ed8a3ec39</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>拍照速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">拍照性能优化看5个点: 拍照开始的回调, 缩略图回帧的回调, 拍照回帧, 后期处理的回调, 保存文件的回调.</span></span></li><li><span class="name"><span class="innerContentContainer">拍照性能优化: 先显示后处理, 在缩略图没有存储时候提前显示缩略图. 给用户快的感觉.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">性能问题</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>android过度绘制 (overdraw)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">过度绘制指屏幕的某个像素在同一帧的时间内会绘制多次. 这是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用.</span></span></li><li><span class="name"><span class="innerContentContainer">android系统设计思路就是递归, 无论是底层, 还是上层, 都喜欢用递归来解决问题. 好处是用很小的投入就能推动了庞大的系统; 坏处是层次太多, 太多无效调用, 系统低效臃肿.</span></span></li><li><span class="name"><span class="innerContentContainer">造成过度绘制的原因:    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">布局存在重叠的部分;</span></span></li><li><span class="name"><span class="innerContentContainer">存在非必须的重叠背景;</span></span></li><li><span class="name"><span class="innerContentContainer">不可见的UI元素也在刷新界面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>如何解决过度绘制?  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?</span></span></li><li><span class="name"><span class="innerContentContainer">1. 合理选择控件容器</span></span><ul><li><span class="name"><span class="innerContentContainer">表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</span></span></li><li><span class="name"><span class="innerContentContainer">从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 去掉window的默认背景</span></span><ul><li><span class="name"><span class="innerContentContainer">使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</span></span></li><li><span class="name"><span class="innerContentContainer">去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);</span></span></li><li><span class="name"><span class="innerContentContainer">或者在theme中添加 android:windowbackground="null"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 去掉其他不必要的背景</span></span><ul><li><span class="name"><span class="innerContentContainer">有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。</span></span></li><li><span class="name"><span class="innerContentContainer">如果采用的是 selector的背景，将normal状态的color设置为“@android:color/transparent",也同样可以解决问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. ClipRect &amp; QuickReject</span></span><ul><li><span class="name"><span class="innerContentContainer">为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</span></span></li><li><span class="name"><span class="innerContentContainer">这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 使用ViewStub</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewStub是个什么东西？一句话总结：高效占位符。</span></span></li><li><span class="name"><span class="innerContentContainer">我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</span></span></li><li><span class="name"><span class="innerContentContainer">推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</span></span></li><li><span class="name"><span class="innerContentContainer">想加载布局时，可以使用下面其中一种方法：</span></span></li><li><span class="name"><span class="innerContentContainer">((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);</span></span></li><li><span class="name"><span class="innerContentContainer">View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 使用Merge标签</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种情况下我们可以使用Merge标签来做容器控件。</span></span></li><li><span class="name"><span class="innerContentContainer">第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">Merge只能作为XML布局的根标签使用，当Inflate以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 善用draw9patch</span></span><ul><li><span class="name"><span class="innerContentContainer">你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 慎用Alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一定做Alpha转化的话，可以采用缓存的方式。</span></span><ul><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_HARDWARE);</span></span></li><li><span class="name"><span class="innerContentContainer">doSmoeThing();</span></span></li><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_NONE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 避免“OverDesign”</span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难"，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">检查方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员选项中有"调试GPU过度绘制", 打开它, 然后在应用界面上会显示各种颜色, 其中:</span></span></li><li><span class="name"><span class="innerContentContainer">没有颜色: 仅绘制1次.</span></span></li><li><span class="name"><span class="innerContentContainer">蓝色: 绘制2次 (可接受)</span></span></li><li><span class="name"><span class="innerContentContainer">绿: 绘制3次</span></span></li><li><span class="name"><span class="innerContentContainer">浅红: 绘制4次. 小块也可接受</span></span></li><li><span class="name"><span class="innerContentContainer">深红: 绘制5次或以上. 这种需要修复.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">traceView</span></span><ul><li><span class="name"><span class="innerContentContainer">使用工具 traceView 观察CPU的执行情况, 找出耗时操作.</span></span></li><li><span class="name"><span class="innerContentContainer">选择: call stack show</span></span></li><li><span class="name"><span class="innerContentContainer">打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">oprofile： linux性能监控工具</span></span><ul><li><span class="name"><span class="innerContentContainer">特点是小巧，对运行影响小。android有一个简化的实现。</span></span></li><li><span class="name"><span class="innerContentContainer">oprofile使用方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">先打开宏：CONFIG_OPROFILE=Y，编译系统生成boot.img，下载到手机侧。</span></span></li><li><span class="name"><span class="innerContentContainer">用adb使能功能：opcontrol 等工具，抓取手机数据；</span></span></li><li><span class="name"><span class="innerContentContainer">然后将/data/oprofile/ 目录下的数据pull 回pc ；</span></span></li><li><span class="name"><span class="innerContentContainer">使用PC工具:opimport、opreport等进行分析。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码位置: </span></span><ul><li><span class="name"><span class="innerContentContainer">手机侧：/external/oprofile，负责收集数据；</span></span></li><li><span class="name"><span class="innerContentContainer">pc-linux侧，/prebuild/linux_x86/oprofile，负责分析数据。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU提频</span></span><ul><li><span class="name"><span class="innerContentContainer">提频也叫CPU boost。</span></span></li><li><span class="name"><span class="innerContentContainer">CPU分大小核，一般情况下，应用线程会跑在小核上。</span></span></li><li><span class="name"><span class="innerContentContainer">如果性能不够，可以将线程提频，即强制让它运行到大核上。</span></span></li><li><span class="name"><span class="innerContentContainer">是否提频，在systrace中搜 hypnus.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">频繁gc的标准</span></span><ul><li><span class="name"><span class="innerContentContainer">gc分为young gc 和 full gc两种。</span></span></li><li><span class="name"><span class="innerContentContainer">young gc 在4秒一次以上，pause 小于20ms，耗时小于400ms，算不频繁。</span></span></li><li><span class="name"><span class="innerContentContainer">full gc 越少越好，因为造成pause时间会达到秒级。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">binder问题分析方法</span></span><ul><li><span class="name"><span class="innerContentContainer">和应用层相关的binder问题主要有两类:</span></span><ul><li><span class="name"><span class="innerContentContainer">主线程被Binder 对端block导致anr;</span></span></li><li><span class="name"><span class="innerContentContainer">Binder被占满, 导致主线程无法启动binder引起异常.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,com.starbucks.cn,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer">940: delay的时长(单位: 毫秒)</span></span></li><li><span class="name"><span class="innerContentContainer">com.starbucks.cn: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER FAILED TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/failed_transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTIONS</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/transactions</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER STATS</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/stats</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER PROCESS STATE</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/proc/*</span></span></li><li><span class="name"><span class="innerContentContainer">bind相关的一些状态</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码堆栈信息 - 内存地址转函数名</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line 是把内存地址转化为代码行的工具。需要符号表。</span></span></li><li><span class="name"><span class="innerContentContainer">用法如下：</span></span></li><li><span class="name"><span class="innerContentContainer">如果想找这行错误：#08 pc 0013b3d5 /system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> (SkPNGImageDecoder::onDecodeSubset(SkBitmap*, SkIRect const&amp;)+604)</span></span></li><li><span class="name"><span class="innerContentContainer">先在符号表目录查找：<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a>。 比如在 ./symbols/system/lib/ 下。</span></span></li><li><span class="name"><span class="innerContentContainer">./bin/x86_64-linux-addr2line -e ./symbols/system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> 0013b3d5</span></span></li><li><span class="name"><span class="innerContentContainer">输出大致为： android/external/skia/src/images/SkImageDecoder_libpng.cpp:907</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">addr2line 的增强版： <a class="contentLink" target="_blank" rel="noreferrer" href="http://stack.py">stack.py</a></span></span><ul><li><span class="name"><span class="innerContentContainer">stack.py 能够把backtrace堆栈一次性对应到代码，也是利用addr2line。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： python stack.py --symbols-dir=[符号变目录] [tombstone文件]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ndk-stack</span></span><ul><li><span class="name"><span class="innerContentContainer">Android NDK 自从版本 r6开始, 提供了一个工具 ndk-stack。这个工具能自动分析 tombstone 文件, 能将崩溃时的调用内存地址和 c++ 代码一行一行对应起来。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： ndk-stack -sym &lt;path&gt; [-dump &lt;path&gt;]</span></span><ul><li><span class="name"><span class="innerContentContainer">dump 参数即 dump 下来的 log 文本文件.</span></span></li><li><span class="name"><span class="innerContentContainer">sym 参数即符号表。就是android项目目录下，编译成功之后，obj目录下的文件（android系统源码o 中带有符号信息的文件）。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存泄漏  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/2ec2e50f9992">https://workflowy.com/#/2ec2e50f9992</a></span></span></li><li><span class="name"><span class="innerContentContainer">功耗问题  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">https://</a><a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">workflowy</a><a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">.com/#/a5573305b407</a></span></span></li><li><span class="name"><span class="innerContentContainer">Monkey</span></span></li><li><span class="name"><span class="innerContentContainer">CTS</span></span></li><li><span class="name"><span class="innerContentContainer">分析问题的首选方法  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">三现原则。log也算现场。</span></span></li><li><span class="name"><span class="innerContentContainer">利用dailybuild版本，将问题分而治之。</span></span></li><li><span class="name"><span class="innerContentContainer">花3-5分钟时间考虑思路，并写在纸上. 然后尽快开始做。</span></span></li><li><span class="name"><span class="innerContentContainer">配环境是难点，三个办法：</span></span><ul><li><span class="name"><span class="innerContentContainer">平时准备好；</span></span></li><li><span class="name"><span class="innerContentContainer">找现成的环境用；</span></span></li><li><span class="name"><span class="innerContentContainer">基本环境出问题, 不要自己琢磨, 直接找高手搞定. 不要把时间浪费在非关键问题上.</span></span><ul><li><span class="name"><span class="innerContentContainer">这意味着平时要维护一个高手的名单, 并和他们处好关系.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">加快闭环</span></span><ul><li><span class="name"><span class="innerContentContainer">code → compiler → install → test</span></span></li><li><span class="name"><span class="innerContentContainer">如果在定位问题，请保证每个小时出一次版本。</span></span></li><li><span class="name"><span class="innerContentContainer">我的经验是，一个较复杂的问题的定位，至少需要3个以上的测试版本，而写完一大段代码（300行以上）后进行功能验证，一般需要4-6个版本才能搞定（平均每个版本能解决两三个个bug）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB 相关问题，首选是Bus Hound；</span></span></li><li><span class="name"><span class="innerContentContainer">硬件问题：把线连出来，上示波器。要会用示波器。</span></span></li><li><span class="name"><span class="innerContentContainer">用trace 跟无问题，不跟才有，一般和踢狗相关。</span></span></li><li><span class="name"><span class="innerContentContainer">性能问题，先要流程分解成3-6个阶段，然后通过log 打印等方式得出各阶段的时耗，找到突破点。</span></span></li><li><span class="name"><span class="innerContentContainer">功耗问题，逐个器件拔。</span></span></li><li><span class="name"><span class="innerContentContainer">迅速缩小焦点：</span></span><ul><li><span class="name"><span class="innerContentContainer">FFA上有吗? 有, 就是高通的问题. 没有,则是我们的修改引入的.</span></span></li><li><span class="name"><span class="innerContentContainer">新版本有吗? 没有, 则已经解决.</span></span></li><li><span class="name"><span class="innerContentContainer">老版本有吗? 没有, 则是最近修改引入的. 有, 则是固有问题.</span></span></li><li><span class="name"><span class="innerContentContainer">新单板有吗? 没有, 则已经解决. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">老单板有吗? 没有, 则为硬件修改引入. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">第三方应用有吗? 有, 说明是底层问题. 没有, 说明是应用的问题. (非绝对)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时刻关注自己是在哪个层面上考虑问题：</span></span><ul><li><span class="name"><span class="innerContentContainer">是cpu层次（包括cpu、硬件寄存器、dma）</span></span></li><li><span class="name"><span class="innerContentContainer">是外设级别（要考虑时序、电源）</span></span></li><li><span class="name"><span class="innerContentContainer">还是task级别（sig、队列、task切换、堆栈、中断等）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">张建春的定位技巧  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">多看 MODEM SOFTWARE INTERFACE .pdf，学会对arm硬件寄存器的直接操作。</span></span></li><li><span class="name"><span class="innerContentContainer">下发“FALSH读”的指令：D.S SD:0X60000304 %LE %LONG 1；D.S SD:0X60000100 %LE %LONG 0x2。0X60000304&nbsp; 即 page read指令。</span></span></li><li><span class="name"><span class="innerContentContainer">设置读地址：D.S SD:0X60000300 %LE %LONG 0x0279c00；</span></span></li><li><span class="name"><span class="innerContentContainer">查看FALSH读写状态：0X60000308；</span></span></li><li><span class="name"><span class="innerContentContainer">查看ECC 纠错的位数：0X6000030C。0表示无错误；超过4个字节就无法正确纠正。</span></span></li></ul></li></ul>
  </body>
</html>