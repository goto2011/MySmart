<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">10-显示系统</span><ul><li><span class="name">分辨率相关概念</span><ul><li><span class="name">坐标原点:</span><ul><li><span class="name">Android 定义屏幕的左上角为坐标原点(0, 0), 向右为x轴, 向下为y轴, 向上为z轴. 都是正数.</span></li></ul></li><li><span class="name">dp(dip):&nbsp;device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。</span></li><li><span class="name">px: pixels(像素). 不同设备显示效果相同.</span></li><li><span class="name">pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业.</span></li><li><span class="name">sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。size和dp相同.</span></li></ul></li><li><span class="name">刷新率相关概念</span><ul><li><span class="name">FPS: 每秒传输帧数, frames per second. 即屏幕刷新率.</span><ul><li><span class="name">单位是Hz, 赫兹. </span></li><li><span class="name">通常, 要避免动作不流畅的最低FPS是 30. 最佳体验是 60或以上.</span></li></ul></li></ul></li><li><span class="name"><b>流量 = 分辨率 * 刷新率</b></span><ul><li><span class="name">比特率: 是指每秒传递的比特数(bit), 单位为 bps.</span></li><li><span class="name">码流: data rate, 指视频文件在单位时间内使用的数据流量, 也叫码率.  码流的单位 KB/s, 等于 比特率 / 8.</span></li></ul></li><li><span class="name">著名的16ms指标的来历</span><ul><li><span class="name">60 fps是手机app性能的衡量标准, 这个标准的来历是: 人眼与大脑之前的协作无法感知超过60 FPS的画面, 所以超过60 FPS 没有意义.</span></li><li><span class="name">对于60 fps, 1帧即 1000 / 60 = 16ms. </span></li><li><span class="name">Android系统每隔16ms, 会发一次 VSync 信息来通知重绘界面. </span></li><li><span class="name">当一个操作超过 16 ms, 系统在得到 VSync 信息时就无法进行绘制, </span></li></ul></li><li><span class="name">Refresh Rate: 屏幕在1秒内刷新屏幕的次数, 这取决于硬件的固定参数, 比如 60Hz.</span></li><li><span class="name">Frame Rate: 代表GPU在1秒内绘制操作的帧数, 比如30 FPS.</span></li><li><span class="name">GPU 获取图形数据进行渲染, 然后硬件负责把渲染的内容呈现到屏幕上, 他们两者不停的进行协作.</span></li><li><span class="name">如果发生帧率和刷新频率不一致的情况, 就会出现Tearing 现象, 画面上下两部分显示内容断裂, 来自不同的两帧数据发生重叠. </span></li><li><span class="name">双缓冲机制</span><ul><li><span class="name">多数系统都会使用双缓冲机制. 即一个buffer用于显示当前帧, 另一个buffer 用于缓存下一帧的数据. 其过程是:</span></li><li><span class="name">1. 屏幕显示缓冲A中的第0帧; </span></li><li><span class="name">2. CPU和GPU在缓冲B中构建第1帧; 构建好后, 并不会马上绘制, 而是必须等待系统的VSync信号.</span></li><li><span class="name">3. 系统发出VSync信号, 屏幕向缓冲B请求第1帧的数据, 如成功, 则绘制它;</span></li><li><span class="name">4. 此时, 缓冲A中的数据被清除, CPU和GPU开始构建第2帧.</span></li><li><span class="name">在第三步, 如果此时缓冲B的第1帧数据没有准备好, 屏幕只好继续显示缓冲A中的第0帧, 这种情况就叫丢帧, 也叫"Jank".</span></li></ul></li><li><span class="name">三缓冲机制</span><ul><li><span class="name">在缓冲A在显示中, 缓冲B数据已经准备好时, 此时时间会被浪费掉. </span></li><li><span class="name">可以再加一个缓冲C, 来准备下一帧数据. 这就是三缓冲机制.</span></li><li><span class="name">三缓冲不能根本上解决卡顿问题, 但是会缓解.</span></li></ul></li><li><span class="name">过度绘制 (overdraw)</span><ul><li><span class="name">指屏幕的某个像素在同一帧的时间内会绘制多次.</span></li><li><span class="name">这显然是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用.</span></li><li><span class="name">造成过度绘制的原因有:</span><ul><li><span class="name">布局存在重叠的部分;</span></li><li><span class="name">存在非必须的重叠背景;</span></li><li><span class="name">不可见的UI元素也在刷新界面.</span></li></ul></li><li><span class="name">检查方法: </span><ul><li><span class="name">开发人员选项中有"调试GPU过度绘制", 打开它, 然后在应用界面上会显示各种颜色, 其中:</span></li><li><span class="name">没有颜色: 仅绘制1次.</span></li><li><span class="name">蓝色: 绘制2次 (可接受)</span></li><li><span class="name">绿: 绘制3次</span></li><li><span class="name">浅红: 绘制4次. 小块也可接受</span></li><li><span class="name">深红: 绘制5次或以上. 这种需要修复.</span></li></ul></li></ul></li><li><span class="name"><b>如何解决过度绘制?</b></span><ul><li><span class="name">总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?</span></li><li><span class="name">1. 合理选择控件容器</span><ul><li><span class="name">表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。</span></li><li><span class="name">LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</span></li><li><span class="name">从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。</span></li></ul></li><li><span class="name">2. 去掉window的默认背景</span><ul><li><span class="name">使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</span></li><li><span class="name">去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);</span></li><li><span class="name">或者在theme中添加 android:windowbackground="null"</span></li></ul></li><li><span class="name">3. 去掉其他不必要的背景</span><ul><li><span class="name">有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。</span></li><li><span class="name">如果采用的是 selector的背景，将normal状态的color设置为“@android:color/transparent",也同样可以解决问题。</span></li></ul></li><li><span class="name">4. ClipRect &amp; QuickReject</span><ul><li><span class="name">为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化.</span></li><li><span class="name">可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</span></li><li><span class="name">这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。</span></li></ul></li><li><span class="name">5. 使用ViewStub</span><ul><li><span class="name">ViewStub是个什么东西？一句话总结：高效占位符。</span></li><li><span class="name">我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。</span></li><li><span class="name">这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</span></li><li><span class="name">推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</span></li><li><span class="name">想加载布局时，可以使用下面其中一种方法：</span></li><li><span class="name">((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);</span></li><li><span class="name">View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();</span></li></ul></li><li><span class="name">6. 使用Merge标签</span><ul><li><span class="name">有两种情况下我们可以使用Merge标签来做容器控件。</span></li><li><span class="name">第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。</span></li><li><span class="name">另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。</span></li><li><span class="name">Merge只能作为XML布局的根标签使用，当Inflate以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。</span></li></ul></li><li><span class="name">7. 善用draw9patch</span><ul><li><span class="name">你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。</span></li><li><span class="name">优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。</span></li></ul></li><li><span class="name">8. 慎用Alpha</span><ul><li><span class="name">对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</span></li><li><span class="name">如果一定做Alpha转化的话，可以采用缓存的方式。</span><ul><li><span class="name">view.setLayerType(LAYER_TYPE_HARDWARE);</span></li><li><span class="name">doSmoeThing();</span></li><li><span class="name">view.setLayerType(LAYER_TYPE_NONE);</span></li></ul></li><li><span class="name">通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</span></li></ul></li><li><span class="name">9. 避免“OverDesign”</span><ul><li><span class="name">开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难"，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。</span></li></ul></li></ul></li><li><span class="name">Canvas</span><ul><li><span class="name">普通view渲染时不用 OpenGL, 用 skia, 不用硬件加速, 依赖CPU性能.</span></li><li><span class="name">SurfaceView/TextureView 用 OpenGL, 用硬件加速.</span></li></ul></li><li><span class="name">SurfaceView 有专门的线程来画图, 不用等view刷图. 一般用于游戏, 高画质图片, 相机预览等场景.</span></li><li><span class="name">Canvas 底层用 skia库实现. </span></li><li><span class="name">Skia 是2D图形引擎, 又叫 SGL. </span></li><li><span class="name">Android系统用skia 来画普通的图形元素, 包括:</span><ul><li><span class="name">image</span></li><li><span class="name">shap</span></li><li><span class="name">color</span></li><li><span class="name">pre-defined 动画.</span></li></ul></li><li><span class="name">OpenGL是 3D图形引擎.</span></li></ul>
  </body>
</html>