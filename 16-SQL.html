<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">16-SQL</span></span><ul><li><span class="name"><span class="innerContentContainer">Provider 即内容提供器. 是Android上对MySQL数据库的封装, 用于系统和应用对外公布和管理关系数据库数据.</span></span></li><li><span class="name"><span class="innerContentContainer">系统提供的ContentProvider包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">Browser：存储如浏览器的信息。</span></span></li><li><span class="name"><span class="innerContentContainer">CallLog：存储通话记录等信息。</span></span></li><li><span class="name"><span class="innerContentContainer">Contacts：存储联系人等信息。</span></span></li><li><span class="name"><span class="innerContentContainer">MediaStore：存储媒体文件的信息。</span></span></li><li><span class="name"><span class="innerContentContainer">Settings：存储设备的设置和首选项信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过这个接口来操作它的内部数据。</span></span></li><li><span class="name"><span class="innerContentContainer">被访问者实现 <b>ContentProvider</b>.</span></span></li><li><span class="name"><span class="innerContentContainer">访问者实现 <b>ContentResolver</b>. 通过与ContentProvider同名的方法请求执行，被执行的就是ContentProvider中的同名方法。</span></span></li><li><span class="name"><span class="innerContentContainer">Uri</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri是一种资源访问方式。对于ContentProvider而言，Uri 是固定格式的：&lt;srandard_prefix&gt;://&lt;authority&gt;/&lt;data_path&gt;/&lt;id&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;srandard_prefix&gt;: ContentProvider的srandard_prefix始终是 content:// .</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;authority&gt;: ContentProvider的名称。</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;data_path&gt;: 请求的数据类型。</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;id&gt;: 指定请求的特定数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ContentProvider 需要在 AndroidManifest.xml 中进行配置。格式如下: </span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;provider android:name=".MyContentProviderDemo" android:authorities="com.content.MyUsers"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;/provider&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">android:authorities 为授权码, 是字符串. 访问者只有在申明了该授权码后才可以访问.</span></span></li><li><span class="name"><span class="innerContentContainer">一般有如下权限:</span></span><ul><li><span class="name"><span class="innerContentContainer">android:grantUriPermssions:临时许可标志。</span></span></li><li><span class="name"><span class="innerContentContainer">android:permission:Provider 读写权限。</span></span></li><li><span class="name"><span class="innerContentContainer">android:readPermission:Provider 的读权限。</span></span></li><li><span class="name"><span class="innerContentContainer">android:writePermission:Provider 的写权限。</span></span></li><li><span class="name"><span class="innerContentContainer">android:enabled:标记允许系统启动Provider。</span></span></li><li><span class="name"><span class="innerContentContainer">android:exported:标记允许其他应用程序使用这个Provider。</span></span></li><li><span class="name"><span class="innerContentContainer">android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ContentProvider必须实现的方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">onCreate()：初始化提供者。</span></span></li><li><span class="name"><span class="innerContentContainer">query(Uri, String[], String, String[], String)：查询数据，返回一个数据Cursor对象。</span></span></li><li><span class="name"><span class="innerContentContainer">insert(Uri, ContentValues)：插入一条数据。</span></span></li><li><span class="name"><span class="innerContentContainer">update(Uri, ContentValues, String, String[])：根据条件更新数据。</span></span></li><li><span class="name"><span class="innerContentContainer">delete(Uri, String, String[])：根据条件删除数据。</span></span></li><li><span class="name"><span class="innerContentContainer">getType(Uri) 返回MIME类型对应内容的URI。</span></span></li><li><span class="name"><span class="innerContentContainer">除了onCreate()和getType()方法外，其他的均为CRUD操作.</span></span></li><li><span class="name"><span class="innerContentContainer">这些方法中，Uri参数为与ContentProvider匹配的请求Uri，剩下的参数和SQLite的CRUD操作基本一致.</span></span></li><li><span class="name"><span class="innerContentContainer">SQLite</span></span><ul><li><span class="name"><span class="innerContentContainer">SQLite基于文本。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SQL语言</b></span></span><ul><li><span class="name"><span class="innerContentContainer">基本语法</span></span><ul><li><span class="name"><span class="innerContentContainer">建表格</span></span><ul><li><span class="name"><span class="innerContentContainer">create table table_name(</span></span></li><li><span class="name"><span class="innerContentContainer">column1 datatype [not null] [not null primary key],</span></span></li><li><span class="name"><span class="innerContentContainer">column2 datatype [not null],</span></span></li><li><span class="name"><span class="innerContentContainer">...）</span></span></li><li><span class="name"><span class="innerContentContainer">其中, datatype --是资料的格式，详见下。</span></span></li><li><span class="name"><span class="innerContentContainer">nut null --可不可以允许资料有空的（尚未有资料填入）。</span></span></li><li><span class="name"><span class="innerContentContainer">primary key --是本表的主键。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sqlite支持的数据结构</span></span><ul><li><span class="name"><span class="innerContentContainer">smallint: 16 位元的整数。</span></span></li><li><span class="name"><span class="innerContentContainer">interger: 32 位元的整数。</span></span></li><li><span class="name"><span class="innerContentContainer">decimal(p,s): p 精确值和 s 大小的十进位整数，精确值p是指全部有几个数(digits)大小值，s是指小数点後有几位数。如果没有特别指定，则系统会设为 p=5; s=0 。</span></span></li><li><span class="name"><span class="innerContentContainer">float: 32位元的实数。</span></span></li><li><span class="name"><span class="innerContentContainer">double: 64位元的实数。</span></span></li><li><span class="name"><span class="innerContentContainer">char(n): n 长度的字串，n不能超过 254。</span></span></li><li><span class="name"><span class="innerContentContainer">varchar(n): 长度不固定且其最大长度为 n 的字串，n不能超过 4000。</span></span></li><li><span class="name"><span class="innerContentContainer">graphic(n): 和 char(n) 一样，不过其单位是两个字元 double-bytes， n不能超过127。这个形态是为了支援两个字元长度的字体，例如中文字。</span></span></li><li><span class="name"><span class="innerContentContainer">vargraphic(n): 可变长度且其最大长度为 n 的双字元字串，n不能超过 2000。</span></span></li><li><span class="name"><span class="innerContentContainer">date: 包含了 年份、月份、日期。</span></span></li><li><span class="name"><span class="innerContentContainer">time: 包含了 小时、分钟、秒。</span></span></li><li><span class="name"><span class="innerContentContainer">timestamp: 包含了 年、月、日、时、分、秒、千分之一秒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">更改表格</span></span><ul><li><span class="name"><span class="innerContentContainer">alter table table_name: 修改表名</span></span></li><li><span class="name"><span class="innerContentContainer">add column column_name datatype: 增加一个字段（没有删除某个栏位的语法)。</span></span></li><li><span class="name"><span class="innerContentContainer">add primary key (column_name): 更改表得的定义把某个栏位设为主键。</span></span></li><li><span class="name"><span class="innerContentContainer">drop primary key (column_name): 把主键的定义删除。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建立索引</span></span><ul><li><span class="name"><span class="innerContentContainer">create index index_name on table_name (column_name)</span></span></li><li><span class="name"><span class="innerContentContainer">说明：对某个表格的栏位建立索引以增加查询时的速度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">删除表格: drop table_name</span></span></li><li><span class="name"><span class="innerContentContainer">删除索引: drop index_name</span></span></li><li><span class="name"><span class="innerContentContainer">增加记录</span></span><ul><li><span class="name"><span class="innerContentContainer">insert into table_name (column1,column2,...) values ( value1,value2, ...)</span></span></li><li><span class="name"><span class="innerContentContainer">说明：</span></span></li><li><span class="name"><span class="innerContentContainer">1. 若没有指定column 系统则会按表格内的栏位顺序填入资料。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 栏位的资料形态和所填入的资料必须吻合。</span></span></li><li><span class="name"><span class="innerContentContainer">3. table_name 也可以是景观 view_name。</span></span></li><li><span class="name"><span class="innerContentContainer">insert into table_name (column1,column2,...) select columnx,columny,... from another_table</span></span></li><li><span class="name"><span class="innerContentContainer">说明：也可以经过一个子查询（subquery）把别的表格的资料填入。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select column1,columns2,… from table_name</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：查询指定字段的记录.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name&nbsp;where column1 = xxx&nbsp;[and column2 &gt; yyy] [or column3 zzz]</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1.'*'表示查询全部字段.</span></span></li><li><span class="name"><span class="innerContentContainer">2.where 之後是接条件式，把符合条件的资料列出来。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select column1,column2&nbsp;from table_name&nbsp;order by column2 [desc]</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：order by 是指定以某个栏位做排序，[desc]是指从大到小排列，若没有指明，则是从小到大排列</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">组合查询</span></span><ul><li><span class="name"><span class="innerContentContainer">组合查询是指所查询得资料来源并不只有单一的表格，而是联合一个以上的表格才能够得到结果的。</span></span></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table1,table2&nbsp;where table1.colum1=table2.column1</span></span></li><li><span class="name"><span class="innerContentContainer">说明： 1.查询两个表格中其中 column1 值相同的资料。</span></span></li><li><span class="name"><span class="innerContentContainer">2.当然两个表格相互比较的栏位，其资料形态必须相同。</span></span></li><li><span class="name"><span class="innerContentContainer">3.一个复杂的查询其动用到的表格可能会很多个。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">整合性查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select count (*)&nbsp;from table_name&nbsp;where column_name = xxx</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：查询符合条件的资料共有几笔。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select sum(column1) from table_name</span></span><ul><li><span class="name"><span class="innerContentContainer">说明： 1.计算出总和，所选的栏位必须是可数的数字形态。</span></span></li><li><span class="name"><span class="innerContentContainer">2.除此以外还有 avg() 是计算平均、max()、min()计算最大最小值的整合性查询。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select column1,avg(column2)&nbsp;from table_name&nbsp;group by column1&nbsp;having avg(column2) &gt; xxx</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1.group by: 以column1 为一组计算 column2 的平均值必须和 avg、sum等整合性查询的关键字一起使用。</span></span></li><li><span class="name"><span class="innerContentContainer">2.having : 必须和 group by 一起使用作为整合性的限制。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">复合性查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where exists (select *&nbsp;from table_name2&nbsp;where conditions )</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1.where 的 conditions 可以是另外一个的 query。</span></span></li><li><span class="name"><span class="innerContentContainer">2.exists 在此是指存在与否。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 in (&nbsp;select column1&nbsp;from table_name2&nbsp;where conditions )</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1. in 後面接的是一个集合，表示column1 存在集合里面。</span></span></li><li><span class="name"><span class="innerContentContainer">2. select 出来的资料形态必须符合 column1。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">其他查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 like 'x%'</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：like 必须和後面的'x%' 相呼应表示以 x为开头的字串。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 in ('xxx','yyy',..)</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：in 後面接的是一个集合，表示column1 存在集合里面。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 between xx and yy</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：between 表示 column1 的值介於 xx 和 yy 之间。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">更改资料</span></span><ul><li><span class="name"><span class="innerContentContainer">update table_name&nbsp;set column1='xxx'&nbsp;where conditoins</span></span></li><li><span class="name"><span class="innerContentContainer">说明：1.更改某个栏位设定其值为'xxx'。</span></span></li><li><span class="name"><span class="innerContentContainer">2.conditions 是所要符合的条件、若没有 where 则整个 table 的那个栏位都会全部被更改。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">删除资料</span></span><ul><li><span class="name"><span class="innerContentContainer">delete from table_name&nbsp;where conditions</span></span></li><li><span class="name"><span class="innerContentContainer">说明：删除符合条件的资料。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SQLite内建函数表</span></span><ul><li><span class="name"><span class="innerContentContainer">算术函数</span></span><ul><li><span class="name"><span class="innerContentContainer">abs(X): 返回给定数字表达式的绝对值。</span></span></li><li><span class="name"><span class="innerContentContainer">max(X,Y[,...]): 返回表达式的最大值。</span></span></li><li><span class="name"><span class="innerContentContainer">min(X,Y[,...]): 返回表达式的最小值。</span></span></li><li><span class="name"><span class="innerContentContainer">random(*): 返回随机数。</span></span></li><li><span class="name"><span class="innerContentContainer">round(X[,Y]): 返回数字表达式并四舍五入为指定的长度或精度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符处理函数</span></span><ul><li><span class="name"><span class="innerContentContainer">length(X): 返回给定字符串表达式的字符个数。</span></span></li><li><span class="name"><span class="innerContentContainer">lower(X): 将大写字符数据转换为小写字符数据后返回字符表达式。</span></span></li><li><span class="name"><span class="innerContentContainer">upper(X): 返回将小写字符数据转换为大写的字符表达式。</span></span></li><li><span class="name"><span class="innerContentContainer">substr(X,Y,Z): 返回表达式的一部分。</span></span></li><li><span class="name"><span class="innerContentContainer">randstr()</span></span></li><li><span class="name"><span class="innerContentContainer">quote(A)</span></span></li><li><span class="name"><span class="innerContentContainer">like(A,B): 确定给定的字符串是否与指定的模式匹配。</span></span></li><li><span class="name"><span class="innerContentContainer">glob(A,B)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">条件判断函数</span></span><ul><li><span class="name"><span class="innerContentContainer">coalesce(X,Y[,...])</span></span></li><li><span class="name"><span class="innerContentContainer">ifnull(X,Y)</span></span></li><li><span class="name"><span class="innerContentContainer">nullif(X,Y)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">集合函数</span></span><ul><li><span class="name"><span class="innerContentContainer">avg(X): 返回组中值的平均值。</span></span></li><li><span class="name"><span class="innerContentContainer">count(X): 返回组中项目的数量。</span></span></li><li><span class="name"><span class="innerContentContainer">max(X): 返回组中值的最大值。</span></span></li><li><span class="name"><span class="innerContentContainer">min(X): 返回组中值的最小值。</span></span></li><li><span class="name"><span class="innerContentContainer">sum(X): 返回表达式中所有值的和。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其他函数</span></span><ul><li><span class="name"><span class="innerContentContainer">typeof(X): 返回数据的类型。</span></span></li><li><span class="name"><span class="innerContentContainer">last_insert_rowid(): 返回最后插入的数据的ID。</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_version(*): 返回SQLite的版本。</span></span></li><li><span class="name"><span class="innerContentContainer">change_count(): 返回受上一语句影响的行数。</span></span></li><li><span class="name"><span class="innerContentContainer">last_statement_change_count()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">处理时间数据</span></span><ul><li><span class="name"><span class="innerContentContainer">sqlite中存放的NSDate</span></span><ul><li><span class="name"><span class="innerContentContainer">coredata存储NSDate时，在内部是存储了字参考时间以来的NSTimeInterval（以秒计算），而这个参考时间根据 apple dateandtimes doc, NSDate computes time as seconds relative to an absolute reference time: the first instant of January 1, 2001 GMT.</span></span></li><li><span class="name"><span class="innerContentContainer">其实参考日期是2001.1.1，而非1970年1月1日，因此有些语言在直接读取coredata NSDate属性的sqlite Timestamp字段并转换成日期后，与原来存储的日期不一样了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关于where条件后面如果包含有日期的比较，不同数据库有不同的表达式。具体如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是access数据库，则为：where mydate&gt;#2000-01-01#</span></span></li><li><span class="name"><span class="innerContentContainer">如果是oracle数据库，则为：where mydate&gt;cast('2000-01-01' as date)</span></span></li><li><span class="name"><span class="innerContentContainer">或：where mydate&gt;to_date('2000-01-01','yyyy-mm-dd')</span></span></li><li><span class="name"><span class="innerContentContainer">在delphi中写成：</span></span></li><li><span class="name"><span class="innerContentContainer">thedate='2000-01-01';</span></span></li><li><span class="name"><span class="innerContentContainer">query1.sql.add('select * from abc where mydate&gt;cast('+''''+thedate+''''+' as date)');</span></span></li><li><span class="name"><span class="innerContentContainer">如果比较日期时间型，则为：</span></span></li><li><span class="name"><span class="innerContentContainer">where mydatetime&gt;to_date('2000-01-01 10:00:01','yyyy-mm-dd hh24:mi:ss')</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IOS上的日期比较</span></span><ul><li><span class="name"><span class="innerContentContainer">SELECT columnName FROM table WHERE (julianday(date(columnName))-julianday(date('now')))&gt;10</span></span></li><li><span class="name"><span class="innerContentContainer">julianday()这个函数会返回一个天数，从格林威治时间公元前4714年11月24号开始算起。date()函数返回一个以“YYYY-MM-DD”为格式的日期。因此上面那条语句也就不难理解了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一天：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where to_days(column_time) = to_days(now());</span></span></li><li><span class="name"><span class="innerContentContainer">select * from table where date(column_time) = curdate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一周：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一个月：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一周：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 WEEK) &lt;= date(column_time);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MySQL 数据类型详解 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">跨表查询</span></span><ul><li><span class="name"><span class="innerContentContainer">左链接（left join）</span></span><ul><li><span class="name"><span class="innerContentContainer">指从左表中返回所有的值，即使右表中没有满足条件的行。</span></span></li><li><span class="name"><span class="innerContentContainer">select * from table1 left join table2 ON table1.col = table2.col</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">右链接（right join）:  和左链接正好相反。</span></span></li><li><span class="name"><span class="innerContentContainer">内链接（Inner&nbsp;join）:  即join，指两个表中满足条件的行进行链接。&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">内链接去重复:  使用 distinct 。&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">全链接（full join）</span></span><ul><li><span class="name"><span class="innerContentContainer">将两个表的所有行都返回。</span></span></li><li><span class="name"><span class="innerContentContainer">Mysql不支持Full join,不过可以通过UNION 关键字来合并 LEFT JOIN 与 RIGHT JOIN来模拟FULL join.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">巧用update和join、count()更新统计字段</span></span><ul><li><span class="name"><span class="innerContentContainer">UPDATE property u</span></span><ul><li><span class="name"><span class="innerContentContainer">LEFT JOIN thing_property u_m ON u_m.property_UUID=u.property_UUID</span></span></li><li><span class="name"><span class="innerContentContainer">SET u.hot_index=(SELECT COUNT(property_UUID) FROM thing_property WHERE property_UUID=u.property_UUID)</span></span></li><li><span class="name"><span class="innerContentContainer">WHERE u.property_UUID=u_m.property_UUID ;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">插入时判断是否重复: insert or ignore into</span></span></li><li><span class="name"><span class="innerContentContainer">统计字数: SELECT&nbsp;sum(char_length(thing))&nbsp;FROM&nbsp;`thing_time`</span></span></li><li><span class="name"><span class="innerContentContainer">mysql允许我们在一条sql语句中批量插入数据:</span></span><ul><li><span class="name"><span class="innerContentContainer">INSERT&nbsp;INTO&nbsp;example  (example_id,&nbsp;name,&nbsp;value,&nbsp;other_value)  VALUES</span></span><ul><li><span class="name"><span class="innerContentContainer">(100,&nbsp;'Name&nbsp;1',&nbsp;'Value&nbsp;1',&nbsp;'Other&nbsp;1'),</span></span></li><li><span class="name"><span class="innerContentContainer">(101,&nbsp;'Name&nbsp;2',&nbsp;'Value&nbsp;2',&nbsp;'Other&nbsp;2'),</span></span></li><li><span class="name"><span class="innerContentContainer">(102,&nbsp;'Name&nbsp;3',&nbsp;'Value&nbsp;3',&nbsp;'Other&nbsp;3'),</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>尽可能不用 in子句:  性能很差。不如用联合 inner。</b></span></span></li><li><span class="name"><span class="innerContentContainer">3个常用的PHP访问数据库的代码</span></span><ul><li><span class="name"><span class="innerContentContainer">返回一个数组的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">$tag_uuids = array();</span></span></li><li><span class="name"><span class="innerContentContainer">$sql_string&nbsp;= "select property_UUID, hot_index from property";</span></span></li><li><span class="name"><span class="innerContentContainer">$result&nbsp;=&nbsp;mysql_query($sql_string);</span></span></li><li><span class="name"><span class="innerContentContainer">if ($result == FALSE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$GLOBALS['log']-&gt;error("error: re_calc_tag_hot_index() -- $sql_string 。");</span></span></li><li><span class="name"><span class="innerContentContainer">return&nbsp;0;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">while($row =&nbsp;mysql_fetch_array($result)) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$tag_uuids[] = $row['property_UUID'];</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回一个值的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">$sql_string = "select count(*) from thing_time ";</span></span></li><li><span class="name"><span class="innerContentContainer">$result = mysql_query($sql_string);</span></span></li><li><span class="name"><span class="innerContentContainer">if($result == FALSE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$GLOBALS['log']-&gt;error("error: get_thing_count_by_period() -- $sql_string 。");</span></span></li><li><span class="name"><span class="innerContentContainer">return -1;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">$row = mysql_fetch_row($result); &nbsp; &nbsp;// 返回一行.</span></span></li><li><span class="name"><span class="innerContentContainer">if ($row == NULL) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return "";</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return $row[0];</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不需要返回值的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">$sql_string = "update thing_time set year_order=time where time_type=2";</span></span></li><li><span class="name"><span class="innerContentContainer">if (!mysql_query($sql_string)) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$GLOBALS['log']-&gt;error("error: re_calc_year_order() -- $sql_string 。");</span></span></li><li><span class="name"><span class="innerContentContainer">return 0;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SQL性能优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">尽可能不用 distinct</span></span><ul><li><span class="name"><span class="innerContentContainer">大多数情况下，Distinct函数都会导致对最终结果集完成一次排序，因此，这就成为成本最昂贵的排序之一。Distinct一直是SQL语言中成本最高的函数之一。解决方法有两个：</span></span></li><li><span class="name"><span class="innerContentContainer">使用GroupBy（V9之前），这会利用关联索引来消除为确定唯一性所导致的排序。</span></span></li><li><span class="name"><span class="innerContentContainer">使用一个Exists子查询重写查询。如果某个表可能导致重复（由于是一对多关系），但是这个表中并不包含结果集将返回的数据，这种情况下这种方法就很适用。&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">推荐使用COMMIT</span></span><ul><li><span class="name"><span class="innerContentContainer">SQLite保存大数据集非常非常快。例如地图程序应该把图块缓存在SQLite里。最昂贵的部分是硬盘I/O。</span></span></li><li><span class="name"><span class="innerContentContainer">要避免在大块之间产生大量的小的写入，就需要用 BEGIN和 COMMIT。</span></span></li><li><span class="name"><span class="innerContentContainer">我们使用2秒钟的计时器去重置每次新的提交。一旦计时器国企，就发送COMMIT，这样所有些操作就写到一个大块里面了。</span></span></li><li><span class="name"><span class="innerContentContainer">SQLLite把事务数据保存在磁盘上，使用Begin/End包装可以避免产生大量的事务文件，把所有的事务写到一个文件里。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用多线程</span></span><ul><li><span class="name"><span class="innerContentContainer">当SQLite在主线程的时候会阻塞你的界面。</span></span></li><li><span class="name"><span class="innerContentContainer">如果你执行非常长的查询，一个好办法是把你的查询保存成静态对象，然后在另一个线程查询。</span></span></li><li><span class="name"><span class="innerContentContainer">把所有会修改数据库的查询用@synchronize() {}块包起来。</span></span></li><li><span class="name"><span class="innerContentContainer">短查询就放在主线程，简单方便。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在多线程里面使用SQLite还有一个更简单的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">用sqlite3_open_v2打开数据库，flag用SQLITE_OPEN_FULLMUTEX，这样SQLite的所有函数就是线程安全的了，不需要synchronize了。</span></span></li><li><span class="name"><span class="innerContentContainer">不过不确定哪个效率更高。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>