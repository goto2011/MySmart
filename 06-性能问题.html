<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>06-性能问题</b></span></span><ul><li><span class="name"><span class="innerContentContainer">显示相关知识参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/56a8ba6ce429">https://workflowy.com/#/56a8ba6ce429</a></span></span></li><li><span class="name"><span class="innerContentContainer"><b>硬件基本速度指标 <span class="contentTag" title="Filter @iPanorama">@<span class="contentTagText">iP</span><span class="contentTagNub"></span></span></b><span class="contentTag" title="Filter @iPanorama"><span class="contentTagText">anorama</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">从L1 cache中获取一个字：2 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从内存中读一个字：10 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘连续位置取一个字：200 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘任意位置取一个字：8000,000 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">双通道DDR4内存: 30GB/s</span></span></li><li><span class="name"><span class="innerContentContainer">PCIe SSD：3600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SATA SSD：600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">机械硬盘：200MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡：读写速度差异大，主流大约是读100MB/s, 写30MB/s.</span></span></li><li><span class="name"><span class="innerContentContainer">Nor FLASH 和 Nand FLASH 的速度对比</span></span><ul><li><span class="name"><span class="innerContentContainer">以美光（Micron）的NAND和NOR对比, 速度数据如下:</span></span></li><li><span class="name"><span class="innerContentContainer">读: Nor: 41MB/s;   Nand: 37MB/s (基本差不多)</span></span></li><li><span class="name"><span class="innerContentContainer">写: Nor: 0.178MB/s;   Nand: 5MB/s (<b>Nand 快了28倍</b>)</span></span></li><li><span class="name"><span class="innerContentContainer">擦一个块的时间: Nor: 750ms;   Nand: 2ms (<b>Nand 快了375倍</b>)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>性能问题优化经验  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">性能问题, 首先要找到参照物. 和谁对比慢? 参照物的合理性在哪里?</span></span></li><li><span class="name"><span class="innerContentContainer">其次, 要找对目标. 性能问题没有尽头, 不可能无限优化下去. 比如: 华为应用启动速度目标：500ms，从点击图标到 activity ouResume的时间。</span></span></li><li><span class="name"><span class="innerContentContainer">基本做法是: 主流程砍几刀, 分别打点, 找出最耗时的操作, 确认哪些步骤水分最大，谁在等待、在等谁. 继续这个动作, 逐步深入.</span></span></li><li><span class="name"><span class="innerContentContainer">首先, 去掉非必要的步骤；</span></span></li><li><span class="name"><span class="innerContentContainer">合并步骤，批量处理；</span></span></li><li><span class="name"><span class="innerContentContainer">预处理；预读. <b>用户感知的动作</b>, 要提前准备数据, 必要时可读入无效数据, 冗余数据.</span></span></li><li><span class="name"><span class="innerContentContainer">按需处理。<b>用户无感知的动作</b>放在后面处理. 延迟读, 延迟写。</span></span></li><li><span class="name"><span class="innerContentContainer">大流程搞成多线程的, 串行改并行, 往往有奇效.</span></span></li><li><span class="name"><span class="innerContentContainer">buffer管理: </span></span><ul><li><span class="name"><span class="innerContentContainer">双buffer，或多buffer ，保证并发；</span></span></li><li><span class="name"><span class="innerContentContainer">更大的 buffer.</span></span><ul><li><span class="name"><span class="innerContentContainer">经验: 读写buffer 超过 64K 就价值不大了; 复杂计算buffer超过一帧就价值不大了.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">同一个处理, 底层和应用都可以做, 那就放在底层做. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>界面刷新速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">setAlpha() 要特别小心. 因为如果界面上有多个Alpha值, 绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作. </span></span></li><li><span class="name"><span class="innerContentContainer">减少页面 layout布局层级.</span></span></li><li><span class="name"><span class="innerContentContainer">减少过度绘制.   --参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/5d3ed8a3ec39">https://workflowy.com/#/5d3ed8a3ec39</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>拍照速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">拍照性能优化看5个点: 拍照开始的回调, 缩略图回帧的回调, 拍照回帧, 后期处理的回调, 保存文件的回调.</span></span></li><li><span class="name"><span class="innerContentContainer">拍照性能优化: 先显示后处理, 在缩略图没有存储时候提前显示缩略图. 给用户快的感觉.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>android过度绘制 (overdraw)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">过度绘制指屏幕的某个像素在同一帧的时间内会绘制多次. 这是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用.</span></span></li><li><span class="name"><span class="innerContentContainer">android系统设计思路就是递归, 无论是底层, 还是上层, 都喜欢用递归来解决问题. 好处是用很小的投入就能推动了庞大的系统; 坏处是层次太多, 太多无效调用, 系统低效臃肿.</span></span></li><li><span class="name"><span class="innerContentContainer">造成过度绘制的原因:    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">布局存在重叠的部分;</span></span></li><li><span class="name"><span class="innerContentContainer">存在非必须的重叠背景;</span></span></li><li><span class="name"><span class="innerContentContainer">不可见的UI元素也在刷新界面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>如何解决过度绘制?  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?</span></span></li><li><span class="name"><span class="innerContentContainer">1. 合理选择控件容器</span></span><ul><li><span class="name"><span class="innerContentContainer">表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</span></span></li><li><span class="name"><span class="innerContentContainer">从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 去掉window的默认背景</span></span><ul><li><span class="name"><span class="innerContentContainer">使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</span></span></li><li><span class="name"><span class="innerContentContainer">去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);</span></span></li><li><span class="name"><span class="innerContentContainer">或者在theme中添加 android:windowbackground="null"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 去掉其他不必要的背景</span></span><ul><li><span class="name"><span class="innerContentContainer">有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。</span></span></li><li><span class="name"><span class="innerContentContainer">如果采用的是 selector的背景，将normal状态的color设置为“@android:color/transparent",也同样可以解决问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. ClipRect &amp; QuickReject</span></span><ul><li><span class="name"><span class="innerContentContainer">为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</span></span></li><li><span class="name"><span class="innerContentContainer">这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 使用ViewStub</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewStub是个什么东西？一句话总结：高效占位符。</span></span></li><li><span class="name"><span class="innerContentContainer">我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</span></span></li><li><span class="name"><span class="innerContentContainer">推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</span></span></li><li><span class="name"><span class="innerContentContainer">想加载布局时，可以使用下面其中一种方法：</span></span></li><li><span class="name"><span class="innerContentContainer">((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);</span></span></li><li><span class="name"><span class="innerContentContainer">View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 使用Merge标签</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种情况下我们可以使用Merge标签来做容器控件。</span></span></li><li><span class="name"><span class="innerContentContainer">第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">Merge只能作为XML布局的根标签使用，当Inflate以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 善用draw9patch</span></span><ul><li><span class="name"><span class="innerContentContainer">你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 慎用Alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一定做Alpha转化的话，可以采用缓存的方式。</span></span><ul><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_HARDWARE);</span></span></li><li><span class="name"><span class="innerContentContainer">doSmoeThing();</span></span></li><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_NONE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 避免“OverDesign”</span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难"，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">检查方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员选项中有"调试GPU过度绘制", 打开它, 然后在应用界面上会显示各种颜色, 其中:</span></span></li><li><span class="name"><span class="innerContentContainer">没有颜色: 仅绘制1次.</span></span></li><li><span class="name"><span class="innerContentContainer">蓝色: 绘制2次 (可接受)</span></span></li><li><span class="name"><span class="innerContentContainer">绿: 绘制3次</span></span></li><li><span class="name"><span class="innerContentContainer">浅红: 绘制4次. 小块也可接受</span></span></li><li><span class="name"><span class="innerContentContainer">深红: 绘制5次或以上. 这种需要修复.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>systrace: 分析性能问题  --异常强大的工具 <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">systrace负责收集Android关键子系统（如surfaceflinger、wms等Framework模块、服务，View系统等）的运行信息。</span></span></li><li><span class="name"><span class="innerContentContainer">systrace模块由3部分组成：</span></span><ul><li><span class="name"><span class="innerContentContainer">内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</span></span></li><li><span class="name"><span class="innerContentContainer">数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 </span></span></li><li><span class="name"><span class="innerContentContainer">从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抓取方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">AS 进入Tools &gt; Android &gt; Monitor 抓取。</span></span></li><li><span class="name"><span class="innerContentContainer">或者使用 monitor.bat , 选择线程。</span></span></li><li><span class="name"><span class="innerContentContainer">选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。</span></span></li><li><span class="name"><span class="innerContentContainer">然后复现问题，抓对应的 systrace.</span></span></li><li><span class="name"><span class="innerContentContainer">设置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件），比如32M。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">chrome中打开 chrome://tracing,  把文件拖进去</span></span></li><li><span class="name"><span class="innerContentContainer">找对应的线程</span></span></li><li><span class="name"><span class="innerContentContainer">遍历快捷键:</span></span><ul><li><span class="name"><span class="innerContentContainer">w: 放大</span></span></li><li><span class="name"><span class="innerContentContainer">s: 缩小</span></span></li><li><span class="name"><span class="innerContentContainer">a: 后退</span></span></li><li><span class="name"><span class="innerContentContainer">d: 前进</span></span></li><li><span class="name"><span class="innerContentContainer">方向键: 四处遍历</span></span></li><li><span class="name"><span class="innerContentContainer">f: 直接放大当前</span></span></li><li><span class="name"><span class="innerContentContainer">m: 高亮当前</span></span></li><li><span class="name"><span class="innerContentContainer">v: 高亮整个 vsync</span></span></li><li><span class="name"><span class="innerContentContainer">0(数字): 恢复到最初状态</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">卡顿看 UIThread , 每个"F"都是一帧, 绿色表示不卡, 其它颜色表示卡.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">界面刷新一般包括如下几个步骤：</span></span><ul><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的 EventThread 唤醒了应用程序UI线程，表明现在是渲染新帧的时候了。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序使用CPU和GPU资源在UI线程，RenderThread 和 hwuiTasks 中渲染帧。这部分占UI的大部分。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序通过binder将绘制好的帧发送到SurfaceFlinger并进入睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的第二个EventThread 负责唤醒SurfaceFlinger来触发组合和显示输出。</span></span></li><li><span class="name"><span class="innerContentContainer">如果SurfaceFlinger确定没有任何工作要完成，它将返回睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过HWC / HWC2或GL处理组合。 HWC / HWC2组合更快，更低的功耗，但会受到SOC的限制。这一步通常需要4-6ms，但是可以与步骤2重叠，因为Android应用程序总是三重缓冲。 （虽然应用程序总是三重缓冲，但在SurfaceFlinger中只能有一个待处理帧，因此和双重缓存差不多。）</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过驱动程序调度最终输出，并返回睡眠状态，等待EventThread唤醒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systrace 加点</span></span><ul><li><span class="name"><span class="innerContentContainer">代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();</span></span></li><li><span class="name"><span class="innerContentContainer">必须成对出现, 且在同一个线程.</span></span></li><li><span class="name"><span class="innerContentContainer">在 release 版本中也生效.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">traceView</span></span><ul><li><span class="name"><span class="innerContentContainer">使用工具 traceView 观察CPU的执行情况, 找出耗时操作.</span></span></li><li><span class="name"><span class="innerContentContainer">选择: call stack show</span></span></li><li><span class="name"><span class="innerContentContainer">打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">oprofile： linux性能监控工具</span></span><ul><li><span class="name"><span class="innerContentContainer">特点是小巧，对运行影响小。android有一个简化的实现。</span></span></li><li><span class="name"><span class="innerContentContainer">oprofile使用方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">先打开宏：CONFIG_OPROFILE=Y，编译系统生成boot.img，下载到手机侧。</span></span></li><li><span class="name"><span class="innerContentContainer">用adb使能功能：opcontrol 等工具，抓取手机数据；</span></span></li><li><span class="name"><span class="innerContentContainer">然后将/data/oprofile/ 目录下的数据pull 回pc ；</span></span></li><li><span class="name"><span class="innerContentContainer">使用PC工具:opimport、opreport等进行分析。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码位置: </span></span><ul><li><span class="name"><span class="innerContentContainer">手机侧：/external/oprofile，负责收集数据；</span></span></li><li><span class="name"><span class="innerContentContainer">pc-linux侧，/prebuild/linux_x86/oprofile，负责分析数据。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>