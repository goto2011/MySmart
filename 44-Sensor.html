<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">44-Sensor</span></span><ul><li><span class="name"><span class="innerContentContainer">Android平台支持三个大类的传感器：</span></span><ul><li><span class="name"><span class="innerContentContainer">Motion sensors（运动传感器）：测量加速力，以及沿三个轴的旋转力。</span></span><ul><li><span class="name"><span class="innerContentContainer">运动传感器中有两个永远是基于硬件的，即加速度计和陀螺仪（accelerometer and gyroscope）。</span></span></li><li><span class="name"><span class="innerContentContainer">运动传感器中有三个是既可以基于硬件又可以基于软件的，即重力感应器、线性加速度计、旋转向量传感器。</span></span></li><li><span class="name"><span class="innerContentContainer">加速度传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 G-sensor，返回x、y、z三轴的加速度数值。</span></span></li><li><span class="name"><span class="innerContentContainer">该数值包含地心引力的影响，单位是m/s^2。</span></span></li><li><span class="name"><span class="innerContentContainer">值域是：</span></span><ul><li><span class="name"><span class="innerContentContainer">将手机平放在桌面上，x轴默认为0，y轴默认0，z轴默认9.81。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机朝下放在桌面上，z轴为-9.81。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机向左倾斜，x轴为正值。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机向右倾斜，x轴为负值。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机向上倾斜，y轴为负值。</span></span></li><li><span class="name"><span class="innerContentContainer">将手机向下倾斜，y轴为正值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动代码：kernel/drivers/input/accelerometer/gs_mma8452.c。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重力感应器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 Gyro-sensor，返回x、y、z三轴的角速度数据。</span></span></li><li><span class="name"><span class="innerContentContainer">角速度的单位是 radians/second。</span></span></li><li><span class="name"><span class="innerContentContainer">值域是：</span></span><ul><li><span class="name"><span class="innerContentContainer">水平逆时针旋转，Z轴为正。</span></span></li><li><span class="name"><span class="innerContentContainer">水平逆时针旋转，z轴为负。</span></span></li><li><span class="name"><span class="innerContentContainer">向左旋转，y轴为负。 </span></span></li><li><span class="name"><span class="innerContentContainer">向右旋转，y轴为正。 </span></span></li><li><span class="name"><span class="innerContentContainer">向上旋转，x轴为负。</span></span></li><li><span class="name"><span class="innerContentContainer"> 向下旋转，x轴为正。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">陀螺仪，gyroscope</span></span><ul><li><span class="name"><span class="innerContentContainer">陀螺仪测量的是设备绕三个轴向的旋转速度，单位是rad/s。</span></span></li><li><span class="name"><span class="innerContentContainer">所使用的坐标系统仍然和加速度计的一样。</span></span></li><li><span class="name"><span class="innerContentContainer">旋转的值在逆时针方向为正，即，如果一个观察者从某个轴的正向某点向原点看，如果观察到的旋转是逆时针的，则是一个正值的旋转。这是一个关于旋转方向的标准的数学定义，注意，这个和方向传感器所用的定义不同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Rotation Vector，旋转矢量传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 RV-sensor。</span></span></li><li><span class="name"><span class="innerContentContainer">旋转矢量代表设备的方向，是一个将坐标轴和角度混合计算得到的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">RV-sensor输出三个数据： xsin(theta/2) ysin(theta/2) z*sin(theta/2) sin(theta/2)是RV的数量级。</span></span></li><li><span class="name"><span class="innerContentContainer">RV的方向与轴旋转的方向相同。 RV的三个数值，与cos(theta/2)组成一个四元组。 RV的数据没有单位，使用的坐标系与加速度相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Gravity，重力传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 GV-sensor，输出重力数据。</span></span></li><li><span class="name"><span class="innerContentContainer">在地球上，重力数值为9.8，单位是m/s^2。 坐标系统与加速度传感器相同。 当设备复位时，重力传感器的输出与加速度传感器相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linear Acceleration，线性加速度传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 LA-sensor。</span></span></li><li><span class="name"><span class="innerContentContainer">线性加速度传感器是加速度传感器减去重力影响获取的数据。 单位是m/s^2，坐标系统与加速度传感器相同。</span></span></li><li><span class="name"><span class="innerContentContainer">加速度传感器、重力传感器和线性加速度传感器的计算公式如下： 加速度 = 重力 + 线性加速度。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Environmental sensors （环境传感器）：测量各种环境参数，例如环境空气温度和压力，照明和湿度。包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">Ambient Light Sensor，环境光传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">检测实时的光线强度，光强单位是lux(勒克司度)，其物理意义是照射到单位面积上的光通量。</span></span></li><li><span class="name"><span class="innerContentContainer">光线感应传感器主要用于LCD自动亮度功能，根据采样到的光强数值实时调整LCD的亮度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Proximity Sensor，接近光传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">接近传感器，检测物体与手机的距离，单位是cm(厘米)。</span></span></li><li><span class="name"><span class="innerContentContainer">一些接近传感器只能返回远和近两个状态， 因此，接近传感器将最大距离返回远状态，小于最大距离返回近状态。</span></span></li><li><span class="name"><span class="innerContentContainer">接近传感器可用于接听电话时自动关闭LCD屏幕以节省电量。</span></span></li><li><span class="name"><span class="innerContentContainer">一些芯片集成了接近传感器和环境光传感器两者功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Barometer Sensor，气压计</span></span><ul><li><span class="name"><span class="innerContentContainer">返回当前的压强，单位是百帕斯卡hectopascal（hPa）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Temperature Sensor，温度计</span></span><ul><li><span class="name"><span class="innerContentContainer">返回当前的温度。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Position sensors （位置传感器）：测量设备的物理位置。包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">方向传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 O-sensor，返回三轴的角度数据，方向数据的单位是角度。</span></span></li><li><span class="name"><span class="innerContentContainer">为了得到精确的角度数据，E-compass(电子罗盘传感器)需要获取G-sensor(加速度传感器)的数据， 经过计算生产O-sensor数据，否则只能获取水平方向的角度。</span></span></li><li><span class="name"><span class="innerContentContainer">方向传感器提供三个数据，分别为azimuth、pitch和roll。</span></span><ul><li><span class="name"><span class="innerContentContainer">azimuth：方位，返回水平时磁北极和Y轴的夹角，范围为0°至360°。 0°=北，90°=东，180°=南，270°=西。</span></span></li><li><span class="name"><span class="innerContentContainer">pitch：x轴和水平面的夹角，范围为-180°至180°。 当z轴向y轴转动时，角度为正值。</span></span></li><li><span class="name"><span class="innerContentContainer">roll：y轴和水平面的夹角，由于历史原因，范围为-90°至90°。 当x轴向z轴移动时，角度为正值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电子罗盘在获取正确的数据前需要进行校准，通常可用8字校准法。 </span></span><ul><li><span class="name"><span class="innerContentContainer">8字校准法要求用户使用需要校准的设备在空中做8字晃动， 原则上尽量多的让设备法线方向指向空间的所有8个象限。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">磁力计</span></span><ul><li><span class="name"><span class="innerContentContainer">简称为 M-sensor，返回x、y、z三轴的环境磁场数据。</span></span></li><li><span class="name"><span class="innerContentContainer">该数值的单位是微特斯拉（micro-Tesla），用uT表示。 单位也可以是高斯（Gauss），1Tesla=10000Gauss。 </span></span></li><li><span class="name"><span class="innerContentContainer">硬件上一般没有独立的磁力传感器，磁力数据由电子罗盘传感器提供（E-compass）。</span></span></li><li><span class="name"><span class="innerContentContainer">电子罗盘传感器同时提供下文的方向传感器数据。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SensorHub</span></span><ul><li><span class="name"><span class="innerContentContainer">Android手机通常用到的计步器、陀螺仪、磁力计等传感器，通常都需要低功耗运行，比如在手机灭屏的状态下，仍然能不休眠地继续工作，这得益于SensorHub.</span></span></li><li><span class="name"><span class="innerContentContainer">通过将传感器挂在主CPU外部的一个小低功耗CPU上，并在这个低功耗CPU上运行RTOS，可以实现待机状态下仍持续不停地获取传感器信息.</span></span></li><li><span class="name"><span class="innerContentContainer">Android有HAL层、设计上独立MCU做SensorHub是趋势，适合写Userspace Driver，甚至TP都可以接到Hub上，Hub和MPU串口连，用户层跑daemon与hub通讯，内核打开uio框架和uinput，背光、RTC、各种Sensor，都可搞定，比在内核里上窜下跳的改代码反复编译调试强。</span></span></li><li><span class="name"><span class="innerContentContainer">至少目前不是你说的那样，现在的SENSORHUB也是通过HAL接入的，而且基本上看到的sensor&nbsp;&nbsp;hub都比传统的结构更复杂，省电和功能强大是一方面，复杂是另外一面，另外SENSORHUB的软件供应商而且目前不开放源码，这个结果你是知道的。未来，中低端机SENSORHUB会好搞一些，因为基带都会集成，高端机在外面。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IMU：惯性测量单元</span></span><ul><li><span class="name"><span class="innerContentContainer">如何理解IMU以及其预积分 https://zhuanlan.zhihu.com/p/38009126</span></span></li><li><span class="name"><span class="innerContentContainer">测量物体三轴姿态角(或角速率)以及加速度的装置。</span></span></li><li><span class="name"><span class="innerContentContainer">一般情况，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪。</span></span></li><li><span class="name"><span class="innerContentContainer">加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层调用方法</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 获取SensorManager对象</span></span></li><li><span class="name"><span class="innerContentContainer">2. 获取Sensor对象</span></span></li><li><span class="name"><span class="innerContentContainer">3. 注册Sensor对象</span></span></li><li><span class="name"><span class="innerContentContainer">4. 重写onAccuracyChanged，onSensorChanged这两个方法</span></span></li><li><span class="name"><span class="innerContentContainer">5. 注销Sensor对象</span></span></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">public class SensorActivity extends Activity implements SensorEventListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">private SensorManager mSensorManager;</span></span></li><li><span class="name"><span class="innerContentContainer">private Sensor mSensor;</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public final void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.main);</span></span></li><li><span class="name"><span class="innerContentContainer">// 第一步：通过getSystemService获得SensorManager实例对象</span></span></li><li><span class="name"><span class="innerContentContainer"><b>mSensorManager </b>= (SensorManager) getSystemService(Context.SENSOR_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">// 第二步：通过SensorManager实例对象获得想要的传感器对象: 参数决定获取哪个传感器</span></span></li><li><span class="name"><span class="innerContentContainer">mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);</span></span></li><li><span class="name"><span class="innerContentContainer">if (mSensor  != null) { </span></span><ul><li><span class="name"><span class="innerContentContainer">// 系统支持该sensor，继续</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 系统不支持该sensor，或者处在不可用状态。进行错误处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 第四步：必须重写的两个方法：onAccuracyChanged，onSensorChanged</span></span></li><li><span class="name"><span class="innerContentContainer">/** 传感器精度发生改变的回调接口 */</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public final void onAccuracyChanged(Sensor sensor, int accuracy) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// TODO 在传感器精度发生改变时做些操作，accuracy为当前传感器精度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/** 传感器事件值改变时的回调接口：执行此方法的频率与注册传感器时的频率有关 */</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public final void onSensorChanged(SensorEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 大部分传感器会返回三个轴方向x,y,x的event值，值的意义因传感器而异</span></span></li><li><span class="name"><span class="innerContentContainer">float x = event.values[0];</span></span></li><li><span class="name"><span class="innerContentContainer">float y = event.values[1];</span></span></li><li><span class="name"><span class="innerContentContainer">float z = event.values[2];</span></span></li><li><span class="name"><span class="innerContentContainer">// TODO 利用获得的三个float传感器值做些操作</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/** 第三步：在获得焦点时注册传感器并让本类实现SensorEventListener接口 */</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">protected void onResume() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onResume();</span></span></li><li><span class="name"><span class="innerContentContainer">/**第一个参数：SensorEventListener接口的实例对象</span></span></li><li><span class="name"><span class="innerContentContainer">*第二个参数：需要注册的传感器实例</span></span></li><li><span class="name"><span class="innerContentContainer">*第三个参数：传感器获取传感器事件event值频率：</span></span><ul><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_FASTEST = 0：对应0微秒的更新间隔，最快，1微秒 = 1 % 1000000秒</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_GAME = 1：对应20000微秒的更新间隔，游戏中常用</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_UI = 2：对应60000微秒的更新间隔</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_NORMAL = 3：对应200000微秒的更新间隔</span></span></li><li><span class="name"><span class="innerContentContainer">键入自定义的int值x时：对应x微秒的更新间隔</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">*/ </span></span></li><li><span class="name"><span class="innerContentContainer">mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/** 第五步：在失去焦点时注销传感器 */</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">protected void onPause() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onPause();</span></span></li><li><span class="name"><span class="innerContentContainer">mSensorManager.unregisterListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">通过 List&lt;Sensor&gt; deviceSensors = mSensorManager.getSensorList(Sensor.TYPE_ALL); 可列举系统支持的所有sensor。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FWK层</span></span><ul><li><span class="name"><span class="innerContentContainer">java-Client</span></span><ul><li><span class="name"><span class="innerContentContainer">即Android Sensor SDK。</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager：封装了 Sensor 相关的 API ，提供给 Application 使用。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/core/java/android/hardware/SensorManager.java</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">java-Server</span></span><ul><li><span class="name"><span class="innerContentContainer">SystemSensorManager：该类主要实现 SensorManager 控制和数据获取的逻辑。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/core/java/android/hardware/SystemSensorManager.java</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">jni</span></span><ul><li><span class="name"><span class="innerContentContainer">该文件负责 jave 层和 native 层通信的 JNI 实现，上层的 Java 代码通过 JNI 调用 Native 层提供的服务。</span></span></li><li><span class="name"><span class="innerContentContainer">android_hardware_SensorManager.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native-client</span></span><ul><li><span class="name"><span class="innerContentContainer">Sensor 在 Native 层的客户端，负责与服务端 SensorService.cpp 的通信。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/gui/SensorManager.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native-server</span></span><ul><li><span class="name"><span class="innerContentContainer">SensorService.cpp，是 Android Sensor Framework 最核心的模块，它实现了主要的 Sensor控制流和数据流逻辑，完成 Sensor 参数配置，数据分发，Client 请求处理等功能。 frameworks/native/services/sensorservice/SensorService.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BnSensorServer，提供类 Sensor 信息获取以及 SensorEventConnection 创建的功能。frameworks/native/include/gui/ISensorServer.h</span></span></li><li><span class="name"><span class="innerContentContainer">SensorEventConnection，是 Sensor 数据的传输通道，当 Client 开始监听某一个 Sensor 是，一个对应的 SensorEventConnection 将会被创建，Server 端在接收到 Sensor 数据后，通过写入到 SensorEventConnection 传递给 Client 端。 frameworks/native/libs/gui/ISensorEventConnection.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">SensorDevice，管理和维护系统中的所有 Sensor，封装了 Sensor 的使能、配置、数据读取等功能。 frameworks/native/services/sensorservice/SensorDevice.cpp</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">HAL层</span></span><ul><li><span class="name"><span class="innerContentContainer">SensorList，定义了 HAL 层提供的 Sensor，提供 Sensor 类型、供应商、功耗等信息。同时，HAL 层需要实现获取 SensorList 的回调接口。</span></span></li><li><span class="name"><span class="innerContentContainer">sensors_module_t，HAL 层需要定义一个 sensors_module_t，供系统在启动时加载 Sensor HAL 动态库。sensors_module_t 向上层注册获取 SensorList 和获取 Sensor 控制接口的相关回调函数。</span></span></li><li><span class="name"><span class="innerContentContainer">HAL 层还需要提供实际控制和获取 Sensor 数据的接口，SensorService 中对 Sensor 的控制和数据的获取最终会调用到这些接口。</span></span></li></ul></li></ul>
  </body>
</html>