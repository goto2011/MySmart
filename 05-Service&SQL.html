<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">05-Service&amp;SQL</span></span><ul><li><span class="name"><span class="innerContentContainer">Service(服务)</span></span><ul><li><span class="name"><span class="innerContentContainer">是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。</span></span></li><li><span class="name"><span class="innerContentContainer">启动后会常驻内存。即使启动服务的组件（Activity）已销毁也不受影响。</span></span></li><li><span class="name"><span class="innerContentContainer">如果Service挂了, 系统会自动重新启动.</span></span></li><li><span class="name"><span class="innerContentContainer">Service不是一个单独的进程, 而是和所在应用程序在同一个进程中. 应避免在Service中进行耗时操作. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定义Service</span></span><ul><li><span class="name"><span class="innerContentContainer">Service都是通过继承Service基类自定义而来的。也都需要在AndroidManifest.xml中声明。</span></span></li><li><span class="name"><span class="innerContentContainer">Service在清单文件中的声明</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;service android:enabled=["true" | "false"]</span></span><ul><li><span class="name"><span class="innerContentContainer">android:exported=["true" | "false"]</span></span></li><li><span class="name"><span class="innerContentContainer">android:icon="drawable resource"</span></span></li><li><span class="name"><span class="innerContentContainer">android:isolatedProcess=["true" | "false"]</span></span></li><li><span class="name"><span class="innerContentContainer">android:label="string resource"</span></span></li><li><span class="name"><span class="innerContentContainer">android:name="string"</span></span></li><li><span class="name"><span class="innerContentContainer">android:permission="string"</span></span></li><li><span class="name"><span class="innerContentContainer">android:process="string" &gt;</span></span></li><li><span class="name"><span class="innerContentContainer">. . .</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/service&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span></li><li><span class="name"><span class="innerContentContainer">android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。</span></span></li><li><span class="name"><span class="innerContentContainer">android:permission：是权限声明</span></span></li><li><span class="name"><span class="innerContentContainer">android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思。</span></span></li><li><span class="name"><span class="innerContentContainer">前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">重写类的如下方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">onBind()。当使用方通过调用 bindService() 与服务绑定时被系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">onCreate()。首次创建服务时被系统调用。仅调用一次。</span></span></li><li><span class="name"><span class="innerContentContainer">onStartCommand()。当使用者通过调用 startService() 请求启动服务时被系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">onDestroy()。服务被销毁时被调用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Service的生命周期  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">非绑定service, 用 <b>startService</b>() 启动的service.</span></span><ul><li><span class="name"><span class="innerContentContainer">onCreate: 当客户端第一次调用 startService()被调, 在整个生命周期中只会调用一次.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onStartCommand </b>/ onStart: <b>当客户端每次调用 startService()时会回调.</b> 一个客户端可多次调用StartService(), 多个客户端分别调用StartService(), 也不会有负面影响.  onStart() 和 onStartCommand()的关系见后.</span></span></li><li><span class="name"><span class="innerContentContainer">onDestory: 当Service被销毁时会回调，只会回调一次.</span></span></li><li><span class="name"><span class="innerContentContainer">非绑定service, Service的生命周期与它的客户端的生命周期无绑定关系. 当客户端结束自己的生命周期时, 只要不调用 stopService(), 那么Service还会继续运行.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">绑定service, 用 <b>bindService</b>() 启动的service.</span></span><ul><li><span class="name"><span class="innerContentContainer">onCreate: 同上.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onBind</b>: 该方法是Service都必须实现的方法，该方法会返回一个 IBinder对象，app通过该对象与Service组件进行通信.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onUnbind</b>: 当该Service上绑定的所有客户端都断开时会回调该方法.</span></span></li><li><span class="name"><span class="innerContentContainer">onDestory: 同上.</span></span></li><li><span class="name"><span class="innerContentContainer">当首次使用 bindService()绑定一个Service时, 默认情况下, 系统会实例化一个Service实例,并调用其onCreate()和onBind()方法, 然后客户端就可以通过IBinder和Service进行交互了.</span></span></li><li><span class="name"><span class="innerContentContainer">此后如果再次使用bindService()绑定Service,系统不会创建新的Sevice实例,也不会再调用onBind()方法,只会直接把IBinder对象传递给后来的客户端.</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们解除与服务的绑定,只需调用 unbindService(), 此时 onUnbind()会被调用. 如果只有这一个客户端, 则接着 onDestory()方法也会被调用. 如果是多个客户端, 只有最后一个客户端都调用了 unbindService(),  onDestory()才会被调用.  --按逻辑行事.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>bindService模式下, Service是与客户端是绑定关系. 在bindService后, 如果客户端在onUnbind()前异常退出, 那么Service也会被终止.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">onStartCommand 和 onStart的关系: 后者不建议使用. 如果使用, 则相当于重写了 onStartCommand, 而且返回值是 START_STICKY.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onStartCommand：</b>返回值. 非常重要.</span></span><ul><li><span class="name"><span class="innerContentContainer">START_STICKY: 系统在调用完onStartCommand()方法后，如果当前服务被终止了，系统会使该服务保持在启动状态，不过它不会保留之前传递的Intent对象。但是由于它保持启动状态，随后系统会尝试重新创建service，但之前的Intent对象没有被保存。在这个情况下，如果期间没有任何启动命令被传递到Service，那么参数Intent将为null。因此使用START_STICKY作为返回值，适用于不执行命令的媒体播放器（或类似的服务），它只是无限期的运行着并等待工作的到来.</span></span></li><li><span class="name"><span class="innerContentContainer">START_NOT_STICKY: 系统在调用完onStartCommand方法后，如果当前服务被终止了并且在此期间没有任何启动命令被传递到Service，那么系统将是使当前服务退出启动状态，并且除非重新调用Context.startService(Intent)，否则不会重新被创建（即不会重新调用onCreate方法）。因为当前服务退出了启动状态，所以除非在此期间启动命令被传递到Service，否则也不会调用。这是最安全的选项，用来避免在不需要的时候运行你的服务。</span></span></li><li><span class="name"><span class="innerContentContainer">START_REDELIVER_INTENT: 如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。并且在在该服务调用stopSelf方法之前，能够一直保留intent对象数据。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。</span></span></li><li><span class="name"><span class="innerContentContainer">START_STICKY_COMPATIBILITY: START_STICKY的兼容版本，但不保证服务被终止后一定能重启。被异常kill后, 服务虽然被重建，但没有重启.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无论启动了多少次Service,只需调用一次StopService即可停掉Service. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>bindService() </b>的函数原型:</span></span><ul><li><span class="name"><span class="innerContentContainer">bindService(Intent Service, ServiceConnection conn, int flags); 其中参数是: </span></span></li><li><span class="name"><span class="innerContentContainer">service: 通过该intent指定要启动的Service.</span></span></li><li><span class="name"><span class="innerContentContainer">conn: ServiceConnection对象,用户监听访问者与Service间的连接情况.</span></span><ul><li><span class="name"><span class="innerContentContainer">连接成功回调该对象中的onServiceConnected(ComponentName,IBinder)方法; </span></span></li><li><span class="name"><span class="innerContentContainer">如果Service所在的宿主由于异常终止或者其他原因终止,导致Service与访问者间断开 连接时调用onServiceDisconnected(CompanentName)方法.</span></span></li><li><span class="name"><span class="innerContentContainer">客户端主动调用unBindService()&nbsp;方法断开, 不会收到 onServiceDisconnected()回调.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">flags: 指定绑定时是否自动创建Service(如果Service还未创建), 参数值域是: </span></span><ul><li><span class="name"><span class="innerContentContainer">0(不自动创建).</span></span></li><li><span class="name"><span class="innerContentContainer">BIND_AUTO_CREATE(自动创建). 默认值.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">StartService启动Service后, 再bindService绑定的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Service已经由某个客户端通过 StartService()启动,接下来其他客户端再调用bindService() 绑定到该Service后, 再调用 unbindService()解除绑定, 最后再调用bindService() 绑定到 Service的话, 此时所触发的生命周期方法如下:</span></span></li><li><span class="name"><span class="innerContentContainer">onCreate() -&gt; onStartCommand() -&gt; onBind() -&gt; onUnbind() -&gt; onRebind()</span></span></li><li><span class="name"><span class="innerContentContainer"><b>注意:  如果你需要在有新客户端连接上时获得onRebind()回调, 则必须在onUnbind()中返回true. 返回false 则收不到. Android就是这么约定的. </b></span></span></li><li><span class="name"><span class="innerContentContainer">这里或许部分读者有疑惑了,调用了unbindService后Service不是应该调用 onDistory()方法么?</span></span></li><li><span class="name"><span class="innerContentContainer">其实这是因为这个Service是由我们的StartService来启动的 ,所以你调用onUnbind()方法取消绑定,Service也是不会终止的.</span></span></li><li><span class="name"><span class="innerContentContainer">得出的结论:&nbsp;假如我们使用bindService来绑定一个启动的Service,注意是已经启动的Service. 系统只是将Service的内部IBinder对象传递给Activity,并不会将Service的生命周期与此Activity绑定, 因此调用unBindService( )方法取消绑定时, Service也不会被销毁。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Service例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">public class TestService2 extends Service {</span></span><ul><li><span class="name"><span class="innerContentContainer">private final String TAG = "TestService2";</span></span></li><li><span class="name"><span class="innerContentContainer">private int count;</span></span></li><li><span class="name"><span class="innerContentContainer">private boolean quit;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义onBinder方法所返回的对象</span></span></li><li><span class="name"><span class="innerContentContainer">private MyBinder binder = new MyBinder();</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyBinder extends Binder {</span></span><ul><li><span class="name"><span class="innerContentContainer">public int getCount() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return count;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//必须实现的方法,绑定改Service时回调该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public IBinder onBind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onBind方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">return binder;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Service被创建时回调</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onCreate方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">//创建一个线程动态地修改count的值</span></span></li><li><span class="name"><span class="innerContentContainer">new Thread() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">while(!quit) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Thread.sleep(1000);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch(InterruptedException e) { e.printStackTrace(); }</span></span></li><li><span class="name"><span class="innerContentContainer">count++;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Service断开连接时回调</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onUnbind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onUnbind方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Service被关闭前回调</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void onDestroy() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onDestroy();</span></span></li><li><span class="name"><span class="innerContentContainer">this.quit = true;</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onDestroyed方法被调用!");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void onRebind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onRebind方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">super.onRebind(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 在AndroidManifest.xml中对Service组件进行注册</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;service android:name=".TestService2" android:exported="false"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;intent-filter&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;action android:name="com.jay.example.service.TEST_SERVICE2"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/intent-filter&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/service&gt;</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 在 MainActivity.java 中使用service.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">TestService2.MyBinder <b>binder</b>;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义ServiceConnection对象</span></span></li><li><span class="name"><span class="innerContentContainer">private <b>ServiceConnection conn </b>= new ServiceConnection() {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Activity与Service断开连接时回调该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onServiceDisconnected(ComponentName name) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println("------Service DisConnected-------");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// Activity与Service连接成功时回调该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onServiceConnected(ComponentName name, IBinder service) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println("------Service Connected-------");</span></span></li><li><span class="name"><span class="innerContentContainer">binder = (TestService2.MyBinder) service;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">final Intent <b>intent </b>= new Intent();</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setAction("com.jay.example.service.TEST_SERVICE2");</span></span></li><li><span class="name"><span class="innerContentContainer">// btnbind 和 btncancel <b>是两个 </b>Button, 不重要.</span></span></li><li><span class="name"><span class="innerContentContainer">btnbind.<b>setOnClickListener</b>(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>bindService</b>(<b>intent</b>, <b>conn</b>, Service.BIND_AUTO_CREATE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">btncancel.setOnClickListener(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>unbindService</b>(conn);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IntentService: 多线程的一种实现方式。耗时操作放在这里</span></span><ul><li><span class="name"><span class="innerContentContainer">IntentService是继承与Service并处理异步请求的一个类. 在 IntentService中有一个工作线程来处理耗时操作, 请求的Intent记录会加入队列.</span></span></li><li><span class="name"><span class="innerContentContainer">客户端通过 startService(Intent)来启动IntentService.</span></span></li><li><span class="name"><span class="innerContentContainer">可以启动 IntentService 多次, 每个操作以工作队列的方式在 IntentService的 onHandleIntent回调方法中执行,并且每次只会执行一个工作线程.</span></span></li><li><span class="name"><span class="innerContentContainer">并不需要手动地区控制  IntentService, 当任务执行完后会自动停止.</span></span></li><li><span class="name"><span class="innerContentContainer">当一个后台的任务需要分成几个子任务, 再按先后顺序执行子任务 (简单的说就是异步操作). 此时如果我们还是定义一个普通Service, 然后在onStart方法中开辟线程, 然后又要去控制线程, 这样显得非常的繁琐; 此时就应该自定义一个 IntentService, 然后在 onHandleIntent() 方法中完成相关任务. </span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">// IntentService 就是 Service.</span></span></li><li><span class="name"><span class="innerContentContainer">public class TestService3 extends IntentService {</span></span><ul><li><span class="name"><span class="innerContentContainer">private final String TAG = "hehe";</span></span></li><li><span class="name"><span class="innerContentContainer">public TestService3() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super("TestService3");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// onHandleIntent是核心方法, 重视.</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onHandleIntent</b>(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务</span></span></li><li><span class="name"><span class="innerContentContainer">String action = intent.getExtras().getString("param");</span></span></li><li><span class="name"><span class="innerContentContainer">if(action.equals("s1")) { Log.i(TAG,"启动service1"); }</span></span></li><li><span class="name"><span class="innerContentContainer">else if(action.equals("s2")) { Log.i(TAG,"启动service2"); }</span></span></li><li><span class="name"><span class="innerContentContainer">else if(action.equals("s3")) { Log.i(TAG,"启动service3"); }</span></span></li><li><span class="name"><span class="innerContentContainer">// 让服务休眠2秒</span></span></li><li><span class="name"><span class="innerContentContainer">try { </span></span><ul><li><span class="name"><span class="innerContentContainer">Thread.sleep(2000);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (InterruptedException e) { e.printStackTrace(); }</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public IBinder onBind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onBind");</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onBind(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onCreate");</span></span></li><li><span class="name"><span class="innerContentContainer">super.onCreate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public int onStartCommand(Intent intent, int flags, int startId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onStartCommand");</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onStartCommand(intent, flags, startId);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void setIntentRedelivery(boolean enabled) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.setIntentRedelivery(enabled);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"setIntentRedelivery");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onDestroy() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onDestroy");</span></span></li><li><span class="name"><span class="innerContentContainer">super.onDestroy();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// AndroidManifest.xml注册下Service</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;service android:name=".TestService3" android:exported="false"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;intent-filter &gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;action android:name="com.test.intentservice"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/intent-filter&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/service&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 在MainActivity启动三次服务</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it1 = new Intent("com.test.intentservice");</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle b1 = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">b1.putString("param", "s1");</span></span></li><li><span class="name"><span class="innerContentContainer">it1.putExtras(b1);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it2 = new Intent("com.test.intentservice");</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle b2 = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">b2.putString("param", "s2");</span></span></li><li><span class="name"><span class="innerContentContainer">it2.putExtras(b2);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it3 = new Intent("com.test.intentservice");</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle b3 = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">b3.putString("param", "s3");</span></span></li><li><span class="name"><span class="innerContentContainer">it3.putExtras(b3);</span></span></li><li><span class="name"><span class="innerContentContainer">// 接着启动多次IntentService,每次启动,都会新建一个工作线程. 但始终只有一个IntentService实例</span></span></li><li><span class="name"><span class="innerContentContainer">startService(it1);</span></span></li><li><span class="name"><span class="innerContentContainer">startService(it2);</span></span></li><li><span class="name"><span class="innerContentContainer">startService(it3);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity与Service通信</span></span><ul><li><span class="name"><span class="innerContentContainer">假如我们启动的是一个下载的后台Service，而我们想知道Service中下载任务的进度. 这涉及 Service 与Activity进行通信. 其基本流程如下：</span></span></li><li><span class="name"><span class="innerContentContainer">在Service中自定义一个 Binder类，然后将需要暴露的方法写到该类中.</span></span></li><li><span class="name"><span class="innerContentContainer">Service类中，实例化这个自定义 Binder类，然后重写 onBind()方法，将这个Binder对象返回.</span></span></li><li><span class="name"><span class="innerContentContainer">Activity类中实例化一个 ServiceConnection对象，重写 onServiceConnected()方法，然后获取Binder对象，然后调用相关方法即可.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">前台服务</span></span><ul><li><span class="name"><span class="innerContentContainer">Service默认是后台服务. 后台服务的缺点是优先级较低, 当内存不足时会优先回收后台服务. 方法是:</span></span></li><li><span class="name"><span class="innerContentContainer">在自定义的Service类中，重写onCreate()，然后根据自己的需求定制Notification； 定制完毕后，调用 startForeground(1,notification对象)即可.</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate();</span></span></li><li><span class="name"><span class="innerContentContainer">Notification.Builder localBuilder = new Notification.Builder(this);</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0));</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setAutoCancel(false);</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setSmallIcon(R.mipmap.ic_cow_icon);</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setTicker("Foreground Service Start");</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setContentTitle("Socket服务端");</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setContentText("正在运行...");</span></span></li><li><span class="name"><span class="innerContentContainer">startForeground(1, localBuilder.getNotification());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定时后台线程</span></span><ul><li><span class="name"><span class="innerContentContainer">Android中给我们提供的定时方式有两种: Timer类 与 Alarm机制.</span></span></li><li><span class="name"><span class="innerContentContainer">前者不适合于需要长期在后台运行的定时任务，CPU一旦休眠，Timer中的定时任务就无法运行.</span></span></li><li><span class="name"><span class="innerContentContainer">Alarm则不存在这种情况，具有唤醒CPU的功能. 另外，要区分CPU唤醒与屏幕唤醒.</span></span></li><li><span class="name"><span class="innerContentContainer">方法是:</span></span></li><li><span class="name"><span class="innerContentContainer">1, 获得Service:&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2, 通过set方法设置定时任务:</span></span><ul><li><span class="name"><span class="innerContentContainer">int anHour = 2 * 1000; </span></span></li><li><span class="name"><span class="innerContentContainer">long triggerAtTime = SystemClock.elapsedRealtime() + anHour; </span></span></li><li><span class="name"><span class="innerContentContainer">manager.<b>set</b>(AlarmManager.RTC_WAKEUP,triggerAtTime,pendingIntent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3, 定义一个Service&nbsp;在onStartCommand中开辟一条事务线程,用于处理一些定时逻辑.</span></span></li><li><span class="name"><span class="innerContentContainer">4, 定义一个Broadcast(广播)，用于启动Service&nbsp;最后别忘了，在AndroidManifest.xml中对这Service与Boradcast进行注册.</span></span></li><li><span class="name"><span class="innerContentContainer">参数详解：&nbsp;<b>set</b>(int type,long startTime,PendingIntent pi);</span></span></li><li><span class="name"><span class="innerContentContainer"><b>type</b>的值域是:</span></span><ul><li><span class="name"><span class="innerContentContainer">ELAPSED_REALTIME:&nbsp;闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3;</span></span></li><li><span class="name"><span class="innerContentContainer">ELAPSED_REALTIME_WAKEUP&nbsp;闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；</span></span></li><li><span class="name"><span class="innerContentContainer">RTC&nbsp;闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；</span></span></li><li><span class="name"><span class="innerContentContainer">RTC_WAKEUP&nbsp;表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0;</span></span></li><li><span class="name"><span class="innerContentContainer">POWER_OFF_WAKEUP&nbsp;表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一， 该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>startTime</b>: type决定startTime的含义.</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是 ELAPSED_REALTIME 和 ELAPSED_REALTIME_WAKEUP, 就用: SystemClock.elapsedRealtime()方法可以获得系统开机到现在经历的毫秒数;</span></span></li><li><span class="name"><span class="innerContentContainer">如果是RTC、RTC_WAKEUP、POWER_OFF_WAKEUP的就用: System.currentTimeMillis() 可获得从1970.1.1 0点到现在做经历的毫秒数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>PendingIntent</b>:&nbsp;绑定了闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent 是Intent的封装类。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是通过启动服务来实现闹钟提示的话， PendingIntent对象的获取就应该采用Pending.getService (Context c,int i,Intent intent,int j)方法；</span></span></li><li><span class="name"><span class="innerContentContainer">如果是通过广播来实现闹钟提示的话， PendingIntent对象的获取就应该采用 PendingIntent.getBroadcast (Context c,int i,Intent intent,int j)方法；</span></span></li><li><span class="name"><span class="innerContentContainer">如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取 就应该采用 PendingIntent.getActivity(Context c,int i,Intent intent,int j) 方法。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从4.4版本后(API 19),Alarm任务的触发时间可能变得不准确,有可能会延时,是系统 对于耗电性的优化,如果需要准确无误可以调用 setExtra()方法.</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class LongRunningService extends Service {</span></span><ul><li><span class="name"><span class="innerContentContainer">public IBinder onBind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public int onStartCommand(Intent intent, int flags, int startId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//这里开辟一条线程,用来执行具体的逻辑操作:</span></span></li><li><span class="name"><span class="innerContentContainer">new Thread(new Runnable() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.d("BackService", new Date().toString());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).start();</span></span></li><li><span class="name"><span class="innerContentContainer">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">// 这里是定时的,这里设置的是每隔两秒打印一次时间=-=,自己改</span></span></li><li><span class="name"><span class="innerContentContainer">int anHour = 2 * 1000;</span></span></li><li><span class="name"><span class="innerContentContainer">long triggerAtTime = SystemClock.elapsedRealtime() + anHour;</span></span></li><li><span class="name"><span class="innerContentContainer">Intent i = new Intent(this,AlarmReceiver.class);</span></span></li><li><span class="name"><span class="innerContentContainer">PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onStartCommand(intent, flags, startId);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public class AlarmReceiver extends BroadcastReceiver {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onReceive(Context context, Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent i = new Intent(context,LongRunningService.class);</span></span></li><li><span class="name"><span class="innerContentContainer">context.startService(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">Provider 即内容提供器. 是Android上对MySQL数据库的封装, 用于系统和应用对外公布和管理关系数据库数据.</span></span></li><li><span class="name"><span class="innerContentContainer">系统提供的ContentProvider包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">Browser：存储如浏览器的信息。</span></span></li><li><span class="name"><span class="innerContentContainer">CallLog：存储通话记录等信息。</span></span></li><li><span class="name"><span class="innerContentContainer">Contacts：存储联系人等信息。</span></span></li><li><span class="name"><span class="innerContentContainer">MediaStore：存储媒体文件的信息。</span></span></li><li><span class="name"><span class="innerContentContainer">Settings：存储设备的设置和首选项信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过这个接口来操作它的内部数据。</span></span></li><li><span class="name"><span class="innerContentContainer">被访问者实现 <b>ContentProvider</b>.</span></span></li><li><span class="name"><span class="innerContentContainer">访问者实现 <b>ContentResolver</b>. 通过与ContentProvider同名的方法请求执行，被执行的就是ContentProvider中的同名方法。</span></span></li><li><span class="name"><span class="innerContentContainer">Uri</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri是一种资源访问方式。对于ContentProvider而言，Uri 是固定格式的：&lt;srandard_prefix&gt;://&lt;authority&gt;/&lt;data_path&gt;/&lt;id&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;srandard_prefix&gt;: ContentProvider的srandard_prefix始终是 content:// .</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;authority&gt;: ContentProvider的名称。</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;data_path&gt;: 请求的数据类型。</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;id&gt;: 指定请求的特定数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ContentProvider 需要在 AndroidManifest.xml 中进行配置。格式如下: </span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;provider android:name=".MyContentProviderDemo" android:authorities="com.content.MyUsers"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;/provider&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">android:authorities 为授权码, 是字符串. 访问者只有在申明了该授权码后才可以访问.</span></span></li><li><span class="name"><span class="innerContentContainer">一般有如下权限:</span></span><ul><li><span class="name"><span class="innerContentContainer">android:grantUriPermssions:临时许可标志。</span></span></li><li><span class="name"><span class="innerContentContainer">android:permission:Provider 读写权限。</span></span></li><li><span class="name"><span class="innerContentContainer">android:readPermission:Provider 的读权限。</span></span></li><li><span class="name"><span class="innerContentContainer">android:writePermission:Provider 的写权限。</span></span></li><li><span class="name"><span class="innerContentContainer">android:enabled:标记允许系统启动Provider。</span></span></li><li><span class="name"><span class="innerContentContainer">android:exported:标记允许其他应用程序使用这个Provider。</span></span></li><li><span class="name"><span class="innerContentContainer">android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ContentProvider必须实现的方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">onCreate()：初始化提供者。</span></span></li><li><span class="name"><span class="innerContentContainer">query(Uri, String[], String, String[], String)：查询数据，返回一个数据Cursor对象。</span></span></li><li><span class="name"><span class="innerContentContainer">insert(Uri, ContentValues)：插入一条数据。</span></span></li><li><span class="name"><span class="innerContentContainer">update(Uri, ContentValues, String, String[])：根据条件更新数据。</span></span></li><li><span class="name"><span class="innerContentContainer">delete(Uri, String, String[])：根据条件删除数据。</span></span></li><li><span class="name"><span class="innerContentContainer">getType(Uri) 返回MIME类型对应内容的URI。</span></span></li><li><span class="name"><span class="innerContentContainer">除了onCreate()和getType()方法外，其他的均为CRUD操作.</span></span></li><li><span class="name"><span class="innerContentContainer">这些方法中，Uri参数为与ContentProvider匹配的请求Uri，剩下的参数和SQLite的CRUD操作基本一致.</span></span></li><li><span class="name"><span class="innerContentContainer">SQLite</span></span><ul><li><span class="name"><span class="innerContentContainer">SQLite基于文本。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SQL基本语法</span></span><ul><li><span class="name"><span class="innerContentContainer">SQL语句基本风格</span></span><ul><li><span class="name"><span class="innerContentContainer">总是使用表别名. 目的是避免重复. </span></span></li><li><span class="name"><span class="innerContentContainer">逗号在字段前. 目的是调试时方便增减字段. 比如:</span></span><ul><li><span class="name"><span class="innerContentContainer">SELECT</span></span></li><li><span class="name"><span class="innerContentContainer">c.cust_post_code</span></span></li><li><span class="name"><span class="innerContentContainer">,p.location</span></span></li><li><span class="name"><span class="innerContentContainer">,COUNT(DISTINCT c.cust_id) number_customers</span></span></li><li><span class="name"><span class="innerContentContainer">,SUM(s.total_amount) AS total_sales</span></span></li><li><span class="name"><span class="innerContentContainer">FROM customers c</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在新的一行JOIN. 目的有多个:</span></span><ul><li><span class="name"><span class="innerContentContainer">通过仅仅向下滚动JOIN语句列表就可以很容易地查看查询中所涉及到的所有表。</span></span></li><li><span class="name"><span class="innerContentContainer">使用 JOIN，相比将所有表和关系表达式都列在 WHERE 语句中，它可以将所有关系逻辑保持在一个地方。JOIN 语句也许不可能总是遵循在一行，但至少会在一个地方。</span></span></li><li><span class="name"><span class="innerContentContainer">注释掉 JOIN 会相对比较容易。在调试时，当你想知道哪个 JOIN 导致数据差异时，将很有用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">每个条件分行写. 目的是方便增减单元测试代码. 比如:</span></span><ul><li><span class="name"><span class="innerContentContainer">WHERE</span></span></li><li><span class="name"><span class="innerContentContainer">s.sales_date BETWEEN '2015-01-01' AND '2015-01-31'</span></span></li><li><span class="name"><span class="innerContentContainer">--AND c.cust_post_code = 2000</span></span></li><li><span class="name"><span class="innerContentContainer">--AND <a class="contentLink" target="_blank" rel="noreferrer" href="http://p.post">p.post</a>_code = 200</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">建表格</span></span><ul><li><span class="name"><span class="innerContentContainer">create table table_name(</span></span></li><li><span class="name"><span class="innerContentContainer">column1 datatype [not null] [not null primary key],</span></span></li><li><span class="name"><span class="innerContentContainer">column2 datatype [not null],</span></span></li><li><span class="name"><span class="innerContentContainer">...）</span></span></li><li><span class="name"><span class="innerContentContainer">其中, datatype --是资料的格式，详见下。</span></span></li><li><span class="name"><span class="innerContentContainer">nut null --可不可以允许资料有空的（尚未有资料填入）。</span></span></li><li><span class="name"><span class="innerContentContainer">primary key --是本表的主键。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sqlite支持的数据结构</span></span><ul><li><span class="name"><span class="innerContentContainer">smallint: 16 位元的整数。</span></span></li><li><span class="name"><span class="innerContentContainer">interger: 32 位元的整数。</span></span></li><li><span class="name"><span class="innerContentContainer">decimal(p,s): p 精确值和 s 大小的十进位整数，精确值p是指全部有几个数(digits)大小值，s是指小数点後有几位数。如果没有特别指定，则系统会设为 p=5; s=0 。</span></span></li><li><span class="name"><span class="innerContentContainer">float: 32位元的实数。</span></span></li><li><span class="name"><span class="innerContentContainer">double: 64位元的实数。</span></span></li><li><span class="name"><span class="innerContentContainer">char(n): n 长度的字串，n不能超过 254。</span></span></li><li><span class="name"><span class="innerContentContainer">varchar(n): 长度不固定且其最大长度为 n 的字串，n不能超过 4000。</span></span></li><li><span class="name"><span class="innerContentContainer">graphic(n): 和 char(n) 一样，不过其单位是两个字元 double-bytes， n不能超过127。这个形态是为了支援两个字元长度的字体，例如中文字。</span></span></li><li><span class="name"><span class="innerContentContainer">vargraphic(n): 可变长度且其最大长度为 n 的双字元字串，n不能超过 2000。</span></span></li><li><span class="name"><span class="innerContentContainer">date: 包含了 年份、月份、日期。</span></span></li><li><span class="name"><span class="innerContentContainer">time: 包含了 小时、分钟、秒。</span></span></li><li><span class="name"><span class="innerContentContainer">timestamp: 包含了 年、月、日、时、分、秒、千分之一秒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">更改表格</span></span><ul><li><span class="name"><span class="innerContentContainer">alter table table_name: 修改表名</span></span></li><li><span class="name"><span class="innerContentContainer">add column column_name datatype: 增加一个字段（没有删除某个栏位的语法)。</span></span></li><li><span class="name"><span class="innerContentContainer">add primary key (column_name): 更改表得的定义把某个栏位设为主键。</span></span></li><li><span class="name"><span class="innerContentContainer">drop primary key (column_name): 把主键的定义删除。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建立索引</span></span><ul><li><span class="name"><span class="innerContentContainer">create index index_name on table_name (column_name)</span></span></li><li><span class="name"><span class="innerContentContainer">说明：对某个表格的栏位建立索引以增加查询时的速度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">删除表格: drop table_name</span></span></li><li><span class="name"><span class="innerContentContainer">删除索引: drop index_name</span></span></li><li><span class="name"><span class="innerContentContainer">增加记录</span></span><ul><li><span class="name"><span class="innerContentContainer">insert into table_name (column1,column2,...) values ( value1,value2, ...)</span></span></li><li><span class="name"><span class="innerContentContainer">说明：</span></span></li><li><span class="name"><span class="innerContentContainer">1. 若没有指定column 系统则会按表格内的栏位顺序填入资料。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 栏位的资料形态和所填入的资料必须吻合。</span></span></li><li><span class="name"><span class="innerContentContainer">3. table_name 也可以是景观 view_name。</span></span></li><li><span class="name"><span class="innerContentContainer">insert into table_name (column1,column2,...) select columnx,columny,... from another_table</span></span></li><li><span class="name"><span class="innerContentContainer">说明：也可以经过一个子查询（subquery）把别的表格的资料填入。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select column1,columns2,… from table_name</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：查询指定字段的记录.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name&nbsp;where column1 = xxx&nbsp;[and column2 &gt; yyy] [or column3 zzz]</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1.'*'表示查询全部字段.</span></span></li><li><span class="name"><span class="innerContentContainer">2.where 之後是接条件式，把符合条件的资料列出来。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select column1,column2&nbsp;from table_name&nbsp;order by column2 [desc]</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：order by 是指定以某个栏位做排序，[desc]是指从大到小排列，若没有指明，则是从小到大排列</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">组合查询</span></span><ul><li><span class="name"><span class="innerContentContainer">组合查询是指所查询得资料来源并不只有单一的表格，而是联合一个以上的表格才能够得到结果的。</span></span></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table1,table2&nbsp;where table1.colum1=table2.column1</span></span></li><li><span class="name"><span class="innerContentContainer">说明： 1. 查询两个表格中其中 column1 值相同的资料。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 当然两个表格相互比较的栏位，其数据类型必须相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">跨表查询</span></span><ul><li><span class="name"><span class="innerContentContainer">左链接（left join）</span></span><ul><li><span class="name"><span class="innerContentContainer">指从左表中返回所有的值，即使右表中没有满足条件的行。</span></span></li><li><span class="name"><span class="innerContentContainer">select * from table1 left join table2 ON table1.col = table2.col</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">右链接（right join）:  和左链接正好相反。</span></span></li><li><span class="name"><span class="innerContentContainer">内链接（Inner&nbsp;join）:  即join，指两个表中满足条件的行进行链接。&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">内链接去重复:  使用 distinct 。&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">全链接（full join）</span></span><ul><li><span class="name"><span class="innerContentContainer">将两个表的所有行都返回。</span></span></li><li><span class="name"><span class="innerContentContainer">Mysql不支持Full join,不过可以通过UNION 关键字来合并 LEFT JOIN 与 RIGHT JOIN来模拟FULL join.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">整合性查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select count (*)&nbsp;from table_name&nbsp;where column_name = xxx</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：查询符合条件的资料共有几笔。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select sum(column1) from table_name</span></span><ul><li><span class="name"><span class="innerContentContainer">说明： 1.计算出总和，所选的栏位必须是可数的数字形态。</span></span></li><li><span class="name"><span class="innerContentContainer">2.除此以外还有 avg() 是计算平均、max()、min()计算最大最小值的整合性查询。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select column1,avg(column2)&nbsp;from table_name&nbsp;group by column1&nbsp;having avg(column2) &gt; xxx</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1.group by: 以column1 为一组计算 column2 的平均值必须和 avg、sum等整合性查询的关键字一起使用。</span></span></li><li><span class="name"><span class="innerContentContainer">2.having : 必须和 group by 一起使用作为整合性的限制。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">复合性查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where exists (select *&nbsp;from table_name2&nbsp;where conditions )</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1.where 的 conditions 可以是另外一个的 query。</span></span></li><li><span class="name"><span class="innerContentContainer">2.exists 在此是指存在与否。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 in (&nbsp;select column1&nbsp;from table_name2&nbsp;where conditions )</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：1. in 後面接的是一个集合，表示column1 存在集合里面。</span></span></li><li><span class="name"><span class="innerContentContainer">2. select 出来的资料形态必须符合 column1。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">其他查询</span></span><ul><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 like 'x%'</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：like 必须和後面的'x%' 相呼应表示以 x为开头的字串。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 in ('xxx','yyy',..)</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：in 後面接的是一个集合，表示column1 存在集合里面。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">select *&nbsp;from table_name1&nbsp;where column1 between xx and yy</span></span><ul><li><span class="name"><span class="innerContentContainer">说明：between 表示 column1 的值介於 xx 和 yy 之间。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">更改资料</span></span><ul><li><span class="name"><span class="innerContentContainer">update table_name&nbsp;set column1='xxx'&nbsp;where conditoins</span></span></li><li><span class="name"><span class="innerContentContainer">说明：1. 更改某个栏位设定其值为'xxx'。</span></span></li><li><span class="name"><span class="innerContentContainer">2. conditions 是所要符合的条件、若没有 where 则整个 table 的那个栏位都会全部被更改。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">删除资料</span></span><ul><li><span class="name"><span class="innerContentContainer">delete from table_name&nbsp;where conditions</span></span></li><li><span class="name"><span class="innerContentContainer">说明：删除符合条件的资料。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">处理时间数据</span></span><ul><li><span class="name"><span class="innerContentContainer">sqlite中存放的NSDate</span></span><ul><li><span class="name"><span class="innerContentContainer">coredata存储NSDate时，在内部是存储了字参考时间以来的NSTimeInterval（以秒计算），而这个参考时间根据 apple dateandtimes doc, NSDate computes time as seconds relative to an absolute reference time: the first instant of January 1, 2001 GMT.</span></span></li><li><span class="name"><span class="innerContentContainer">其实参考日期是2001.1.1，而非1970年1月1日，因此有些语言在直接读取coredata NSDate属性的sqlite Timestamp字段并转换成日期后，与原来存储的日期不一样了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关于where条件后面如果包含有日期的比较，不同数据库有不同的表达式。具体如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是access数据库，则为：where mydate&gt;#2000-01-01#</span></span></li><li><span class="name"><span class="innerContentContainer">如果是oracle数据库，则为：where mydate&gt;cast('2000-01-01' as date)</span></span></li><li><span class="name"><span class="innerContentContainer">或：where mydate&gt;to_date('2000-01-01','yyyy-mm-dd')</span></span></li><li><span class="name"><span class="innerContentContainer">在delphi中写成：</span></span></li><li><span class="name"><span class="innerContentContainer">thedate='2000-01-01';</span></span></li><li><span class="name"><span class="innerContentContainer">query1.sql.add('select * from abc where mydate&gt;cast('+''''+thedate+''''+' as date)');</span></span></li><li><span class="name"><span class="innerContentContainer">如果比较日期时间型，则为：</span></span></li><li><span class="name"><span class="innerContentContainer">where mydatetime&gt;to_date('2000-01-01 10:00:01','yyyy-mm-dd hh24:mi:ss')</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IOS上的日期比较</span></span><ul><li><span class="name"><span class="innerContentContainer">SELECT columnName FROM table WHERE (julianday(date(columnName))-julianday(date('now')))&gt;10</span></span></li><li><span class="name"><span class="innerContentContainer">julianday()这个函数会返回一个天数，从格林威治时间公元前4714年11月24号开始算起。date()函数返回一个以“YYYY-MM-DD”为格式的日期。因此上面那条语句也就不难理解了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一天：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where to_days(column_time) = to_days(now());</span></span></li><li><span class="name"><span class="innerContentContainer">select * from table where date(column_time) = curdate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一周：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一个月：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询一周：</span></span><ul><li><span class="name"><span class="innerContentContainer">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 WEEK) &lt;= date(column_time);</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SQL高级技巧</b></span></span><ul><li><span class="name"><span class="innerContentContainer">巧用update和join、count()更新统计字段</span></span><ul><li><span class="name"><span class="innerContentContainer">UPDATE property u</span></span><ul><li><span class="name"><span class="innerContentContainer">LEFT JOIN thing_property u_m ON u_m.property_UUID=u.property_UUID</span></span></li><li><span class="name"><span class="innerContentContainer">SET u.hot_index=(SELECT COUNT(property_UUID) FROM thing_property WHERE property_UUID=u.property_UUID)</span></span></li><li><span class="name"><span class="innerContentContainer">WHERE u.property_UUID=u_m.property_UUID ;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">插入时判断是否重复: insert or ignore into</span></span></li><li><span class="name"><span class="innerContentContainer">统计字数: SELECT&nbsp;sum(char_length(thing))&nbsp;FROM&nbsp;`thing_time`</span></span></li><li><span class="name"><span class="innerContentContainer">3个常用的PHP访问数据库的代码</span></span><ul><li><span class="name"><span class="innerContentContainer">返回一个数组的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">$tag_uuids = array();</span></span></li><li><span class="name"><span class="innerContentContainer">$sql_string&nbsp;= "select property_UUID, hot_index from property";</span></span></li><li><span class="name"><span class="innerContentContainer">$result&nbsp;=&nbsp;mysql_query($sql_string);</span></span></li><li><span class="name"><span class="innerContentContainer">if ($result == FALSE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$GLOBALS['log']-&gt;error("error: re_calc_tag_hot_index() -- $sql_string 。");</span></span></li><li><span class="name"><span class="innerContentContainer">return&nbsp;0;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">while($row =&nbsp;mysql_fetch_array($result)) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$tag_uuids[] = $row['property_UUID'];</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回一个值的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">$sql_string = "select count(*) from thing_time ";</span></span></li><li><span class="name"><span class="innerContentContainer">$result = mysql_query($sql_string);</span></span></li><li><span class="name"><span class="innerContentContainer">if($result == FALSE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$GLOBALS['log']-&gt;error("error: get_thing_count_by_period() -- $sql_string 。");</span></span></li><li><span class="name"><span class="innerContentContainer">return -1;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">$row = mysql_fetch_row($result); &nbsp; &nbsp;// 返回一行.</span></span></li><li><span class="name"><span class="innerContentContainer">if ($row == NULL) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return "";</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return $row[0];</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不需要返回值的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">$sql_string = "update thing_time set year_order=time where time_type=2";</span></span></li><li><span class="name"><span class="innerContentContainer">if (!mysql_query($sql_string)) {</span></span><ul><li><span class="name"><span class="innerContentContainer">$GLOBALS['log']-&gt;error("error: re_calc_year_order() -- $sql_string 。");</span></span></li><li><span class="name"><span class="innerContentContainer">return 0;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库平台</span></span><ul><li><span class="name"><span class="innerContentContainer">MySQL 数据类型详解 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">SQLite内建函数表</span></span><ul><li><span class="name"><span class="innerContentContainer">算术函数</span></span><ul><li><span class="name"><span class="innerContentContainer">abs(X): 返回给定数字表达式的绝对值。</span></span></li><li><span class="name"><span class="innerContentContainer">max(X,Y[,...]): 返回表达式的最大值。</span></span></li><li><span class="name"><span class="innerContentContainer">min(X,Y[,...]): 返回表达式的最小值。</span></span></li><li><span class="name"><span class="innerContentContainer">random(*): 返回随机数。</span></span></li><li><span class="name"><span class="innerContentContainer">round(X[,Y]): 返回数字表达式并四舍五入为指定的长度或精度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符处理函数</span></span><ul><li><span class="name"><span class="innerContentContainer">length(X): 返回给定字符串表达式的字符个数。</span></span></li><li><span class="name"><span class="innerContentContainer">lower(X): 将大写字符数据转换为小写字符数据后返回字符表达式。</span></span></li><li><span class="name"><span class="innerContentContainer">upper(X): 返回将小写字符数据转换为大写的字符表达式。</span></span></li><li><span class="name"><span class="innerContentContainer">substr(X,Y,Z): 返回表达式的一部分。</span></span></li><li><span class="name"><span class="innerContentContainer">randstr()</span></span></li><li><span class="name"><span class="innerContentContainer">quote(A)</span></span></li><li><span class="name"><span class="innerContentContainer">like(A,B): 确定给定的字符串是否与指定的模式匹配。</span></span></li><li><span class="name"><span class="innerContentContainer">glob(A,B)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">条件判断函数</span></span><ul><li><span class="name"><span class="innerContentContainer">coalesce(X,Y[,...])</span></span></li><li><span class="name"><span class="innerContentContainer">ifnull(X,Y)</span></span></li><li><span class="name"><span class="innerContentContainer">nullif(X,Y)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">集合函数</span></span><ul><li><span class="name"><span class="innerContentContainer">avg(X): 返回组中值的平均值。</span></span></li><li><span class="name"><span class="innerContentContainer">count(X): 返回组中项目的数量。</span></span></li><li><span class="name"><span class="innerContentContainer">max(X): 返回组中值的最大值。</span></span></li><li><span class="name"><span class="innerContentContainer">min(X): 返回组中值的最小值。</span></span></li><li><span class="name"><span class="innerContentContainer">sum(X): 返回表达式中所有值的和。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其他函数</span></span><ul><li><span class="name"><span class="innerContentContainer">typeof(X): 返回数据的类型。</span></span></li><li><span class="name"><span class="innerContentContainer">last_insert_rowid(): 返回最后插入的数据的ID。</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_version(*): 返回SQLite的版本。</span></span></li><li><span class="name"><span class="innerContentContainer">change_count(): 返回受上一语句影响的行数。</span></span></li><li><span class="name"><span class="innerContentContainer">last_statement_change_count()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">mysql允许我们在一条sql语句中批量插入数据</span></span><ul><li><span class="name"><span class="innerContentContainer">INSERT&nbsp;INTO&nbsp;example  (example_id,&nbsp;name,&nbsp;value,&nbsp;other_value)  VALUES</span></span><ul><li><span class="name"><span class="innerContentContainer">(100,&nbsp;'Name&nbsp;1',&nbsp;'Value&nbsp;1',&nbsp;'Other&nbsp;1'),</span></span></li><li><span class="name"><span class="innerContentContainer">(101,&nbsp;'Name&nbsp;2',&nbsp;'Value&nbsp;2',&nbsp;'Other&nbsp;2'),</span></span></li><li><span class="name"><span class="innerContentContainer">(102,&nbsp;'Name&nbsp;3',&nbsp;'Value&nbsp;3',&nbsp;'Other&nbsp;3'),</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SQL性能优化  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>为查询缓存优化你的查询</b></span></span><ul><li><span class="name"><span class="innerContentContainer">大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一.</span></span></li><li><span class="name"><span class="innerContentContainer">当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</span></span></li><li><span class="name"><span class="innerContentContainer">某些查询语句会让MySQL不使用缓存。需要避免这些代码. </span></span></li><li><span class="name"><span class="innerContentContainer">比如:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 查询缓存不开启</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT username FROM user WHERE signup_date &gt;= CURDATE()");</span></span></li><li><span class="name"><span class="innerContentContainer">// 开启查询缓存</span></span></li><li><span class="name"><span class="innerContentContainer">$today =&nbsp;date("Y-m-d");</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT username FROM user WHERE signup_date &gt;= '$today'");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">函数 CURDATE() 使得MySQL查询缓存不起作用。像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。</span></span></li><li><span class="name"><span class="innerContentContainer">所以需要用一个变量来代替MySQL的函数，从而开启缓存。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EXPLAIN 你的 SELECT 查询</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。</span></span></li><li><span class="name"><span class="innerContentContainer">EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。</span></span></li><li><span class="name"><span class="innerContentContainer">挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：</span></span></li><li><span class="name"><span class="innerContentContainer">当我们为 group_id 字段加上索引后：</span></span></li><li><span class="name"><span class="innerContentContainer">我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当只要一行数据时使用 LIMIT 1</span></span><ul><li><span class="name"><span class="innerContentContainer">当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</span></span></li><li><span class="name"><span class="innerContentContainer">在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）</span></span></li><li><span class="name"><span class="innerContentContainer">// 没有效率的：</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT * FROM user WHERE country = 'China'");</span></span></li><li><span class="name"><span class="innerContentContainer">if (mysql_num_rows($r) &gt; 0) {...}</span></span></li><li><span class="name"><span class="innerContentContainer">// 有效率的：</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT 1 FROM user WHERE country = 'China' LIMIT 1");</span></span></li><li><span class="name"><span class="innerContentContainer">if (mysql_num_rows($r) &gt; 0) {...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">为搜索字段建索引</span></span><ul><li><span class="name"><span class="innerContentContainer">索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。</span></span></li><li><span class="name"><span class="innerContentContainer">从上图你可以看到那个搜索字串 “last_name LIKE ‘a%’”，一个是建了索引，一个是没有索引，性能差了4倍左右。</span></span></li><li><span class="name"><span class="innerContentContainer">另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用MySQL全文索引 或是自己做一个索引（比如说：搜索关键词或是Tag什么的）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在Join表的时候使用相当类型的例，并将其索引</span></span><ul><li><span class="name"><span class="innerContentContainer">如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。</span></span></li><li><span class="name"><span class="innerContentContainer">而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）</span></span></li><li><span class="name"><span class="innerContentContainer">// 在state中查找company</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT company_name FROM users</span></span></li><li><span class="name"><span class="innerContentContainer">LEFT JOIN companies ON (users.state = companies.state)</span></span></li><li><span class="name"><span class="innerContentContainer">WHERE users.id = $user_id");</span></span></li><li><span class="name"><span class="innerContentContainer">// 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">千万不要 ORDER BY RAND()</span></span><ul><li><span class="name"><span class="innerContentContainer">想打乱返回的数据行？有N种方法可以达到这个目的。用 ORDER BY RAND() 性能极其可怕.</span></span></li><li><span class="name"><span class="innerContentContainer">// 千万不要这样做：</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT username FROM user ORDER BY RAND() LIMIT 1");</span></span></li><li><span class="name"><span class="innerContentContainer">// 这要会更好：</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT count(*) FROM user");</span></span></li><li><span class="name"><span class="innerContentContainer">$d = mysql_fetch_row($r);</span></span></li><li><span class="name"><span class="innerContentContainer">$rand = mt_rand(0,$d[0] - 1);</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT username FROM user LIMIT $rand, 1");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">避免 SELECT *</span></span><ul><li><span class="name"><span class="innerContentContainer">从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。</span></span></li><li><span class="name"><span class="innerContentContainer">应该养成一个需要什么就取什么的好的习惯。</span></span></li><li><span class="name"><span class="innerContentContainer">// 不推荐</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT * FROM user WHERE user_id = 1");</span></span></li><li><span class="name"><span class="innerContentContainer">$d = mysql_fetch_assoc($r);</span></span></li><li><span class="name"><span class="innerContentContainer">echo "Welcome {$d['username']}";</span></span></li><li><span class="name"><span class="innerContentContainer">// 推荐</span></span></li><li><span class="name"><span class="innerContentContainer">$r = mysql_query("SELECT username FROM user WHERE user_id = 1");</span></span></li><li><span class="name"><span class="innerContentContainer">$d = mysql_fetch_assoc($r);</span></span></li><li><span class="name"><span class="innerContentContainer">echo "Welcome {$d['username']}";</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">永远为每张表设置一个ID</span></span><ul><li><span class="name"><span class="innerContentContainer">我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</span></span></li><li><span class="name"><span class="innerContentContainer">就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。</span></span></li><li><span class="name"><span class="innerContentContainer">而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……</span></span></li><li><span class="name"><span class="innerContentContainer">在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用 ENUM 而不是 VARCHAR</span></span><ul><li><span class="name"><span class="innerContentContainer">ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</span></span></li><li><span class="name"><span class="innerContentContainer">如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</span></span></li><li><span class="name"><span class="innerContentContainer">MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从 PROCEDURE ANALYSE() 取得建议</span></span><ul><li><span class="name"><span class="innerContentContainer">PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。</span></span></li><li><span class="name"><span class="innerContentContainer">在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">尽可能的使用 NOT NULL</span></span><ul><li><span class="name"><span class="innerContentContainer">除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。</span></span></li><li><span class="name"><span class="innerContentContainer">首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)</span></span></li><li><span class="name"><span class="innerContentContainer">不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。</span></span></li><li><span class="name"><span class="innerContentContainer">下面摘自MySQL自己的文档：</span></span></li><li><span class="name"><span class="innerContentContainer">“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Prepared Statements</span></span><ul><li><span class="name"><span class="innerContentContainer">Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</span></span></li><li><span class="name"><span class="innerContentContainer">Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。</span></span></li><li><span class="name"><span class="innerContentContainer">在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。</span></span></li><li><span class="name"><span class="innerContentContainer">虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。</span></span></li><li><span class="name"><span class="innerContentContainer">当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。</span></span></li><li><span class="name"><span class="innerContentContainer">在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展 或是使用数据库抽象层，如： PDO.</span></span></li><li><span class="name"><span class="innerContentContainer">// 创建 prepared statement</span></span></li><li><span class="name"><span class="innerContentContainer">if ($stmt =&nbsp;$mysqli-&gt;prepare("SELECT username FROM user WHERE state=?")) {</span></span></li><li><span class="name"><span class="innerContentContainer">// 绑定参数</span></span></li><li><span class="name"><span class="innerContentContainer">$stmt-&gt;bind_param("s", $state);</span></span></li><li><span class="name"><span class="innerContentContainer">// 执行</span></span></li><li><span class="name"><span class="innerContentContainer">$stmt-&gt;execute();</span></span></li><li><span class="name"><span class="innerContentContainer">// 绑定结果</span></span></li><li><span class="name"><span class="innerContentContainer">$stmt-&gt;bind_result($username);</span></span></li><li><span class="name"><span class="innerContentContainer">// 移动游标</span></span></li><li><span class="name"><span class="innerContentContainer">$stmt-&gt;fetch();</span></span></li><li><span class="name"><span class="innerContentContainer">printf("%s is from %s\n", $username, $state);</span></span></li><li><span class="name"><span class="innerContentContainer">$stmt-&gt;close();</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">把IP地址存成 UNSIGNED INT</span></span><ul><li><span class="name"><span class="innerContentContainer">很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。</span></span></li><li><span class="name"><span class="innerContentContainer">我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。</span></span></li><li><span class="name"><span class="innerContentContainer">而你的查询，你可以使用 <a class="contentLink" target="_blank" rel="noreferrer" href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-aton">INET_ATON()</a> 来把一个字符串IP转成一个整形，并使用 <a class="contentLink" target="_blank" rel="noreferrer" href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-ntoa">INET_NTOA()</a> 把一个整形转成一个字符串IP。在PHP中，也有这样的函数 <a class="contentLink" target="_blank" rel="noreferrer" href="http://php.net/manual/en/function.ip2long.php">ip2long()</a> 和&nbsp;<a class="contentLink" target="_blank" rel="noreferrer" href="http://us.php.net/manual/en/function.long2ip.php">long2ip()</a>。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">固定长度的表会更快</span></span><ul><li><span class="name"><span class="innerContentContainer">如果表中的所有字段都是“固定长度”的，整个表会被认为是 <a class="contentLink" target="_blank" rel="noreferrer" href="http://dev.mysql.com/doc/refman/5.1/en/static-format.html">“static” 或 “fixed-length”</a>。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</span></span></li><li><span class="name"><span class="innerContentContainer">固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</span></span></li><li><span class="name"><span class="innerContentContainer">并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</span></span></li><li><span class="name"><span class="innerContentContainer">使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">垂直分割</span></span><ul><li><span class="name"><span class="innerContentContainer">“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）</span></span></li><li><span class="name"><span class="innerContentContainer">示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。</span></span></li><li><span class="name"><span class="innerContentContainer">示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。</span></span></li><li><span class="name"><span class="innerContentContainer">另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是指数级的下降。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拆分大的 DELETE 或 INSERT 语句</span></span><ul><li><span class="name"><span class="innerContentContainer">如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</span></span></li><li><span class="name"><span class="innerContentContainer">Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</span></span></li><li><span class="name"><span class="innerContentContainer">如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。</span></span></li><li><span class="name"><span class="innerContentContainer">所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：</span></span></li><li><span class="name"><span class="innerContentContainer">while (1) {</span></span></li><li><span class="name"><span class="innerContentContainer">//每次只做1000条</span></span></li><li><span class="name"><span class="innerContentContainer">mysql_query("DELETE FROM logs WHERE log_date &lt;= '2009-11-01' LIMIT 1000");</span></span></li><li><span class="name"><span class="innerContentContainer">if (mysql_affected_rows() == 0) {</span></span></li><li><span class="name"><span class="innerContentContainer">// 没得可删了，退出！</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 每次都要休息一会儿</span></span></li><li><span class="name"><span class="innerContentContainer">usleep(50000);</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">越小的列会越快</span></span><ul><li><span class="name"><span class="innerContentContainer">对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</span></span></li><li><span class="name"><span class="innerContentContainer">参看 MySQL 的文档 <a class="contentLink" target="_blank" rel="noreferrer" href="http://dev.mysql.com/doc/refman/5.0/en/storage-requirements.html">Storage Requirements</a> 查看所有的数据类型。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。</span></span></li><li><span class="name"><span class="innerContentContainer">当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看<a class="contentLink" target="_blank" rel="noreferrer" href="http://news.slashdot.org/article.pl?sid=06/11/09/1534204">Slashdot的例子</a>（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">选择正确的存储引擎</span></span><ul><li><span class="name"><span class="innerContentContainer">在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《<a class="contentLink" target="_blank" rel="noreferrer" href="http://coolshell.cn/articles/652.html">MySQL: InnoDB 还是 MyISAM?</a>》讨论和这个事情。</span></span></li><li><span class="name"><span class="innerContentContainer">MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。</span></span></li><li><span class="name"><span class="innerContentContainer">另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</span></span></li><li><span class="name"><span class="innerContentContainer">InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用一个对象关系映射器（Object Relational Mapper）</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。</span></span></li><li><span class="name"><span class="innerContentContainer">ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。</span></span></li><li><span class="name"><span class="innerContentContainer">ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。目前，个人最喜欢的PHP的ORM是：<a class="contentLink" target="_blank" rel="noreferrer" href="http://www.doctrine-project.org/">Doctrine</a>。&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">小心“永久链接”</span></span><ul><li><span class="name"><span class="innerContentContainer">“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。</span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://php.net/manual/en/function.mysql-pconnect.php">PHP手册：mysql_pconnect()</a></span></span></li><li><span class="name"><span class="innerContentContainer">在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>尽可能不用 in子句:  性能很差。不如用联合 inner。</b></span></span></li><li><span class="name"><span class="innerContentContainer">尽可能不用 distinct</span></span><ul><li><span class="name"><span class="innerContentContainer">大多数情况下，Distinct函数都会导致对最终结果集完成一次排序，因此，这就成为成本最昂贵的排序之一。Distinct一直是SQL语言中成本最高的函数之一。解决方法有两个：</span></span></li><li><span class="name"><span class="innerContentContainer">使用GroupBy（V9之前），这会利用关联索引来消除为确定唯一性所导致的排序。</span></span></li><li><span class="name"><span class="innerContentContainer">使用一个Exists子查询重写查询。如果某个表可能导致重复（由于是一对多关系），但是这个表中并不包含结果集将返回的数据，这种情况下这种方法就很适用。&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">推荐使用COMMIT</span></span><ul><li><span class="name"><span class="innerContentContainer">SQLite保存大数据集非常非常快。例如地图程序应该把图块缓存在SQLite里。最昂贵的部分是硬盘I/O。</span></span></li><li><span class="name"><span class="innerContentContainer">要避免在大块之间产生大量的小的写入，就需要用 BEGIN和 COMMIT。</span></span></li><li><span class="name"><span class="innerContentContainer">我们使用2秒钟的计时器去重置每次新的提交。一旦计时器国企，就发送COMMIT，这样所有些操作就写到一个大块里面了。</span></span></li><li><span class="name"><span class="innerContentContainer">SQLLite把事务数据保存在磁盘上，使用Begin/End包装可以避免产生大量的事务文件，把所有的事务写到一个文件里。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用多线程</span></span><ul><li><span class="name"><span class="innerContentContainer">当SQLite在主线程的时候会阻塞你的界面。</span></span></li><li><span class="name"><span class="innerContentContainer">如果你执行非常长的查询，一个好办法是把你的查询保存成静态对象，然后在另一个线程查询。</span></span></li><li><span class="name"><span class="innerContentContainer">把所有会修改数据库的查询用@synchronize() {}块包起来。</span></span></li><li><span class="name"><span class="innerContentContainer">短查询就放在主线程，简单方便。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在多线程里面使用SQLite还有一个更简单的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">用sqlite3_open_v2打开数据库，flag用SQLITE_OPEN_FULLMUTEX，这样SQLite的所有函数就是线程安全的了，不需要synchronize了。</span></span></li><li><span class="name"><span class="innerContentContainer">不过不确定哪个效率更高。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>