<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>22-FWK-AMS</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks\base\core\java\android\app</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks\base\services\java\com\android\server\am</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks\base\services\java\com\android\server\wm</span></span></li><li><span class="name"><span class="innerContentContainer">四大组件都由AMS统一管理生命周期. </span></span></li><li><span class="name"><span class="innerContentContainer">应用启动流程  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">先创建Application;</span></span></li><li><span class="name"><span class="innerContentContainer">启动应用启动的主Activity;</span></span></li><li><span class="name"><span class="innerContentContainer">执行该Activity的onCreate()，onStart()，onResume()方法;</span></span></li><li><span class="name"><span class="innerContentContainer">在onResume()中,  向WMS添加注册的应用主窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">显示主窗口.</span></span></li><li><span class="name"><span class="innerContentContainer">如果在 onCreate()，onStart()，onResume() 中做了耗时操作, 则应用启动会出现暂时的黑屏相信.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Activity启动流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">无论是Launcher(Launcher也是应用)启动一个activity, 还是应用内部启动一个activity, 第一步都是应用线程调用 startActivity(), 该函数通过Binder调用ams的 startActivity().</span></span></li><li><span class="name"><span class="innerContentContainer">ams 调用<b>Zygote的fork(), 复制创建一个虚拟机进程. 然后在进程上创建 ActivityThread. 相关代码在 </b>scheduleLaunchActivity() 中.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>ActivityThread 负责创建对应的Activity对象, </b>使用ClassLoader从程序文件中装载指定的Activity对应的Class文件, <b>加载布局和资源.  </b></span></span></li><li><span class="name"><span class="innerContentContainer">最后会调用 attach方法，然后在 PolicyManager实现一个IPolicy接口，接着实现一个 Policy对象。</span></span></li><li><span class="name"><span class="innerContentContainer">接着调用 makeNewWindow(Context)方法，该方法会返回一个 PhoneWindow对象，而 PhoneWindow 是Window的子类。</span></span></li><li><span class="name"><span class="innerContentContainer">在这个 PhoneWindow 持有一个DecorView的内部类，是所有应用窗口的根 View， 直接控制 Activity是否显示。</span></span></li><li><span class="name"><span class="innerContentContainer">DecorView里面有一个 LinearLayout。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout里面又有两个 FrameLayout, 他们分别拿来装 ActionBar(状态栏)和CustomView。</span></span></li><li><span class="name"><span class="innerContentContainer">而我们在 setContentView() 加载的布局就放到这个 <b>CustomView </b>中。</span></span></li><li><span class="name"><span class="innerContentContainer">整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。</span></span></li><li><span class="name"><span class="innerContentContainer">View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>在这个过程中, 会回调用户</b>activity<b>的 onCreate(), onStart(), onResume(). </b></span></span></li><li><span class="name"><span class="innerContentContainer">梳理过程如下: activity -<b>binder</b>- AMS -<b>biner</b>- ActivityThread - PhoneWindow - DecorView - ActionBar+CustomView - View.</span></span></li><li><span class="name"><span class="innerContentContainer">执行完onResume()完之后，并且界面没有更新，应用UI主线程的looper会进入MessageQueue.nativePollOnce()。当有消息来临的时候，此looper便会被wake，执行消息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理activity生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer">创建过程中, Activity会先后调用<b>onCreate(), onStart(), onResume(). </b></span></span></li><li><span class="name"><span class="innerContentContainer">销毁过程中, 会先后调用 onPause() 和 onStop+onDestroy方法. 其中,调用完onPause()方法后不能立即调用onStop()方法，因为这个时候我们需要先调用前一个页面的<b>onResume</b>()方法, 所以我们需要先切回到AMS进程去处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>任务栈: 对Activity进行管理  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">APP一般是由多个Activity构成的。Android用 Task(任务)的概念将多个相关的Activity放在<b> Back Stack（回退堆栈）</b>中管理，以便进行Activity间的跳转与返回.</span></span></li><li><span class="name"><span class="innerContentContainer">注意，是相关的Activity，而不是同一个app的activity。有时候，同一个app的activity在不同的task （参见 taskAffinity ）；有时候，不同app的activity在同一个task。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>任务栈, 也叫task 栈, 或者 back栈</b></span></span><ul><li><span class="name"><span class="innerContentContainer">是一种用来放置Activity实例的容器，以栈的形式进行盛放Activity实例，也就是所谓的先进后出(LIFO).</span></span></li><li><span class="name"><span class="innerContentContainer">处于最顶部的叫栈顶，最底部叫栈底.</span></span></li><li><span class="name"><span class="innerContentContainer">常用操作: 入栈(<b>push</b>)，出栈(<b>pop</b>)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>栈内切换</b></span></span><ul><li><span class="name"><span class="innerContentContainer">当用户在主屏幕点击图标打开一个新的App，此时会创建一个<b>新的Task</b>. 然后开始把新产生的Activity入栈, 作为栈顶. </span></span></li><li><span class="name"><span class="innerContentContainer">当切换到新的Activity，那么该Activity会被压入栈中，成为新的栈顶。</span></span></li><li><span class="name"><span class="innerContentContainer">而当用户点击Back键，栈顶的Activity出栈，紧随其后的Activity来到栈顶。</span></span></li><li><span class="name"><span class="innerContentContainer">有一种特殊情况, 当我们在通讯录的APP中打开了短信APP的页面，但是此时不会新建一个栈，而是继续添加到栈1中。</span></span></li><li><span class="name"><span class="innerContentContainer">这是 Android推崇一种用户体验方式，即不同应用程序之间的切换能使用户感觉就像是同一个应用程序，连贯的用户体验，官方称其为seamless (无缝衔接）.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>栈间切换</b></span></span><ul><li><span class="name"><span class="innerContentContainer">同一时间系统会有多个task. 这些task 也组成一个 task堆栈. </span></span></li><li><span class="name"><span class="innerContentContainer">用户按下Home键回到桌面，再启动另一个应用，这时候<b>Task1</b>就被移到后台，成为<b>后台任务栈</b>，而刚启动的那个<b>Task2</b>就被调到前台，成为<b>前台任务栈</b>. </span></span></li><li><span class="name"><span class="innerContentContainer">点击recent键，打开之前的程序，然后<b>Task1</b>又回到前台了。</span></span></li><li><span class="name"><span class="innerContentContainer">如果Task1是通讯录的APP中打开了短信APP的页面, 现在回到桌面, 当我们点击主屏幕上通信录的图标打开APP，此时也不会创建新的栈，而是Task1回到前台。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意: 当调用到 onNewIntent(intent)的时候，需要使用 setIntent(intent)赋值给Activity的Intent. 否则后续的 getIntent()都是得到老的Intent。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>进程优先级 adj <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">进程 omm_adj的大小跟进程的类型以及进程被调度的次序有关。</span></span></li><li><span class="name"><span class="innerContentContainer">在init.rc中，定义init进程的pid为1，omm_adj 被配置为-16，永远不会被杀死。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>ActivityManagerService 负责定义各种进程的 oom_adj.  </b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>adj 有如下值(也即进程有如下分类):    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">NATIVE_ADJ = -17;  // native进程（不被系统管理）</span></span></li><li><span class="name"><span class="innerContentContainer">SYSTEM_ADJ = -16;  // 系统进程, 永远不会被杀死. init进程就是-16.</span></span></li><li><span class="name"><span class="innerContentContainer">CORE_SERVER_ADJ = -12;   // 核心服务, 永远不会被杀死。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>FOREGROUND_APP_ADJ = 0;  // 前台进程, 一个应用切换到前台, 就会被赋值0. </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>特殊情况: talkback 没有界面, 但是只要打开, 其 adj 就是0 , 和前台进程优先级一样.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>VISIBLE_APP_ADJ  = 1;   // 用户可见进程. 包括systemui(状态栏, 导航栏等), widget控件, 输入法窗口等.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>PERCEPTIBLE_APP_ADJ = 2;  // 可感知进程. 比如后台音乐播放</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>HEAVY_WEIGHT_APP_ADJ = 4;  // 后台重量级进程 (在 system/rootdir/init.rc 中定义)</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>SERVICE_ADJ = 5;  // 服务进程</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>HOME_APP_ADJ = 6;  // </b>即 Launcher. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>PREVIOUS_APP_ADJ = 7;   // 上一个App的进程(往往通过back键或者home键切走的那个进程) . 优先级比服务进程低.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>CACHED_APP_MIN_ADJ = 9;  // 不可见进程的adj最小值. app切换到后台即是这个adj值.</b></span></span><ul><li><span class="name"><span class="innerContentContainer">后台进程的管理策略有多种：</span></span></li><li><span class="name"><span class="innerContentContainer">有较为积极的方式，一旦程序到达后台立即终止，这种方式会提高程序的运行速度，但无法加速程序的再次启动；</span></span></li><li><span class="name"><span class="innerContentContainer">也有较消极的方式，尽可能多的保留后台程序，虽然可能会影响到单个程序的运行速度，但在再次启动已启动的程序时，速度会有所提升。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内容供应节点（content provider）: 为保证provider所在进程的优先级高于或等于 客户端进程, 所以在被使用时, 它的adj和使用者一样, 使用结束后再恢复为空.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml 中相关的配置项</span></span><ul><li><span class="name"><span class="innerContentContainer">taskAffinity 和 allowTaskReparenting <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">默认情况下，一个应用程序中的所有activity使用同一个Affinity，这让它们属于同一个Task。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 taskAffinity可指定该activity使用独立的Task。</span></span></li><li><span class="name"><span class="innerContentContainer">不同应用程序中的Activity可以共享同一个Affinity，同一个应用程序中的不同Activity 也可以设置成不同的Affinity。</span></span></li><li><span class="name"><span class="innerContentContainer">Affinity属性在2种情况下起作用：</span></span></li><li><span class="name"><span class="innerContentContainer">1）当启动 activity的Intent对象包含FLAG_ACTIVITY_NEW_TASK标记： 当传递给 startActivity()的Intent对象包含 FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的Activity寻找与当前Activity不同Task。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果要启动的 Activity的Affinity属性与当前所有的Task的Affinity属性都不相同，系统会新建一个带该Affinity属性的Task，并将要启动的Activity压到新建的Task栈中；</span></span></li><li><span class="name"><span class="innerContentContainer">否则将Activity压入同一Affinity属性的栈中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2）如果一个activity的 allowTaskReparenting属性为true， 那么它可以从一个Task（Task1）移到另外一个有相同Affinity的Task（Task2）中（Task2带到前台时）。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个APP从用户角度来看包含了多个"应用程序"，就可能需要对那些 Activity赋不同的Affinity值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Intent 中可以指定启动标志, 常见的包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_NEW_TASK: 放入新的task堆栈. 见上.</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_CLEAR_TOP</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_SINGLE_TOP</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>launchMode  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">activity启动模式, 常用且关键. 值域如下:</span></span></li><li><span class="name"><span class="innerContentContainer">standard(默认): 在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，会在A的上面再次启动一个A的实例，即当前的桟中的状态为A--&gt;A。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleTop: 如果一个以singleTop模式启动的Activity的实例已经存在于当前任务栈的栈顶， 那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例， 并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中， 那么再启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。 这时任务栈中还是这有一个A的实例。</span></span></li><li><span class="name"><span class="innerContentContainer">如果以singleTop模式启动的activity的一个实例已经存在与任务栈中，<b>但是不在栈顶</b>，那么它的行为和standard模式相同，也会创建多个实例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleTask: 创建一个新的实例时, 如果该实例在当前栈中已经存在，则不管它在不在栈顶, 直接将它移动到顶部，并且清空任务栈中这个activity上面所有的activity。</span></span><ul><li><span class="name"><span class="innerContentContainer">intent将被通过onNewIntent()发送.</span></span></li><li><span class="name"><span class="innerContentContainer">singleTask相当于singleTop的彻底版.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleInstance: 单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。比如来电界面.</span></span><ul><li><span class="name"><span class="innerContentContainer">当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">clearTaskOnLaunch: 清空栈</span></span><ul><li><span class="name"><span class="innerContentContainer">默认情况下, 当用户长时间离开Task（当前task被转移到后台）时，系统会清除task中栈底Activity外的所有Activity 。这样，当用户返回到Task时，只留下那个task最初始的Activity了。</span></span></li><li><span class="name"><span class="innerContentContainer">可通过修改 clearTaskOnLaunch 来改变这种行为. 其值域是: </span></span></li><li><span class="name"><span class="innerContentContainer">alwaysRetainTaskState: 如果栈底Activity的这个属性被设置为true，上述的情况就不会发生。 Task中的所有activity将被长时间保存。</span></span></li><li><span class="name"><span class="innerContentContainer">clearTaskOnLaunch: 如果栈底activity的这个属性被设置为true，一旦用户离开Task， 则 Task栈中的Activity将被清空到只剩下栈底activity。这种情况刚好与 alwaysRetainTaskState相反。即使用户只是短暂地离开，task也会返回到初始状态 （只剩下栈底acitivty）。</span></span></li><li><span class="name"><span class="innerContentContainer">finishOnTaskLaunch: 与clearTaskOnLaunch相似，但它只对单独的activity操 作，而不是整个Task。它可以结束任何Activity，包括栈底的Activity。 当它设置为true时，当前的Activity只在当前会话期间作为Task的一部分存在， 当用户退出Activity再返回时，它将不存在。</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">管理Service生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer">Service是否是独立进程?</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Service没有设定属性android:process=”:remote”, Service会和Activity是在同一个进程中的，即主线程.</span></span></li><li><span class="name"><span class="innerContentContainer">如果Service设定属性android:process=”:remote”, 那么就会创建新进程.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Service的启动方式有两种：</span></span></li><li><span class="name"><span class="innerContentContainer">startService</span></span><ul><li><span class="name"><span class="innerContentContainer">ContextWrapper类中的startService(), 调用了ContextImpl的startService()。</span></span></li><li><span class="name"><span class="innerContentContainer">在startServiceCommon()中通过binder，调用了AMS服务的startService()。</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService.startServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">在AMS服务中，每个Service都使用一个ServiceRecord对象来描述，然后调用retrieveServiceLocked方法来查找一个和目标Service对应的ServiceRecord，最后将这个ServiceRecord对象封装在ServiceLookupResult对象中。</span></span></li><li><span class="name"><span class="innerContentContainer">查找方案是首先从AMS服务中的ServiceMap中查找，ServiceMap中保存了AMS服务中所有激活的Service信息，如果在ServiceMap中没有找到，说明该Service还没有启动。那么就需要从PMS服务中查找目标Service的信息并创建一个ServiceRecord对象。最后把它保存在对应的ServiceMap集合中。</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService. bringUpServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService.realStartServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityThread.handleCreateService()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bindService</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理BroadcastReceiver生命周期，分发和接受Broadcast</span></span></li><li><span class="name"><span class="innerContentContainer">管理ContentProvider生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/c35313c52eef">https://www.jianshu.com/p/c35313c52eef</a></span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider&nbsp;封装了数据的跨进程传输，我们可以直接使用 getContentResolver() 拿到&nbsp;ContentResolver&nbsp;进行增删改查即可。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">处理应用程序的Crash</span></span></li></ul>
  </body>
</html>