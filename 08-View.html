<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">08-View</span></span><ul><li><span class="name"><span class="innerContentContainer">https://www.runoob.com/w3cnote/android-tutorial-intro.html</span></span></li><li><span class="name"><span class="innerContentContainer">Android的图形界面都是由 View和 ViewGroup以及他们的子类构成的.</span></span><ul><li><span class="name"><span class="innerContentContainer">View：所有可视化控件的父类,提供组件描绘和时间处理方法.</span></span></li><li><span class="name"><span class="innerContentContainer">ViewGroup：View类的子类，可以拥有子控件,可以看作是容器.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">View的可见性</span></span><ul><li><span class="name"><span class="innerContentContainer">View.VISIBLE: 0, 可见.</span></span></li><li><span class="name"><span class="innerContentContainer">View.INCISIBLE: 4, 不可见. 占用layout空间, 不重新绘制.</span></span></li><li><span class="name"><span class="innerContentContainer">View,GONE: 8, 不可见. 不再占用layout空间, 会重新绘制.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看当前窗口的Layout</span></span><ul><li><span class="name"><span class="innerContentContainer">AS/IDEA: Tools - Layout Inspector</span></span></li><li><span class="name"><span class="innerContentContainer">AS monitor: "Open Perspective" - "Hierarchy View" - "Tree View"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>7种布局</b></span></span><ul><li><span class="name"><span class="innerContentContainer">LinearLayout: 线性布局</span></span><ul><li><span class="name"><span class="innerContentContainer">weight(权重)属性，等比例划分, 非常强大.</span></span></li><li><span class="name"><span class="innerContentContainer">缺点: 当界面比较复杂的时候，需要嵌套多层的 LinearLayout,这样就会降低UI Render的效率(渲染速度),而且如果是 listview或者 GridView上的 item,效率会更低.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RelativeLayout: 相对布局  --推荐用这个</span></span><ul><li><span class="name"><span class="innerContentContainer">优点: 很复杂的界面, 也可以一层搞定.</span></span></li><li><span class="name"><span class="innerContentContainer">根据父容器定位</span></span></li><li><span class="name"><span class="innerContentContainer">根据兄弟组件定位</span></span></li><li><span class="name"><span class="innerContentContainer">margin与padding的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">margin代表的是偏移,比如 marginleft = "5dp"表示组件离容器左边缘偏移5dp; </span></span></li><li><span class="name"><span class="innerContentContainer">padding代表的则是填充,而填充的对象针对的是组件中的元素,比如为 TextView 设置paddingleft = "5dp", 是在组件里的元素的左边填充5dp的空间.</span></span></li><li><span class="name"><span class="innerContentContainer">margin针对的是容器中的组件，而padding针对的是组件中的元素.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TableLayout: 表格布局</span></span><ul><li><span class="name"><span class="innerContentContainer">如果我们直接往 TableLayout 中添加组件的话,那么这个组件将占满一行.</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们想一行上有多个组件的话,就要添加一个 TableRow 的容器,把组件都丢到里面.</span></span></li><li><span class="name"><span class="innerContentContainer">tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定.</span></span></li><li><span class="name"><span class="innerContentContainer">tablerow的 layout_width 属性, 默认是 fill_parent 的, 设置成其他的值也不会生效. 但是layout_height默认是wrapten-content的,我们却可以自己设置大小.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FrameLayout: 帧布局</span></span><ul><li><span class="name"><span class="innerContentContainer">这个布局直接在屏幕上开辟出一块空白的区域,当我们往里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AbsoluteLayout: 绝对布局  --不要使用这个</span></span></li><li><span class="name"><span class="innerContentContainer">GridLayout: 网格布局</span></span><ul><li><span class="name"><span class="innerContentContainer">GridLayout 相当于 TableLayout的升级版, 较之后者更好用. 比如: </span></span><ul><li><span class="name"><span class="innerContentContainer">可以自己设置布局中组件的排列方式</span></span></li><li><span class="name"><span class="innerContentContainer">可以自定义网格布局有多少行,多少列</span></span></li><li><span class="name"><span class="innerContentContainer">可以直接设置组件位于某行某列</span></span></li><li><span class="name"><span class="innerContentContainer">可以设置组件横跨几行或者几列</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GridLayout是4.0新增的, 低版本sdk如何使用 GridLayout?</span></span><ul><li><span class="name"><span class="innerContentContainer">只需要导入v7包的gridlayout包即可! v7包一般在sdk下的:sdk\extras\android\support\v7\gridlayout目录下.</span></span></li><li><span class="name"><span class="innerContentContainer">用的时候,标签却是这样写的:  &lt;android.support.v7.widget.GridLayout&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ConstraintLayout: 约束布局</span></span><ul><li><span class="name"><span class="innerContentContainer">它是Android Studio 2.2中主要的新增功能之一。</span></span></li><li><span class="name"><span class="innerContentContainer">它适合使用可视化的方式来编写界面，而不适合xml方式来编写。</span></span></li><li><span class="name"><span class="innerContentContainer">它还可以有效地解决布局嵌套过多的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">为了使用ConstraintLayout，需要在 app/build.gradle 中添加ConstraintLayout的依赖</span></span><ul><li><span class="name"><span class="innerContentContainer">dependencies {</span></span><ul><li><span class="name"><span class="innerContentContainer">compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4'</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">邮件点击 layout文件，可以把现在的布局改成ConstraintLayout。</span></span></li><li><span class="name"><span class="innerContentContainer">然后就可以拖控件，安排位置，修改属性了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TextView(文本框)</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>id：</b>为TextView设置一个组件id，根据id，我们可以在Java代码中通过findViewById()的方法获取到该对象，然后进行相关属性的设置，又或者使用RelativeLayout时，参考组件用的也是id！</span></span></li><li><span class="name"><span class="innerContentContainer"><b>layout_width：</b>组件的宽度，一般写：**wrap_content**或者**match_parent(fill_parent)**，前者是控件显示的内容多大，控件就多大，而后者会填满该控件所在的父容器；当然也可以设置成特定的大小，比如我这里为了显示效果，设置成了200dp。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>layout_height：</b>组件的宽度，内容同上。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>gravity：</b>设置控件中内容的对齐方向，TextView中是文字，ImageView中是图片等等。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>text：</b>设置显示的文本内容，一般我们是把字符串写到string.xml文件中，然后通过@String/xxx取得对应的字符串内容的.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>textColor：</b>设置字体颜色，同上，通过 colors.xml资源来引用，别直接这样写！</span></span></li><li><span class="name"><span class="innerContentContainer"><b>textStyle：</b>设置字体风格，三个可选值：normal(无效果)，bold(加粗)，italic(斜体)</span></span></li><li><span class="name"><span class="innerContentContainer"><b>textSize：</b>字体大小，单位一般是用sp</span></span></li><li><span class="name"><span class="innerContentContainer"><b>background：</b>控件的背景颜色，可以理解为填充整个控件的颜色，可以是图片.</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;solid&nbsp;android:color = "xxx"&gt; 这个是设置背景颜色的</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;stroke&nbsp;android:width = "xdp" android:color="xxx"&gt; 这个是设置边框的粗细,以及边框颜色的</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;padding&nbsp;androidLbottom = "xdp"...&gt; 这个是设置边距的</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;corners&nbsp;android:topLeftRadius="10px"...&gt; 这个是设置圆角的</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;gradient&gt; 这个是设置渐变色的,可选属性有:&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">startColor:起始颜色</span></span></li><li><span class="name"><span class="innerContentContainer">endColor:结束颜色</span></span></li><li><span class="name"><span class="innerContentContainer">centerColor:中间颜色</span></span></li><li><span class="name"><span class="innerContentContainer">angle:方向角度,等于0时,从左到右,然后逆时针方向转,当 angle = 90度时从下往上</span></span></li><li><span class="name"><span class="innerContentContainer">type:设置渐变的类型</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;corners   // 设置四个圆角的半径</span></span><ul><li><span class="name"><span class="innerContentContainer">android:bottomLeftRadius="10px"</span></span></li><li><span class="name"><span class="innerContentContainer">android:bottomRightRadius="10px"</span></span></li><li><span class="name"><span class="innerContentContainer">android:topLeftRadius="10px"</span></span></li><li><span class="name"><span class="innerContentContainer">android:topRightRadius="10px" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">监听EditText的内容变化</span></span><ul><li><span class="name"><span class="innerContentContainer">public class DelEditText extends EditText {</span></span><ul><li><span class="name"><span class="innerContentContainer">public DelEditText(Context context, AttributeSet attrs) {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>addTextChangedListener</b>(new TextWatcher() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void beforeTextChanged(CharSequence s, int start, int count, int after) {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onTextChanged(CharSequence s, int start, int before, int count) {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void afterTextChanged(Editable editable) {</span></span><ul><li><span class="name"><span class="innerContentContainer">setDrawable();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">密码输入框的可见和不可见</span></span><ul><li><span class="name"><span class="innerContentContainer">private EditText edit_pawd  = (EditText) findViewById(R.id.edit_pawd);</span></span></li><li><span class="name"><span class="innerContentContainer">edit_pawd.setTransformationMethod(HideReturnsTransformationMethod.getInstance());   // 不可见</span></span></li><li><span class="name"><span class="innerContentContainer">edit_pawd.setTransformationMethod(PasswordTransformationMethod.getInstance());   // 可见</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EditText(输入框)</span></span><ul><li><span class="name"><span class="innerContentContainer">EditText可以接受用户输入.</span></span></li><li><span class="name"><span class="innerContentContainer">android:hint="默认提示文本"</span></span></li><li><span class="name"><span class="innerContentContainer">android:textColorHint="#95A1AA"  // 设置提示文本的颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:selectAllOnFocus="true"   // 获得焦点后全选组件内所有文本内容</span></span></li><li><span class="name"><span class="innerContentContainer">android:inputType="phone"    // 限制 EditText输入类型. 类型相当多, </span></span></li><li><span class="name"><span class="innerContentContainer">android:maxLines="3"   // 设置最大的行数</span></span></li><li><span class="name"><span class="innerContentContainer">android:windowSoftInputMode   &nbsp;// Activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题. 这个属性可影响两件事:</span></span><ul><li><span class="name"><span class="innerContentContainer">当有焦点产生时，软键盘是隐藏还是显示</span></span></li><li><span class="name"><span class="innerContentContainer">是否减少活动主窗口大小以便腾出空间放软键盘. </span></span></li><li><span class="name"><span class="innerContentContainer">相关属性较多, 可以同时设多个, 如下:</span></span></li><li><span class="name"><span class="innerContentContainer">stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置</span></span></li><li><span class="name"><span class="innerContentContainer">stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示</span></span></li><li><span class="name"><span class="innerContentContainer">stateHidden：用户选择activity时，软键盘总是被隐藏</span></span></li><li><span class="name"><span class="innerContentContainer">stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的</span></span></li><li><span class="name"><span class="innerContentContainer">stateVisible：软键盘通常是可见的</span></span></li><li><span class="name"><span class="innerContentContainer">stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态</span></span></li><li><span class="name"><span class="innerContentContainer">adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示</span></span></li><li><span class="name"><span class="innerContentContainer">adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间</span></span></li><li><span class="name"><span class="innerContentContainer">adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">监听EditText的内容变化</span></span><ul><li><span class="name"><span class="innerContentContainer">文本内容 变化的监听器则是：TextWatcher，我们可以调用EditText.addTextChangedListener(mTextWatcher); 为EditText设置内容变化监听！</span></span></li><li><span class="name"><span class="innerContentContainer">TextWatcher，需实现三个方法：</span></span></li><li><span class="name"><span class="innerContentContainer">public void beforeTextChanged(CharSequence s, int start,int count, int after);  // 内容变化前</span></span></li><li><span class="name"><span class="innerContentContainer">public void onTextChanged(CharSequence s, int start, int before, int count);  // 内容变化中</span></span></li><li><span class="name"><span class="innerContentContainer">public void afterTextChanged(Editable s);  // 内容变化后</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class DelEditText extends EditText {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Drawable imgClear;</span></span></li><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">public DelEditText(Context context, AttributeSet attrs) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super(context, attrs);</span></span></li><li><span class="name"><span class="innerContentContainer">this.mContext = context;</span></span></li><li><span class="name"><span class="innerContentContainer">init();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private void init() {</span></span><ul><li><span class="name"><span class="innerContentContainer">imgClear = mContext.getResources().getDrawable(R.drawable.delete_gray);</span></span></li><li><span class="name"><span class="innerContentContainer">addTextChangedListener(new TextWatcher() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void beforeTextChanged(CharSequence s, int start, int count, int after) {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onTextChanged(CharSequence s, int start, int before, int count) {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void afterTextChanged(Editable editable) {</span></span><ul><li><span class="name"><span class="innerContentContainer">setDrawable();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//绘制删除图片</span></span></li><li><span class="name"><span class="innerContentContainer">private void setDrawable(){</span></span><ul><li><span class="name"><span class="innerContentContainer">if (length() &lt; 1)</span></span><ul><li><span class="name"><span class="innerContentContainer">setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">else</span></span><ul><li><span class="name"><span class="innerContentContainer">setCompoundDrawablesWithIntrinsicBounds(null, null, imgClear, null);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//当触摸范围在右侧时，触发删除方法，隐藏叉叉</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouchEvent(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(imgClear != null &amp;&amp; event.getAction() == MotionEvent.ACTION_UP)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">int eventX = (int) event.getRawX();</span></span></li><li><span class="name"><span class="innerContentContainer">int eventY = (int) event.getRawY();</span></span></li><li><span class="name"><span class="innerContentContainer">Rect rect = new Rect();</span></span></li><li><span class="name"><span class="innerContentContainer">getGlobalVisibleRect(rect);</span></span></li><li><span class="name"><span class="innerContentContainer">rect.left = rect.right - 100;</span></span></li><li><span class="name"><span class="innerContentContainer">if (rect.contains(eventX, eventY))</span></span><ul><li><span class="name"><span class="innerContentContainer">setText("");</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onTouchEvent(event);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">protected void finalize() throws Throwable {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.finalize();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实现EditText的密码可见与不可见</span></span><ul><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private EditText edit_pawd;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btnChange;</span></span></li><li><span class="name"><span class="innerContentContainer">private boolean flag = false;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">edit_pawd = (EditText) findViewById(R.id.edit_pawd);</span></span></li><li><span class="name"><span class="innerContentContainer">btnChange = (Button) findViewById(R.id.btnChange);</span></span></li><li><span class="name"><span class="innerContentContainer">edit_pawd.setHorizontallyScrolling(true);    //设置EditText不换行</span></span></li><li><span class="name"><span class="innerContentContainer">btnChange.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View view) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(flag == true){</span></span><ul><li><span class="name"><span class="innerContentContainer">edit_pawd.setTransformationMethod(HideReturnsTransformationMethod.getInstance());</span></span></li><li><span class="name"><span class="innerContentContainer">flag = false;</span></span></li><li><span class="name"><span class="innerContentContainer">btnChange.setText("密码不可见");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">edit_pawd.setTransformationMethod(PasswordTransformationMethod.getInstance());</span></span></li><li><span class="name"><span class="innerContentContainer">flag = true;</span></span></li><li><span class="name"><span class="innerContentContainer">btnChange.setText("密码可见");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Button(按钮)与ImageButton(图像按钮)</span></span><ul><li><span class="name"><span class="innerContentContainer">Button是TextView的子类，所以TextView上很多属性也可以应用到Button 上.</span></span></li><li><span class="name"><span class="innerContentContainer">StateListDrawable是Drawable资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点&nbsp;&lt; selector &gt;，我们只需要将Button的background属性设置为该drawable资源即可轻松实现，按下 按钮时不同的按钮颜色或背景.</span></span></li><li><span class="name"><span class="innerContentContainer">drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~</span></span></li><li><span class="name"><span class="innerContentContainer">state_focused:是否获得焦点</span></span></li><li><span class="name"><span class="innerContentContainer">state_window_focused:是否获得窗口焦点</span></span></li><li><span class="name"><span class="innerContentContainer">state_enabled:控件是否可用</span></span></li><li><span class="name"><span class="innerContentContainer">state_checkable:控件可否被勾选, eg:checkbox</span></span></li><li><span class="name"><span class="innerContentContainer">state_checked:控件是否被勾选</span></span></li><li><span class="name"><span class="innerContentContainer">state_selected:控件是否被选择,针对有滚轮的情况</span></span></li><li><span class="name"><span class="innerContentContainer">state_pressed:控件是否被按下</span></span></li><li><span class="name"><span class="innerContentContainer">state_active:控件是否处于活动状态,eg:slidingTab</span></span></li><li><span class="name"><span class="innerContentContainer">state_single:控件包含多个子控件时,确定是否只显示一个子控件</span></span></li><li><span class="name"><span class="innerContentContainer">state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态</span></span></li><li><span class="name"><span class="innerContentContainer">state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态</span></span></li><li><span class="name"><span class="innerContentContainer">state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ImageView(图像视图)</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView有两个可以设置图片的属性，分别是：src和 background</span></span><ul><li><span class="name"><span class="innerContentContainer">background通常指的都是背景,而src指的是内容</span></span></li><li><span class="name"><span class="innerContentContainer">当使用src填入图片时,是按照图片大小直接填充,并不会进行拉伸</span></span></li><li><span class="name"><span class="innerContentContainer">而使用 background填入图片,则是会根据 ImageView给定的宽度来进行拉伸</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">src + background 可以实现融入效果.</span></span><ul><li><span class="name"><span class="innerContentContainer">找一张透明的png图片 + 设置一个黑色的背景</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;ImageView</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="150dp"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:src="@drawable/pig"</span></span></li><li><span class="name"><span class="innerContentContainer">android:background="#6699FF" /&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Java代码中设置 blackground和 src属性</span></span><ul><li><span class="name"><span class="innerContentContainer">前景(对应src属性): setImageDrawable( );</span></span></li><li><span class="name"><span class="innerContentContainer">背景(对应background属性): setBackgroundDrawable( );</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adjustViewBounds设置缩放是否保存原图长宽比</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView为我们提供了adjustViewBounds属性，用于设置缩放时是否保持原图长宽比！ 单独设置不起作用，需要配合maxWidth和maxHeight属性一起使用！而后面这两个属性 也是需要adjustViewBounds为true才会生效的~</span></span></li><li><span class="name"><span class="innerContentContainer">android:maxHeight:设置ImageView的最大高度</span></span></li><li><span class="name"><span class="innerContentContainer">android:maxWidth:设置ImageView的最大宽度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">scaleType设置缩放类型</span></span><ul><li><span class="name"><span class="innerContentContainer">android:scaleType用于设置显示的图片如何缩放或者移动以适应ImageView的大小 Java代码中可以通过imageView.setScaleType(ImageView.ScaleType.CENTER);来设置~ 可选值如下：</span></span></li><li><span class="name"><span class="innerContentContainer">fitXY:对图像的横向与纵向进行独立缩放,使得该图片完全适应ImageView,但是图片的横纵比可能会发生改变</span></span></li><li><span class="name"><span class="innerContentContainer">fitStart:保持纵横比缩放图片,知道较长的边与Image的编程相等,缩放完成后将图片放在ImageView的左上角</span></span></li><li><span class="name"><span class="innerContentContainer">fitCenter:同上,缩放后放于中间;</span></span></li><li><span class="name"><span class="innerContentContainer">fitEnd:同上,缩放后放于右下角;</span></span></li><li><span class="name"><span class="innerContentContainer">center:保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。</span></span></li><li><span class="name"><span class="innerContentContainer">centerCrop:保持横纵比缩放图片,知道完全覆盖ImageView,可能会出现图片的显示不完全</span></span></li><li><span class="name"><span class="innerContentContainer">centerInside:保持横纵比缩放图片,直到ImageView能够完全地显示图片</span></span></li><li><span class="name"><span class="innerContentContainer">matrix:默认值，不改变原图的大小，从ImageView的左上角开始绘制原图， 原图超过ImageView的部分作裁剪处理</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">RadioButton(单选按钮)&amp;Checkbox(复选框)</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;RadioGroup</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/radioGroup"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:orientation="horizontal"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;RadioButton</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/btnMan"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="男"</span></span></li><li><span class="name"><span class="innerContentContainer">android:checked="true"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;RadioButton</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/btnWoman"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="女"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/RadioGroup&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">获得选中的值：</span></span><ul><li><span class="name"><span class="innerContentContainer">第一种是为RadioButton设置一个事件监听器setOnCheckChangeListener</span></span><ul><li><span class="name"><span class="innerContentContainer">RadioGroup radgroup = (RadioGroup) findViewById(R.id.radioGroup);</span></span></li><li><span class="name"><span class="innerContentContainer">radgroup.setOnCheckedChangeListener(new OnCheckedChangeListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onCheckedChanged(RadioGroup group, int checkedId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">RadioButton radbtn = (RadioButton) findViewById(checkedId);</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "按钮组值发生改变,你选了" + radbtn.getText(), Toast.LENGTH_LONG).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二种方法是通过单击其他按钮获取选中单选按钮的值</span></span><ul><li><span class="name"><span class="innerContentContainer">RadioButton rd = (RadioButton) radgroup.getChildAt(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改变文字与选择框的相对位置</span></span><ul><li><span class="name"><span class="innerContentContainer">1.&nbsp;android:button="@null"</span></span></li><li><span class="name"><span class="innerContentContainer">2.&nbsp;android:drawableTop="@android:drawable/btn_radio"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">修改文字与选择框的距离</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 在XML代码中控制： 使用android:paddingXxx = "xxx" 来控制距离</span></span></li><li><span class="name"><span class="innerContentContainer">2. 在Java代码中，稍微好一点，动态计算paddingLeft.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">开关按钮ToggleButton和开关Switch</span></span><ul><li><span class="name"><span class="innerContentContainer">ToggleButton(开关按钮) 有如下属性:</span></span></li><li><span class="name"><span class="innerContentContainer">android:disabledAlpha：设置按钮在禁用时的透明度</span></span></li><li><span class="name"><span class="innerContentContainer">android:textOff：按钮没有被选中时显示的文字</span></span></li><li><span class="name"><span class="innerContentContainer">android:textOn：按钮被选中时显示的文字 另外，除了这个我们还可以自己写个selector，然后设置下Background属性即可~</span></span></li><li><span class="name"><span class="innerContentContainer">Switch(开关)</span></span></li><li><span class="name"><span class="innerContentContainer">android:showText：设置on/off的时候是否显示文字,boolean</span></span></li><li><span class="name"><span class="innerContentContainer">android:splitTrack：是否设置一个间隙，让滑块与底部图片分隔,boolean</span></span></li><li><span class="name"><span class="innerContentContainer">android:switchMinWidth：设置开关的最小宽度</span></span></li><li><span class="name"><span class="innerContentContainer">android:switchPadding：设置滑块内文字的间隔</span></span></li><li><span class="name"><span class="innerContentContainer">android:switchTextAppearance：设置开关的文字外观，暂时没发现有什么用...</span></span></li><li><span class="name"><span class="innerContentContainer">android:textOff：按钮没有被选中时显示的文字</span></span></li><li><span class="name"><span class="innerContentContainer">android:textOn：按钮被选中时显示的文字</span></span></li><li><span class="name"><span class="innerContentContainer">android:textStyle：文字风格，粗体，斜体写划线那些</span></span></li><li><span class="name"><span class="innerContentContainer">android:track：底部的图片</span></span></li><li><span class="name"><span class="innerContentContainer">android:thumb：滑块的图片</span></span></li><li><span class="name"><span class="innerContentContainer">android:typeface：设置字体，默认支持这三种:sans, serif, monospace</span></span></li><li><span class="name"><span class="innerContentContainer">还可以使用 其他字体文件(*.ttf)，首先要将字体文件保存在 assets/fonts/目录下，然后在 Java代码中设置：</span></span><ul><li><span class="name"><span class="innerContentContainer">Typeface typeFace =Typeface.createFromAsset(getAssets(),"fonts/HandmadeTypewriter.ttf"); textView.setTypeface(typeFace);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ProgressBar(进度条)</span></span><ul><li><span class="name"><span class="innerContentContainer">ProgressBar继承与 View类，直接子类有 AbsSeekBar和 ContentLoadingProgressBar， 其中 AbsSeekBar的子类有 SeekBar和 RatingBar</span></span></li><li><span class="name"><span class="innerContentContainer">android:max：进度条的最大值</span></span></li><li><span class="name"><span class="innerContentContainer">android:progress：进度条已完成进度值</span></span></li><li><span class="name"><span class="innerContentContainer">android:progressDrawable：设置轨道对应的Drawable对象</span></span></li><li><span class="name"><span class="innerContentContainer">android:indeterminate：如果设置成true，则进度条不精确显示进度</span></span></li><li><span class="name"><span class="innerContentContainer">android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象</span></span></li><li><span class="name"><span class="innerContentContainer">android:indeterminateDuration：设置不精确显示进度的持续时间</span></span></li><li><span class="name"><span class="innerContentContainer">android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SeekBar(拖动条)</span></span><ul><li><span class="name"><span class="innerContentContainer">android:max="100" //滑动条的最大值</span></span></li><li><span class="name"><span class="innerContentContainer">android:progress="60" //滑动条的当前值</span></span></li><li><span class="name"><span class="innerContentContainer">android:secondaryProgress="70" //二级滑动条的进度</span></span></li><li><span class="name"><span class="innerContentContainer">android:thumb&nbsp;= "@mipmap/sb_icon" //滑块的drawable</span></span></li><li><span class="name"><span class="innerContentContainer">SeekBar的事件，SeekBar.OnSeekBarChangeListener&nbsp;我们只需重写三个对应的方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">onProgressChanged：进度发生改变时会触发</span></span></li><li><span class="name"><span class="innerContentContainer">onStartTrackingTouch：按住SeekBar时会触发</span></span></li><li><span class="name"><span class="innerContentContainer">onStopTrackingTouch：放开SeekBar时触发</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">RatingBar(星级评分条)</span></span><ul><li><span class="name"><span class="innerContentContainer">android:isIndicator：是否用作指示，用户无法更改，默认false</span></span></li><li><span class="name"><span class="innerContentContainer">android:numStars：显示多少个星星，必须为整数</span></span></li><li><span class="name"><span class="innerContentContainer">android:rating：默认评分值，必须为浮点数</span></span></li><li><span class="name"><span class="innerContentContainer">android:stepSize：&nbsp;评分每次增加的值，必须为浮点数</span></span></li><li><span class="name"><span class="innerContentContainer">除了上面这些，还有两种样式供我们选择咧，但是不建议使用，因为这两种样式都好丑... 他们分别是：</span></span></li><li><span class="name"><span class="innerContentContainer">style="?android:attr/ratingBarStyleSmall"</span></span></li><li><span class="name"><span class="innerContentContainer">style="?android:attr/ratingBarStyleIndicator"</span></span></li><li><span class="name"><span class="innerContentContainer">——事件处理：&nbsp;只需为RatingBar设置OnRatingBarChangeListener事件，然后重写下onRatingChanged()方法即可！</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ScrollView(滚动条)</span></span><ul><li><span class="name"><span class="innerContentContainer">ScrollView(滚动条)，应该叫它竖直滚动条，对应的另外一个水平方向上的滚动条：HorizontalScrollView.</span></span></li><li><span class="name"><span class="innerContentContainer">滚动到底部</span></span><ul><li><span class="name"><span class="innerContentContainer">利用ScrollView给我们提供的:fullScroll()方法：</span></span></li><li><span class="name"><span class="innerContentContainer">scrollView.fullScroll(ScrollView.FOCUS_DOWN);滚动到底部</span></span></li><li><span class="name"><span class="innerContentContainer">scrollView.fullScroll(ScrollView.FOCUS_UP);滚动到顶部</span></span></li><li><span class="name"><span class="innerContentContainer">另外用这玩意的时候要小心异步的玩意，就是addView后，有可能还没有显示完， 如果这个时候直接调用该方法的话，可能会无效，这就需要自己写handler来更新了~</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置滚动的滑块图片</span></span><ul><li><span class="name"><span class="innerContentContainer">垂直方向滑块：android:scrollbarThumbVertical</span></span></li><li><span class="name"><span class="innerContentContainer">水平方向滑块：android:scrollbarThumbHorizontal</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">隐藏滑块</span></span><ul><li><span class="name"><span class="innerContentContainer">方法有两种： 1.android:scrollbars="none"</span></span></li><li><span class="name"><span class="innerContentContainer">2.Java代码设置：scrollview.setVerticalScrollBarEnabled(false);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置滚动速度</span></span><ul><li><span class="name"><span class="innerContentContainer">没有可以直接设置的方法，需要继承ScrollView，然后重写一个 public void fling (int velocityY)的方法：</span></span></li><li><span class="name"><span class="innerContentContainer">public void fling(int velocityY) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.fling(velocityY / 2);    //速度变为原来的一半</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Date &amp; Time组件(时间相关)</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>显示时间的控件有：TextClock，AnalogClock，Chronometer.  </b></span></span></li><li><span class="name"><span class="innerContentContainer">TextClock(文本时钟)</span></span><ul><li><span class="name"><span class="innerContentContainer">TextClock提供的 is24HourModeEnabled()方法来查看系统是否在使用24进制时间显示</span></span></li><li><span class="name"><span class="innerContentContainer">android:format12Hour, 设置12时制的格式</span></span></li><li><span class="name"><span class="innerContentContainer">android:format24Hour, 设置24时制的格式</span></span></li><li><span class="name"><span class="innerContentContainer">android:timeZone, 设置时区</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AnalogClock(模拟时钟)</span></span><ul><li><span class="name"><span class="innerContentContainer">android:dial="@mipmap/ic_c_bg"   // 背景</span></span></li><li><span class="name"><span class="innerContentContainer">android:hand_hour="@mipmap/zhen_shi"   // 时针</span></span></li><li><span class="name"><span class="innerContentContainer">android:hand_minute="@mipmap/zhen_fen  // 分针</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Chronometer(计时器)</span></span></li><li><span class="name"><span class="innerContentContainer"><b>选择时间的控件有: DatePicker(日期选择器)，TimePicker(时间选择器)，CalendarView(日期视图).</b></span></span></li><li><span class="name"><span class="innerContentContainer">DatePicker(日期选择器)</span></span><ul><li><span class="name"><span class="innerContentContainer">android:calendarTextColor&nbsp;： 日历列表的文本的颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:calendarViewShown：是否显示日历视图</span></span></li><li><span class="name"><span class="innerContentContainer">android:datePickerMode：组件外观，可选值:spinner，calendar 前者效果如下，默认效果</span></span></li><li><span class="name"><span class="innerContentContainer">android:dayOfWeekBackground：顶部星期几的背景颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:dayOfWeekTextAppearance：顶部星期几的文字颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:endYear：去年(内容)比如2010</span></span></li><li><span class="name"><span class="innerContentContainer">android:firstDayOfWeek：设置日历列表以星期几开头</span></span></li><li><span class="name"><span class="innerContentContainer">android:headerBackground：整个头部的背景颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:headerDayOfMonthTextAppearance：头部日期字体的颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:headerMonthTextAppearance：头部月份的字体颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:headerYearTextAppearance：头部年的字体颜色</span></span></li><li><span class="name"><span class="innerContentContainer">android:maxDate：最大日期显示在这个日历视图mm / dd / yyyy格式</span></span></li><li><span class="name"><span class="innerContentContainer">android:minDate：最小日期显示在这个日历视图mm / dd / yyyy格式</span></span></li><li><span class="name"><span class="innerContentContainer">android:spinnersShown：是否显示spinner</span></span></li><li><span class="name"><span class="innerContentContainer">android:startYear：设置第一年(内容)，比如19940年</span></span></li><li><span class="name"><span class="innerContentContainer">android:yearListItemTextAppearance：列表的文本出现在列表中。</span></span></li><li><span class="name"><span class="innerContentContainer">android:yearListSelectorColor：年列表选择的颜色</span></span></li><li><span class="name"><span class="innerContentContainer">DatePicker的事件：&nbsp;DatePicker.OnDateChangedListener</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TimePicker(时间选择器)</span></span><ul><li><span class="name"><span class="innerContentContainer">官方提供的属性只有一个：&nbsp;android:timePickerMode：组件外观，同样可选值为: spinner和 clock(默认) 前者是旧版本的TimePicker</span></span></li><li><span class="name"><span class="innerContentContainer">对应的监听事件是：TimePicker.OnTimeChangedListener</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CalendarView(日期视图)</span></span><ul><li><span class="name"><span class="innerContentContainer">android:firstDayOfWeek：设置一个星期的第一天</span></span></li><li><span class="name"><span class="innerContentContainer">android:maxDate&nbsp;：最大的日期显示在这个日历视图mm / dd / yyyy格式</span></span></li><li><span class="name"><span class="innerContentContainer">android:minDate：最小的日期显示在这个日历视图mm / dd / yyyy格式</span></span></li><li><span class="name"><span class="innerContentContainer">android:weekDayTextAppearance：工作日的文本出现在日历标题缩写</span></span></li><li><span class="name"><span class="innerContentContainer">对应的日期改变事件是：CalendarView.OnDateChangeListener</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Adapter: 复杂控件的数据更新一般放在单独类中完成, 后者叫 Adapter.</span></span><ul><li><span class="name"><span class="innerContentContainer">Adapter即MVC模型中的C. 家族很大, 明星成员有: </span></span></li><li><span class="name"><span class="innerContentContainer">BaseAdapter：抽象类，实际开发中我们会继承这个类并且重写相关方法，用得最多的一个Adapter！</span></span></li><li><span class="name"><span class="innerContentContainer"><b>ArrayAdapter</b>：支持泛型操作，最简单的一个Adapter，只能展现一行行文字.</span></span></li><li><span class="name"><span class="innerContentContainer">SimpleAdapter：同样具有良好扩展性的一个Adapter，可以自定义多种效果.</span></span></li><li><span class="name"><span class="innerContentContainer">SimpleCursorAdapter：用于显示简单文本类型的listView，一般在数据库那里会用到，不过有点过时， 不推荐使用.</span></span></li><li><span class="name"><span class="innerContentContainer">ArrayAdapter的例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 要显示的数据</span></span></li><li><span class="name"><span class="innerContentContainer">String[] strs = {"基神","B神","翔神","曹神","J神"};</span></span></li><li><span class="name"><span class="innerContentContainer">// 创建ArrayAdapter</span></span></li><li><span class="name"><span class="innerContentContainer">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">(this, android.R.layout.simple_expandable_list_item_1, strs);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 获取ListView对象，通过调用 setAdapter方法为 ListView设置Adapter设置适配器</span></span></li><li><span class="name"><span class="innerContentContainer">ListView list_test = (ListView) findViewById(R.id.list_test);</span></span></li><li><span class="name"><span class="innerContentContainer">list_test.setAdapter(adapter);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ArrayAdapter的第二个参数负责定义界面风格, 其值域是:</span></span><ul><li><span class="name"><span class="innerContentContainer">simple_list_item_1 : 单独一行的文本框</span></span></li><li><span class="name"><span class="innerContentContainer">simple_list_item_2 : 两个文本框组成</span></span></li><li><span class="name"><span class="innerContentContainer">simple_list_item_checked : 每项都是由一个已选中的列表项</span></span></li><li><span class="name"><span class="innerContentContainer">simple_list_item_multiple_choice : 都带有一个复选框</span></span></li><li><span class="name"><span class="innerContentContainer">simple_list_item_single_choice : 都带有一个单选钮</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simpleAdapter的例子</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>ListView: 需搭配Adapter使用的UI控件</b></span></span><ul><li><span class="name"><span class="innerContentContainer">ListView 适用于搭复杂界面的框架, 所以最好按MVC模型进行组织. 其中关键是controller, 一般采用 adapter模型. </span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 要显示的数据. </span></span></li><li><span class="name"><span class="innerContentContainer">String[] strs = {"基神","B神","翔神","曹神","J神"};</span></span></li><li><span class="name"><span class="innerContentContainer">// 创建 ArrayAdapter</span></span></li><li><span class="name"><span class="innerContentContainer">ArrayAdapter&lt;String&gt; <b>adapter </b>= new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1, strs);</span></span></li><li><span class="name"><span class="innerContentContainer">// 获取ListView对象，通过调用setAdapter方法为ListView设置Adapter设置适配器</span></span></li><li><span class="name"><span class="innerContentContainer">ListView list_test = (ListView) findViewById(R.id.list_test);</span></span></li><li><span class="name"><span class="innerContentContainer">list_test.setAdapter(<b>adapter</b>);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对于数组资源, 创建 ArrayAdapter 是用: </span></span><ul><li><span class="name"><span class="innerContentContainer">ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.<b>createFromResource</b>(this, R.array.myarray, android.R.layout.simple_list_item_multiple_choice);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">还有一个简写的方式, 在 ListView 的layout中使用:  android:entries="@array/myarray"; 直接引用数组资源.</span></span></li><li><span class="name"><span class="innerContentContainer">其它属性</span></span><ul><li><span class="name"><span class="innerContentContainer">footerDividersEnabled：是否在footerView(表尾)前绘制一个分隔条,默认为true</span></span></li><li><span class="name"><span class="innerContentContainer">headerDividersEnabled:是否在headerView(表头)前绘制一个分隔条,默认为true</span></span></li><li><span class="name"><span class="innerContentContainer">divider:设置分隔条,可以用颜色分割,也可以用drawable资源分割</span></span></li><li><span class="name"><span class="innerContentContainer">dividerHeight:设置分隔条的高度</span></span></li><li><span class="name"><span class="innerContentContainer">addHeaderView(View v)：添加headView(表头),括号中的参数是一个View对象, 使用这个方法必须在listview.setAdapter前面，否则会报错。</span></span></li><li><span class="name"><span class="innerContentContainer">addFooterView(View v)：添加footerView(表尾)，括号中的参数是一个View对象</span></span></li><li><span class="name"><span class="innerContentContainer">addHeaderView(headView, null, false)：和前面的区别：设置Header是否可以被选中</span></span></li><li><span class="name"><span class="innerContentContainer">addFooterView(View,view,false)：同上</span></span></li><li><span class="name"><span class="innerContentContainer">想让列表显示你列表的最下面的话，将 stackFromBottom 属性设置为true即可.</span></span></li><li><span class="name"><span class="innerContentContainer">设置点击颜色 cacheColorHint</span></span><ul><li><span class="name"><span class="innerContentContainer">如果你为ListView设置了一个图片作为Background的话，当你拖动或者点击listView空白位置会发现 item都变成黑色了，这是时候我们可以通过这个cacheColorHint将颜色设置为透明: # 00000000</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">隐藏滑动条: android:scrollbars="none" 或者 setVerticalScrollBarEnabled(true);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">上面的例子直接使用 ArrayAdapter作 adapter, 这种太简单, 常见的是重载 BaseAdapter. 如下:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 先编写下表头与表尾的布局：</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:orientation="vertical"</span></span></li><li><span class="name"><span class="innerContentContainer">android:gravity="center"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;TextView</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="48dp"</span></span></li><li><span class="name"><span class="innerContentContainer">android:textSize="18sp"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="表头"</span></span></li><li><span class="name"><span class="innerContentContainer">android:gravity="center"</span></span></li><li><span class="name"><span class="innerContentContainer">android:background="#43BBEB"</span></span></li><li><span class="name"><span class="innerContentContainer">android:textColor="#FFFFFF"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/LinearLayout&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 表尾除了text字段不同外, 其它都一样.</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 自定义 BaseAdapter</span></span></li><li><span class="name"><span class="innerContentContainer">public class AnimalAdapter extends BaseAdapter {</span></span><ul><li><span class="name"><span class="innerContentContainer">private LinkedList&lt;Animal&gt; mData;</span></span></li><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">// Animal 是个数据类库, 这里不再累述.</span></span></li><li><span class="name"><span class="innerContentContainer">public AnimalAdapter(LinkedList&lt;Animal&gt; mData, Context mContext) {</span></span><ul><li><span class="name"><span class="innerContentContainer">this.mData = mData;</span></span></li><li><span class="name"><span class="innerContentContainer">this.mContext = mContext;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 关键函数. 返回表格有多少列.</span></span></li><li><span class="name"><span class="innerContentContainer">public int getCount() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return mData.size();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public Object getItem(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public long getItemId(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return position;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 关键函数. 返回每一列的view, 界面上有多少列就会调用多少次 getView.</span></span></li><li><span class="name"><span class="innerContentContainer">public View getView(int position, View convertView, ViewGroup parent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewHolder holder = null;</span></span></li><li><span class="name"><span class="innerContentContainer">if(convertView == null){</span></span><ul><li><span class="name"><span class="innerContentContainer">convertView = LayoutInflater.from(mContext).inflate(R.layout.item_list_animal,parent,false);</span></span></li><li><span class="name"><span class="innerContentContainer"><b>holder = new ViewHolder();</b></span></span></li><li><span class="name"><span class="innerContentContainer">holder.img_icon = (ImageView) convertView.findViewById(R.id.img_icon);</span></span></li><li><span class="name"><span class="innerContentContainer">holder.txt_aName = (TextView) convertView.findViewById(R.id.txt_aName);</span></span></li><li><span class="name"><span class="innerContentContainer">holder.txt_aSpeak = (TextView) convertView.findViewById(R.id.txt_aSpeak);</span></span></li><li><span class="name"><span class="innerContentContainer">convertView.setTag(holder);   //将Holder存储到convertView中</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}else{</span></span><ul><li><span class="name"><span class="innerContentContainer">holder = (ViewHolder) convertView.getTag();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">holder.img_icon.setBackgroundResource(mData.get(position).getaIcon());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.txt_aName.setText(mData.get(position).getaName());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.txt_aSpeak.setText(mData.get(position).getaSpeak());</span></span></li><li><span class="name"><span class="innerContentContainer">return convertView;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 数据类</span></span></li><li><span class="name"><span class="innerContentContainer">static class ViewHolder{</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView img_icon;</span></span></li><li><span class="name"><span class="innerContentContainer">TextView txt_aName;</span></span></li><li><span class="name"><span class="innerContentContainer">TextView txt_aSpeak;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 主函数:</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity implements AdapterView.OnItemClickListener{</span></span><ul><li><span class="name"><span class="innerContentContainer">private List&lt;Animal&gt; mData = null;</span></span></li><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">private AnimalAdapter <b>mAdapter </b>= null;</span></span></li><li><span class="name"><span class="innerContentContainer">private ListView list_animal;</span></span></li><li><span class="name"><span class="innerContentContainer">private LinearLayout ly_content;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">mContext = MainActivity.this;</span></span></li><li><span class="name"><span class="innerContentContainer">list_animal = (ListView) findViewById(R.id.list_animal);</span></span></li><li><span class="name"><span class="innerContentContainer">// 动态加载顶部View和底部View</span></span></li><li><span class="name"><span class="innerContentContainer">final LayoutInflater inflater = LayoutInflater.from(this);</span></span></li><li><span class="name"><span class="innerContentContainer">View headView = inflater.inflate(R.layout.view_header, null, false);</span></span></li><li><span class="name"><span class="innerContentContainer">View footView = inflater.inflate(R.layout.view_footer, null, false);</span></span></li><li><span class="name"><span class="innerContentContainer">mData = new LinkedList&lt;Animal&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(new Animal("狗说", "你是狗么?", R.mipmap.ic_icon_dog));</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(new Animal("牛说", "你是牛么?", R.mipmap.ic_icon_cow));</span></span></li><li><span class="name"><span class="innerContentContainer"><b>mAdapter </b>= new AnimalAdapter((LinkedList&lt;Animal&gt;) mData, mContext);</span></span></li><li><span class="name"><span class="innerContentContainer">// 添加表头和表尾需要写在setAdapter方法调用之前！！！</span></span></li><li><span class="name"><span class="innerContentContainer">list_animal.addHeaderView(headView);</span></span></li><li><span class="name"><span class="innerContentContainer">list_animal.addFooterView(footView);</span></span></li><li><span class="name"><span class="innerContentContainer">list_animal.<b>setAdapter</b>(<b>mAdapter</b>);</span></span></li><li><span class="name"><span class="innerContentContainer">list_animal.<b>setOnItemClickListener</b>(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 添加表头表尾后，positon是从表头开始算的，表头是0, 第一个数据是1.</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext,"你点击了第" + position + "项",Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ViewHolder重用组件</span></span><ul><li><span class="name"><span class="innerContentContainer">之前说过, ListView上有多少个列就会调多少次 getView(). 但是findViewById不一样需要调用多次. 可以自己定义一个ViewHolder类来对这一部分进行性能优化.</span></span></li><li><span class="name"><span class="innerContentContainer">具体做法参见例子中的 <b>holder = new ViewHolder(); </b>这几行代码.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ListView的数据更新</span></span><ul><li><span class="name"><span class="innerContentContainer">在BaseAdapter中加一个接口</span></span><ul><li><span class="name"><span class="innerContentContainer">public void add(Data data) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (mData == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData = new LinkedList&lt;&gt;();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(data);</span></span></li><li><span class="name"><span class="innerContentContainer">// notifyDataSetChanged()方法会判断是否需要重新渲染，如果当前item没有必要重新渲染 是不会重新渲染的，如果某个Item的状态发生改变，都会导致View的重绘，而重绘的并不是 所有的Item，而是View状态发生变化的那个Item.</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">然后在数据更新处调用即可. Adapter.add();</span></span></li><li><span class="name"><span class="innerContentContainer">删除也是如此.</span></span><ul><li><span class="name"><span class="innerContentContainer">public void remove(Data data) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(mData != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.remove(data);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void remove(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(mData != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.remove(position);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ListView的焦点问题</span></span><ul><li><span class="name"><span class="innerContentContainer">如果往ListView的Item中添加了Button，CheckBox，EditText 等控件的话，就需要考虑ListView的焦点问题. 因为这些控件点击不了，触发不了onItemClick 和 onItemLongClick.</span></span></li><li><span class="name"><span class="innerContentContainer">解决办法是在 item根节点设置 android:descendantFocusability="blocksDescendants"</span></span></li><li><span class="name"><span class="innerContentContainer">该属性的值域是：</span></span><ul><li><span class="name"><span class="innerContentContainer">beforeDescendants： ViewGroup会优先其子类控件而获取到焦点</span></span></li><li><span class="name"><span class="innerContentContainer">afterDescendants： ViewGroup只有当其子类控件不需要获取焦点时才获取焦点</span></span></li><li><span class="name"><span class="innerContentContainer">blocksDescendants： ViewGroup会覆盖子类控件而直接获得焦点</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ListView之 checkbox 错位问题 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">作为ListView经典问题之一，如果你尝试过自定义ListView的item，在上面带有一个checkbox的话，那么当 item数超过了一页的话，就会出现错位问题.</span></span></li><li><span class="name"><span class="innerContentContainer">问题产生的原因是ListView当前屏的item都是缓存到 convertView中去的. 当滚出屏幕，这时候&nbsp;ConvertView不为空，所以新的一项会复用这个ConvertView, 这个地方产生了问题. </span></span></li><li><span class="name"><span class="innerContentContainer">第一个解决方式就是，不重用这个ConvertView，或者 说每次getView都将这个ConvertView设置为null. 如果Item数目巨大的话， 这种方法的性能比较差. </span></span></li><li><span class="name"><span class="innerContentContainer">第二个方法是, 找个地方保存当前Item CheckBox的状态，初始化的时候进行判断，设置是否选中.</span></span><ul><li><span class="name"><span class="innerContentContainer">放在哪里合适? 当然是 ViewHolder 类中了. 增加一个 CheckBox 成员.</span></span></li><li><span class="name"><span class="innerContentContainer">增加checkbox监听器:</span></span><ul><li><span class="name"><span class="innerContentContainer">viewHolder.cbxStatus.setOnCheckedChangeListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在checkbox状态变化时保存状态</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {</span></span><ul><li><span class="name"><span class="innerContentContainer">int index = (int)buttonView.getTag();</span></span></li><li><span class="name"><span class="innerContentContainer">if (isChecked)</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.get(index).setCheckStatus(true);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">else</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.get(index).setCheckStatus(false);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">使用该值</span></span><ul><li><span class="name"><span class="innerContentContainer">viewHolder.cbxStatus.setChecked(mData.get(position).getcheckStatus());</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">优化ListView的性能  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">在adapter中的getView方法中尽量少使用逻辑;</span></span></li><li><span class="name"><span class="innerContentContainer">尽最大可能避免GC;</span></span><ul><li><span class="name"><span class="innerContentContainer">在 getView()方法 中不要创建非常多的对象。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">滑动的时候不载入图片;</span></span></li><li><span class="name"><span class="innerContentContainer">将 ListView 的 scrollingCache 和 animateCache 设置为 false;</span></span></li><li><span class="name"><span class="innerContentContainer">item的布局层级越少越好;</span></span><ul><li><span class="name"><span class="innerContentContainer">当滑动ListView的时候，会导致大量的測量与绘制。所以我们应该将一些不必要的布局嵌套关系去掉, 降低item布局深度.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用ViewHolder.</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewHolder 可以大大提高 ListView 的性能.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">构建一个可复用的自定义BaseAdapter</span></span><ul><li><span class="name"><span class="innerContentContainer">在上面ListView的Adapter基础上, 做几次进化.</span></span></li><li><span class="name"><span class="innerContentContainer">第一步, 将Item实体类设置成泛型. 这样任何数据都可以复用这个Adapter.</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MyAdapter&lt;T&gt; extends BaseAdapter {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">private LinkedList&lt;T&gt; mData;</span></span></li><li><span class="name"><span class="innerContentContainer">public MyAdapter() {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public MyAdapter(LinkedList&lt;T&gt; mData, Context mContext) {</span></span><ul><li><span class="name"><span class="innerContentContainer">this.mData = mData;</span></span></li><li><span class="name"><span class="innerContentContainer">this.mContext = mContext;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public int getCount() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return mData.size();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public Object getItem(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public long getItemId(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return position;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public View getView(int position, View convertView, ViewGroup parent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewHolder holder = null;</span></span></li><li><span class="name"><span class="innerContentContainer">if (convertView == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">convertView = LayoutInflater.from(mContext).inflate(R.layout.item_list, parent, false);</span></span></li><li><span class="name"><span class="innerContentContainer">holder = new ViewHolder();</span></span></li><li><span class="name"><span class="innerContentContainer">holder.img_icon = (ImageView) convertView.findViewById(R.id.img_icon);</span></span></li><li><span class="name"><span class="innerContentContainer">holder.txt_content = (TextView) convertView.findViewById(R.id.txt_content);</span></span></li><li><span class="name"><span class="innerContentContainer">convertView.setTag(holder);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder = (ViewHolder) convertView.getTag();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">holder.img_icon.setImageResource(mData.get(position).getImgId());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.txt_content.setText(mData.get(position).getContent());</span></span></li><li><span class="name"><span class="innerContentContainer">return convertView;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//添加一个元素</span></span></li><li><span class="name"><span class="innerContentContainer">public void add(T data) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (mData == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData = new LinkedList&lt;&gt;();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(data);</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//往特定位置，添加一个元素</span></span></li><li><span class="name"><span class="innerContentContainer">public void add(int position,T data){</span></span><ul><li><span class="name"><span class="innerContentContainer">if (mData == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData = new LinkedList&lt;&gt;();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(position, data);</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void remove(T data) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(mData != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.remove(data);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void remove(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(mData != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.remove(position);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void clear() {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(mData != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mData.clear();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">notifyDataSetChanged();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private class ViewHolder {</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView img_icon;</span></span></li><li><span class="name"><span class="innerContentContainer">TextView txt_content;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二步, ViewHolder类的升级改造</span></span><ul><li><span class="name"><span class="innerContentContainer">目标: 将getView()方法大部分的逻辑写到ViewHolder类里. 这样 getView() 就不需要了解各个Item的界面表现了. </span></span></li><li><span class="name"><span class="innerContentContainer">ViewHolder要做的事：</span></span><ul><li><span class="name"><span class="innerContentContainer">定义一个查找控件的方法，我们的思路是通过暴露公共的方法，调用方法时传递过来控件id，以及设置的内容.</span></span></li><li><span class="name"><span class="innerContentContainer">将convertView复用部分搬到这里，那就需要传递一个context对象了，我们把需要获取 的部分都写到构造方法中！</span></span></li><li><span class="name"><span class="innerContentContainer">写一堆设置方法(public)，比如设置文字大小颜色，图片背景等！</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码如下:</span></span></li><li><span class="name"><span class="innerContentContainer">public static class ViewHolder {</span></span><ul><li><span class="name"><span class="innerContentContainer">private SparseArray&lt;View&gt; mViews;    // 存储ListView 的 item中的View</span></span></li><li><span class="name"><span class="innerContentContainer">private View item;                  // 存放convertView</span></span></li><li><span class="name"><span class="innerContentContainer">private int position;                // 游标</span></span></li><li><span class="name"><span class="innerContentContainer">private Context context;        // Context上下文</span></span></li><li><span class="name"><span class="innerContentContainer">// 构造方法，完成相关初始化</span></span></li><li><span class="name"><span class="innerContentContainer">private ViewHolder(Context context, ViewGroup parent, int layoutRes) {</span></span><ul><li><span class="name"><span class="innerContentContainer">mViews = new SparseArray&lt;&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">this.context = context;</span></span></li><li><span class="name"><span class="innerContentContainer">View convertView = LayoutInflater.from(context).inflate(layoutRes, parent,false);</span></span></li><li><span class="name"><span class="innerContentContainer">convertView.setTag(this);</span></span></li><li><span class="name"><span class="innerContentContainer">item = convertView;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 绑定ViewHolder与Item</span></span></li><li><span class="name"><span class="innerContentContainer">public static ViewHolder bind(Context context, View convertView, ViewGroup parent,</span></span><ul><li><span class="name"><span class="innerContentContainer">int layoutRes, int position) {</span></span></li><li><span class="name"><span class="innerContentContainer">ViewHolder holder;</span></span></li><li><span class="name"><span class="innerContentContainer">if(convertView == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder = new ViewHolder(context, parent, layoutRes);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder = (ViewHolder) convertView.getTag();</span></span></li><li><span class="name"><span class="innerContentContainer">holder.item = convertView;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">holder.position = position;</span></span></li><li><span class="name"><span class="innerContentContainer">return holder;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 根据id获取集合中保存的控件</span></span></li><li><span class="name"><span class="innerContentContainer">public &lt;T extends View&gt; T getView(int id) {</span></span><ul><li><span class="name"><span class="innerContentContainer">T t = (T) mViews.get(id);</span></span></li><li><span class="name"><span class="innerContentContainer">if(t == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">t = (T) item.findViewById(id);</span></span></li><li><span class="name"><span class="innerContentContainer">mViews.put(id, t);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return t;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 获取当前条目</span></span></li><li><span class="name"><span class="innerContentContainer">public View getItemView() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return item;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 获取条目位置</span></span></li><li><span class="name"><span class="innerContentContainer">public int getItemPosition() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return position;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置文字</span></span></li><li><span class="name"><span class="innerContentContainer">public ViewHolder setText(int id, CharSequence text) {</span></span><ul><li><span class="name"><span class="innerContentContainer">View view = getView(id);</span></span></li><li><span class="name"><span class="innerContentContainer">if(view instanceof TextView) {</span></span><ul><li><span class="name"><span class="innerContentContainer">((TextView) view).setText(text);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return this;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置图片</span></span></li><li><span class="name"><span class="innerContentContainer">public ViewHolder setImageResource(int id, int drawableRes) {</span></span><ul><li><span class="name"><span class="innerContentContainer">View view = getView(id);</span></span></li><li><span class="name"><span class="innerContentContainer">if(view instanceof ImageView) {</span></span><ul><li><span class="name"><span class="innerContentContainer">((ImageView) view).setImageResource(drawableRes);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">view.setBackgroundResource(drawableRes);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return this;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置点击监听</span></span></li><li><span class="name"><span class="innerContentContainer">public ViewHolder setOnClickListener(int id, View.OnClickListener listener) {</span></span><ul><li><span class="name"><span class="innerContentContainer">getView(id).setOnClickListener(listener);</span></span></li><li><span class="name"><span class="innerContentContainer">return this;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置可见性</span></span></li><li><span class="name"><span class="innerContentContainer">public ViewHolder setVisibility(int id, int visible) {</span></span><ul><li><span class="name"><span class="innerContentContainer">getView(id).setVisibility(visible);</span></span></li><li><span class="name"><span class="innerContentContainer">return this;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">ImageView img_icon;</span></span></li><li><span class="name"><span class="innerContentContainer">TextView txt_content;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第三步, 定义一个抽象方法，完成ViewHolder与Data数据集的绑定</span></span><ul><li><span class="name"><span class="innerContentContainer">public abstract void bindView(ViewHolder holder, T obj);</span></span></li><li><span class="name"><span class="innerContentContainer">我们创建新的BaseAdapter的时候，实现这个方法就好.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第四步, 修改getView()部分的内容</span></span><ul><li><span class="name"><span class="innerContentContainer">public View getView(int position, View convertView, ViewGroup parent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewHolder holder = ViewHolder.bind(parent.getContext(), convertView, parent, mLayoutRes, position);</span></span></li><li><span class="name"><span class="innerContentContainer">bindView(holder,getItem(position));</span></span></li><li><span class="name"><span class="innerContentContainer">return holder.getItemView();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第四步, 怎么使用?</span></span><ul><li><span class="name"><span class="innerContentContainer">//Adapter初始化</span></span></li><li><span class="name"><span class="innerContentContainer">myAdapter1 = new MyAdapter&lt;App&gt;((ArrayList)mData1, R.layout.item_one) {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void bindView(ViewHolder holder, App obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder.setImageResource(R.id.img_icon, obj.getaIcon());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.setText(R.id.txt_aname, obj.getaName());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">ListView list_app = (ListView) findViewById(R.id.list_app);</span></span></li><li><span class="name"><span class="innerContentContainer">list_app.setAdapter(myAdapter1);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ListView的多布局</span></span><ul><li><span class="name"><span class="innerContentContainer">同一个ListView中有多种布局风格叫ListView的多布局. 比如聊天窗口, 你说的和别人说的显示风格认定是不一样的. </span></span></li><li><span class="name"><span class="innerContentContainer">重写getViewTypeCount()方法iew返回 总共多少个类别</span></span><ul><li><span class="name"><span class="innerContentContainer">public int getViewTypeCount() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return 2;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重写getItemViewType()方法对应View是哪个类别. 关键接口</span></span><ul><li><span class="name"><span class="innerContentContainer">public int getItemViewType(int position) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (mData.get(position) instanceof App) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return TYPE_APP;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else if (mData.get(position) instanceof Book) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return TYPE_BOOK;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">return super.getItemViewType(position);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在getView那里调用getItemViewType获得对应类别，再加载对应的View</span></span><ul><li><span class="name"><span class="innerContentContainer">代码较长. 不贴了.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">GridView(网格视图)</span></span><ul><li><span class="name"><span class="innerContentContainer">GridView和ListView一样是AbsListView的子类. 和ListView很类似, 主要的不同是支持多列显示.</span></span></li><li><span class="name"><span class="innerContentContainer">一些属性</span></span><ul><li><span class="name"><span class="innerContentContainer">android:columnWidth：设置列的宽度</span></span></li><li><span class="name"><span class="innerContentContainer">android:gravity：组件对其方式</span></span></li><li><span class="name"><span class="innerContentContainer">android:horizontalSpacing：水平方向每个单元格的间距</span></span></li><li><span class="name"><span class="innerContentContainer">android:verticalSpacing：垂直方向每个单元格的间距</span></span></li><li><span class="name"><span class="innerContentContainer">android:numColumns：设置列数. 数字.</span></span></li><li><span class="name"><span class="innerContentContainer">android:stretchMode：设置拉伸模式. 值域:</span></span><ul><li><span class="name"><span class="innerContentContainer">none：不拉伸;</span></span></li><li><span class="name"><span class="innerContentContainer">spacingWidth：拉伸元素间的间隔空隙;</span></span></li><li><span class="name"><span class="innerContentContainer">columnWidth：仅仅拉伸表格元素自身;</span></span></li><li><span class="name"><span class="innerContentContainer">spacingWidthUniform：既拉元素间距又拉伸他们之间的间隔空袭.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">private GridView grid_photo;</span></span></li><li><span class="name"><span class="innerContentContainer">private BaseAdapter mAdapter = null;</span></span></li><li><span class="name"><span class="innerContentContainer">private ArrayList&lt;Icon&gt; mData = null;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">mContext = MainActivity.this;</span></span></li><li><span class="name"><span class="innerContentContainer">grid_photo = (GridView) findViewById(R.id.grid_photo);</span></span></li><li><span class="name"><span class="innerContentContainer">mData = new ArrayList&lt;Icon&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(new Icon(R.mipmap.iv_icon_1, "图标1"));</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(new Icon(R.mipmap.iv_icon_2, "图标2"));</span></span></li><li><span class="name"><span class="innerContentContainer">mAdapter = new MyAdapter&lt;Icon&gt;(mData, R.layout.item_grid_icon) {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void bindView(ViewHolder holder, Icon obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder.setImageResource(R.id.img_icon, obj.getiId());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.setText(R.id.txt_icon, obj.getiName());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">grid_photo.setAdapter(mAdapter);</span></span></li><li><span class="name"><span class="innerContentContainer">grid_photo.setOnItemClickListener(new AdapterView.OnItemClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext, "你点击了~" + position + "~项", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Spinner(列表选项框)</span></span><ul><li><span class="name"><span class="innerContentContainer">功能: 当我们的app需要用户输入数据时，除了让用户自己打字以外，还有一种方便的设计: 列出一组选项让用户从中挑选.</span></span></li><li><span class="name"><span class="innerContentContainer">相关属性</span></span><ul><li><span class="name"><span class="innerContentContainer">android:dropDownHorizontalOffset：设置列表框的水平偏移距离</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownVerticalOffset：设置列表框的水平竖直距离</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownSelector：列表框被选中时的背景</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownWidth：设置下拉列表框的宽度</span></span></li><li><span class="name"><span class="innerContentContainer">android:gravity：设置里面组件的对其方式</span></span></li><li><span class="name"><span class="innerContentContainer">android:popupBackground：设置列表框的背景</span></span></li><li><span class="name"><span class="innerContentContainer">android:prompt：设置对话框模式的列表框的提示信息(标题)，只能够引用string.xml 中的资源id,而不能直接写字符串</span></span></li><li><span class="name"><span class="innerContentContainer">android:spinnerMode：列表框的模式. 值域:</span></span><ul><li><span class="name"><span class="innerContentContainer">dropdown：下拉菜单风格的窗口(默认)</span></span></li><li><span class="name"><span class="innerContentContainer">dialog：对话框风格的窗口</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可选属性：android:entries：使用数组资源设置下拉列表框的列表项目</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Spinner会默认选中第一个值，请把默认值放在这里, 方便用户选择. </span></span></li><li><span class="name"><span class="innerContentContainer">代码: 第一步, 在layout文件中加入控件定义:</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;Spinner</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/spin_one"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="100dp"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="64dp"</span></span></li><li><span class="name"><span class="innerContentContainer">android:entries="@array/data"</span></span></li><li><span class="name"><span class="innerContentContainer">android:prompt="@string/spin_title"</span></span></li><li><span class="name"><span class="innerContentContainer">android:spinnerMode="dialog" /&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">第二步, 使用:</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Spinner spin_one;</span></span></li><li><span class="name"><span class="innerContentContainer">private Spinner spin_two;</span></span></li><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">// 判断是否为刚进去时触发onItemSelected的标志</span></span></li><li><span class="name"><span class="innerContentContainer">private boolean one_selected = false;</span></span></li><li><span class="name"><span class="innerContentContainer">private boolean two_selected = false;</span></span></li><li><span class="name"><span class="innerContentContainer">private ArrayList&lt;Hero&gt; mData = null;</span></span></li><li><span class="name"><span class="innerContentContainer">private BaseAdapter myAdadpter = null;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">mContext = MainActivity.this;</span></span></li><li><span class="name"><span class="innerContentContainer">mData = new ArrayList&lt;Hero&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">bindViews();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private void bindViews() {</span></span><ul><li><span class="name"><span class="innerContentContainer">spin_one = (Spinner) findViewById(R.id.spin_one);</span></span></li><li><span class="name"><span class="innerContentContainer">spin_two = (Spinner) findViewById(R.id.spin_two);</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(new Hero(R.mipmap.iv_lol_icon1,"迅捷斥候：提莫（Teemo）"));</span></span></li><li><span class="name"><span class="innerContentContainer">mData.add(new Hero(R.mipmap.iv_lol_icon2,"诺克萨斯之手：德莱厄斯（Darius）"));</span></span></li><li><span class="name"><span class="innerContentContainer">myAdadpter = new MyAdapter&lt;Hero&gt;(mData,R.layout.item_spin_hero) {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void bindView(ViewHolder holder, Hero obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder.setImageResource(R.id.img_icon,obj.gethIcon());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.setText(R.id.txt_name, obj.gethName());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">spin_two.setAdapter(myAdadpter);</span></span></li><li><span class="name"><span class="innerContentContainer">spin_one.setOnItemSelectedListener(this);</span></span></li><li><span class="name"><span class="innerContentContainer">spin_two.setOnItemSelectedListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (parent.getId()){</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.spin_one:</span></span><ul><li><span class="name"><span class="innerContentContainer">if(one_selected){</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext,"您的分段是~：" + parent.getItemAtPosition(position).toString(),</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.LENGTH_SHORT).show();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}else one_selected = true;</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.spin_two:</span></span><ul><li><span class="name"><span class="innerContentContainer">if(two_selected){</span></span><ul><li><span class="name"><span class="innerContentContainer">TextView txt_name = (TextView) view.findViewById(R.id.txt_name);</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext,"您选择的英雄是~：" + txt_name.getText().toString(),</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.LENGTH_SHORT).show();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}else two_selected = true;</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onNothingSelected(AdapterView&lt;?&gt; parent) {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AutoCompleteTextView(自动完成文本框)</span></span><ul><li><span class="name"><span class="innerContentContainer">属性</span></span><ul><li><span class="name"><span class="innerContentContainer">android:completionHint：设置下拉菜单中的提示标题. 比如 "请输入搜索内容". 如果觉得丑可以设置一个View.</span></span></li><li><span class="name"><span class="innerContentContainer">android:completionHintView：定义提示视图中显示下拉菜单.</span></span></li><li><span class="name"><span class="innerContentContainer">android:completionThreshold：指定至少输入多少个字符才会显示提示. 1表示输入1个就提示.</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownAnchor：设置下拉菜单的定位"锚点"组件，如果没有指定改属性， 将使用该TextView作为定位"锚点"组件</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownHeight：设置下拉菜单的高度</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownWidth：设置下拉菜单的宽度</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownHorizontalOffset：指定下拉菜单与文本之间的水平间距</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownVerticalOffset：指定下拉菜单与文本之间的竖直间距</span></span></li><li><span class="name"><span class="innerContentContainer">android:dropDownSelector：设置下拉菜单点击效果</span></span></li><li><span class="name"><span class="innerContentContainer">android:popupBackground：设置下拉菜单的背景</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ExpandableListView(可折叠列表)</span></span><ul><li><span class="name"><span class="innerContentContainer">属性:</span></span><ul><li><span class="name"><span class="innerContentContainer">android:childDivider：指定各组内子类表项之间的分隔条，图片不会完全显示， 分离子列表项的是一条直线</span></span></li><li><span class="name"><span class="innerContentContainer">android:childIndicator：显示在子列表旁边的Drawable对象，可以是一个图像</span></span></li><li><span class="name"><span class="innerContentContainer">android:childIndicatorEnd：子列表项指示符的结束约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:childIndicatorLeft：子列表项指示符的左边约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:childIndicatorRight：子列表项指示符的右边约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:childIndicatorStart：子列表项指示符的开始约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:groupIndicator：显示在组列表旁边的Drawable对象，可以是一个图像</span></span></li><li><span class="name"><span class="innerContentContainer">android:indicatorEnd：组列表项指示器的结束约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:indicatorLeft：组列表项指示器的左边约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:indicatorRight：组列表项指示器的右边约束位置</span></span></li><li><span class="name"><span class="innerContentContainer">android:indicatorStart：组列表项指示器的开始约束位置</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">核心是重写BaseExpandableListAdpter，其实和之前写的普通的BaseAdapter是类似的， 但是BaseExpandableListAdpter则分成了两部分：组和子列表.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ViewFlipper(翻转视图)</span></span><ul><li><span class="name"><span class="innerContentContainer">是一个多页面管理控件，且支持自动播放. 多用于应用的引导页, 或者用于图片轮播.</span></span></li><li><span class="name"><span class="innerContentContainer">和ViewPager不同，ViewPager是一页页的，而ViewFlipper则是一层层的.</span></span></li><li><span class="name"><span class="innerContentContainer">属性</span></span><ul><li><span class="name"><span class="innerContentContainer">setInAnimation：设置View进入屏幕时使用的动画</span></span></li><li><span class="name"><span class="innerContentContainer">setOutAnimation：设置View退出屏幕时使用的动画</span></span></li><li><span class="name"><span class="innerContentContainer">showNext：调用该方法来显示ViewFlipper里的下一个View</span></span></li><li><span class="name"><span class="innerContentContainer">showPrevious：调用该方法来显示ViewFlipper的上一个View</span></span></li><li><span class="name"><span class="innerContentContainer">setFilpInterval：设置View之间切换的时间间隔</span></span></li><li><span class="name"><span class="innerContentContainer">setFlipping：使用上面设置的时间间隔来开始切换所有的View，切换会循环进行</span></span></li><li><span class="name"><span class="innerContentContainer">stopFlipping：停止View切换</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子</span></span><ul><li><span class="name"><span class="innerContentContainer">// 布局中这么定义.</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;ViewFlipper</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/vflp_help"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:inAnimation="@anim/right_in"</span></span></li><li><span class="name"><span class="innerContentContainer">android:outAnimation="@anim/right_out"</span></span></li><li><span class="name"><span class="innerContentContainer">// 每隔3000ms切换一次.</span></span></li><li><span class="name"><span class="innerContentContainer">android:flipInterval="3000"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;include layout="@layout/page_help_one" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;include layout="@layout/page_help_two" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;include layout="@layout/page_help_three" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;include layout="@layout/page_help_four" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/ViewFlipper&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 代码中调用 <b>startFlipping() 即尅是播放.</b></span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">vflp_help = (ViewFlipper) findViewById(R.id.vflp_help);</span></span></li><li><span class="name"><span class="innerContentContainer">vflp_help.<b>startFlipping</b>();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Toast(吐司)</span></span><ul><li><span class="name"><span class="innerContentContainer">直接调用Toast类的makeText()方法创建:</span></span><ul><li><span class="name"><span class="innerContentContainer">比如点击一个按钮，然后弹出Toast，</span></span></li><li><span class="name"><span class="innerContentContainer">用法：&nbsp;Toast.makeText(MainActivity.this, "提示内容", Toast.LENGTH_LONG).show();</span></span></li><li><span class="name"><span class="innerContentContainer">其中第3个参数是显示时间，只有 LONG 和 SHORT 两种.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果需要对Toast窗口做更多定制, 则要这么做:</span></span><ul><li><span class="name"><span class="innerContentContainer">private void midToast(String str, int showTime) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast toast = Toast.makeText(mContext, str, showTime);</span></span></li><li><span class="name"><span class="innerContentContainer">toast.setGravity(Gravity.CENTER_HORIZONTAL|Gravity.BOTTOM , 0, 0);  //设置显示位置</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout layout = (LinearLayout) toast.getView();</span></span></li><li><span class="name"><span class="innerContentContainer">layout.setBackgroundColor(Color.BLUE);</span></span></li><li><span class="name"><span class="innerContentContainer">ImageView image = new ImageView(this);</span></span></li><li><span class="name"><span class="innerContentContainer">image.setImageResource(R.mipmap.ic_icon_qitao);</span></span></li><li><span class="name"><span class="innerContentContainer">layout.addView(image, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">TextView v = (TextView) toast.getView().findViewById(android.R.id.message);</span></span></li><li><span class="name"><span class="innerContentContainer">v.setTextColor(Color.YELLOW);     //设置字体颜色</span></span></li><li><span class="name"><span class="innerContentContainer">toast.show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一个常见的效果: 圆角. 在布局文件中加入</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;!-- 设置四个圆角的半径 --&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;corners</span></span><ul><li><span class="name"><span class="innerContentContainer">android:bottomLeftRadius="50px"</span></span></li><li><span class="name"><span class="innerContentContainer">android:bottomRightRadius="50px"</span></span></li><li><span class="name"><span class="innerContentContainer">android:topLeftRadius="50px"</span></span></li><li><span class="name"><span class="innerContentContainer">android:topRightRadius="50px" /&gt;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Notification(状态栏通知)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Notification，是一种具有全局效果的通知，可以在系统的通知栏中显示。</span></span></li><li><span class="name"><span class="innerContentContainer">当 APP 向系统发出通知时，它将先以图标的形式显示在通知栏中。用户可以下拉通知栏查看通知的详细信息。</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏和抽屉式通知栏均是由系统控制，用户可以随时查看。</span></span></li><li><span class="name"><span class="innerContentContainer">Notification 的基本操作：有创建、更新、取消这三种。</span></span></li><li><span class="name"><span class="innerContentContainer">涉及到3个类：</span></span><ul><li><span class="name"><span class="innerContentContainer">Notification.Builer&nbsp;: 使用建造者模式构建 Notification 对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">仅支持 Android 4.1及之后的版本，为了解决兼容性问题， Google 在 Android Support v4 中加入了 NotificationCompat.Builder 类。</span></span></li><li><span class="name"><span class="innerContentContainer">但是请注意，对于某些在 Android 4.1 之后才特性，使用NotificationCompat.Builder也不可用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Notification&nbsp;: 通知对应类，保存通知相关的数据。NotificationManager 向系统发送通知时会用到。</span></span></li><li><span class="name"><span class="innerContentContainer">NotificationManager&nbsp;: NotificationManager 是通知管理类，它是一个系统服务。调用 NotificationManager 的 notify() 方法可以向系统发送通知。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性</span></span><ul><li><span class="name"><span class="innerContentContainer">Notification.Builder mBuilder = new Notification.Builder(this);</span></span></li><li><span class="name"><span class="innerContentContainer">后再调用下述的相关的方法进行设置：(官方API文档：Notification.Builder) 常用的方法如下：</span></span></li><li><span class="name"><span class="innerContentContainer"><b>setContentTitle</b>(CharSequence)：标题（<b>必须</b>）</span></span></li><li><span class="name"><span class="innerContentContainer"><b>setSmallIcon</b>(int)：右下角的小图标（<b>必须</b>）</span></span><ul><li><span class="name"><span class="innerContentContainer">在接收到通知的时候顶部也会显示这个小图标。</span></span></li><li><span class="name"><span class="innerContentContainer">当大小图标都设置了的时, smallIcon 显示在通知的右下角, largeIcon 显示在左侧。</span></span></li><li><span class="name"><span class="innerContentContainer">当只设置 setSmallIcon() 时, smallIcon 显示在左侧。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>setContentText</b>(CharSequence)：通知内容（<b>必须</b>）</span></span></li><li><span class="name"><span class="innerContentContainer">setLargeIcon(Bitmap)：设置左边的大图标（可选，以下都可选）</span></span></li><li><span class="name"><span class="innerContentContainer">setSubText(CharSequence)：内容下面一小行的文字</span></span></li><li><span class="name"><span class="innerContentContainer">setTicker(CharSequence)：设置收到通知时在顶部显示的文字信息</span></span></li><li><span class="name"><span class="innerContentContainer"><b>setWhen</b>(long)：设置通知时间，一般设置的是收到通知时的System.currentTimeMillis()</span></span></li><li><span class="name"><span class="innerContentContainer">setAutoCancel(boolean)：用户点击Notification点击面板后是否让通知取消(默认不取消)</span></span></li><li><span class="name"><span class="innerContentContainer">setDefaults(int)：向通知添加声音、闪灯和振动效果的最简单、 使用默认（defaults）属性，可以组合多个属性，</span></span><ul><li><span class="name"><span class="innerContentContainer">Notification.DEFAULT_VIBRATE(添加默认震动提醒)；</span></span></li><li><span class="name"><span class="innerContentContainer">Notification.DEFAULT_SOUND(添加默认声音提醒)；</span></span></li><li><span class="name"><span class="innerContentContainer">Notification.DEFAULT_LIGHTS(添加默认三色灯提醒)</span></span></li><li><span class="name"><span class="innerContentContainer">Notification.DEFAULT_ALL(添加默认以上3种全部提醒)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">setVibrate(long[])：设置振动方式，比如：</span></span><ul><li><span class="name"><span class="innerContentContainer">setVibrate(new long[] {0,300,500,700});延迟0ms，然后振动300ms，在延迟500ms， 接着再振动700ms，关于Vibrate用法后面会讲解。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">setLights(int argb, int onMs, int offMs)：设置三色灯，参数依次是：灯光颜色， 亮持续时间，暗的时间，不是所有颜色都可以，这跟设备有关，有些手机还不带三色灯； 另外，还需要为Notification设置flags为Notification.FLAG_SHOW_LIGHTS才支持三色灯提醒！</span></span></li><li><span class="name"><span class="innerContentContainer">setSound(Uri)：设置接收到通知时的铃声，可以用系统的，也可以自己设置，例子如下:</span></span></li><li><span class="name"><span class="innerContentContainer">setDefaults(Notification.DEFAULT_SOUND)  // 获取默认铃声</span></span></li><li><span class="name"><span class="innerContentContainer">setSound(Uri.parse("file:///sdcard/xx/xx.mp3"))  // 获取自定义铃声</span></span></li><li><span class="name"><span class="innerContentContainer">setSound(Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, "5")) //获取Android多媒体库内的铃声</span></span></li><li><span class="name"><span class="innerContentContainer">setOngoing(boolean)：设置为ture，表示它为一个正在进行的通知。他们通常是用来表示 一个后台任务,用户积极参与(如播放音乐)或以某种方式正在等待,因此占用设备(如一个文件下载, 同步操作,主动网络连接)</span></span></li><li><span class="name"><span class="innerContentContainer">setProgress(int,int,boolean)：设置带进度条的通知 参数依次为：进度条最大数值，当前进度，进度是否不确定 如果为确定的进度条：调用setProgress(max, progress, false)来设置通知， 在更新进度的时候在此发起通知更新progress，并且在下载完成后要移除进度条 ，通过调用setProgress(0, 0, false)既可。如果为不确定（持续活动）的进度条， 这是在处理进度无法准确获知时显示活动正在持续，所以调用setProgress(0, 0, true) ，操作结束时，调用setProgress(0, 0, false)并更新通知以移除指示条</span></span></li><li><span class="name"><span class="innerContentContainer">setContentIntent(PendingIntent)：PendingIntent。</span></span><ul><li><span class="name"><span class="innerContentContainer">PendingIntent 是一种特殊的 Intent ，字面意思可以解释为延迟的 Intent ，用于在某个事件结束后执行特定的 Action 。</span></span></li><li><span class="name"><span class="innerContentContainer">PendingIntent可以设置执行次数， 主要用于远程服务通信、闹铃、通知、启动器、短信中。</span></span></li><li><span class="name"><span class="innerContentContainer">比如这里通过 Pending启动Activity：getActivity(Context, int, Intent, int)，当然还可以启动Service或者Broadcast。</span></span></li><li><span class="name"><span class="innerContentContainer">注意： PendingIntent 是 AMS 管理并持有的对象。即便创建该 PendingIntent对象的进程被杀死了，这个PendingItent对象在其他进程中还是可用的。</span></span></li><li><span class="name"><span class="innerContentContainer">PendingIntent的位标识符(第四个参数)：</span></span><ul><li><span class="name"><span class="innerContentContainer">FLAG_ONE_SHOT&nbsp;表示返回的PendingIntent仅能执行一次，执行完后自动取消</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_NO_CREATE&nbsp;表示如果描述的PendingIntent不存在，并不创建相应的PendingIntent，而是返回NULL</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_CANCEL_CURRENT&nbsp;表示相应的PendingIntent已经存在，则取消前者，然后创建新的PendingIntent， 这个有利于数据保持为最新的，可以用于即时通信的通信场景</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_UPDATE_CURRENT&nbsp;表示更新的 PendingIntent.  </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">setPriority(int)：设置优先级. 值域包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">MAX	重要而紧急的通知，通知用户这个事件是时间上紧迫的或者需要立即处理的。</span></span></li><li><span class="name"><span class="innerContentContainer">HIGH	高优先级用于重要的通信内容，例如短消息或者聊天，这些都是对用户来说比较有兴趣的。</span></span></li><li><span class="name"><span class="innerContentContainer">DEFAULT	默认优先级用于没有特殊优先级分类的通知。</span></span></li><li><span class="name"><span class="innerContentContainer">LOW	低优先级可以通知用户但又不是很紧急的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">MIN	     用于后台消息 (例如天气或者位置信息)。最低优先级通知将只在状态栏显示图标，只有用户下拉通知抽屉才能看到内容。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Notification的基本使用流程</span></span><ul><li><span class="name"><span class="innerContentContainer">Step 1.&nbsp;获得NotificationManager对象： NotificationManager mNManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">Step 2.&nbsp;创建一个通知栏的Builder构造类： Notification.Builder mBuilder = new Notification.Builder(this);</span></span></li><li><span class="name"><span class="innerContentContainer">Step 3.&nbsp;对Builder进行相关的设置，比如标题，内容，图标，动作等！</span></span></li><li><span class="name"><span class="innerContentContainer">Step 4.调用Builder的build()方法为notification赋值</span></span></li><li><span class="name"><span class="innerContentContainer">Step 5.调用NotificationManager的notify()方法发送通知！</span></span></li><li><span class="name"><span class="innerContentContainer">PS:另外我们还可以调用NotificationManager的cancel()方法取消通知</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">简单例子：</span></span></li><li><span class="name"><span class="innerContentContainer">private void sendNotification() {</span></span><ul><li><span class="name"><span class="innerContentContainer">//  1. 获取NotificationManager实例</span></span></li><li><span class="name"><span class="innerContentContainer">NotificationManager notifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">// 2. 实例化NotificationCompat.Builde并设置相关属性</span></span></li><li><span class="name"><span class="innerContentContainer">NotificationCompat.Builder builder = new NotificationCompat.Builder(this)</span></span><ul><li><span class="name"><span class="innerContentContainer">// 设置小图标</span></span></li><li><span class="name"><span class="innerContentContainer">.setSmallIcon(R.mipmap.icon_fab_repair)</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置通知标题</span></span></li><li><span class="name"><span class="innerContentContainer">.setContentTitle("最简单的Notification")</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置通知内容</span></span></li><li><span class="name"><span class="innerContentContainer">.setContentText("只有小图标、标题、内容")</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置通知时间，默认为系统发出通知的时间，通常不用设置</span></span></li><li><span class="name"><span class="innerContentContainer">//.setWhen(System.currentTimeMillis());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 3. 通过builder.build()方法生成Notification对象,并发送通知,id=1</span></span></li><li><span class="name"><span class="innerContentContainer">notifyManager.notify(1, builder.build());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">如果需要用户交互，则应该给 Notification 设置一个 Action。</span></span><ul><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">// 发送一个点击跳转到MainActivity的消息</span></span></li><li><span class="name"><span class="innerContentContainer">Intent mainIntent = new Intent(this, MainActivity.class);</span></span></li><li><span class="name"><span class="innerContentContainer">PendingIntent mainPendingIntent = PendingIntent.getActivity(this, 0, mainIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span></span></li><li><span class="name"><span class="innerContentContainer">然后在 new NotificationCompat.Builder() 中setContentIntent(mainPendingIntent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复杂例子：</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity implements View.OnClickListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">private NotificationManager mNManager;</span></span></li><li><span class="name"><span class="innerContentContainer">private Notification notify1;</span></span></li><li><span class="name"><span class="innerContentContainer">Bitmap LargeBitmap = null;</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int NOTIFYID_1 = 1;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btn_show_normal;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btn_close_normal;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">mContext = MainActivity.this;</span></span></li><li><span class="name"><span class="innerContentContainer">// 创建大图标的Bitmap</span></span></li><li><span class="name"><span class="innerContentContainer">LargeBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.iv_lc_icon);</span></span></li><li><span class="name"><span class="innerContentContainer">mNManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">bindView();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private void bindView() {</span></span><ul><li><span class="name"><span class="innerContentContainer">btn_show_normal = (Button) findViewById(R.id.btn_show_normal);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_close_normal = (Button) findViewById(R.id.btn_close_normal);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_show_normal.setOnClickListener(this);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_close_normal.setOnClickListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (v.getId()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.btn_show_normal:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 定义一个PendingIntent点击Notification后启动一个Activity</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it = new Intent(mContext, OtherActivity.class);</span></span></li><li><span class="name"><span class="innerContentContainer">PendingIntent pit = PendingIntent.getActivity(mContext, 0, it, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">//设置图片,通知标题,发送时间,提示方式等属性</span></span></li><li><span class="name"><span class="innerContentContainer">Notification.Builder mBuilder = new Notification.Builder(this);</span></span></li><li><span class="name"><span class="innerContentContainer">mBuilder.setContentTitle("叶良辰") </span></span><ul><li><span class="name"><span class="innerContentContainer">.setContentText("我有一百种方法让你呆不下去~")  </span></span></li><li><span class="name"><span class="innerContentContainer">.setSubText("——记住我叫叶良辰") </span></span></li><li><span class="name"><span class="innerContentContainer">.setTicker("收到叶良辰发送过来的信息~") </span></span></li><li><span class="name"><span class="innerContentContainer">.setWhen(System.currentTimeMillis()) </span></span></li><li><span class="name"><span class="innerContentContainer">.setSmallIcon(R.mipmap.ic_lol_icon) </span></span></li><li><span class="name"><span class="innerContentContainer">.setLargeIcon(LargeBitmap) </span></span></li><li><span class="name"><span class="innerContentContainer">.setDefaults(Notification.DEFAULT_LIGHTS | Notification.DEFAULT_VIBRATE)</span></span></li><li><span class="name"><span class="innerContentContainer">.setSound(Uri.parse("android.resource://" + getPackageName() + "/" + R.raw.biaobiao)) </span></span></li><li><span class="name"><span class="innerContentContainer">.setAutoCancel(true) </span></span></li><li><span class="name"><span class="innerContentContainer">.setContentIntent(pit);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">notify1 = mBuilder.build();</span></span></li><li><span class="name"><span class="innerContentContainer">mNManager.notify(NOTIFYID_1, notify1);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_close_normal:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 除了可以根据ID来取消Notification外,还可以调用cancelAll();关闭该应用产生的所有通知</span></span></li><li><span class="name"><span class="innerContentContainer">mNManager.cancel(NOTIFYID_1);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AlertDialog(对话框)</span></span><ul><li><span class="name"><span class="innerContentContainer">AlertDialog是其他 Dialog的的父类, 包括ProgressDialog，TimePickerDialog等.</span></span></li><li><span class="name"><span class="innerContentContainer">不像Toast和Notification，AlertDialog并不能直接new出来.  AlertDialog的构造方法是protected的.</span></span></li><li><span class="name"><span class="innerContentContainer">如果要创建AlertDialog的话，需要使用到该类中的一个静态内部类：public static class&nbsp;Builder，然后来调用AlertDialog 里的相关方法来对AlertDialog进行定制，最后调用show()方法来显示我们的AlertDialog对话框.</span></span></li><li><span class="name"><span class="innerContentContainer">基本使用流程</span></span><ul><li><span class="name"><span class="innerContentContainer">Step 1：创建AlertDialog.Builder对象；</span></span></li><li><span class="name"><span class="innerContentContainer">Step 2：调用setIcon()设置图标，setTitle()或setCustomTitle()设置标题；</span></span></li><li><span class="name"><span class="innerContentContainer">Step 3：设置对话框的内容：setMessage()还有其他方法来指定显示的内容；</span></span></li><li><span class="name"><span class="innerContentContainer">Step 4：调用setPositive/Negative/NeutralButton()设置：确定，取消，中立按钮；</span></span></li><li><span class="name"><span class="innerContentContainer">Step 5：调用create()方法创建这个对象，再调用show()方法将对话框显示出来；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子: 点击后弹出对话框.</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (v.getId()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//普通对话框</span></span></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_dialog_one:</span></span><ul><li><span class="name"><span class="innerContentContainer">alert = null;</span></span></li><li><span class="name"><span class="innerContentContainer">builder = new AlertDialog.Builder(mContext);</span></span></li><li><span class="name"><span class="innerContentContainer">alert = builder.setIcon(R.mipmap.ic_icon_fish)</span></span><ul><li><span class="name"><span class="innerContentContainer">.setTitle("系统提示：")</span></span></li><li><span class="name"><span class="innerContentContainer">.setMessage("这是一个最普通的AlertDialog,\n带有三个按钮，分别是取消，中立和确定")</span></span></li><li><span class="name"><span class="innerContentContainer">.setNegativeButton("取消", new DialogInterface.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext, "你点击了取消按钮~", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">})</span></span></li><li><span class="name"><span class="innerContentContainer">.setPositiveButton("确定", new DialogInterface.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext, "你点击了确定按钮~", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">})</span></span></li><li><span class="name"><span class="innerContentContainer">.setNeutralButton("中立", new DialogInterface.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(mContext, "你点击了中立按钮~", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).create();             //创建AlertDialog对象</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">alert.show();                    //显示对话框</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">//普通列表对话框</span></span></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_dialog_two:</span></span><ul><li><span class="name"><span class="innerContentContainer">final String[] lesson = new String[]{"语文", "数学", "英语", "化学", "生物", "物理", "体育"};</span></span></li><li><span class="name"><span class="innerContentContainer">alert = null;</span></span></li><li><span class="name"><span class="innerContentContainer">builder = new AlertDialog.Builder(mContext);</span></span></li><li><span class="name"><span class="innerContentContainer">alert = builder.setIcon(R.mipmap.ic_icon_fish)</span></span><ul><li><span class="name"><span class="innerContentContainer">.setTitle("选择你喜欢的课程")</span></span></li><li><span class="name"><span class="innerContentContainer">.setItems(lesson, new DialogInterface.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "你选择了" + lesson[which], Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).create();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">alert.show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">//单选列表对话框</span></span></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_dialog_three:</span></span><ul><li><span class="name"><span class="innerContentContainer">final String[] fruits = new String[]{"苹果", "雪梨", "香蕉", "葡萄", "西瓜"};</span></span></li><li><span class="name"><span class="innerContentContainer">alert = null;</span></span></li><li><span class="name"><span class="innerContentContainer">builder = new AlertDialog.Builder(mContext);</span></span></li><li><span class="name"><span class="innerContentContainer">alert = builder.setIcon(R.mipmap.ic_icon_fish)</span></span><ul><li><span class="name"><span class="innerContentContainer">.setTitle("选择你喜欢的水果，只能选一个哦~")</span></span></li><li><span class="name"><span class="innerContentContainer">.setSingleChoiceItems(fruits, 0, new DialogInterface.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "你选择了" + fruits[which], Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).create();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">alert.show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">//多选列表对话框</span></span></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_dialog_four:</span></span><ul><li><span class="name"><span class="innerContentContainer">final String[] menu = new String[]{"水煮豆腐", "萝卜牛腩", "酱油鸡", "胡椒猪肚鸡"};</span></span></li><li><span class="name"><span class="innerContentContainer">//定义一个用来记录个列表项状态的boolean数组</span></span></li><li><span class="name"><span class="innerContentContainer">checkItems = new boolean[]{false, false, false, false};</span></span></li><li><span class="name"><span class="innerContentContainer">alert = null;</span></span></li><li><span class="name"><span class="innerContentContainer">builder = new AlertDialog.Builder(mContext);</span></span></li><li><span class="name"><span class="innerContentContainer">alert = builder.setIcon(R.mipmap.ic_icon_fish)</span></span><ul><li><span class="name"><span class="innerContentContainer">.setMultiChoiceItems(menu, checkItems, new DialogInterface.OnMultiChoiceClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which, boolean isChecked) {</span></span><ul><li><span class="name"><span class="innerContentContainer">checkItems[which] = isChecked;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">})</span></span></li><li><span class="name"><span class="innerContentContainer">.setPositiveButton("确定", new DialogInterface.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(DialogInterface dialog, int which) {</span></span><ul><li><span class="name"><span class="innerContentContainer">String result = "";</span></span></li><li><span class="name"><span class="innerContentContainer">for (int i = 0; i &lt; checkItems.length; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (checkItems[i])</span></span><ul><li><span class="name"><span class="innerContentContainer">result += menu[i] + " ";</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "客官你点了:" + result, Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">})</span></span></li><li><span class="name"><span class="innerContentContainer">.create();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">alert.show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ProgressDialog(进度条对话框)</span></span><ul><li><span class="name"><span class="innerContentContainer">创建进度条对话框的方式有两种：</span></span><ul><li><span class="name"><span class="innerContentContainer">直接调用ProgressDialog提供的静态方法show()显示</span></span></li><li><span class="name"><span class="innerContentContainer">创建ProgressDialog,再设置对话框的参数,最后show()出来</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity implements View.OnClickListener{</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btn_one;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btn_two;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btn_three;</span></span></li><li><span class="name"><span class="innerContentContainer">private ProgressDialog pd1 = null;</span></span></li><li><span class="name"><span class="innerContentContainer">private ProgressDialog pd2 = null;</span></span></li><li><span class="name"><span class="innerContentContainer">private final static int MAXVALUE = 100;</span></span></li><li><span class="name"><span class="innerContentContainer">private int progressStart = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">private int add = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">private Context mContext = null;</span></span></li><li><span class="name"><span class="innerContentContainer">//定义一个用于更新进度的Handler,因为只能由主线程更新界面,所以要用Handler传递信息</span></span></li><li><span class="name"><span class="innerContentContainer">final Handler hand = new Handler()</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">public void handleMessage(Message msg) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//这里的话如果接受到信息码是123</span></span></li><li><span class="name"><span class="innerContentContainer">if(msg.what == 123)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">//设置进度条的当前值</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setProgress(progressStart);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//如果当前大于或等于进度条的最大值,调用dismiss()方法关闭对话框</span></span></li><li><span class="name"><span class="innerContentContainer">if(progressStart &gt;= MAXVALUE)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">pd2.dismiss();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">mContext = MainActivity.this;</span></span></li><li><span class="name"><span class="innerContentContainer">bindViews();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private void bindViews() {</span></span><ul><li><span class="name"><span class="innerContentContainer">btn_one = (Button) findViewById(R.id.btn_one);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_two = (Button) findViewById(R.id.btn_two);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_three = (Button) findViewById(R.id.btn_three);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_one.setOnClickListener(this);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_two.setOnClickListener(this);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_three.setOnClickListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (v.getId()){</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.btn_one:</span></span><ul><li><span class="name"><span class="innerContentContainer">//这里的话参数依次为,上下文,标题,内容,是否显示进度,是否可以用取消按钮关闭</span></span></li><li><span class="name"><span class="innerContentContainer">ProgressDialog.show(MainActivity.this, "资源加载中", "资源加载中,请稍后...",false,true);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_two:</span></span><ul><li><span class="name"><span class="innerContentContainer">pd1 = new ProgressDialog(mContext);</span></span></li><li><span class="name"><span class="innerContentContainer">//依次设置标题,内容,是否用取消按钮关闭,是否显示进度</span></span></li><li><span class="name"><span class="innerContentContainer">pd1.setTitle("软件更新中");</span></span></li><li><span class="name"><span class="innerContentContainer">pd1.setMessage("软件正在更新中,请稍后...");</span></span></li><li><span class="name"><span class="innerContentContainer">pd1.setCancelable(true);</span></span></li><li><span class="name"><span class="innerContentContainer">//这里是设置进度条的风格,HORIZONTAL是水平进度条,SPINNER是圆形进度条</span></span></li><li><span class="name"><span class="innerContentContainer">pd1.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span></span></li><li><span class="name"><span class="innerContentContainer">pd1.setIndeterminate(true);</span></span></li><li><span class="name"><span class="innerContentContainer">//调用show()方法将ProgressDialog显示出来</span></span></li><li><span class="name"><span class="innerContentContainer">pd1.show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_three:</span></span><ul><li><span class="name"><span class="innerContentContainer">//初始化属性</span></span></li><li><span class="name"><span class="innerContentContainer">progressStart = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">add = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">//依次设置一些属性</span></span></li><li><span class="name"><span class="innerContentContainer">pd2 = new ProgressDialog(MainActivity.this);</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setMax(MAXVALUE);</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setTitle("文件读取中");</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setMessage("文件加载中,请稍后...");</span></span></li><li><span class="name"><span class="innerContentContainer">//这里设置为不可以通过按取消按钮关闭进度条</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setCancelable(false);</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span></span></li><li><span class="name"><span class="innerContentContainer">//这里设置的是是否显示进度,设为false才是显示的哦！</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.setIndeterminate(false);</span></span></li><li><span class="name"><span class="innerContentContainer">pd2.show();</span></span></li><li><span class="name"><span class="innerContentContainer">//这里的话新建一个线程,重写run()方法,</span></span></li><li><span class="name"><span class="innerContentContainer">new Thread()</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run()</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">while(progressStart &lt; MAXVALUE)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">//这里的算法是决定进度条变化的,可以按需要写</span></span></li><li><span class="name"><span class="innerContentContainer">progressStart = 2 * usetime() ;</span></span></li><li><span class="name"><span class="innerContentContainer">//把信息码发送给handle让更新界面</span></span></li><li><span class="name"><span class="innerContentContainer">hand.sendEmptyMessage(123);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}.start();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//这里设置一个耗时的方法:</span></span></li><li><span class="name"><span class="innerContentContainer">private int usetime() {</span></span><ul><li><span class="name"><span class="innerContentContainer">add++;</span></span></li><li><span class="name"><span class="innerContentContainer">try{</span></span><ul><li><span class="name"><span class="innerContentContainer">Thread.sleep(100);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}catch (InterruptedException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return add;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">DatePickerDialog(日期选择对话框)与TimePickerDialog(时间选择对话框)</span></span><ul><li><span class="name"><span class="innerContentContainer">直接上例子</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity implements View.OnClickListener{</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btn_date;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btn_time;</span></span></li><li><span class="name"><span class="innerContentContainer">private String result = "";</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">bindViews();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private void bindViews() {</span></span><ul><li><span class="name"><span class="innerContentContainer">btn_date = (Button) findViewById(R.id.btn_date);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_time = (Button) findViewById(R.id.btn_time);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_date.setOnClickListener(this);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_time.setOnClickListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">result = "";</span></span></li><li><span class="name"><span class="innerContentContainer">switch (v.getId()){</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.btn_date:</span></span><ul><li><span class="name"><span class="innerContentContainer">Calendar cale1 = Calendar.getInstance();</span></span></li><li><span class="name"><span class="innerContentContainer">new DatePickerDialog(MainActivity.this,new DatePickerDialog.OnDateSetListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onDateSet(DatePicker view, int year, int monthOfYear,</span></span><ul><li><span class="name"><span class="innerContentContainer">int dayOfMonth) {</span></span></li><li><span class="name"><span class="innerContentContainer">//这里获取到的月份需要加上1哦~</span></span></li><li><span class="name"><span class="innerContentContainer">result += "你选择的是"+year+"年"+(monthOfYear+1)+"月"+dayOfMonth+"日";</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), result, Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span><ul><li><span class="name"><span class="innerContentContainer">,cale1.get(Calendar.YEAR)</span></span><ul><li><span class="name"><span class="innerContentContainer">,cale1.get(Calendar.MONTH)</span></span></li><li><span class="name"><span class="innerContentContainer">,cale1.get(Calendar.DAY_OF_MONTH)).show();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.btn_time:</span></span><ul><li><span class="name"><span class="innerContentContainer">Calendar cale2 = Calendar.getInstance();</span></span></li><li><span class="name"><span class="innerContentContainer">new TimePickerDialog(MainActivity.this, new TimePickerDialog.OnTimeSetListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onTimeSet(TimePicker view, int hourOfDay, int minute) {</span></span><ul><li><span class="name"><span class="innerContentContainer">result = "";</span></span></li><li><span class="name"><span class="innerContentContainer">result += "您选择的时间是:"+hourOfDay+"时"+minute+"分";</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), result, Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}, cale2.get(Calendar.HOUR_OF_DAY), cale2.get(Calendar.MINUTE), true).show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PopupWindow(悬浮框)</span></span><ul><li><span class="name"><span class="innerContentContainer">也是弹出框. 但和AlertDialog对话框不同的是，它的位置可以是随意的.</span></span></li><li><span class="name"><span class="innerContentContainer">另外AlertDialog是非堵塞线程的，而PopupWindow则是堵塞线程的. 即它是模式窗口.</span></span></li><li><span class="name"><span class="innerContentContainer">常用的构造方法</span></span><ul><li><span class="name"><span class="innerContentContainer">public PopupWindow (Context context)</span></span></li><li><span class="name"><span class="innerContentContainer">public PopupWindow(View contentView, int width, int height)</span></span></li><li><span class="name"><span class="innerContentContainer">public PopupWindow(View contentView)</span></span></li><li><span class="name"><span class="innerContentContainer">public PopupWindow(View contentView, int width, int height, boolean focusable)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(View contentView)：设置PopupWindow显示的View</span></span></li><li><span class="name"><span class="innerContentContainer">getContentView()：获得PopupWindow显示的View</span></span></li><li><span class="name"><span class="innerContentContainer">showAsDropDown(View anchor)：相对某个控件的位置（正左下方），无偏移</span></span></li><li><span class="name"><span class="innerContentContainer">showAsDropDown(View anchor, int xoff, int yoff)：相对某个控件的位置，有偏移</span></span></li><li><span class="name"><span class="innerContentContainer">showAtLocation(View parent, int gravity, int x, int y)： 相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 PS:parent这个参数只要是activity中的view就可以了！</span></span></li><li><span class="name"><span class="innerContentContainer">setWidth/setHeight：设置宽高，也可以在构造方法那里指定好宽高， 除了可以写具体的值，还可以用WRAP_CONTENT或MATCH_PARENT， popupWindow的width和height属性直接和第一层View相对应。</span></span></li><li><span class="name"><span class="innerContentContainer">setFocusable(true)：设置焦点，PopupWindow弹出后，所有的触屏和物理按键都由PopupWindows 处理。其他任何事件的响应都必须发生在PopupWindow消失之后，（home 等系统层面的事件除外）。 比如这样一个PopupWindow出现的时候，按back键首先是让PopupWindow消失，第二次按才是退出 activity，准确的说是想退出activity你得首先让PopupWindow消失，因为不并是任何情况下按back PopupWindow都会消失，必须在PopupWindow设置了背景的情况下 。</span></span></li><li><span class="name"><span class="innerContentContainer">setAnimationStyle(int)：设置动画效果</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btn_show;</span></span></li><li><span class="name"><span class="innerContentContainer">private Context mContext;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">mContext = MainActivity.this;</span></span></li><li><span class="name"><span class="innerContentContainer">btn_show = (Button) findViewById(R.id.btn_show);</span></span></li><li><span class="name"><span class="innerContentContainer">btn_show.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">initPopWindow(v);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">private void initPopWindow(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">View view = LayoutInflater.from(mContext).inflate(R.layout.item_popup, null, false);</span></span></li><li><span class="name"><span class="innerContentContainer">Button btn_xixi = (Button) view.findViewById(R.id.btn_xixi);</span></span></li><li><span class="name"><span class="innerContentContainer">Button btn_hehe = (Button) view.findViewById(R.id.btn_hehe);</span></span></li><li><span class="name"><span class="innerContentContainer">//1.构造一个PopupWindow，参数依次是加载的View，宽高</span></span></li><li><span class="name"><span class="innerContentContainer">final PopupWindow popWindow = new PopupWindow(view,</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">popWindow.setAnimationStyle(R.anim.anim_pop);  //设置加载动画</span></span></li><li><span class="name"><span class="innerContentContainer">//这些为了点击非PopupWindow区域，PopupWindow会消失的，如果没有下面的</span></span></li><li><span class="name"><span class="innerContentContainer">//代码的话，你会发现，当你把PopupWindow显示出来了，无论你按多少次后退键</span></span></li><li><span class="name"><span class="innerContentContainer">//PopupWindow并不会关闭，而且退不出程序，加上下述代码可以解决这个问题</span></span></li><li><span class="name"><span class="innerContentContainer">popWindow.setTouchable(true);</span></span></li><li><span class="name"><span class="innerContentContainer">popWindow.setTouchInterceptor(new View.OnTouchListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public boolean onTouch(View v, MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return false;</span></span></li><li><span class="name"><span class="innerContentContainer">// 这里如果返回true的话，touch事件将被拦截</span></span></li><li><span class="name"><span class="innerContentContainer">// 拦截后 PopupWindow的onTouchEvent不被调用，这样点击外部区域无法dismiss</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">popWindow.setBackgroundDrawable(new ColorDrawable(0x00000000));    //要为popWindow设置一个背景才有效</span></span></li><li><span class="name"><span class="innerContentContainer">//设置popupWindow显示的位置，参数依次是参照View，x轴的偏移量，y轴的偏移量</span></span></li><li><span class="name"><span class="innerContentContainer">popWindow.showAsDropDown(v, 50, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">//设置popupWindow里的按钮的事件</span></span></li><li><span class="name"><span class="innerContentContainer">btn_xixi.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this, "你点击了嘻嘻~", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">btn_hehe.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this, "你点击了呵呵~", Toast.LENGTH_SHORT).show();</span></span></li><li><span class="name"><span class="innerContentContainer">popWindow.dismiss();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单(Menu)</span></span><ul><li><span class="name"><span class="innerContentContainer">Android中的菜单有如下几种：</span></span><ul><li><span class="name"><span class="innerContentContainer">OptionMenu：选项菜单，android中最常见的菜单，通过Menu键来调用</span></span></li><li><span class="name"><span class="innerContentContainer">SubMenu：子菜单，android中点击子菜单将弹出一个显示子菜单项的悬浮框， 子菜单不支持嵌套，即不能包括其他子菜单</span></span></li><li><span class="name"><span class="innerContentContainer">ContextMenu：上下文菜单，通过长按某个视图组件后出现的菜单，该组件需注册上下文菜单.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">OptionMenu(选项菜单)</span></span><ul><li><span class="name"><span class="innerContentContainer">产生选项菜单只需要实现如下2个接口:</span></span><ul><li><span class="name"><span class="innerContentContainer">public boolean&nbsp;onCreateOptionsMenu(Menu menu)：调用OptionMenu，在这里完成菜单初始化</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean&nbsp;onOptionsItemSelected(MenuItem item)：菜单项被选中时触发，这里完成事件处理</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它接口还有3个:</span></span><ul><li><span class="name"><span class="innerContentContainer">public void&nbsp;onOptionsMenuClosed(Menu menu)：菜单关闭会调用该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean&nbsp;onPrepareOptionsMenu(Menu menu)：选项菜单显示前会调用该方法， 可在这里进行菜单的调整(动态加载菜单列表)</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean&nbsp;onMenuOpened(int featureId, Menu menu)：选项菜单打开以后会调用这个方法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">//1.定义不同颜色的菜单项的标识:</span></span></li><li><span class="name"><span class="innerContentContainer">final private int RED = 110;</span></span></li><li><span class="name"><span class="innerContentContainer">final private int GREEN = 111;</span></span></li><li><span class="name"><span class="innerContentContainer">final private int BLUE = 112;</span></span></li><li><span class="name"><span class="innerContentContainer">final private int YELLOW = 113;</span></span></li><li><span class="name"><span class="innerContentContainer">final private int GRAY= 114;</span></span></li><li><span class="name"><span class="innerContentContainer">final private int CYAN= 115;</span></span></li><li><span class="name"><span class="innerContentContainer">final private int BLACK= 116;</span></span></li><li><span class="name"><span class="innerContentContainer">private TextView tv_test;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">tv_test = (TextView) findViewById(R.id.tv_test);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onCreateOptionsMenu(Menu menu) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Inflate the menu; this adds items to the action bar if it is present.</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,RED,4,"红色");</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,GREEN,2,"绿色");</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,BLUE,3,"蓝色");</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,YELLOW,1,"黄色");</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,GRAY,5,"灰色");</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,CYAN,6,"蓝绿色");</span></span></li><li><span class="name"><span class="innerContentContainer">menu.add(1,BLACK,7,"黑色");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onOptionsItemSelected(MenuItem item) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Handle action bar item clicks here. The action bar will</span></span></li><li><span class="name"><span class="innerContentContainer">// automatically handle clicks on the Home/Up button, so long</span></span></li><li><span class="name"><span class="innerContentContainer">// as you specify a parent activity in AndroidManifest.xml.</span></span></li><li><span class="name"><span class="innerContentContainer">int id = item.getItemId();</span></span></li><li><span class="name"><span class="innerContentContainer">switch (id){</span></span><ul><li><span class="name"><span class="innerContentContainer">case RED:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.RED);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case GREEN:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.GREEN);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case BLUE:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.BLUE);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case YELLOW:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.YELLOW);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case GRAY:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.GRAY);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case CYAN:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.CYAN);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case BLACK:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_test.setTextColor(Color.BLACK);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onOptionsItemSelected(item);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ContextMenu(上下文菜单)</span></span><ul><li><span class="name"><span class="innerContentContainer">基本流程</span></span><ul><li><span class="name"><span class="innerContentContainer">Step 1：重写onCreateContextMenu()方法</span></span></li><li><span class="name"><span class="innerContentContainer">Step 2：为view组件注册上下文菜单，使用registerForContextMenu()方法,参数是View</span></span></li><li><span class="name"><span class="innerContentContainer">Step 3：重写onContextItemSelected()方法为菜单项指定事件监听器</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子</span></span><ul><li><span class="name"><span class="innerContentContainer">// 布局文件</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;!-- 定义一组单选按钮 --&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;!-- checkableBehavior的可选值由三个：single设置为单选，all为多选，none为普通选项 --&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;group android:checkableBehavior="none"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;item android:id="@+id/blue" android:title="@string/font_blue"/&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item android:id="@+id/green" android:title="@string/font_green"/&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item android:id="@+id/red" android:title="@string/font_red"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/group&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/menu&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 代码</span></span></li><li><span class="name"><span class="innerContentContainer">private TextView tv_context;</span></span></li><li><span class="name"><span class="innerContentContainer">tv_context = (TextView) findViewById(R.id.tv_context);</span></span><ul><li><span class="name"><span class="innerContentContainer">registerForContextMenu(tv_context);</span></span></li><li><span class="name"><span class="innerContentContainer">//重写与ContextMenu相关方法</span></span></li><li><span class="name"><span class="innerContentContainer">//重写上下文菜单的创建方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreateContextMenu(ContextMenu menu, View v,</span></span><ul><li><span class="name"><span class="innerContentContainer">ContextMenu.ContextMenuInfo menuInfo) {</span></span></li><li><span class="name"><span class="innerContentContainer">MenuInflater inflator = new MenuInflater(this);</span></span></li><li><span class="name"><span class="innerContentContainer">inflator.inflate(R.menu.menu_context, menu);</span></span></li><li><span class="name"><span class="innerContentContainer">super.onCreateContextMenu(menu, v, menuInfo);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//上下文菜单被点击是触发该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onContextItemSelected(MenuItem item) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (item.getItemId()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.blue:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_context.setTextColor(Color.BLUE);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.green:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_context.setTextColor(Color.GREEN);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.red:</span></span><ul><li><span class="name"><span class="innerContentContainer">tv_context.setTextColor(Color.RED);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SubMenu(子菜单)</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onCreateContextMenu(ContextMenu menu, View v,</span></span><ul><li><span class="name"><span class="innerContentContainer">ContextMenu.ContextMenuInfo menuInfo) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//子菜单部分：</span></span></li><li><span class="name"><span class="innerContentContainer">MenuInflater inflator = new MenuInflater(this);</span></span></li><li><span class="name"><span class="innerContentContainer">inflator.inflate(R.menu.menu_sub, menu);</span></span></li><li><span class="name"><span class="innerContentContainer">super.onCreateContextMenu(menu, v, menuInfo);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onContextItemSelected(MenuItem item) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (item.getItemId()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.one:</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this,"你点击了子菜单一",Toast.LENGTH_SHORT).show();</span></span><ul><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.two:</span></span><ul><li><span class="name"><span class="innerContentContainer">item.setCheckable(true);</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this,"你点击了子菜单二",Toast.LENGTH_SHORT).show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.three:</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this,"你点击了子菜单三",Toast.LENGTH_SHORT).show();</span></span></li><li><span class="name"><span class="innerContentContainer">item.setCheckable(true);</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PopupMenu(弹出式菜单)</span></span><ul><li><span class="name"><span class="innerContentContainer">直接上例子:</span></span></li><li><span class="name"><span class="innerContentContainer">btn_show_menu.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">PopupMenu popup = new PopupMenu(MainActivity.this,btn_show_menu);</span></span></li><li><span class="name"><span class="innerContentContainer">popup.getMenuInflater().inflate(R.menu.menu_pop, popup.getMenu());</span></span></li><li><span class="name"><span class="innerContentContainer">popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public boolean onMenuItemClick(MenuItem item) {</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (item.getItemId()){</span></span><ul><li><span class="name"><span class="innerContentContainer">case R.id.lpig:</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this,"你点了小猪~",</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.LENGTH_SHORT).show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case R.id.bpig:</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this,"你点了大猪~",</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.LENGTH_SHORT).show();</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">popup.show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ViewPager(视图滑动切换工具)</span></span><ul><li><span class="name"><span class="innerContentContainer">通过手势滑动可以完成View的切换，一般是用来做APP 的引导页或者实现图片轮播.</span></span></li><li><span class="name"><span class="innerContentContainer">是3.0后引入的. 如果想在低版本下使用，就需要引入v4 兼容包.</span></span></li><li><span class="name"><span class="innerContentContainer">ViewPager是一个简单的页面切换组件，我们可以往里面填充多个View，然后我们可以左 右滑动，从而切换不同的View，我们可以通过setPageTransformer()方法为我们的ViewPager 设置切换时的动画效果.</span></span></li><li><span class="name"><span class="innerContentContainer">属性</span></span><ul><li><span class="name"><span class="innerContentContainer">getCount():获得viewpager中有多少个view.  --必须实现.</span></span></li><li><span class="name"><span class="innerContentContainer">destroyItem():移除一个给定位置的页面。适配器有责任从容器中删除这个视图。 这是为了确保在finishUpdate(viewGroup)返回时视图能够被移除。 --必须实现</span></span></li><li><span class="name"><span class="innerContentContainer">instantiateItem(): ①将给定位置的view添加到ViewGroup(容器)中,创建并显示出来 ②返回一个代表新增页面的Object(key),通常都是直接返回view本身就可以了,当然你也可以 自定义自己的key,但是key和每个view要一一对应的关系 </span></span></li><li><span class="name"><span class="innerContentContainer">isViewFromObject(): 判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是 代表的同一个视图(即它俩是否是对应的，对应的表示同一个View),通常我们直接写 return view == object!</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子</span></span><ul><li><span class="name"><span class="innerContentContainer">public class OneActivity extends AppCompatActivity{</span></span><ul><li><span class="name"><span class="innerContentContainer">private ViewPager vpager_one;</span></span></li><li><span class="name"><span class="innerContentContainer">private ArrayList&lt;View&gt; aList;</span></span></li><li><span class="name"><span class="innerContentContainer">private MyPagerAdapter mAdapter;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_one);</span></span></li><li><span class="name"><span class="innerContentContainer">vpager_one = (ViewPager) findViewById(R.id.vpager_one);</span></span></li><li><span class="name"><span class="innerContentContainer">aList = new ArrayList&lt;View&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">LayoutInflater li = getLayoutInflater();</span></span></li><li><span class="name"><span class="innerContentContainer">aList.add(li.inflate(R.layout.view_one,null,false));</span></span></li><li><span class="name"><span class="innerContentContainer">aList.add(li.inflate(R.layout.view_two,null,false));</span></span></li><li><span class="name"><span class="innerContentContainer">aList.add(li.inflate(R.layout.view_three,null,false));</span></span></li><li><span class="name"><span class="innerContentContainer">mAdapter = new MyPagerAdapter(aList);</span></span></li><li><span class="name"><span class="innerContentContainer">vpager_one.setAdapter(mAdapter);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">DrawerLayout(侧滑菜单)</span></span><ul><li><span class="name"><span class="innerContentContainer">3.0以后引入，低版本使用它需要v4兼容包.</span></span></li><li><span class="name"><span class="innerContentContainer">使用的注意事项</span></span><ul><li><span class="name"><span class="innerContentContainer">1.主内容视图一定要是DrawerLayout的第一个子视图</span></span></li><li><span class="name"><span class="innerContentContainer">2.主内容视图宽度和高度需要match_parent</span></span></li><li><span class="name"><span class="innerContentContainer">3.必须显示指定侧滑视图的android:layout_gravity属性&nbsp;android:layout_gravity = "start"时，从左向右滑出菜单 android:layout_gravity = "end"时，从右向左滑出菜单 不推荐使用left和right!</span></span></li><li><span class="name"><span class="innerContentContainer">侧滑视图的宽度以dp为单位，不建议超过320dp(为了总能看到一些主内容视图)</span></span></li><li><span class="name"><span class="innerContentContainer">最多由三个部分组成，中间的内容部分，左边的侧滑菜单部分，右边的侧滑菜单部分组成.</span></span></li><li><span class="name"><span class="innerContentContainer">设置侧滑事件：mDrawerLayout.setDrawerListener(DrawerLayout.DrawerListener);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子</span></span><ul><li><span class="name"><span class="innerContentContainer">// 布局</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/drawer_layout"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;FrameLayout</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/ly_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;ListView</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/list_left_drawer"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="180dp"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_gravity="start"</span></span></li><li><span class="name"><span class="innerContentContainer">android:background="#080808"</span></span></li><li><span class="name"><span class="innerContentContainer">android:choiceMode="singleChoice"</span></span></li><li><span class="name"><span class="innerContentContainer">android:divider="#FFFFFF"</span></span></li><li><span class="name"><span class="innerContentContainer">android:dividerHeight="1dp" /&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/android.support.v4.widget.DrawerLayout&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 代码</span></span></li><li><span class="name"><span class="innerContentContainer">// ContentFragment.java</span></span></li><li><span class="name"><span class="innerContentContainer">public class ContentFragment extends Fragment {</span></span><ul><li><span class="name"><span class="innerContentContainer">private TextView tv_content;</span></span></li><li><span class="name"><span class="innerContentContainer">public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">View view = inflater.inflate(R.layout.fg_content, container, false);</span></span></li><li><span class="name"><span class="innerContentContainer">tv_content = (TextView) view.findViewById(R.id.tv_content);</span></span></li><li><span class="name"><span class="innerContentContainer">String text = getArguments().getString("text");</span></span></li><li><span class="name"><span class="innerContentContainer">tv_content.setText(text);</span></span></li><li><span class="name"><span class="innerContentContainer">return view;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// MainActivity.java</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends AppCompatActivity implements AdapterView.OnItemClickListener{</span></span><ul><li><span class="name"><span class="innerContentContainer">private DrawerLayout drawer_layout;</span></span></li><li><span class="name"><span class="innerContentContainer">private ListView list_left_drawer;</span></span></li><li><span class="name"><span class="innerContentContainer">private ArrayList&lt;Item&gt; menuLists;</span></span></li><li><span class="name"><span class="innerContentContainer">private MyAdapter&lt;Item&gt; myAdapter = null;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">drawer_layout = (DrawerLayout) findViewById(R.id.drawer_layout);</span></span></li><li><span class="name"><span class="innerContentContainer">list_left_drawer = (ListView) findViewById(R.id.list_left_drawer);</span></span></li><li><span class="name"><span class="innerContentContainer">menuLists = new ArrayList&lt;Item&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">menuLists.add(new Item(R.mipmap.iv_menu_realtime,"实时信息"));</span></span></li><li><span class="name"><span class="innerContentContainer">menuLists.add(new Item(R.mipmap.iv_menu_alert,"提醒通知"));</span></span></li><li><span class="name"><span class="innerContentContainer">menuLists.add(new Item(R.mipmap.iv_menu_trace,"活动路线"));</span></span></li><li><span class="name"><span class="innerContentContainer">menuLists.add(new Item(R.mipmap.iv_menu_settings,"相关设置"));</span></span></li><li><span class="name"><span class="innerContentContainer">myAdapter = new MyAdapter&lt;Item&gt;(menuLists,R.layout.item_list) {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void bindView(ViewHolder holder, Item obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">holder.setImageResource(R.id.img_icon,obj.getIconId());</span></span></li><li><span class="name"><span class="innerContentContainer">holder.setText(R.id.txt_content, obj.getIconName());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">list_left_drawer.setAdapter(myAdapter);</span></span></li><li><span class="name"><span class="innerContentContainer">list_left_drawer.setOnItemClickListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ContentFragment contentFragment = new ContentFragment();</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle args = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">args.putString("text", menuLists.get(position).getIconName());</span></span></li><li><span class="name"><span class="innerContentContainer">contentFragment.setArguments(args);</span></span></li><li><span class="name"><span class="innerContentContainer">FragmentManager fm = getSupportFragmentManager();</span></span></li><li><span class="name"><span class="innerContentContainer">fm.beginTransaction().replace(R.id.ly_content,contentFragment).commit();</span></span></li><li><span class="name"><span class="innerContentContainer">drawer_layout.closeDrawer(list_left_drawer);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">导航栏</span></span><ul><li><span class="name"><span class="innerContentContainer">在5.0后，ActionBarActivity被Google弃用了，推荐用 ToolBar.</span></span></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SurfaceView</span></span><ul><li><span class="name"><span class="innerContentContainer">视频内容, 或openGL内容往往显示在 SurfaceView 中. 一般用于游戏, 高画质图片, 相机预览等场景.</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceView 可通过 SurfaceHolderAddCallback 方法在子线程中更新UI, 不依赖主线程.</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceView 刷新效率较高，因为：  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">它是一个置于应用窗口前面的独立窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">有独立的 surface(画布)；</span></span></li><li><span class="name"><span class="innerContentContainer">有专门的线程来画图,  不依赖UI线程；</span></span></li><li><span class="name"><span class="innerContentContainer">其刷新不会导致view hierarchy 的递归绘制。</span></span></li><li><span class="name"><span class="innerContentContainer">作为对比, 普通view在刷新时, 会递归刷新其各级父view. 效率非常低下.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">但是SurfaceView 也有缺点, 因为它不在应用窗口, 所以它:   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">不能使用变换(平移, 缩放, 旋转等), </span></span></li><li><span class="name"><span class="innerContentContainer">不能放在 ListView 或 ScrollView 等容器中滚动, </span></span></li><li><span class="name"><span class="innerContentContainer">不能使用ui控制的一些属性, 比如设置透明度.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TextureView</span></span><ul><li><span class="name"><span class="innerContentContainer">TextureView 是SurfaceView的升级版, 取其精华去其糟粕:   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">为了解决SurfaceView 的缺点, Android 4.0 引入了 TextureView . </span></span></li><li><span class="name"><span class="innerContentContainer">TextureView 具有SurfaceView 的优点, 可以在独立线程中绘制和渲染. </span></span></li><li><span class="name"><span class="innerContentContainer">和后者不同的是, TextureView 没有创建独立的Surface 来绘制, 而是继承自view, 因此可以象普通view一样在view hierarchy中管理与绘制, 并处理变换, 比如横竖屏切换, 设置透明度等. </span></span></li><li><span class="name"><span class="innerContentContainer">TextureView 也有限制, 它必须放在开启硬件加速的窗口中.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TextureView 持有 SurfaceTexture 和 HardwareLayer. 其要点是: </span></span><ul><li><span class="name"><span class="innerContentContainer">通过重载 draw() 方法, 把 SurfaceTexture 中捕获的图像数据作为openGL纹理更新到 HardwareLayer 中去. </span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceTexture.OnFrameAvailableListener用于通知 TextureView 有新图像数据到来.</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceTextureListener 用于通知 TextureView 的使用者, SurfaceTexture 已经准备好. 这样就可以把SurfaceTexture 交给相应的内容源. 其接口包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">OnSurfaceTextureAvailable(): 在SurfaceTexture 准备好时被调用.</span></span></li><li><span class="name"><span class="innerContentContainer">OnSurfaceTextureDestroyed(): 在SurfaceTexture 即将被销毁时被调用. </span></span><ul><li><span class="name"><span class="innerContentContainer">注意: 如果该函数返回 true, 则调用此方法后, SurfaceTexture 中不会发生渲染. 如果返回false, 则客户端需要调用 release(). </span></span></li><li><span class="name"><span class="innerContentContainer">一般应该返回true.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">OnSurfaceTextureSizeChanged(): 在SurfaceTexture 的缓冲区大小更改时被调用.</span></span></li><li><span class="name"><span class="innerContentContainer">OnSurfaceTextureUpdated(): 在SurfaceTexture 更新时被调用. 需要调用 updataTextImage().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TextureView 持有 Surface, Surface作为 BufferQueue的 producer接口实现类, 使生产者可以通过它的软件或硬件渲染接口为 SurfaceTexture 内部的 BufferQueue 提供graphic buffer.</span></span></li><li><span class="name"><span class="innerContentContainer">TextureView 可通过TextureView.setSurfaceTextureListener 在子线程中更新UI.</span></span></li></ul></li></ul></li></ul>
  </body>
</html>