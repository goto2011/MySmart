<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>20-Framework</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>AMS</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks\base\core\java\android\app</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks\base\services\java\com\android\server\am</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks\base\services\java\com\android\server\wm</span></span></li><li><span class="name"><span class="innerContentContainer">四大组件都由AMS统一管理生命周期. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>Activity创建过程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">无论是Launcher(Launcher也是应用)启动一个activity, 还是应用内部启动一个activity, 第一步都是应用线程调用 startActivity(), 该函数通过Binder调用ams的 startActivity().</span></span></li><li><span class="name"><span class="innerContentContainer">ams 调用<b>Zygote的fork(), 复制创建一个虚拟机进程. 然后在进程上创建 ActivityThread. 相关代码在 </b>scheduleLaunchActivity() 中.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>ActivityThread 负责创建对应的Activity对象, </b>使用ClassLoader从程序文件中装载指定的Activity对应的Class文件, <b>加载布局和资源.  </b></span></span></li><li><span class="name"><span class="innerContentContainer">最后会调用 attach方法，然后在 PolicyManager实现一个IPolicy接口，接着实现一个 Policy对象。</span></span></li><li><span class="name"><span class="innerContentContainer">接着调用 makeNewWindow(Context)方法，该方法会返回一个 PhoneWindow对象，而 PhoneWindow 是Window的子类。</span></span></li><li><span class="name"><span class="innerContentContainer">在这个 PhoneWindow 持有一个DecorView的内部类，是所有应用窗口的根 View， 直接控制 Activity是否显示。</span></span></li><li><span class="name"><span class="innerContentContainer">DecorView里面有一个 LinearLayout。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout里面又有两个 FrameLayout, 他们分别拿来装 ActionBar(状态栏)和CustomView。</span></span></li><li><span class="name"><span class="innerContentContainer">而我们在 setContentView() 加载的布局就放到这个 <b>CustomView </b>中。</span></span></li><li><span class="name"><span class="innerContentContainer">整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。</span></span></li><li><span class="name"><span class="innerContentContainer">View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>在这个过程中, 会回调用户</b>activity<b>的 onCreate(), onStart(), onResume(). </b></span></span></li><li><span class="name"><span class="innerContentContainer">梳理过程如下: activity -<b>binder</b>- AMS -<b>biner</b>- ActivityThread - PhoneWindow - DecorView - ActionBar+CustomView - View.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理activity生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer">创建过程中, Activity会先后调用<b>onCreate(), onStart(), onResume(). </b></span></span></li><li><span class="name"><span class="innerContentContainer">销毁过程中, 会先后调用 onPause() 和 onStop+onDestroy方法. 其中,调用完onPause()方法后不能立即调用onStop()方法，因为这个时候我们需要先调用前一个页面的<b>onResume</b>()方法, 所以我们需要先切回到AMS进程去处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>任务栈: 对Activity进行管理  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">APP一般是由多个Activity构成的。Android用 Task(任务)的概念将多个相关的Activity放在<b> Back Stack（回退堆栈）</b>中管理，以便进行Activity间的跳转与返回.</span></span></li><li><span class="name"><span class="innerContentContainer">注意，是相关的Activity，而不是同一个app的activity。有时候，同一个app的activity在不同的task （参见 taskAffinity ）；有时候，不同app的activity在同一个task。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>任务栈, 也叫task 栈, 或者 back栈</b></span></span><ul><li><span class="name"><span class="innerContentContainer">是一种用来放置Activity实例的容器，以栈的形式进行盛放Activity实例，也就是所谓的先进后出(LIFO).</span></span></li><li><span class="name"><span class="innerContentContainer">处于最顶部的叫栈顶，最底部叫栈底.</span></span></li><li><span class="name"><span class="innerContentContainer">常用操作: 入栈(<b>push</b>)，出栈(<b>pop</b>)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>栈内切换</b></span></span><ul><li><span class="name"><span class="innerContentContainer">当用户在主屏幕点击图标打开一个新的App，此时会创建一个<b>新的Task</b>. 然后开始把新产生的Activity入栈, 作为栈顶. </span></span></li><li><span class="name"><span class="innerContentContainer">当切换到新的Activity，那么该Activity会被压入栈中，成为新的栈顶。</span></span></li><li><span class="name"><span class="innerContentContainer">而当用户点击Back键，栈顶的Activity出栈，紧随其后的Activity来到栈顶。</span></span></li><li><span class="name"><span class="innerContentContainer">有一种特殊情况, 当我们在通讯录的APP中打开了短信APP的页面，但是此时不会新建一个栈，而是继续添加到栈1中。</span></span></li><li><span class="name"><span class="innerContentContainer">这是 Android推崇一种用户体验方式，即不同应用程序之间的切换能使用户感觉就像是同一个应用程序，连贯的用户体验，官方称其为seamless (无缝衔接）.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>栈间切换</b></span></span><ul><li><span class="name"><span class="innerContentContainer">同一时间系统会有多个task. 这些task 也组成一个 task堆栈. </span></span></li><li><span class="name"><span class="innerContentContainer">用户按下Home键回到桌面，再启动另一个应用，这时候<b>Task1</b>就被移到后台，成为<b>后台任务栈</b>，而刚启动的那个<b>Task2</b>就被调到前台，成为<b>前台任务栈</b>. </span></span></li><li><span class="name"><span class="innerContentContainer">点击recent键，打开之前的程序，然后<b>Task1</b>又回到前台了。</span></span></li><li><span class="name"><span class="innerContentContainer">如果Task1是通讯录的APP中打开了短信APP的页面, 现在回到桌面, 当我们点击主屏幕上通信录的图标打开APP，此时也不会创建新的栈，而是Task1回到前台。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意: 当调用到 onNewIntent(intent)的时候，需要使用 setIntent(intent)赋值给Activity的Intent. 否则后续的 getIntent()都是得到老的Intent。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml 的activity相关的配置项  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">taskAffinity 和 allowTaskReparenting</span></span><ul><li><span class="name"><span class="innerContentContainer">默认情况下，一个应用程序中的所有activity使用同一个Affinity，这让它们属于同一个Task。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 taskAffinity可指定该activity使用独立的Task。</span></span></li><li><span class="name"><span class="innerContentContainer">不同应用程序中的Activity可以共享同一个Affinity，同一个应用程序中的不同Activity 也可以设置成不同的Affinity。</span></span></li><li><span class="name"><span class="innerContentContainer">Affinity属性在2种情况下起作用：</span></span></li><li><span class="name"><span class="innerContentContainer">1）当启动 activity的Intent对象包含FLAG_ACTIVITY_NEW_TASK标记： 当传递给 startActivity()的Intent对象包含 FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的Activity寻找与当前Activity不同Task。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果要启动的 Activity的Affinity属性与当前所有的Task的Affinity属性都不相同，系统会新建一个带该Affinity属性的Task，并将要启动的Activity压到新建的Task栈中；</span></span></li><li><span class="name"><span class="innerContentContainer">否则将Activity压入同一Affinity属性的栈中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2）如果一个activity的 allowTaskReparenting属性为true， 那么它可以从一个Task（Task1）移到另外一个有相同Affinity的Task（Task2）中（Task2带到前台时）。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个APP从用户角度来看包含了多个"应用程序"，就可能需要对那些 Activity赋不同的Affinity值。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>launchMode  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">activity启动模式, 常用且关键. 值域如下:</span></span></li><li><span class="name"><span class="innerContentContainer">standard(默认): 在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，会在A的上面再次启动一个A的实例，即当前的桟中的状态为A--&gt;A。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleTop: 如果一个以singleTop模式启动的Activity的实例已经存在于当前任务栈的栈顶， 那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例， 并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中， 那么再启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。 这时任务栈中还是这有一个A的实例。</span></span></li><li><span class="name"><span class="innerContentContainer">如果以singleTop模式启动的activity的一个实例已经存在与任务栈中，<b>但是不在栈顶</b>，那么它的行为和standard模式相同，也会创建多个实例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleTask: 创建一个新的实例时, 如果该实例在当前栈中已经存在，则不管它在不在栈顶, 直接将它移动到顶部，并且清空任务栈中这个activity上面所有的activity。</span></span><ul><li><span class="name"><span class="innerContentContainer">intent将被通过onNewIntent()发送.</span></span></li><li><span class="name"><span class="innerContentContainer">singleTask相当于singleTop的彻底版.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleInstance: 单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。比如来电界面.</span></span><ul><li><span class="name"><span class="innerContentContainer">当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">clearTaskOnLaunch: 清空栈</span></span><ul><li><span class="name"><span class="innerContentContainer">默认情况下, 当用户长时间离开Task（当前task被转移到后台）时，系统会清除task中栈底Activity外的所有Activity 。这样，当用户返回到Task时，只留下那个task最初始的Activity了。</span></span></li><li><span class="name"><span class="innerContentContainer">可通过修改 clearTaskOnLaunch 来改变这种行为. 其值域是: </span></span></li><li><span class="name"><span class="innerContentContainer">alwaysRetainTaskState: 如果栈底Activity的这个属性被设置为true，上述的情况就不会发生。 Task中的所有activity将被长时间保存。</span></span></li><li><span class="name"><span class="innerContentContainer">clearTaskOnLaunch: 如果栈底activity的这个属性被设置为true，一旦用户离开Task， 则 Task栈中的Activity将被清空到只剩下栈底activity。这种情况刚好与 alwaysRetainTaskState相反。即使用户只是短暂地离开，task也会返回到初始状态 （只剩下栈底acitivty）。</span></span></li><li><span class="name"><span class="innerContentContainer">finishOnTaskLaunch: 与clearTaskOnLaunch相似，但它只对单独的activity操 作，而不是整个Task。它可以结束任何Activity，包括栈底的Activity。 当它设置为true时，当前的Activity只在当前会话期间作为Task的一部分存在， 当用户退出Activity再返回时，它将不存在。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主要的Intent标志有：</span></span><ul><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_NEW_TASK: 放入新的task堆栈. 见上.</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_CLEAR_TOP</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_SINGLE_TOP</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">管理Service生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer">Service是否是独立进程?</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Service没有设定属性android:process=”:remote”, Service会和Activity是在同一个进程中的，即主线程.</span></span></li><li><span class="name"><span class="innerContentContainer">如果Service设定属性android:process=”:remote”, 那么就会创建新进程.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Service的启动方式有两种：</span></span></li><li><span class="name"><span class="innerContentContainer">startService</span></span><ul><li><span class="name"><span class="innerContentContainer">ContextWrapper类中的startService(), 调用了ContextImpl的startService()。</span></span></li><li><span class="name"><span class="innerContentContainer">在startServiceCommon()中通过binder，调用了AMS服务的startService()。</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService.startServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">在AMS服务中，每个Service都使用一个ServiceRecord对象来描述，然后调用retrieveServiceLocked方法来查找一个和目标Service对应的ServiceRecord，最后将这个ServiceRecord对象封装在ServiceLookupResult对象中。</span></span></li><li><span class="name"><span class="innerContentContainer">查找方案是首先从AMS服务中的ServiceMap中查找，ServiceMap中保存了AMS服务中所有激活的Service信息，如果在ServiceMap中没有找到，说明该Service还没有启动。那么就需要从PMS服务中查找目标Service的信息并创建一个ServiceRecord对象。最后把它保存在对应的ServiceMap集合中。</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService. bringUpServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService.realStartServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityThread.handleCreateService()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bindService</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理BroadcastReceiver生命周期，分发和接受Broadcast</span></span></li><li><span class="name"><span class="innerContentContainer">管理ContentProvider生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/c35313c52eef">https://www.jianshu.com/p/c35313c52eef</a></span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider&nbsp;封装了数据的跨进程传输，我们可以直接使用 getContentResolver() 拿到&nbsp;ContentResolver&nbsp;进行增删改查即可。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">处理应用程序的Crash</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>WMS</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">引入Window的目的是为了实现Activity和其上的视图View的解耦. 解耦之后, Activity只负责生命周期管理. </span></span></li><li><span class="name"><span class="innerContentContainer">Activity, PhoneWindow, DecorView, titleBar, contentView 之间关系的示意图  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">WMS功能</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 窗口的添加和删除</span></span></li><li><span class="name"><span class="innerContentContainer">2. 窗口的显示和隐藏控制</span></span></li><li><span class="name"><span class="innerContentContainer">3. Z-order顺序管理</span></span></li><li><span class="name"><span class="innerContentContainer">4. 焦点窗口和焦点应用的管理</span></span></li><li><span class="name"><span class="innerContentContainer">5. 输入法窗口管理和墙纸窗口管理</span></span></li><li><span class="name"><span class="innerContentContainer">6. 窗口动画管理</span></span></li><li><span class="name"><span class="innerContentContainer">7. 系统消息收集和分发</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建窗口的过程  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">创建Activity的过程中, 会调用 <b>addWindow</b>() 来请求WMS添加窗口.</span></span></li><li><span class="name"><span class="innerContentContainer">Window的具体实现类是PhoneWindow. 在Activity初始化执行 attach 的时候，会创建一个PhoneWindow对象。然后给Window对象中的mWindowManager变量赋值。</span></span></li><li><span class="name"><span class="innerContentContainer">PhoneWindow作为装载根视图DecorView的容器，Activity通过setContentView实际上是调用PhoneWindow来创建DecorView。</span></span></li><li><span class="name"><span class="innerContentContainer">首先调用installDecor() 为Window类添加窗口装饰，其实就是标题栏.</span></span></li><li><span class="name"><span class="innerContentContainer">然后, 布局文件所定义的界面, 被包含在在窗口内容中。</span></span></li><li><span class="name"><span class="innerContentContainer">把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后AMS经过一系列调用到 Activity的makeVisible()，该方法将真正完成把窗口添加进Wms中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理窗口 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">处理系统按键和触摸消息</span></span></li><li><span class="name"><span class="innerContentContainer">管理窗口动画</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Input子系统</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/categories/Android/View/">https://www.viseator.com/categories/Android/View/</a> , <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://gityuan.com/2016/12/31/input-ipc/">http://gityuan.com/2016/12/31/input-ipc/</a>,  <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://www.mysixue.com/?p=144">http://www.mysixue.com/?p=144</a>, <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/2017/09/14/android_view_event_1/">https://www.viseator.com/2017/09/14/android_view_event_1/</a></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://blog.csdn.net/guolin_blog/article/details/9097463/">https://blog.csdn.net/guolin_blog/article/details/9097463/</a></span></span></li><li><span class="name"><span class="innerContentContainer">代码静态结构</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinputflinger.so">libinputflinger.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">InputDispatcher.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputManager.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">EventHub.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputListener.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/input/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinput.so">libinput.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Input.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputDevice.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Keyboard.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">KeyCharacterMap.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">IInputFlinger.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/base/services/core/  --  services. jar,  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libandroid_services.so">libandroid_services.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">java/com/android/server/input/InputManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">jni/com_android_server_input_InputManagerService.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/base/libs/input/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinputservice.so">libinputservice.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">PointerController.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">SpriteController.cpp</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">初始化流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>开机过程中, systemserver.java, 调用</b>startOtherServices(), 创建InputManagerService 对象。</span></span></li><li><span class="name"><span class="innerContentContainer">为这个对象设置与 WindowManagerService相关的回调函数，然后调用InputManagerService的start()。</span></span></li><li><span class="name"><span class="innerContentContainer">start()通过JNI调用，进行native层初始化。</span></span></li><li><span class="name"><span class="innerContentContainer">在native层初始化的时候，创建 NativeInputMnager 的对象（重要）。</span></span><ul><li><span class="name"><span class="innerContentContainer">InputReader 和 InputDispatcher 和其他模块的交互由 NativeInputMnager&nbsp;负责中转。</span></span></li><li><span class="name"><span class="innerContentContainer">NativeInputMnager 持有 InputReaderPolicyInterface和 InputDispatcherPolicyInterface。</span></span></li><li><span class="name"><span class="innerContentContainer">负责创建 InputManager。</span></span><ul><li><span class="name"><span class="innerContentContainer">InputManager 创建 InputReader 和 InputDispatcher 两个线程。 代码在: InputManager::InputManager()</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader::InputReader() 构造时, mQueuedListener = new QueuedInputListener(listener);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">负责管理 EventHub，InputReader，InputReaderThread，InputDispatcher，InputDispatcherThread等对象。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件上报流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">EventHub</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/EventHub.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">事件的起源地，所有的事件都是它从驱动中读取出来的。</span></span></li><li><span class="name"><span class="innerContentContainer">负责监视  /dev/input/eventX 多个FD上产生的事件，包括设备添加，移除，以及触摸等事件, 然后把事件封装成 RawEvent 结构体供 InputReader 使用。</span></span></li><li><span class="name"><span class="innerContentContainer">使用的结构体叫 RawEvent。</span></span></li><li><span class="name"><span class="innerContentContainer">监听机制，是通过Linux提供的epoll机制来实现。epoll机制简单地说就是高效地I/O多路复用机制，使用epoll_wait来监听所需要的文件描述符的变化。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputReader</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/InputReader.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">是 systemserver子线程。</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader 持有 EventHub 和 InputDispatcher , 是Input子系统的核心. </span></span></li><li><span class="name"><span class="innerContentContainer">InputReader 负责完成描点. (开发人员选项中可打开描点)  --代码在哪儿?   <span class="contentTag" title="Filter @Plan">@<span class="contentTagText">Plan</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">void InputReader::<b>loopOnce</b>()   // 核心函数</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>1. 接受事件</b></span></span></li><li><span class="name"><span class="innerContentContainer">mEventHub-&gt;getEvents()   // 通过 threadLoop，周期性的从EventHub中读取事件。</span></span><ul><li><span class="name"><span class="innerContentContainer">这些事件是 rawdata，即没有经过加工处理的事件；</span></span></li><li><span class="name"><span class="innerContentContainer">最终调用 epoll_wait() 来读取 /dev/input/input* 上的事件信息.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>2. 对事件信息进行数据封装</b></span></span></li><li><span class="name"><span class="innerContentContainer">processEventLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">device-&gt;process(rawEvents, count);   // InputDevice代表输入设备</span></span></li><li><span class="name"><span class="innerContentContainer">mapper-&gt;process(rawEvent);     // InputMapper, 负责定义每种键值事件是如何处理的.   一个InputDevice对应多个InputMapper。</span></span></li><li><span class="name"><span class="innerContentContainer">我们关注的触摸屏有如下处理:</span></span><ul><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::process(const RawEvent* rawEvent)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::sync(nsecs_t when)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::processRawTouches(bool timeout)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::cookAndDispatch(nsecs_t when)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) </span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::<b>dispatchMotion</b>(nsecs_t when...)  // 封装 NotifyArgs事件</span></span></li><li><span class="name"><span class="innerContentContainer">void QueuedInputListener::notifyMotion(...)</span></span></li><li><span class="name"><span class="innerContentContainer">mArgsQueue.<b>push</b>();   // 事件数据保存到 QueuedInputListener的 mArgsQueue中.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>3. 事件分发</b></span></span></li><li><span class="name"><span class="innerContentContainer">mQueuedListener-&gt;flush();   // QueuedInputListener, 事件监视器</span></span></li><li><span class="name"><span class="innerContentContainer">NotifyMotionArgs::notify()</span></span></li><li><span class="name"><span class="innerContentContainer">listener-&gt;<b>notifyMotion</b>(this);</span></span><ul><li><span class="name"><span class="innerContentContainer">listener 即 QueuedInputListener, 事件监视器, 持有 mInnerListener, 指向 InputDispatcher对象.</span></span></li><li><span class="name"><span class="innerContentContainer">这便是 InputReader跟 InputDispatcher交互的中转站。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputDispatcher::notifyMotion()   // 这里就是 InputDispatcher了.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">InputDispatcher</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/InputDispatcher.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher为<b>systemserver子线程。</b></span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher.<b>notifyMotion</b>()  // 将 NotifyArgs 构建KeyEvent。</span></span></li><li><span class="name"><span class="innerContentContainer">enqueueInboundEventLocked(newEntry);  // 将事件entry 放入消息队列.</span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher::dispatchOnce()   // 死循环执行事件分发. </span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher::dispatchMotionLocked()&nbsp; // 分发触摸事件.</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">开始事件的分发，通过InputChannel把事件分发给WindowManager或者应用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果是应用的话，可通过 registerInputChannel来定义输入事件的目标。</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">将 KeyEvent传递给WindowManagerService去处理。</span></span></li><li><span class="name"><span class="innerContentContainer">事件在入队前(before enqueue)的处理：</span></span><ul><li><span class="name"><span class="innerContentContainer">NativeInputManager</span></span></li><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeQueueing</span></span></li><li><span class="name"><span class="innerContentContainer">InputManagerService.interceptKeyBeforeQueueing</span></span></li><li><span class="name"><span class="innerContentContainer">InputMonitor.interceptKeyBeforeQueueing </span></span></li><li><span class="name"><span class="innerContentContainer">PhoneWindowManager.<b>interceptKeyBeforeQueueing</b></span></span></li><li><span class="name"><span class="innerContentContainer">一般首先把事件都标记上PASS_TO_USER，即这个事件要交给应用程序去处理，但是在处理过程中决定，有些事件是没必要传递给应用程序的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用 dispatchKeyLocked() 分发事件</span></span><ul><li><span class="name"><span class="innerContentContainer">根据每一个target（一个事件可以有多个）对应的inputChannel找到connection，</span></span></li><li><span class="name"><span class="innerContentContainer">然后&nbsp;prepareDispatchCycleLocked使用这个connection把事件逐个分发到target中。 </span></span></li><li><span class="name"><span class="innerContentContainer">在prepareDispatchCycleLocked方法中，主要就是根据事件是否可以分割，分别把事件放入队列。</span></span></li><li><span class="name"><span class="innerContentContainer">在入队列的之后，InputPublisher的发布事件的队列就不再为空，然后会调用&nbsp;startDispatchCycleLocked方法，通过InputPublisher开始发布事件。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">InputChannel</span></span><ul><li><span class="name"><span class="innerContentContainer">InputChannel就是一个通道，具有通信功能。</span></span></li><li><span class="name"><span class="innerContentContainer">每个活跃的activity都有自己的 InputChannel对象。在 ViewRootImpl.<b>setView</b>() 中创建。然后把 InputChannel 传递给 WindowManagerService。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 sendMessage() 发生事件, 通过 receiveMessage() 接受事件.</span></span></li><li><span class="name"><span class="innerContentContainer">1. 原始事件通过建立好的InputChannel的 sendMessage()函数发送触摸事件.</span></span></li><li><span class="name"><span class="innerContentContainer">2. 直接调用send()函数向fd表示的socket中写入数.</span></span></li><li><span class="name"><span class="innerContentContainer">3. 在另一边的 epoll_wait()调用就会因socket另一端fd数据的到来而唤醒，并通过fd找到注册好的request.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 进而调用request中的 NativeInputEventReceiver的 handleEvent()方法，参数就是我们接收到的事件信息与数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputPublisher</span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp 的内部类.</span></span></li><li><span class="name"><span class="innerContentContainer">调用 InputChannel 发送事件, 并接受finish事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputConsumer</span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp 的内部类</span></span></li><li><span class="name"><span class="innerContentContainer">消费来自 inputChannel 的事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputFilter</span></span><ul><li><span class="name"><span class="innerContentContainer">这是一个java类.</span></span></li><li><span class="name"><span class="innerContentContainer">负责对事件进行拦截, 过滤. 比如手势识别, 辅助功能, 盲人模式等模块会用. </span></span></li><li><span class="name"><span class="innerContentContainer">AccessbilityManagerService 负责初始化 InputFilter.</span></span></li><li><span class="name"><span class="innerContentContainer">然后赋值给 InputManagerService. InputManagerService&nbsp;只支持一个InputFilter,&nbsp;新注册的InputFilter会把老的覆盖。</span></span></li><li><span class="name"><span class="innerContentContainer">filterInput()&nbsp;的调用是发生在Input Reader线程里，通过InputManagerService&nbsp;里的&nbsp;InputFilterHost&nbsp;对象通知另外一个线程里的InputFilter&nbsp;开始真正的解析工作。</span></span></li><li><span class="name"><span class="innerContentContainer">InputFilter&nbsp;的工作也分为两个步骤，首先由InputEventConsistencyVerifier&nbsp;对象（InputEventConsistencyVerifier.java）对输入事件的完整性做一个检查，检查事件的ACTION_DOWN&nbsp;和&nbsp;ACTION_UP&nbsp;是否一一配对。</span></span></li><li><span class="name"><span class="innerContentContainer">接下来，进入到 AccessibilityInputFilter&nbsp;的&nbsp;onInputEvent()，这里将把输入事件（主要是MotionEvent)进行处理，根据需要变成另外一个Event，然后通过sendInputEvent() 将事件发回给InputDispatcher。最终调用到injectInputEvent()&nbsp;将这个事件送入&nbsp;mInBoundQueue.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层事件传递流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Activity -&gt; Windows -&gt; DecorView -&gt; ViewGroup -&gt; 各子View</span></span></li><li><span class="name"><span class="innerContentContainer">Activity中 InputEventReceiver的 <b>onInputEvent ()</b>被回调，开始 java层touch事件传递。</span></span></li><li><span class="name"><span class="innerContentContainer">InputStage的子类有: NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage、EarlyPostImeInputStage、NativePostImeInputStage、ViewPostImeInputStage、SyntheticInputStage.</span></span><ul><li><span class="name"><span class="innerContentContainer">它们构成一个输入事件处理链，如果本阶段对事件没有处理，则传递到下一个对象进行处理，直至事件被处理。</span></span></li><li><span class="name"><span class="innerContentContainer">NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage三个类用来实现输入法的按键派发和处理，如果事件不传递到输入法服务中，这三个类可以跳过。</span></span></li><li><span class="name"><span class="innerContentContainer">EarlyPostImeInputStage对象开始处理，在 ViewPostImeInputStage 对象处理阶段调用了主View 对象（对应PhoneWindow中的DecorView对象）的事件提交函数如（dispatchTouchEvent）函数向视图对象提交输入事件, 在当前窗口的视图树中派发事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MainActivity.&nbsp;<b>DecorView</b> 在传递事件过程中首先将事件传给Activity的 dispatchTouchEvent()方法，所以我们可以重写这个方法来阻止事件继续传递。</span></span></li><li><span class="name"><span class="innerContentContainer">如果 onInterceptTouchEvent() 返回true，<b>ViewGroup </b>就会拦截touch事件，由自己的dispatchTouchEvent()  继续分发. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>ViewGroup.dispatchTouchEvent() 详解:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">TouchTarget链表保存了处理了初始触摸事件的子View，注意只有一系列触摸动作的初始事件（Down事件）才会找到对应的子View并生成TouchTarget的一个节点。后面的系列事件都会分发给TouchTarget链表中保存的子View，这也就意味着，如果一个子View没有处理初始的Down事件，那么它也就不会再接收到后面的move&nbsp;up等事件。</span></span></li><li><span class="name"><span class="innerContentContainer">如果onInterceptTouchEvent()返回true，当前ViewGroup拦截了该事件，那么该事件不会再向下面分发，并且会向TouchTarget中保存的所有子View发送cancel事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会移除分发记录，意味着后面的事件也不再会分发到子View。</span></span></li><li><span class="name"><span class="innerContentContainer">如果是辅助功能的事件，那么会优先分发给支持辅助功能的View，如果不存在这样的view，则进行一般的事件分发。</span></span></li><li><span class="name"><span class="innerContentContainer">1. 判断是否被拦截</span></span></li><li><span class="name"><span class="innerContentContainer">2. 如果未被拦截且为初始事件，找到可以处理事件的子View（在点击范围内且可被点击），分发事件后如果该子View处理了事件（dispatchTouchEvent()方法返回true）则存入TouchTarget链表并停止子View的遍历（后面的子View就没有机会再收到事件），如果该子View没有处理该事件，则继续遍历寻找</span></span></li><li><span class="name"><span class="innerContentContainer">3. 如果事件被拦截，向TouchTarget中的子View发送cancel事件</span></span></li><li><span class="name"><span class="innerContentContainer">4. 将未被2、3情况处理的事件分发给TouchTarget中的子View，如果TouchTarget为空，则交给ViewGroup本身父View的dispatchTouchEvent()方法处理. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当一个触摸事件分发到一个非ViewGroup的View或者ViewGroup不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么View类的dispatchTouchEvent()将会被调用.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>View.dispatchTouchEvent() 详解:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">主要是先检查是否注册了onTouchListener，如果注册了监听并且调用返回了true消耗了该事件，那么说明该View处理了该事件，也会收到后续的事件，</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有注册监听或者没有消耗，就调用View本身的 onTouchEvent()，如果返回true则消耗事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">View<b>.</b>onTouchEvent(), 按事件类型(up, down, move, cancel) 分别处理. 判断是否触发单击、长按、长按等, 并提供了默认的按下、点击、长按的视觉反馈。</span></span></li><li><span class="name"><span class="innerContentContainer">应用层事件封装成 MotionEvent。</span></span><ul><li><span class="name"><span class="innerContentContainer">mAction的低8位（也就是0-7位）是动作类型信息。</span></span></li><li><span class="name"><span class="innerContentContainer">mAction的8-15位，是触控点的索引信息。（即表示是哪一个触控点的事件）。</span></span></li><li><span class="name"><span class="innerContentContainer">MotionEvent有两个方法，一个是getAction(),另一个是getActionMasked(), 二个方法就是通过掩码的方式隐去触控点的索引信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">java 层消息机制</span></span><ul><li><span class="name"><span class="innerContentContainer">Java层的Looper是为了处理的消息队列中的消息.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native 层消息机制</span></span><ul><li><span class="name"><span class="innerContentContainer">Native中的Looper是为了处理注册的自定义Fd引起的Request&nbsp;消息，这些消息一般来自于系统底层如触摸事件等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel epoll机制  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/615a60e740b6">https://workflowy.com/#/615a60e740b6</a></span></span></li><li><span class="name"><span class="innerContentContainer">问题分类</span></span><ul><li><span class="name"><span class="innerContentContainer">器件和驱动问题</span></span><ul><li><span class="name"><span class="innerContentContainer">通过查看器件上报的数据确认</span></span><ul><li><span class="name"><span class="innerContentContainer">getevent -l</span></span></li><li><span class="name"><span class="innerContentContainer">前提：研发现场可复现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过adb模拟事件，如果模拟的事件没问题，则可反向确认是bsp异常。</span></span><ul><li><span class="name"><span class="innerContentContainer">前提：研发现场可复现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过查看 inputReader LOG打印确认上报的数据有没有问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Fwk policy错误</span></span><ul><li><span class="name"><span class="innerContentContainer">input policy主要是在pwm 中对一些按键和手势的拦截处理。涉及这方面要多考虑这块。</span></span></li><li><span class="name"><span class="innerContentContainer">主要逻辑在 interceptKeyBeforeQueueing() 和 interceptKeyBeforeDispatching()。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件分开过程中出现错误</span></span><ul><li><span class="name"><span class="innerContentContainer">事件有没有分发到inputdispatcher。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>PMS: 包管理</b></span></span><ul><li><span class="name"><span class="innerContentContainer">APK组成结构</span></span><ul><li><span class="name"><span class="innerContentContainer">APK: Android Package, 即安卓应用安装包. APK文件其实是zip格式，但后缀名被修改为apk，通过UnZip解压后，可以看到Dex文件.</span></span></li><li><span class="name"><span class="innerContentContainer">AAPT工具：(android asset packing tool)，安卓资源打包工具</span></span></li><li><span class="name"><span class="innerContentContainer">APK文件其实是zip格式, 解压缩后是如下目录: </span></span><ul><li><span class="name"><span class="innerContentContainer">META-INF\（Jar文件中常可以看到）</span></span></li><li><span class="name"><span class="innerContentContainer">res\（存放资源文件的目录）</span></span></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml（程序全局配置文件）</span></span><ul><li><span class="name"><span class="innerContentContainer">app包名 + 组件声明 + 程序兼容的最低版本 + 所需权限等程序的配置文件. </span></span></li><li><span class="name"><span class="innerContentContainer">一个apk一个.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">classes.dex（<b>dex文件，Dalvik字节码</b>）</span></span></li><li><span class="name"><span class="innerContentContainer">resources.arsc(编译后的二进制资源文件）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>其中最重要的是 dex文件，即Dalvik字节码</b></span></span><ul><li><span class="name"><span class="innerContentContainer">android java代码编译为dex格式（Dalvik execute）文件。</span></span></li><li><span class="name"><span class="innerContentContainer">dex格式是专为Dalvik设计的一种压缩格式。</span></span></li><li><span class="name"><span class="innerContentContainer">Dex: DalvikVM executes的简称，即Android Dalvik执行程序, Dalvik字节码. </span></span></li><li><span class="name"><span class="innerContentContainer">一个dex档通常会有多个.class。</span></span></li><li><span class="name"><span class="innerContentContainer">dx 是一套工具，可以将 Java .class 转换成 .dex 格式. </span></span></li><li><span class="name"><span class="innerContentContainer">对classes.dex文件进行Cache优化后, 文件大小会增加1-4倍，这种文件以ODEX结尾。</span></span><ul><li><span class="name"><span class="innerContentContainer">APK中原来的classes.dex文件会保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Dalvik第一次加载时，会对每个apk进行优化，这个过程叫odex。目的是加快apk启动速度。所以手机第一次开机时间较长。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml解析</span></span></li><li><span class="name"><span class="innerContentContainer">APK安装流程</span></span></li><li><span class="name"><span class="innerContentContainer">APK管理，权限和查询</span></span></li><li><span class="name"><span class="innerContentContainer">APK卸载流程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件通知机制: epoll</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/categories/Android/Event/">https://www.viseator.com/categories/Android/Event/</a>  --相当不错</span></span></li><li><span class="name"><span class="innerContentContainer">Android系统本质上是一个事件驱动的系统. 消息机制在android系统中占据核心位置.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">这里说的消息机制, 分为3个层面:</span></span><ul><li><span class="name"><span class="innerContentContainer">IO设备管理方面, 通过native层消息机制完成数据传输的同步控制. 比如Input;</span></span></li><li><span class="name"><span class="innerContentContainer">消息队列, Looper, 通过java层消息机制完成跨线程通讯.</span></span></li><li><span class="name"><span class="innerContentContainer">Binder机制也是通过java层消息机制完成的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">android的消息机制分为native与java两个部分.</span></span><ul><li><span class="name"><span class="innerContentContainer">java层消息机制, 是通过native层消息机制实现的.</span></span></li><li><span class="name"><span class="innerContentContainer">连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理.</span></span></li><li><span class="name"><span class="innerContentContainer">native层消息机制中, 最关键的超时与唤醒机制, 是通过kernel层epoll机制实现.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Epoll属于哪个领域的概念?</span></span><ul><li><span class="name"><span class="innerContentContainer">Epoll机制属于事件通知机制, 而事件通知机制看起来属于跨进程通讯的范畴, 但是它实际上属于设备管理的范畴.</span></span></li><li><span class="name"><span class="innerContentContainer">事件通知机制本质上要处理CPU和设备之间的不同步问题. 简言之, 就是CPU通知设备做点事, 设备不一定能马上处理完并返回的问题.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这里说的"事件"的含义是什么?</span></span><ul><li><span class="name"><span class="innerContentContainer">所谓"事件", 就其本质而言, 产生于设备的内核缓冲区, 当然最终是设备硬件中断产生的. </span></span></li><li><span class="name"><span class="innerContentContainer">事件和硬件中断不是一一对应的. 以网卡为例:</span></span><ul><li><span class="name"><span class="innerContentContainer">当数据量很少的时候，每来一个数据包网卡都回产生一个中断，os响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。</span></span></li><li><span class="name"><span class="innerContentContainer">当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。</span></span></li><li><span class="name"><span class="innerContentContainer">当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到<b>轮询</b>处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件包括4种:</span></span><ul><li><span class="name"><span class="innerContentContainer">内核读缓冲器非空.  (读方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 有人写入</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 事件未处理完.  (常用)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核读缓冲区空. (读方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚空. (常用)</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 空.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写缓冲区满.  (写方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚满</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 满</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写缓冲区非满. (写方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚非满</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 非满</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件通知机制有三种: 阻塞, 轮询, IO 多路复用.</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞指读取数据时, 数据没有准备好, 读进程会停止运行, 等数据准备好再被系统唤醒.&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞是一种同步机制.</span></span></li><li><span class="name"><span class="innerContentContainer">缺点是一个线程只能处理一路IO. 原因是如果同时处理两路, 一路阻塞了, 另外一路就得不到处理了. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">轮询指轮流查询各路IO的状态. </span></span><ul><li><span class="name"><span class="innerContentContainer">缺点是浪费CPU时间.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IO多路复用机制是, 数据没有准备好, 也会阻塞, 但是系统会设置一个IO<b>代理</b>, 当若干路IO就绪时, 由代理唤醒线程, 并告诉它是哪路IO就绪, 从而提升处理效率.</span></span><ul><li><span class="name"><span class="innerContentContainer">IO多路复用机制相当于阻塞机制的改进.</span></span></li><li><span class="name"><span class="innerContentContainer">epoll即 I/O多路复用机制的实现.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">epoll背景知识</span></span><ul><li><span class="name"><span class="innerContentContainer">epoll机制于Linux 2.5.44首度登场.</span></span></li><li><span class="name"><span class="innerContentContainer">设计目的旨在取代既有POSIX&nbsp;select(2)与poll(2)系统函数.</span></span></li><li><span class="name"><span class="innerContentContainer">优势是处理多路IO事件时, 性能提升非常多. 旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n). (很多材料说是 O(1), 这是错误的).</span></span></li><li><span class="name"><span class="innerContentContainer">性能提升的原因是它能够只关注有数据的FD(文件描述符), 而不是所有FD都轮询一遍.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">epoll&nbsp;通过使用红黑树(RB-tree)搜索被监视的文件描述符(file descriptor, FD)。</span></span></li><li><span class="name"><span class="innerContentContainer">在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</span></span></li><li><span class="name"><span class="innerContentContainer">程序接口</span></span><ul><li><span class="name"><span class="innerContentContainer">接口实现在 /bionic/libc/bionic/sys_epoll.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">int epoll_create(int size);  // 在内核中创建epoll实例并返回一个epoll文件描述符。</span></span></li><li><span class="name"><span class="innerContentContainer">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  // 添加、修改或删除对 fd 上事件 event 的监听。</span></span><ul><li><span class="name"><span class="innerContentContainer">op 可以为&nbsp;EPOLL_CTL_ADD,&nbsp;添加新的事件</span></span></li><li><span class="name"><span class="innerContentContainer">EPOLL_CTL_MOD,&nbsp;修改文件描述符上监听的事件类型. 类型包括沿触发和状态触发. </span></span></li><li><span class="name"><span class="innerContentContainer">EPOLL_CTL_DEL, 从实例上删除一个事件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">int <b>epoll_wait</b>(int epfd, struct epoll_event *events, int maxevents, int timeout);   // 监听并阻塞, 等待唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">当 timeout 为 0 时，epoll_wait 永远会立即返回。</span></span></li><li><span class="name"><span class="innerContentContainer">而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。</span></span></li><li><span class="name"><span class="innerContentContainer">当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">应用程序调用 <b>epoll_wait() 启动监听, 并阻塞自身后, 需要等待另一个进程唤醒.</b></span></span></li><li><span class="name"><span class="innerContentContainer">唤醒的机制是通过对event FD写入一个数据(一般是1, 显然在这个上下文下写入的内容无关紧要), epoll会监听这个FD, 发现有新数据了, 就把上面监听的进程逐一放入系统的就绪队列, 逐一处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">沿触发和状态触发</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发时，epoll_wait() 仅会在新的事件首次被加入epoll队列时返回.</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发时, epoll_wait在事件状态未变更前将不断被触发。</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发模式是默认的模式。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>同步, 异步, 阻塞, 非阻塞, 轮询, 事件之间的关系  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">这几个概念之所以很混乱, 是因为汉语中把同步调用和跨线程的同步控制, 这两个几乎无关系的概念, 都缩写成"同步"这个词. 这导致了广泛的概念混淆.</span></span></li><li><span class="name"><span class="innerContentContainer">这几个概念不是并列的. 其关系如下:</span></span></li><li><span class="name"><span class="innerContentContainer">同步调用</span></span><ul><li><span class="name"><span class="innerContentContainer">同步就是同一个线程一直在跑, 函数调用返回的时候, 就拿到了调用结果. </span></span></li><li><span class="name"><span class="innerContentContainer">但是, 如果调用涉及到IO操作, 即对硬件的处理. 由于一般情况下面 硬件的访问速度比CPU和内存慢若干个数量级, 所以就存在调用了不能马上得到调用结果的问题. </span></span><ul><li><span class="name"><span class="innerContentContainer">反推回去, 同步之所以行得通, 仅仅因为CPU和内存的速度处在同一个数量级上的(当然, 这个话也不准确, 为了解决这个问题, 有无数的解决方案, 这个领域属于芯片设计, 不提), 由于它们的速度处在同一个数量级, 所以当我们的代码仅仅是读一个数, 做个计算, 再写一个数的时候, 所有这些事情都可以同步完成. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">面对这种不同步, <b>轮询</b>是最直接的解决办法. 轮询算同步.</span></span><ul><li><span class="name"><span class="innerContentContainer">轮询指调用一个函数, 如果不能马上得到结果, 就反复调用它, 直到得到结果为止. </span></span><ul><li><span class="name"><span class="innerContentContainer">一般情况下, 轮询是消费CPU资源的, 而且会引起界面卡顿等问题. </span></span></li><li><span class="name"><span class="innerContentContainer">当然也有特殊情况, 此时轮询效率更高.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">异步</span></span><ul><li><span class="name"><span class="innerContentContainer">异步是轮询的一种改进, 改进的目的是节省CPU资源.</span></span></li><li><span class="name"><span class="innerContentContainer">异步的特点是, 调用结束时拿不到调用结果, 继续执行别的代码. 然后发生线程切换, 在另外一个线程中执行被调方代码并返回结果. 调用和拿到调用结果, 不是在同一个函数中, 一般也不在同一个线程中.</span></span></li><li><span class="name"><span class="innerContentContainer">异步的常见方式是: 调用的同时注册回调函数, 然后在没有执行结果的情况下直接返回, 接着往下执行. 回调函数则会在被调者执行完之后被调用.</span></span></li><li><span class="name"><span class="innerContentContainer">异步, 实际上是把调用逻辑分为4部分: 调用者前半部, 被调者前半部, 被调者后半部, 调用者后半部(也就是回调函数). </span></span></li><li><span class="name"><span class="innerContentContainer"><b>调用者前半部</b> 调用 <b>被调者前半部</b>, <b>被调者前半部</b> 想办法调用 <b>被调者后半部</b>(这里存在跨线程通讯), 这个过程发生在调用者线程中. 然后发生线程切换, 去执行 <b>被调者后半部</b>, 等它执行完了, 再调用 <b>调用者后半部</b>(再强调一遍, 也就是回调函数), 这个过程发生在被调者线程中. </span></span></li><li><span class="name"><span class="innerContentContainer">我之所以说异步是一种特殊的同步实现方法, 是因为调用者前半部 调用 被调者前半部, 是同步调用, 马上得到结果; 被调者后半部, 调用 调用者后半部, 也是同步调用, 马上得到结果. 至于被调者前半部 调用 被调者后半部的机制, 这往往是框架或平台在处理, 对使用者不可见. </span></span></li><li><span class="name"><span class="innerContentContainer">对初学者而言, 理解异步最困难的是理解回调函数. </span></span></li><li><span class="name"><span class="innerContentContainer">但是对于有经验的人来说, 回调函数仅仅是把处理的后半部分单独出来, 稍微有些绕而已, 并不难理解. 真正复杂的问题是, 被调者前半部, 怎么去调用 被调者后半部.</span></span></li><li><span class="name"><span class="innerContentContainer">首先要理解的是, 被调者前半部 和 被调者后半部 处在不同的线程中(调用者前半部, 和回调函数也在不同的线程中).  也就是说, 这是一个跨线程的调用. 因此请参见: "跨线程的同步机制".</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">阻塞</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞, 就是调用一个函数半途中发生线程切换, 等拿到调用结果时, 再把线程切换回来继续执行.</span></span></li><li><span class="name"><span class="innerContentContainer">其突出特点是虽然线程切换了, 但是函数没有换, 还是在原来函数中. </span></span></li><li><span class="name"><span class="innerContentContainer">从某种意义上讲, 阻塞是操作系统(或者虚拟机)帮忙, 以同步的形式, 完成异步的实质. 毕竟, 同步调用, 代码的执行顺序和编写顺序是一致的, 好理解多了.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">非阻塞, 就是异步. 不用阻塞, 又在IO操作中, 只能是异步. </span></span></li><li><span class="name"><span class="innerContentContainer">epoll: epoll是同步机制, 它支持阻塞, 也可以支持非阻塞. 区别在于入参. epoll_wait() 的</span></span></li><li><span class="name"><span class="innerContentContainer">跨线程的同步机制</span></span><ul><li><span class="name"><span class="innerContentContainer">异步和阻塞, 都涉及到同一个处理逻辑(从业务视角出发), 分解到不同的线程的问题. 因此, 这几个线程之间必须要有同步机制, 才能把业务逻辑处理好. </span></span></li><li><span class="name"><span class="innerContentContainer">同步机制是消息队列. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">还有一种分类方式, 就是把阻塞作为一种特殊的同步调用方式. 其理由是, 同步调用就是这个函数执行完了, 就拿到执行结果了. 阻塞没出函数拿到结果, 所以算同步机制. </span></span><ul><li><span class="name"><span class="innerContentContainer">这个仅仅是一个定义的问题. 这么算也可以. 但是阻塞出现了当前线程挂起, 失去CPU, 以及多个线程间的同步控制, 这种算同步就掩盖了很多技术细节.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同步阻塞的IO会使线程挂起，同步非阻塞(即轮询)的IO会消耗CPU资源在轮询上。</span></span></li><li><span class="name"><span class="innerContentContainer">IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）.</span></span></li><li><span class="name"><span class="innerContentContainer">直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PowerManagerService: 功耗管理   --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">https://workflowy.com/#/a5573305b407</a></span></span></li><li><span class="name"><span class="innerContentContainer">BatteryService: 电池管理服务   --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">https://workflowy.com/#/a5573305b407</a></span></span></li><li><span class="name"><span class="innerContentContainer">NotificationManagerService: 通知栏管理服务   --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/2bfbaf316a49">https://workflowy.com/#/2bfbaf316a49</a></span></span></li><li><span class="name"><span class="innerContentContainer">StatusBarManagerService: 状态栏管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">视窗系统  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/56a8ba6ce429">https://workflowy.com/#/56a8ba6ce429</a></span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/e96b8978d6de">https://workflowy.com/#/e96b8978d6de</a></span></span></li><li><span class="name"><span class="innerContentContainer">Location  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/cb01714441aa">https://workflowy.com/#/cb01714441aa</a></span></span></li><li><span class="name"><span class="innerContentContainer"><b>其它系统服务(运行于SystemServer)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">EntropyService: 提供伪随机数</span></span></li><li><span class="name"><span class="innerContentContainer">AccountManagerService: 账户管理服务，android系统账户</span></span></li><li><span class="name"><span class="innerContentContainer">LightsService: 自然光强度感应传感器服务</span></span></li><li><span class="name"><span class="innerContentContainer">VibratorService: 震动器服务</span></span></li><li><span class="name"><span class="innerContentContainer">AlarmManagerService: 定时器管理服务，提供定时提醒服务</span></span></li><li><span class="name"><span class="innerContentContainer">BluetoothService: 蓝牙服务</span></span></li><li><span class="name"><span class="innerContentContainer">DevicePolicyManagerService: 系统级别的设置及属性管理</span></span></li><li><span class="name"><span class="innerContentContainer">ClipboardService: 系统剪切板服务</span></span></li><li><span class="name"><span class="innerContentContainer">InputMethodManagerService: 输入法管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">NetworkManagementService: 网络管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">NetStatService: 网络状态服务</span></span></li><li><span class="name"><span class="innerContentContainer">AccessibilityManagerService: 无障碍访问服务</span></span></li><li><span class="name"><span class="innerContentContainer">MountService: 挂载服务，可通过该服务调用Linux层面的mount程序</span></span></li><li><span class="name"><span class="innerContentContainer">SearchManagerService: 搜索管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">DropBoxManagerService: 通过该服务访问Linux层面的Dropbox程序</span></span></li><li><span class="name"><span class="innerContentContainer">WallpaperManagerService: 墙纸管理服务，墙纸不等同于桌面背景，在View系统内部，墙纸可以作为任何窗口的背景</span></span></li><li><span class="name"><span class="innerContentContainer">AudioService: 音频管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">BackupManagerService: 系统备份服务</span></span></li><li><span class="name"><span class="innerContentContainer">AppWidgetService: Widget服务</span></span></li><li><span class="name"><span class="innerContentContainer">RecognitionManagerService: 身份识别服务</span></span></li><li><span class="name"><span class="innerContentContainer">DiskStatsService: 磁盘统计服务</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">XMPP服务</span></span><ul><li><span class="name"><span class="innerContentContainer">开源的即时通讯框架.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Phone MS</span></span><ul><li><span class="name"><span class="innerContentContainer">属于协议领域.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">华为飞马架构</span></span><ul><li><span class="name"><span class="innerContentContainer">2019年发展到 5.0</span></span></li><li><span class="name"><span class="innerContentContainer">芯片组件</span></span></li><li><span class="name"><span class="innerContentContainer">系统组件</span></span></li><li><span class="name"><span class="innerContentContainer">版本组件</span></span></li><li><span class="name"><span class="innerContentContainer">定制组件</span></span><ul><li><span class="name"><span class="innerContentContainer">代码+配置仓</span></span></li></ul></li></ul></li></ul>
  </body>
</html>