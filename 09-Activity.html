<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">09-Activity</span><ul><li><span class="name">Activity生命周期</span><ul><li><span class="name">参见: Activity生命周期图, 一定要看图.  <span class="contentTag" title="Filter #Chart">#<span class="contentTagText">Chart</span><span class="contentTagNub"></span></span> </span></li><li><span class="name"><b>onCreate&nbsp;</b>: 该方法是在Activity被创建时回调，它是生命周期第一个调用的方法，我们在创建Activity时一般都需要重写该方法，然后在该方法中做一些初始化的操作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。</span></li><li><span class="name"><b>onStart&nbsp;</b>: 此方法被回调时表示Activity正在启动，此时Activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。可以简单理解为Activity已显示而我们无法看见摆了.</span></li><li><span class="name"><b>onResume </b>: 当此方法回调时，则说明Activity已在前台可见，可与用户交互了（处于前面所说的Active/Running形态）.</span><ul><li><span class="name">onResume方法与onStart的相同点是两者都表示Activity可见，只不过onStart回调时Activity还是后台无法与用户交互，而onResume则已显示在前台，可与用户交互。</span></li><li><span class="name">还有, 当Activity停止后（onPause方法和onStop方法被调用），重新回到前台时也会调用onResume方法，</span></li><li><span class="name">我们可以在onResume方法中初始化一些资源，比如重新初始化在 onPause 或者 onStop 方法中释放的资源。</span></li></ul></li><li><span class="name"><b>onPause </b>: 此方法被回调时则表示Activity正在停止（Paused形态），一般情况下onStop方法会紧接着被回调。</span><ul><li><span class="name">通过流程图我们还可以看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象了，这可能是用户操作使当前Activity退居后台后又迅速地再回到到当前的Activity，此时onResume方法就会被回调。</span></li><li><span class="name">在onPause方法中我们可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示. </span></li><li><span class="name"><b>因为旧activity的 onPause方法执行完成后，新Activity的onResume方法才会被执行。</b></span></li><li><span class="name">onPause()和onStop()被调用的前提是： 打开了一个新的Activity！而前者是旧Activity还可见的状态；后者是旧Activity已经不可见！</span></li><li><span class="name">同时, AlertDialog 和 PopWindow是不会触发上述两个回调方法的~</span></li></ul></li><li><span class="name"><b>onStop </b>: 一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖（Stopped形态），此时Activity不可见，仅在后台运行。在onStop方法可以做一些资源释放的操作（不能太耗时）。</span></li><li><span class="name"><b>onRestart </b>: 表示Activity正在重新启动，当Activity由<b>onStop</b>() 状态切换回前台时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。</span></li><li><span class="name"><b>onDestroy </b>:此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。</span></li><li><span class="name">总结下: </span><ul><li><span class="name">Activity第一启动的时候执行: onCreate() -&gt; onStart() -&gt; onResume(). </span></li><li><span class="name">如果再有启动同一Activity的时候, 执行: onNewIntent() -&gt; onResart() -&gt; onStart() -&gt; onResume().</span></li><li><span class="name">如果android系统由于内存不足把已存在Activity释放掉了，那么再次调用的时候会重新启动Activity, 即执行: onCreate() -&gt; onStart() -&gt; onResume()。</span></li></ul></li></ul></li><li><span class="name">横竖屏切换</span><ul><li><span class="name">横竖屏切换的时候会销毁当前的Activity然后重新创建一个. </span></li><li><span class="name">横竖屏切换时会走这个生命周期：onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume</span></li><li><span class="name">准备两套不同的布局，Android会自己根据横竖屏加载不同布局. 创建两个布局文件夹：</span><ul><li><span class="name">layout-land: 横屏</span></li><li><span class="name">layout-port: 竖屏</span></li></ul></li><li><span class="name">在onCreate()方法中判断横竖屏</span><ul><li><span class="name">if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE){</span><ul><li><span class="name">setContentView(R.layout.横屏);</span></li></ul></li><li><span class="name">} else if (this.getResources().getConfiguration().orientation ==Configuration.ORIENTATION_PORTRAIT) {</span><ul><li><span class="name">setContentView(R.layout.竖屏);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">禁止屏幕横竖屏自动切换</span><ul><li><span class="name">在AndroidManifest.xml中为Act添加一个属性：&nbsp;android:screenOrientation, 值域是:</span></li><li><span class="name">unspecified: 默认值.由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向。</span></li><li><span class="name">landscape: 横屏显示（宽比高要长）</span></li><li><span class="name">portrait: 竖屏显示(高比宽要长)</span></li><li><span class="name">user: 用户当前首选的方向</span></li><li><span class="name">behind: 和Activity堆栈中前面那个Activity的方向一致.</span></li><li><span class="name">sensor: 有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。</span></li><li><span class="name">nosensor: 忽略物理感应器，这样就不会随着用户旋转设备而更改了（"unspecified"设置除外）。</span></li></ul></li><li><span class="name">系统给我们提供的常见的Activity</span><ul><li><span class="name">拨打电话</span><ul><li><span class="name">// 给移动客服10086拨打电话</span></li><li><span class="name">Uri uri = Uri.parse("tel:10086");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_DIAL, uri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">发送短信</span><ul><li><span class="name">// 给10086发送内容为“Hello”的短信</span></li><li><span class="name">Uri uri = Uri.parse("smsto:10086");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_SENDTO, uri);</span></li><li><span class="name">intent.putExtra("sms_body", "Hello");</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">发送彩信（相当于发送带附件的短信）</span><ul><li><span class="name">Intent intent = new Intent(Intent.ACTION_SEND);</span></li><li><span class="name">intent.putExtra("sms_body", "Hello");</span></li><li><span class="name">Uri uri = Uri.parse("<a class="contentLink" target="_blank" rel="noreferrer" href="content://media/external/images/media/23">content://media/external/images/media/23</a>");</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_STREAM, uri);</span></li><li><span class="name">intent.setType("image/png");</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">打开浏览器</span><ul><li><span class="name">Uri uri = Uri.parse("<a class="contentLink" target="_blank" rel="noreferrer" href="http://www.baidu.com">http://www.baidu.com</a>");</span></li><li><span class="name">Intent intent&nbsp; = new Intent(Intent.ACTION_VIEW, uri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">发送电子邮件(阉割了Google服务的没戏)</span><ul><li><span class="name">Uri uri = Uri.parse("mailto:<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:someone@domain.com">someone@domain.com</a>");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_SENDTO, uri);</span></li><li><span class="name">startActivity(intent);</span></li><li><span class="name">// 给<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:someone@domain.com">someone@domain.com</a>发邮件发送内容为“Hello”的邮件</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_SEND);</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_EMAIL, "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:someone@domain.com">someone@domain.com</a>");</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_SUBJECT, "Subject");</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_TEXT, "Hello");</span></li><li><span class="name">intent.setType("text/plain");</span></li><li><span class="name">startActivity(intent);</span></li><li><span class="name">// 给多人发邮件</span></li><li><span class="name">Intent intent=new Intent(Intent.ACTION_SEND);</span></li><li><span class="name">String[] tos = {"<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:1@abc.com">1@abc.com</a>", "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:2@abc.com">2@abc.com</a>"}; // 收件人</span></li><li><span class="name">String[] ccs = {"<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:3@abc.com">3@abc.com</a>", "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:4@abc.com">4@abc.com</a>"}; // 抄送</span></li><li><span class="name">String[] bccs = {"<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:5@abc.com">5@abc.com</a>", "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:6@abc.com">6@abc.com</a>"}; // 密送</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_EMAIL, tos);</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_CC, ccs);</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_BCC, bccs);</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_SUBJECT, "Subject");</span></li><li><span class="name">intent.putExtra(Intent.EXTRA_TEXT, "Hello");</span></li><li><span class="name">intent.setType("message/rfc822");</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">显示地图</span><ul><li><span class="name">// 打开Google地图中国北京位置（北纬39.9，东经116.3）</span></li><li><span class="name">Uri uri = Uri.parse("geo:39.9,116.3");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">路径规划</span><ul><li><span class="name">// 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4）</span></li><li><span class="name">Uri uri = Uri.parse("<a class="contentLink" target="_blank" rel="noreferrer" href="http://maps.google.com/maps?f=d&amp;saddr=39.9">http://maps.google.com/maps?f=d&amp;saddr=39.9</a> 116.3&amp;daddr=31.2 121.4");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">多媒体播放</span><ul><li><span class="name">Intent intent = new Intent(Intent.ACTION_VIEW);</span></li><li><span class="name">Uri uri = Uri.parse("<a class="contentLink" target="_blank" rel="noreferrer" href="file:///sdcard/foo.mp3">file:///sdcard/foo.mp3</a>");</span></li><li><span class="name">intent.setDataAndType(uri, "audio/mp3");</span></li><li><span class="name">startActivity(intent);</span></li><li><span class="name">// 获取SD卡下所有音频文件,然后播放第一首=-=</span></li><li><span class="name">Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">打开摄像头拍照</span><ul><li><span class="name">// 打开拍照程序</span></li><li><span class="name">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span></li><li><span class="name">startActivityForResult(intent, 0);</span></li><li><span class="name">// 取出照片数据</span></li><li><span class="name">Bundle extras = intent.getExtras();</span></li><li><span class="name">Bitmap bitmap = (Bitmap) extras.get("data");</span></li></ul></li><li><span class="name">调用系统相机应用程序，并存储拍下来的照片</span><ul><li><span class="name">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span></li><li><span class="name">time = Calendar.getInstance().getTimeInMillis();</span></li><li><span class="name">intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment</span></li><li><span class="name">.getExternalStorageDirectory().getAbsolutePath()+"/tucue", time + ".jpg")));</span></li><li><span class="name">startActivityForResult(intent, ACTIVITY_GET_CAMERA_IMAGE);</span></li></ul></li><li><span class="name">获取并剪切图片</span><ul><li><span class="name">// 获取并剪切图片</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_GET_CONTENT);</span></li><li><span class="name">intent.setType("image/*");</span></li><li><span class="name">intent.putExtra("crop", "true"); // 开启剪切</span></li><li><span class="name">intent.putExtra("aspectX", 1); // 剪切的宽高比为1：2</span></li><li><span class="name">intent.putExtra("aspectY", 2);</span></li><li><span class="name">intent.putExtra("outputX", 20); // 保存图片的宽和高</span></li><li><span class="name">intent.putExtra("outputY", 40);</span></li><li><span class="name">intent.putExtra("output", Uri.fromFile(new File("/mnt/sdcard/temp"))); // 保存路径</span></li><li><span class="name">intent.putExtra("outputFormat", "JPEG");// 返回格式</span></li><li><span class="name">startActivityForResult(intent, 0);</span></li><li><span class="name">// 剪切特定图片</span></li><li><span class="name">Intent intent = new Intent("com.android.camera.action.CROP");</span></li><li><span class="name">intent.setClassName("com.android.camera", "com.android.camera.CropImage");</span></li><li><span class="name">intent.setData(Uri.fromFile(new File("/mnt/sdcard/temp")));</span></li><li><span class="name">intent.putExtra("outputX", 1); // 剪切的宽高比为1：2</span></li><li><span class="name">intent.putExtra("outputY", 2);</span></li><li><span class="name">intent.putExtra("aspectX", 20); // 保存图片的宽和高</span></li><li><span class="name">intent.putExtra("aspectY", 40);</span></li><li><span class="name">intent.putExtra("scale", true);</span></li><li><span class="name">intent.putExtra("noFaceDetection", true);</span></li><li><span class="name">intent.putExtra("output", Uri.parse("<a class="contentLink" target="_blank" rel="noreferrer" href="file:///mnt/sdcard/temp">file:///mnt/sdcard/temp</a>"));</span></li><li><span class="name">startActivityForResult(intent, 0);</span></li></ul></li><li><span class="name">打开Google Market</span><ul><li><span class="name">// 打开Google Market直接进入该程序的详细页面</span></li><li><span class="name">Uri uri = Uri.parse("<a class="contentLink" target="_blank" rel="noreferrer" href="market://details?id=">market://details?id=</a>" + "com.demo.app");</span></li><li><span class="name">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">进入手机设置界面</span><ul><li><span class="name">// 进入无线网络设置界面（其它可以举一反三）</span></li><li><span class="name">Intent intent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);</span></li><li><span class="name">startActivityForResult(intent, 0);</span></li></ul></li><li><span class="name">安装apk</span><ul><li><span class="name">Uri installUri = Uri.fromParts("package", "xxx", null);</span></li><li><span class="name">returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);</span></li></ul></li><li><span class="name">卸载apk</span><ul><li><span class="name">Uri uri = Uri.fromParts("package", strPackageName, null);</span></li><li><span class="name">Intent it = new Intent(Intent.ACTION_DELETE, uri);</span></li><li><span class="name">startActivity(it);</span></li></ul></li><li><span class="name">发送附件</span><ul><li><span class="name">Intent it = new Intent(Intent.ACTION_SEND);</span></li><li><span class="name">it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");</span></li><li><span class="name">it.putExtra(Intent.EXTRA_STREAM, "<a class="contentLink" target="_blank" rel="noreferrer" href="file:///sdcard/eoe.mp3">file:///sdcard/eoe.mp3</a>");</span></li><li><span class="name">sendIntent.setType("audio/mp3");</span></li><li><span class="name">startActivity(Intent.createChooser(it, "Choose Email Client"));</span></li></ul></li><li><span class="name">进入联系人页面</span><ul><li><span class="name">Intent intent = new Intent();</span></li><li><span class="name">intent.setAction(Intent.ACTION_VIEW);</span></li><li><span class="name">intent.setData(People.CONTENT_URI);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li><li><span class="name">查看指定联系人</span><ul><li><span class="name">Uri personUri = ContentUris.withAppendedId(People.CONTENT_URI, <a class="contentLink" target="_blank" rel="noreferrer" href="http://info.id">info.id</a>);  //info.id联系人ID</span></li><li><span class="name">Intent intent = new Intent();</span></li><li><span class="name">intent.setAction(Intent.ACTION_VIEW);</span></li><li><span class="name">intent.setData(personUri);</span></li><li><span class="name">startActivity(intent);</span></li></ul></li></ul></li><li><span class="name">Activity间的数据传递</span><ul><li><span class="name"><b>Intent </b>it = new Intent(MyActivity.this, MyActivity2.class);</span></li><li><span class="name"><b>Bundle </b>bd = new Bundle();   // // 新建Bundle对象,并把数据写入</span></li><li><span class="name">bd.putCharSequence("user",name);</span></li><li><span class="name">bd.putCharSequence("sex",sex);</span></li><li><span class="name">it.<b>putExtras</b>(bd);  // 将数据包Bundle绑定到Intent上</span></li><li><span class="name">startActivity(it);   // 启动第二个activity</span></li><li><span class="name">finish();   // 关闭第一个Activity</span></li></ul></li><li><span class="name">一次性关闭所有Activity</span><ul><li><span class="name">public class ActivityCollector {</span><ul><li><span class="name">// 用一个list集合来存储所有Activity</span></li><li><span class="name">public static LinkedList&lt;Activity&gt; activities = new LinkedList&lt;Activity&gt;();</span></li><li><span class="name">public static void addActivity(Activity activity) {</span><ul><li><span class="name">activities.add(activity);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public static void removeActivity(Activity activity) {</span><ul><li><span class="name">activities.remove(activity);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public static void finishAll() {</span><ul><li><span class="name">for(Activity activity:activities) {</span><ul><li><span class="name">if(!activity.isFinishing()) {</span><ul><li><span class="name">activity.finish();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">假如app中所有的activity 都继承自 BaseActivity.  在它的 onCreate() 中调用 ActivityCollector.addActivity(this);  在 onDestory() 中调用 ActivityCollector.removeActivity().</span></li><li><span class="name">然后在任何地方调用 ActivityCollector.finishAll() 即可关闭所有的activity.</span></li></ul></li><li><span class="name">完全退出App</span><ul><li><span class="name">上面是关闭所有的activity, 但是app并没有退出, 还有service. </span></li><li><span class="name">下面是完全退出app的代码:</span></li><li><span class="name">public void AppExit(Context context) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">ActivityCollector.finishAll();</span></li><li><span class="name">ActivityManager activityMgr = (ActivityManager) context</span><ul><li><span class="name">.getSystemService(Context.ACTIVITY_SERVICE);</span></li></ul></li><li><span class="name">activityMgr.killBackgroundProcesses(context.getPackageName());</span></li><li><span class="name">System.exit(0);</span></li></ul></li><li><span class="name">} catch (Exception ignored) {}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">为Activity设置过场动画</span><ul><li><span class="name">过场动画就是切换到另外的Activity时加上一些切换动画，比如淡入淡出，放大缩小，左右互推等.</span></li><li><span class="name"></span></li><li><span class="name">通过style进行配置，这个是全局的哦，就是所有的Activity都会加载这个动画.</span></li><li><span class="name">(1) 在style.xml中自定义style：</span></li><li><span class="name">&lt;!-- 默认Activity跳转动画 --&gt;</span></li><li><span class="name">&lt;style name="default_animation" mce_bogus="1" parent="@android:style/Animation.Activity"&gt;</span><ul><li><span class="name">&lt;item name="android:activityOpenEnterAnimation"&gt;@anim/default_anim_in&lt;/item&gt;</span></li><li><span class="name">&lt;item name="android:activityOpenExitAnimation"&gt;@anim/anim_stay&lt;/item&gt;</span></li><li><span class="name">&lt;item name="android:activityCloseEnterAnimation"&gt;@anim/anim_stay&lt;/item&gt;</span></li><li><span class="name">&lt;item name="android:activityCloseExitAnimation"&gt;@anim/default_anim_out&lt;/item&gt;</span></li></ul></li><li><span class="name">&lt;/style&gt;</span></li><li><span class="name">4个item分别代表:</span></li><li><span class="name">Activity A跳转到Activity B时Activity B进入动画;</span></li><li><span class="name">Activity A跳转到Activity B时Activity A退出动画;</span></li><li><span class="name">Activity B返回Activity A时Activity A的进入动画</span></li><li><span class="name">Activity B返回Activity A时ActivityB的退出动画</span></li><li><span class="name"><b>(2) 然后修改下AppTheme:</b>&lt;style name="AppTheme" mce_bogus="1" parent="@android:style/Theme.Light"&gt;</span><ul><li><span class="name">&lt;item name="android:windowAnimationStyle"&gt;@style/default_animation&lt;/item&gt;</span></li><li><span class="name">&lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;</span></li></ul></li><li><span class="name">&lt;/style&gt;</span></li><li><span class="name"><b>(3) 最后在appliction设置下：</b></span></li><li><span class="name">&lt;application</span><ul><li><span class="name">android:icon="@drawable/logo"</span></li><li><span class="name">android:label="@string/app_name"</span></li><li><span class="name">android:theme="@style/AppTheme" &gt;</span></li></ul></li></ul></li><li><span class="name">Bundle传递数据的限制: 不能超过0.5MB, 超过会报 TransactionTooLargeException 异常.</span></li><li><span class="name">设置Activity全屏. 3个方法: </span><ul><li><span class="name">1）代码隐藏ActionBar</span><ul><li><span class="name">在Activity的onCreate方法中调用getActionBar.hide();即可</span></li></ul></li><li><span class="name">2）通过requestWindowFeature设置</span></li><li><span class="name">requestWindowFeature(Window.FEATURE_NO_TITLE);  // 需要在setContentView ()之前调用. </span></li><li><span class="name">注：&nbsp;把 requestWindowFeature(Window.FEATURE_NO_TITLE); 放在super.onCreate(savedInstanceState);前面就可以隐藏ActionBar而不报错。</span></li><li><span class="name">3）通过AndroidManifest.xml的theme</span></li><li><span class="name">在需要全屏的Activity的标签内设置 theme = <span class="contentTag" title="Filter @android:style">@<span class="contentTagText">android:style</span><span class="contentTagNub"></span></span>/Theme.NoTitleBar.FullScreen</span></li></ul></li><li><span class="name">定义对话框风格的Activity</span><ul><li><span class="name">Activity一般是占满全屏的， 而Dialog则是占据部分屏幕的.</span></li><li><span class="name">直接设置下Activity的theme: android:theme="@android:style/Theme.Dialog" 即可.</span></li><li><span class="name">// 然后再设置左上角小图标</span></li><li><span class="name">requestWindowFeature(Window.FEATURE_LEFT_ICON);</span></li><li><span class="name">setContentView(R.layout.main);</span></li><li><span class="name">getWindow().setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, android.R.drawable.ic_lion_icon);</span></li><li><span class="name">// 设置文字:</span></li><li><span class="name">setTitle(R.string.actdialog_title);  //XML代码中设置:android:label="@string/activity_dialog"</span></li></ul></li><li><span class="name">Activity创建过程(AMS内容)</span><ul><li><span class="name">Activity调用startActivity后最后会调用attach方法，然后在PolicyManager实现一个IPolicy接口，接着实现一个Policy对象，</span></li><li><span class="name">接着调用makenewwindow(Context)方法，该方法会返回一个PhoneWindow对象，而PhoneWindow 是Window的子类，</span></li><li><span class="name">在这个PhoneWindow中有一个DecorView的内部类，是所有应用窗口的根View，即View的老大， 直接控制Activity是否显示, </span></li><li><span class="name">DecorView里面有一个LinearLayout，</span></li><li><span class="name">LinearLayout里面又有两个 FrameLayout, 他们分别拿来装ActionBar(状态栏)和CustomView，</span></li><li><span class="name">而我们 setContentView()加载的布局就放到这个 <b>CustomView </b>中.</span></li></ul></li><li><span class="name">Activity的管理机制(AMS内容)</span><ul><li><span class="name">APP一般是由多个Activity构成的，在Android用 Task(任务)的概念将多个相关的Activity放在一个堆栈中管理，以便进行Activity间的(合乎逻辑的)跳转与返回.</span></li><li><span class="name">实现这个Activity Task的数据结构就是Back Stack（回退堆栈）.</span></li><li><span class="name">栈具有如下特点：后进先出(LIFO).</span><ul><li><span class="name">常用操作: 入栈(push)，出栈(pop)，处于最顶部的叫栈顶，最底部叫栈底.</span></li></ul></li><li><span class="name">当切换到新的Activity，那么该Activity会被压入栈中，成为栈顶！ 而当用户点击Back键，栈顶的Activity出栈，紧随其后的Activity来到栈顶！</span></li><li><span class="name">每个task中有多个 activity. 同时, 系统中有多个task. 这些task 也组成一个 task堆栈. </span></li><li><span class="name">当我们通过主屏幕，点击图标打开一个新的App，此时会创建一个新的Task. 比如在桌面点击通信录APP的图标打开APP, 这个时候会新建一个栈1，然后开始把新产生的Activity添加进来. </span></li><li><span class="name">然后, 关键内容来了. 当我们在通讯录的APP中打开了短信APP的页面，但是此时不会新建一个栈，而是继续添加到栈1中，这是 Android推崇一种用户体验方式，即不同应用程序之间的切换能使用户感觉就像是同一个应用程序， 很连贯的用户体验，官方称其为seamless (无缝衔接）.</span></li><li><span class="name">这个时候假如我们点击Home键，回到主屏幕，此时栈1进入后台.</span></li><li><span class="name">接下来我们可能有下述两种操作：</span></li><li><span class="name">1）点击菜单键，点击打开刚刚的程序，然后栈1又回到前台了！ 又或者我们点击主屏幕上通信录的图标，打开APP，此时也不会创建新的栈，栈1回到前台！</span></li><li><span class="name">2）如果此时我们点击另一个图标打开一个新的APP，那么此时则会创建一个新的栈2，栈2就会到前台， 而栈1继续呆在后台.</span></li><li><span class="name">通过修改AndroidManifest.xml中 &lt; activity &gt;的相关属性值或者在代码中通过传递特殊标识的Intent给 startActivity( )就可以完成对Actvitiy的管理了。</span><ul><li><span class="name">&lt;activity&gt;中我们可以使用的属性如下：</span></li><li><span class="name">taskAffinity 和 allowTaskReparenting</span><ul><li><span class="name">默认情况下，一个应用程序中的所有activity都有一个Affinity，这让它们属于同一个Task。</span></li><li><span class="name">通过taskAffinity可指定该activity使用独立的Task.</span></li><li><span class="name">不同应用程序中的Activity可以共享同一个Affinity，同一个应用程序中的不同Activity 也可以设置成不同的Affinity。</span></li><li><span class="name">Affinity属性在2种情况下起作用：</span></li><li><span class="name">1）当启动 activity的Intent对象包含FLAG_ACTIVITY_NEW_TASK标记： 当传递给 startActivity()的Intent对象包含 FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的Activity寻找与当前Activity不同Task。如果要启动的 Activity的Affinity属性与当前所有的Task的Affinity属性都不相同，系统会新建一个带那个Affinity属性的Task，并将要启动的Activity压到新建的Task栈中；否则将Activity压入那个Affinity属性相同的栈中。</span></li><li><span class="name">2）allowTaskReparenting属性设置为true 如果一个activity的allowTaskReparenting属性为true， 那么它可以从一个Task（Task1）移到另外一个有相同Affinity的Task（Task2）中（Task2带到前台时）。 如果一个.apk文件从用户角度来看包含了多个"应用程序"，你可能需要对那些 Activity赋不同的Affinity值。</span></li></ul></li><li><span class="name"><b>launchMode</b></span><ul><li><span class="name">启动模式, 常用, 且关键. 值域是:</span></li><li><span class="name">standard(默认): 在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。</span><ul><li><span class="name">如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，会在A的上面再次启动一个A的实例，即当前的桟中的状态为A--&gt;A。</span></li></ul></li><li><span class="name">singleTop: 如果一个以singleTop模式启动的Activity的实例已经存在于任务栈的栈顶， 那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例， 并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。 </span><ul><li><span class="name">如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中， 那么再启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。 这时任务栈中还是这有一个A的实例。</span></li><li><span class="name">如果以singleTop模式启动的activity的一个实例已经存在与任务栈中，<b>但是不在栈顶</b>，那么它的行为和standard模式相同，也会创建多个实例。</span></li></ul></li><li><span class="name">singleTask: 只允许在系统中有一个Activity实例。如果系统中已经有了一个实例，不管它在不在栈顶, 持有这个实例的任务将移动到顶部，同时intent将被通过onNewIntent()发送。 如果没有，则会创建一个新的Activity并置放在合适的任务中。</span><ul><li><span class="name">singleTask相当于singleTop的彻底版.</span></li></ul></li><li><span class="name">singleInstance: 保证系统无论从哪个Task启动Activity都只会创建一个Activity实例, 并将它加入新的Task栈顶. 也就是说被该实例启动的其他activity会自动运行于另一个Task中。 当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例 的onNewIntent()方法，将Intent实例传递到该实例中。和singleTask相同， 同一时刻在系统中只会存在一个这样的Activity实例。</span></li></ul></li><li><span class="name">clearTaskOnLaunch: 清空栈</span><ul><li><span class="name">默认情况下, 当用户长时间离开Task（当前task被转移到后台）时，系统会清除task中栈底Activity外的所有Activity 。这样，当用户返回到Task时，只留下那个task最初始的Activity了。</span></li><li><span class="name">可通过修改 clearTaskOnLaunch 来改变这种行为. 其值域是: </span></li><li><span class="name">alwaysRetainTaskState: 如果栈底Activity的这个属性被设置为true，上述的情况就不会发生。 Task中的所有activity将被长时间保存。</span></li><li><span class="name">clearTaskOnLaunch: 如果栈底activity的这个属性被设置为true，一旦用户离开Task， 则 Task栈中的Activity将被清空到只剩下栈底activity。这种情况刚好与 alwaysRetainTaskState相反。即使用户只是短暂地离开，task也会返回到初始状态 （只剩下栈底acitivty）。</span></li><li><span class="name">finishOnTaskLaunch: 与clearTaskOnLaunch相似，但它只对单独的activity操 作，而不是整个Task。它可以结束任何Activity，包括栈底的Activity。 当它设置为true时，当前的Activity只在当前会话期间作为Task的一部分存在， 当用户退出Activity再返回时，它将不存在。</span></li></ul></li><li><span class="name">主要的Intent标志有：</span><ul><li><span class="name">FLAG_ACTIVITY_NEW_TASK: 放入新的task堆栈. 见上.</span></li><li><span class="name">FLAG_ACTIVITY_CLEAR_TOP</span></li><li><span class="name">FLAG_ACTIVITY_SINGLE_TOP</span></li></ul></li></ul></li><li><span class="name">注意: 当调用到 onNewIntent(intent)的时候，需要使用 setIntent(intent)赋值给Activity的Intent. 否则后续的 getIntent()都是得到老的Intent。</span></li></ul></li><li><span class="name">开源中国客户端Activity管理类 --还在哪里?</span><ul><li><span class="name">package net.oschina.app;</span></li><li><span class="name">import java.util.Stack;</span></li><li><span class="name">import android.app.Activity;</span></li><li><span class="name">import android.app.ActivityManager;</span></li><li><span class="name">import android.content.Context;</span></li><li><span class="name">public class AppManager {</span><ul><li><span class="name">private static Stack&lt;Activity&gt; activityStack;</span></li><li><span class="name">private static AppManager instance;</span></li><li><span class="name">private AppManager(){}</span></li><li><span class="name">/* 单一实例 */</span></li><li><span class="name">public static AppManager getAppManager(){</span><ul><li><span class="name">if(instance==null){</span><ul><li><span class="name">instance=new AppManager();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">return instance;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/**</span><ul><li><span class="name">添加Activity到堆栈</span></li><li><span class="name">*/</span></li></ul></li><li><span class="name">public void addActivity(Activity activity){</span><ul><li><span class="name">if(activityStack==null){</span><ul><li><span class="name">activityStack=new Stack&lt;Activity&gt;();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">activityStack.add(activity);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/* 获取当前Activity（堆栈中最后一个压入的） */</span></li><li><span class="name">public Activity currentActivity(){</span><ul><li><span class="name">Activity activity=activityStack.lastElement();</span></li><li><span class="name">return activity;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/* 结束当前Activity（堆栈中最后一个压入的） */</span></li><li><span class="name">public void finishActivity(){</span><ul><li><span class="name">Activity activity=activityStack.lastElement();</span></li><li><span class="name">finishActivity(activity);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/**</span><ul><li><span class="name">结束指定的Activity</span></li><li><span class="name">*/</span></li></ul></li><li><span class="name">public void finishActivity(Activity activity){</span><ul><li><span class="name">if(activity!=null){</span><ul><li><span class="name">activityStack.remove(activity);</span></li><li><span class="name">activity.finish();</span></li><li><span class="name">activity=null;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/* 结束指定类名的Activity */</span></li><li><span class="name">public void finishActivity(Class&lt;?&gt; cls){</span><ul><li><span class="name">for (Activity activity : activityStack) {</span><ul><li><span class="name">if(activity.getClass().equals(cls) ){</span><ul><li><span class="name">finishActivity(activity);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/* 结束所有Activity */</span></li><li><span class="name">public void finishAllActivity(){</span><ul><li><span class="name">for (int i = 0, size = activityStack.size(); i &lt; size; i++){</span><ul><li><span class="name">if (null != activityStack.get(i)){</span><ul><li><span class="name">activityStack.get(i).finish();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">activityStack.clear();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">/* 退出应用程序 */</span></li><li><span class="name">public void AppExit(Context context) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">finishAllActivity();</span></li><li><span class="name">ActivityManager activityMgr= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span></li><li><span class="name">activityMgr.restartPackage(context.getPackageName());</span></li><li><span class="name">System.exit(0);</span></li></ul></li><li><span class="name">} catch (Exception e) {&nbsp; &nbsp; }</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul>
  </body>
</html>