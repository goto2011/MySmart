<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">Python</span><ul><li><span class="name">代码组织方式</span><ul><li><span class="name">最小编程规范</span><ul><li><span class="name">模板名/文件名: 全小写，单词间用下划线分割.</span></li><li><span class="name">类名: 各单词首字母大写.</span></li><li><span class="name">方法名:第一个单词小写, 其它单词首字母大写; （Python之父推荐用这种：lower_with_under()）</span></li><li><span class="name">属性名:前缀m, 各单词首字母大写;</span></li><li><span class="name">局部变量:前缀my, 各单词首字母大写.</span></li><li><span class="name">适当的空格：变量命前空格，符号前后都不要加。使用空格要节制。</span></li><li><span class="name">适当的空行：类之间可空两行， 其它均空一行。</span></li></ul></li><li><span class="name">导入其它模块</span><ul><li><span class="name">通过 import + 文件名. 比如:&nbsp;import mymodule</span></li><li><span class="name">包括两种：py文件（Python写的）和sys文件（c写的）。</span></li></ul></li><li><span class="name">导入后如何调用函数?</span><ul><li><span class="name">mymodule.myFunc(params)</span></li></ul></li><li><span class="name">模块导入的搜索路径</span><ul><li><span class="name">在 sys.path 中维护路径.</span></li><li><span class="name">运行时可以新增路径，即：sys.path.append('/Volumes/Data/TensorFlow/abc/')，退出后该路径即不生效。</span></li></ul></li><li><span class="name">代码块定义</span><ul><li><span class="name">Python的核心特色就是通过缩进来表达代码的逻辑关系。</span></li><li><span class="name">代码块通过它们的缩进来定义的。 "代码块" 包括函数、if 语句、for 循环、while 循环, 等等。</span></li><li><span class="name">def myFunc(param):</span><ul><li><span class="name">if param&nbsp;&gt; 1:</span><ul><li><span class="name">return param&nbsp;* myFunc(param&nbsp;- 1)</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">return 1</span></li></ul></li></ul></li><li><span class="name">这是一个名为 myFunc&nbsp;的函数, 有一个参数 param。在函数内的所有代码都是缩进的。</span></li></ul></li><li><span class="name">模块执行入口</span><ul><li><span class="name">if __name__ == '__main__’:</span></li></ul></li></ul></li><li><span class="name">类和对象</span><ul><li><span class="name">“万物皆对象”：在Python中，变量是对象，字符串是对象，列表时对象，函数是对象，模块也是对象。但Python的对象定义比较松散。很多对象既没有属性没有方法，也不能子类化。</span></li><li><span class="name">申明类。注意，object是所有类的基类, 括号表示继承关系。</span><ul><li><span class="name">class MyClass(object):</span><ul><li><span class="name"># 构造方法。第一个参数是self。</span></li><li><span class="name">def __init__(self, room, cf=1.0):</span><ul><li><span class="name">self.room = room  # 引用属性，并赋值。</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.cf">self.cf</a> = cf</span></li></ul></li><li><span class="name"># 定义其它类方法</span></li><li><span class="name">def cacl_all(self, days=1):</span><ul><li><span class="name">return (self.room * <a class="contentLink" target="_blank" rel="noreferrer" href="http://self.cf">self.cf</a> + <a class="contentLink" target="_blank" rel="noreferrer" href="http://self.br">self.br</a>) * days</span></li></ul></li></ul></li></ul></li><li><span class="name">实例属性</span><ul><li><span class="name">self.room 即为对象属性, 实例化后一个对象一个. 在类方法中用&nbsp;self.room 引用.</span></li></ul></li><li><span class="name">类属性</span><ul><li><span class="name">在类内部,且在函数外定义的变量即为类属性. 为所有实例共享. 且可通过 类名.属性名 访问.&nbsp;</span></li></ul></li><li><span class="name">实例方法</span><ul><li><span class="name">def cacl_all(self, days=1):   # 注意: 第一个参数永远是 self.</span></li></ul></li><li><span class="name">类方法</span><ul><li><span class="name">类内以 <span class="contentTag" title="Filter @classmethod">@<span class="contentTagText">classmethod</span><span class="contentTagNub"></span></span> 定义的函数是类方法.</span></li><li><span class="name">第一个参数是本类的实例名. 可访问类属性和其它类方法, 并通过实例名访问实例属性和实例方法.</span></li></ul></li><li><span class="name">静态方法</span><ul><li><span class="name">类内以 <span class="contentTag" title="Filter @staticmethod">@<span class="contentTagText">staticmethod</span><span class="contentTagNub"></span></span> 定义的函数是静态方法.静态方法不能访问类的任何属性和方法. </span></li><li><span class="name">目的是为全局函数找个地方放, 和本类没关系. <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></li></ul></li><li><span class="name">调用类</span><ul><li><span class="name"># 定义类。注意初始化的方式。</span></li><li><span class="name">std_room = MyClass(200)</span></li><li><span class="name">big_room = MyClass(230, 0.9)</span></li><li><span class="name"># 调用类的方法</span></li><li><span class="name">print std_room.cacl_all()</span></li><li><span class="name">print big_room.cacl_all(3)</span></li></ul></li></ul></li><li><span class="name">Hello World！</span><ul><li><span class="name">helloworld.py中如下. 其中第一行是必须的.</span></li><li><span class="name">#!/usr/bin/python</span></li><li><span class="name">print 'Hello World'</span></li><li><span class="name">运行：使用命令行输入命令，python <a class="contentLink" target="_blank" rel="noreferrer" href="http://helloworld.py">helloworld.py</a>。</span></li></ul></li><li><span class="name">注释</span><ul><li><span class="name"># 号开始的行是注释，只影响本行。</span></li><li><span class="name">连续3个引号 """ 定义一个多行注释，截止也是3个引号。</span></li><li><span class="name">函数体最开始的注释为函数文档，可以被IDE、代码访问。文档和代码融为一体。</span><ul><li><span class="name">myFunc.__doc__ 即可打印myFunc的函数级注释。</span></li><li><span class="name">可通过关键字 help 访问函数文档, help(myFunc)</span></li></ul></li></ul></li><li><span class="name">log打印</span><ul><li><span class="name">Python内置了一个log模块logging。例如：</span></li><li><span class="name">import logging</span></li><li><span class="name">LOG_FILENAME="~/log.txt" //// 打印到文件</span></li><li><span class="name">logging.basicConfig(filename=LOG_FILENAME,level=<a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.INFO">logging.INFO</a>) //// 设置基准等级</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.info">logging.info</a>("This message should go to the log file") //// 按info等级打印。</span></li><li><span class="name">其中，有6级log打印级别，分别是 CRITICAL、ERROR、WARNING、INFO、DEBUG、NOTSET，默认为WARNING。</span></li></ul></li><li><span class="name">函数（传值、传址、传引用）</span><ul><li><span class="name">函数定义</span><ul><li><span class="name">def myFunc(params, spacing=10, collapse=1):</span><ul><li><span class="name">"""Build a connection string from a dictionary of parameters.</span></li><li><span class="name">Returns string."""</span></li><li><span class="name">return ";".join(["%s=%s" % (k, v) for k, v in params.items()])</span></li></ul></li><li><span class="name">其中：</span></li><li><span class="name">def：关键字，表示开始定义函数。</span></li><li><span class="name">myFunc：为函数名。<b>不需要定义返回值类型。</b></span></li><li><span class="name">params：参数，也不需要指定类型。spacing=10即参数默认值.</span></li></ul></li><li><span class="name">命名参数</span><ul><li><span class="name">Python支持命名参数. 命名参数的一个好处是代码可读性强，另一个好处参数不在依赖顺序，比如myFunc()这个函数，如果要指定 collapse（第三个）的值，同时第二个参数使用默认值：</span></li><li><span class="name">myFunc(sqlStrings, collapse=0)</span></li></ul></li><li><span class="name">参数默认值： 定义时给出指定值的参数. 调用时不赋值则使用默认值。</span></li><li><span class="name">传值、传址、传引用</span><ul><li><span class="name">Python不允许选择采用传值还是传址。</span></li><li><span class="name">Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传址的综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值, 相当于传址。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象, 相当于传值。</span></li><li><span class="name">传值的参数类型：数字，字符串，元组</span></li><li><span class="name">传址的参数类型：列表，字典</span></li></ul></li><li><span class="name">支持多返回值</span><ul><li><span class="name">Python支持多返回值.  这是最方便的地方了! <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></li><li><span class="name">import math</span></li><li><span class="name">def <b>move</b>(x, y, step, angle=0):</span><ul><li><span class="name">nx = x + step * math.cos(angle)</span></li><li><span class="name">ny = y - step * math.sin(angle)</span></li><li><span class="name">return nx, ny</span></li></ul></li><li><span class="name">x, y = <b>move</b>(100, 100, 60, math.pi / 6)   # 使用时这样做。</span></li><li><span class="name">对于调用方, 如果要忽略某个返回值, 可以用 _ 代替.</span></li><li><span class="name">实际上返回的是一个tuple。由于按Python的语法，多个变量可以同时接收一个tuple，按位置赋给对应的值。这样更简洁。</span></li></ul></li><li><span class="name">可变参数</span><ul><li><span class="name">参数表加 * 表示可变参数. 比如:</span></li><li><span class="name">def myFunc (* params):</span><ul><li><span class="name">len(params)       # 参数的数量</span></li><li><span class="name">print params[0]   # 第一个参数</span></li></ul></li><li><span class="name">可见, Python 把参数打包为一个元组.</span></li><li><span class="name">可变参数一般应该放在参数表的最后面. 如果不是这样, 则普通参数需要用命名参数方式. </span><ul><li><span class="name">def myFunc (* params, extra)</span></li><li><span class="name">使用时 myFunc(1, 2, 3, extra=4)</span></li></ul></li></ul></li><li><span class="name">函数递归</span><ul><li><span class="name">递归就是函数调用自身。</span></li><li><span class="name">Python对递归深度默认限制为最多1000层。</span></li><li><span class="name">可以自定义递归深度：</span></li><li><span class="name">import sys</span></li><li><span class="name">sys.setrecursionlimit(1000000) # 改为100万层</span></li></ul></li></ul></li><li><span class="name">整数&amp;布尔量&amp;枚举量</span><ul><li><span class="name">整数是int性的. 变量通过首次赋值产生. 整数就是: myParams = 5</span></li><li><span class="name">Python 整数支持无限大的整数.</span></li><li><span class="name">布尔量</span><ul><li><span class="name">True(1). 只有1是True, 其它值不是.</span></li><li><span class="name">False(0). 只有0是False, 其它值不是.</span></li></ul></li><li><span class="name">枚举量</span><ul><li><span class="name">导入enum模块; 用class关键字定义枚举，且继承Enum类。 如:</span></li><li><span class="name">from enum import Enum</span></li><li><span class="name">class MyEnmu(Enum):</span><ul><li><span class="name">red = 1</span></li><li><span class="name">orange = 2</span></li><li><span class="name">yellow = 3</span></li><li><span class="name">green = 4</span></li><li><span class="name">blue = 5</span></li><li><span class="name">indigo = 6</span></li><li><span class="name">purple = 7</span></li></ul></li><li><span class="name">使用时用:&nbsp;MyEnmu.red</span></li><li><span class="name">还可以这么用:&nbsp;print(MyEnmu(1)). 输出:&nbsp;MyEnmu.red</span></li></ul></li></ul></li><li><span class="name">浮点数</span><ul><li><span class="name">myParams = 5.5</span></li><li><span class="name">浮点数还有一种表达方式：科学计数法。352.3E-4，E标记表示10的幂，52.3E-4表示52.3 * 10-4。</span></li><li><span class="name">还有一种数，即复数. 用a+/-bj的方式定义, a和b皆为数字. 如: my = -5+4j</span><ul><li><span class="name">print my.real &nbsp;  # 打印复数的实部</span></li><li><span class="name">print my.imag &nbsp; # 打印复数的虚部</span></li></ul></li></ul></li><li><span class="name">常量&amp;全局变量&amp;静态变量</span><ul><li><span class="name">常量: python无此概念。5.5就是数字常量，‘123’就是字符串常量。</span></li><li><span class="name">全局变量</span><ul><li><span class="name">在类外定义的变量为全局变量, 全局可见, 直接读取.</span></li><li><span class="name">但是如果尝试改写全局变量, 则不会成功. Python会创建一个同名的局部变量, 修改的是该局部变量.</span></li><li><span class="name">如果一定要改写全局变量, 则要用 global 关键字申明.</span><ul><li><span class="name">count = 5</span></li><li><span class="name">def myFunc():</span><ul><li><span class="name">global count</span></li><li><span class="name">count = 10</span></li></ul></li></ul></li></ul></li><li><span class="name">静态变量:&nbsp;类内函数外定义的变量是类变量, 和静态变量的概念类似.</span></li></ul></li><li><span class="name">运算符表 (优先级递减)</span><ul><li><span class="name">正负号: +x, -x</span></li><li><span class="name">乘法、除法、取余数、取整数、幂运算: *, / ,%, //,&nbsp;&nbsp;**(返回x的y次幂, 如2**4 = 16)</span><ul><li><span class="name">其中: / 为普通除法. 两个整数相除, 可能得到一个浮点数.</span></li><li><span class="name">// 为地板除法, 比如 3//2 = 1, 3.0//2 == 1.0</span></li><li><span class="name">% 为取余数.</span></li></ul></li><li><span class="name">加法与减法: +, -</span></li><li><span class="name">移位: &lt;&lt;, &gt;&gt;</span></li><li><span class="name">按位与: &amp;</span></li><li><span class="name">按位异或: ^</span></li><li><span class="name">按位或: |</span></li><li><span class="name">比较: &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></li><li><span class="name">赋值: =, +=, -=, *=, /=, %=, **=, //==</span></li><li><span class="name">身份运算符: is, is not</span><ul><li><span class="name">is:&nbsp;判断两个标识符是不是引用自一个对象.&nbsp;x is y, 等价于 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False.</span></li><li><span class="name">is not: 和is相反.</span></li></ul></li><li><span class="name">成员运算符: in, not in</span><ul><li><span class="name">成员运算符负责测试集合中是否包括指定成员，支持的集合包括字符串，列表或元组。</span></li><li><span class="name">in:&nbsp;如果在集合中找到值返回 True，否则返回 False。如:</span><ul><li><span class="name">a = 10</span></li><li><span class="name">myList = [1, 2, 3, 4, 5]</span></li><li><span class="name">if ( a in myList&nbsp;):</span><ul><li><span class="name">print&nbsp;“找到了”</span></li></ul></li></ul></li><li><span class="name">not in: 与in相反.</span></li></ul></li><li><span class="name">逻辑运算符: not, and, or</span></li><li><span class="name">Lambda 表达式</span><ul><li><span class="name">Lambda表达式类似于c中的宏定义函数, 它定义了一个匿名函数，有参数, 函数体和返回值。使用时直接传入参数即可. 适合简单运算的函数.</span></li><li><span class="name">定义时，冒号左边是参数，右边是返回值。</span></li><li><span class="name">func=<b>lambda </b>x:x+1</span></li><li><span class="name">print(func(1)) &nbsp;# 返回2</span></li><li><span class="name">其作用在于：</span><ul><li><span class="name">不需要考虑函数命名。大型项目中函数命名是一个很大的负担。</span></li><li><span class="name">函数做参数时可直接在调用处定义，简洁，可读性强。</span></li></ul></li></ul></li><li><span class="name"><b>和 Lambda 表达式配合的3大内置函数：filter、map, reduce</b></span><ul><li><span class="name">filter</span><ul><li><span class="name">filter(function, iterable)</span></li><li><span class="name">两个参数: 第一个可以是None, 也可以是函数, 指定过滤方法. 第二个是个序列, 指定过滤对象. </span></li><li><span class="name">如果第一个参数是None, 则直接把第二个参数中为True或1的值筛选出来, 放在一个序列中返回.</span></li><li><span class="name">如果第二个参数是函数, 则把第二个参数中的每个元素作为函数的参数进行运行, 结果为True或1 的值筛选出来, 放在一个序列中返回.</span></li><li><span class="name">myList = filter(<b>lambda x : x </b>% 2 == 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])   # 过滤出列表中的所有奇数</span></li><li><span class="name">==&gt;[1, 3, 5, 7, 9]</span></li></ul></li><li><span class="name">map</span><ul><li><span class="name">map(function, iterable, ...)</span></li><li><span class="name">两个参数： 第一个是函数；第二个是一个或可迭代序列。</span></li><li><span class="name">功能是将序列的每一个元素作为函数的入参进行调用，然后把返回值放在一个序列中返回。</span></li><li><span class="name">map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 计算平方数</span></li><li><span class="name">==&gt;[1, 4, 9, 16, 25]</span></li><li><span class="name">map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])  # 两个列表，对相同位置的列表数据进行相加</span></li><li><span class="name">==&gt;[3, 7, 11, 15, 19]</span></li></ul></li><li><span class="name">reduce</span><ul><li><span class="name">reduce(function, iterable[, initializer])</span><ul><li><span class="name">function -- 函数，必须有两个参数</span></li><li><span class="name">iterable -- 可迭代对象</span></li><li><span class="name">initializer -- 可选，初始参数</span></li></ul></li><li><span class="name">对参数序列中元素进行挨个累积。</span></li><li><span class="name">reduce(lambda x, y: x+y, [1,2,3,4,5])  ？# 求和</span></li><li><span class="name">==&gt; 15</span></li></ul></li></ul></li><li><span class="name">三元运算符: exp1 if exp2 else exp3</span><ul><li><span class="name">exp2 == True, 则返回 exp1, 否则返回 exp3.</span></li></ul></li></ul></li><li><span class="name">内嵌函数(内部函数) 和闭包</span><ul><li><span class="name">在函数内部可定义另外一个函数. 该函数叫内嵌函数. </span></li><li><span class="name">内嵌函数仅可被宿主函数调用. </span></li><li><span class="name">闭包 (closure)</span><ul><li><span class="name">如果在一个内部函数中, 对在外部作用域(但不是在全局作用域) 的变量进行应用, 那么此内部函数被视为闭包. 例如:</span></li><li><span class="name">def out(x):</span><ul><li><span class="name">def in(y):</span><ul><li><span class="name">return x+y</span></li></ul></li><li><span class="name">return in  # 外部函数把内部函数作为返回值.</span></li></ul></li><li><span class="name">外部使用时用这种格式: out(8)(5)   ==&gt; 13</span></li></ul></li><li><span class="name">闭包主要用于装饰模式.</span></li></ul></li><li><span class="name">对象判空</span><ul><li><span class="name">对象判空</span><ul><li><span class="name">if <b>any</b>(myObject): &nbsp;#&nbsp;myObject为空则返回true.&nbsp;</span></li></ul></li><li><span class="name">list判空</span><ul><li><span class="name">if len(myList): &nbsp;# myList 不为空则返回true.</span></li></ul></li></ul></li><li><span class="name">对象的元属性</span><ul><li><span class="name">type 函数返回任意对象的数据类型</span><ul><li><span class="name">&gt;&gt;&gt; type(1)</span><ul><li><span class="name">&lt;type 'int’&gt;</span></li></ul></li><li><span class="name">&gt;&gt;&gt; myList = [ ]</span></li><li><span class="name">&gt;&gt;&gt; type(myList)</span><ul><li><span class="name">&lt;type 'list’&gt;</span></li></ul></li><li><span class="name">&gt;&gt;&gt; import odbchelper</span></li><li><span class="name">&gt;&gt;&gt; type(odbchelper)</span><ul><li><span class="name">&lt;type 'module’&gt;</span></li></ul></li><li><span class="name">&gt;&gt;&gt; import types</span></li><li><span class="name">&gt;&gt;&gt; type(odbchelper) == types.ModuleType</span><ul><li><span class="name">True</span></li></ul></li></ul></li><li><span class="name">isinstance(A, objA) ，如果A是objA类型，则返回true。</span></li><li><span class="name">id(): 返回对象或变量的内存地址.</span><ul><li><span class="name">a=1</span></li><li><span class="name">print(id(a)) &nbsp;///&nbsp;&nbsp;&nbsp; &nbsp;11246696</span></li></ul></li><li><span class="name">列出类支持的方法: dir</span><ul><li><span class="name">比如 list类, 使用 dir(list)</span></li></ul></li></ul></li><li><span class="name">for &amp; while</span><ul><li><span class="name">python的 list 很强大， 所以一般情况下你并不需要for循环。</span></li><li><span class="name">循环一个list（当然有更简洁的方式）：</span><ul><li><span class="name">&gt;&gt;&gt; myList = ['a', 'b', 'e']</span></li><li><span class="name">&gt;&gt;&gt; for my in myList:</span></li><li><span class="name">print my</span></li></ul></li><li><span class="name">还有一种方式：</span><ul><li><span class="name">&gt;&gt;&gt; for my in range(len(myList)):</span></li><li><span class="name">print myList[my]</span></li></ul></li><li><span class="name">循环数字</span><ul><li><span class="name">&gt;&gt;&gt; for i in range(4):</span></li><li><span class="name">print i</span></li></ul></li><li><span class="name">遍历一个dictionary</span><ul><li><span class="name">&gt;&gt;&gt; import os</span></li><li><span class="name">&gt;&gt;&gt; for k, v in os.environ.items():</span></li><li><span class="name">print "%s=%s" % (k, v)</span></li><li><span class="name">输出:</span></li><li><span class="name">USERPROFILE=C:\Documents and Settings\mpilgrim</span></li><li><span class="name">OS=Windows_NT</span></li><li><span class="name">COMPUTERNAME=MPILGRIM</span></li><li><span class="name">USERNAME=mpilgrim</span></li><li><span class="name">其中：os.environ.items() 返回一个 tuple 的 list：[(key1, value1), (key2, value2), ...]。</span></li></ul></li><li><span class="name">while</span><ul><li><span class="name"><b>while</b> ii &lt; 100: </span><ul><li><span class="name">ii += 1</span></li><li><span class="name">if i &gt; 10:</span><ul><li><span class="name"><b>break</b></span></li></ul></li><li><span class="name">if ii%2 &gt; 0:</span><ul><li><span class="name"><b>continue</b></span></li></ul></li></ul></li></ul></li><li><span class="name">while ... else ... 结构</span><ul><li><span class="name">while count &lt; 5:</span><ul><li><span class="name">print count, " is  less than 5"</span></li><li><span class="name">count = count + 1</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">print count, " is not less than 5"</span></li></ul></li></ul></li></ul></li><li><span class="name">if &amp; swith</span><ul><li><span class="name">def fib(n):</span><ul><li><span class="name">if n &gt; 1:</span><ul><li><span class="name">return n * fib(n - 1)</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">print 'end of the line'</span></li></ul></li><li><span class="name">return 1</span></li></ul></li></ul></li><li><span class="name">字符串的使用</span><ul><li><span class="name">字符串定义</span><ul><li><span class="name">字符串可以使用单引号、双引号、三引号（'''）。</span></li><li><span class="name">其中单引号和双引号是同一个功能. 而三引号则可以定义多行字符串，且其间可以使用单引号和双引号。如：</span><ul><li><span class="name">uid = '''This is a multi-line string. This is the first line.</span></li><li><span class="name">"What's your name?," I asked.</span></li><li><span class="name">He said "Bond, James Bond."</span></li><li><span class="name">‘''</span></li></ul></li><li><span class="name">转移符\。当需要在字符串中使用引号时，需要使用转义符：\', \"</span></li><li><span class="name">自然字符串。一般用于正则表达式和文件路径。前面加r。比如：r'\1’。</span></li><li><span class="name">字符串判空:&nbsp;len(myStr)==0</span></li></ul></li><li><span class="name">Unicode字符串</span><ul><li><span class="name">需要在字符串前加上前缀u或U。例如，u"This is a Unicode string."。</span></li></ul></li><li><span class="name">字符串转化</span><ul><li><span class="name">int(str): 将符合整数规定的字符串转换成int型</span></li><li><span class="name">float(str): 将符合浮点型规定的字符串转换成float型</span></li><li><span class="name">str(num): 将整数、浮点型转换成字符串型的</span></li></ul></li><li><span class="name">取长: len(myStr)</span></li><li><span class="name">去空格</span><ul><li><span class="name">去两边空格：myStr.strip()</span></li><li><span class="name">去左空格：myStr.lstrip()</span></li><li><span class="name">去右空格：myStr.rstrip()</span></li></ul></li><li><span class="name">字符串连接</span><ul><li><span class="name">用 + 运算符. 如:  “Hello” +&nbsp;“world!"</span></li><li><span class="name">用join合并多个字符串</span><ul><li><span class="name">&gt;&gt;&gt; myDict = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret”}</span></li><li><span class="name">print ";".join(["%s=%s" % (k, v) for k, v in myDict.items()])</span></li><li><span class="name">==&gt; 'server=mpilgrim;uid=sa;database=master;pwd=secret’</span></li></ul></li><li><span class="name">join 比 + 性能高, 因为+会引起内存复制和GC.</span></li><li><span class="name">避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象。替代方案是将每个子串加入列表, 然后在循环结束后用&nbsp;.join&nbsp;连接列表。</span></li></ul></li><li><span class="name">字符串截取</span><ul><li><span class="name">myStr = "abcdef"</span></li><li><span class="name">myStr2&nbsp;= myStr<b>[1:2]  </b>&nbsp;#&nbsp;myStr2是myStr从下标1开始，到2结束的连续子串。</span></li><li><span class="name">获取固定长度，右对齐，左边不够用空格补齐： myStr.rjust(width)</span></li><li><span class="name">获取固定长度，左对齐，右边不够用空格补齐： myStr.ljust(width)</span></li><li><span class="name">获取固定长度，中间对齐，两边不够用空格补齐： .center(width)</span></li><li><span class="name">获取固定长度，右对齐，左边不足用0补齐： myStr.myStrzfill(width)</span></li></ul></li><li><span class="name">字符串比较</span><ul><li><span class="name">使用 is equal 或 == 操作符比较字符串, 使用例如 &gt;= 或 &lt; 的运算符来确定几个字符串的排列顺序。</span><ul><li><span class="name">if myStr1 == myStr2:</span></li></ul></li><li><span class="name">是否以start开头：myStr.startswith('start')</span></li><li><span class="name">是否以end结尾：myStr.endswith('end’)</span></li><li><span class="name">是否全为字母或数字：myStr.isalnum()</span></li><li><span class="name">是否全字母：myStr.isalpha()</span></li><li><span class="name">是否全数字：myStr.isdigit()</span></li><li><span class="name">是否全小写：myStr.islower()</span></li><li><span class="name">是否全大写：myStr.isupper()</span></li></ul></li><li><span class="name">字符串查找</span><ul><li><span class="name">搜索指定字符串，没有返回-1：myStr.find('t')</span></li><li><span class="name">指定起始位置搜索：myStr.find('t',start)</span></li><li><span class="name">指定起始及结束位置搜索：myStr.find('t',start,end)</span></li><li><span class="name">从右边开始查找：myStr.rfind('t')</span></li><li><span class="name">搜索到多少个指定字符串：myStr.count('t’)</span></li><li><span class="name">上面所有方法都可用 myStr.index 代替，不同的是使用index查找不到会抛异常，而find返回-1.</span></li></ul></li><li><span class="name">字符串替换</span><ul><li><span class="name">替换old为new: myStr.replace('old','new')</span></li><li><span class="name">指定替换次数：myStr.replace('old’, 'new’, 5) &nbsp;# 最多替换5次</span></li></ul></li><li><span class="name">字符串切分</span><ul><li><span class="name">myStr&nbsp;= 'server=mpilgrim;uid=sa;database=master;pwd=secret'</span></li><li><span class="name">&gt;&gt;&gt; myStr.split(";")</span></li><li><span class="name">返回: ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']</span></li><li><span class="name">split() 指定的分隔符可以是字符，也可以是子串.</span></li></ul></li><li><span class="name">格式转化</span><ul><li><span class="name">字符串格式化使用与 C 中 sprintf 函数类似的语法.</span></li><li><span class="name">&gt;&gt;&gt; myStr1&nbsp;= "uid"</span></li><li><span class="name">&gt;&gt;&gt; myStr2&nbsp;= "sa"</span></li><li><span class="name">&gt;&gt;&gt; "%s=%s" % (myStr1, myStr2)</span></li><li><span class="name">其中: %s 为占位符, 引号外的 % 为分隔符.</span></li><li><span class="name">占位符有如下格式:</span><ul><li><span class="name">%d，%i	转换为带符号的十进制形式的整数</span></li><li><span class="name">%o	转换为带符号的八进制形式的整数</span></li><li><span class="name">%x，%X	转换为带符号的十六进制形式的整数</span></li><li><span class="name">%e	转化为科学计数法表示的浮点数（e 小写）</span></li><li><span class="name">%E	转化为科学计数法表示的浮点数（E 大写）</span></li><li><span class="name">%f，%F	转化为十进制形式的浮点数</span></li><li><span class="name">%g	智能选择使用 %f 或 %e 格式</span></li><li><span class="name">%G	智能选择使用 %F 或 %E 格式</span></li><li><span class="name">%c	格式化字符及其&nbsp;ASCII&nbsp;码</span></li><li><span class="name">%r	使用 repr() 将变量或表达式转换为字符串</span></li><li><span class="name">%s	使用 str() 将变量或表达式转换为字符串</span></li></ul></li><li><span class="name">占位符还有规定缩进对齐的功能. 放在%和后面的字母之间:</span><ul><li><span class="name">默认是右对齐. </span></li><li><span class="name">-：指定左对齐。</span></li><li><span class="name">+：表示数值总要带着符号（正数带“+”，负数带“-”）。</span></li><li><span class="name">0：表示不补充空格，而是补充 0。</span></li><li><span class="name">数字: 表示位数.</span></li><li><span class="name">以上可以同时出现. 比如 %-6s, %-06d, %+4.2f (带正负号, 4位整数, 2位小数)</span></li></ul></li></ul></li><li><span class="name">大小写转换</span><ul><li><span class="name">全部大写：myStr.upper()</span></li><li><span class="name">全部小写：myStr.lower()</span></li><li><span class="name">大小写互换：myStr.swapcase()</span></li><li><span class="name">首字母大写：myStr.title()</span></li><li><span class="name">首字母大写，其余小写：myStr.capitalize()</span></li></ul></li></ul></li><li><span class="name">对时间的处理</span><ul><li><span class="name">import time, datetime</span></li><li><span class="name">获取系统时间</span><ul><li><span class="name">time.time() &nbsp; # 返回从1970年1月1日0点到现在的秒数(用浮点数表示)，用的是UTC时间。</span></li><li><span class="name">time.localtime()</span></li></ul></li><li><span class="name">时间到字符串</span><ul><li><span class="name">strftime() &nbsp;# 用来将时间格式化成字符串.如:</span><ul><li><span class="name">print time.strftime("%Y-%m-%d %X", "2011-09-28 10:00:00”)&nbsp;# 第二个参数是系统可识别的时间字符串.&nbsp;“可识别"这个概念就有一定的灰度了.</span></li></ul></li><li><span class="name">如果需要对时间做计算, 一般把时间转化为&nbsp;struct_time 结构，然后再转化为epoch时间(即秒数), 这是个数字 比较方便计算。</span></li><li><span class="name">time.gmtime(t) &nbsp; &nbsp;#&nbsp;用UTC时间转为struct_time结构.如果不传参数, 则time.time()取系统当前时间.</span></li><li><span class="name">time.localtime(t) # 和上面同. 但使用本地时区调整过.</span></li><li><span class="name">calendar.timegm() # 把UTC的struct_time(gmtime的返回对象)转为从epoch开始的秒数</span></li><li><span class="name">time.mktime() # 把用时区调整过的struct_time(即localtime的返回对象)对象转为从epoch开始的秒数</span></li></ul></li><li><span class="name">字符串到时间</span><ul><li><span class="name">time.strptime() &nbsp;#&nbsp;将字符串解析成时间如:</span><ul><li><span class="name">myTime = time.strptime("2009-08-08", "%Y - %m - %d”) &nbsp;# 返回struct_time对象</span></li></ul></li></ul></li><li><span class="name">strftime()和strptime()的format参数由如下占位符构成</span><ul><li><span class="name">%a 英文星期简写</span></li><li><span class="name">%A 英文星期的完全</span></li><li><span class="name">%b 英文月份的简写</span></li><li><span class="name">%B 英文月份的完全</span></li><li><span class="name">%c 显示本地日期时间</span></li><li><span class="name">%d 日期，取1-31</span></li><li><span class="name">%H 小时， 0-23</span></li><li><span class="name">%I 小时， 0-12</span></li><li><span class="name">%m 月， 01 -12</span></li><li><span class="name">%M 分钟，1-59</span></li><li><span class="name">%j 年中当天的天数</span></li><li><span class="name">%w 显示今天是星期几</span></li><li><span class="name">%W 第几周</span></li><li><span class="name">%x 当天日期</span></li><li><span class="name">%X 本地的当天时间</span></li><li><span class="name">%y 年份 00-99间</span></li><li><span class="name">%Y 年份的完整拼写</span></li></ul></li><li><span class="name">其它函数</span><ul><li><span class="name">time.asctime():&nbsp;将一个struct_time对象转为标准24字符的字符串，如:</span><ul><li><span class="name">Sun Jun 20 23:21:05 1993</span></li></ul></li><li><span class="name">time.ctime(): 将一个秒数转化为标准24字符的字符串, 如上.</span></li></ul></li><li><span class="name">延迟</span><ul><li><span class="name">time.sleep(1)  # 单位是秒。0.1秒则代表100毫秒。</span></li></ul></li></ul></li><li><span class="name">内存管理</span><ul><li><span class="name">import gc</span></li><li><span class="name">python 不需要做内存管理. 但理解内存模式还是很有价值的. Python提供如下函数帮助我们理解:</span></li><li><span class="name">id(my) &nbsp;# my是一个对象, id()返回它的内存地址.</span></li><li><span class="name">使用sys包中的getrefcount()，来查看某个对象的引用计数。注意,&nbsp;getrefcount()所得到的结果，会比期望的多1。因为它自己也会创建一次应用.</span></li><li><span class="name">globals(): 获取保存所有全局变量的词典. Python用统一的字典维护所有的全局变量.</span></li><li><span class="name">容器对象的引用可能构成很复杂的拓扑结构。我们可以用 objgraph包 来绘制其引用关系，比如:</span><ul><li><span class="name">import objgraph</span></li><li><span class="name">objgraph.show_refs([z], filename='ref_topo.png’)</span></li><li><span class="name">objgraph是Python的一个第三方包。安装之前需要安装xdot。 参见:&nbsp;<a class="contentLink" target="_blank" rel="noreferrer" href="http://mg.pov.lt/objgraph/">http://mg.pov.lt/objgraph/</a></span></li></ul></li><li><span class="name">垃圾回收机制</span><ul><li><span class="name">当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。</span></li><li><span class="name">但是减肥是个昂贵而费力的事情。Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</span></li><li><span class="name">通过gc模块的get_threshold()方法，查看该阈值:</span><ul><li><span class="name">print(gc.get_threshold())</span></li><li><span class="name">返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</span></li></ul></li><li><span class="name">我们也可以手动启动垃圾回收，即使用gc.collect()。</span></li><li><span class="name">Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</span></li><li><span class="name">Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</span></li><li><span class="name">这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</span></li><li><span class="name">同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</span><ul><li><span class="name">gc.set_threshold(700, 10, 5)</span></li></ul></li></ul></li></ul></li><li><span class="name">文件</span><ul><li><span class="name">Python 文件文件夹方法参见： <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.runoob.com/python/os-file-methods.html">https://www.runoob.com/python/os-file-methods.html</a></span></li><li><span class="name">Python 文件方法参见： <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.runoob.com/python/file-methods.html">https://www.runoob.com/python/file-methods.html</a></span></li><li><span class="name">获取路径分隔符： os.sep</span><ul><li><span class="name">Windows上是'\'</span></li><li><span class="name">Linux上是'/'</span></li></ul></li><li><span class="name">获取行终止符： os.linesp</span><ul><li><span class="name">Windows使用 '\r\n'</span></li><li><span class="name">Linux使用 '\n'</span></li><li><span class="name">Mac使用 '\r'</span></li></ul></li><li><span class="name">获取特定目录</span><ul><li><span class="name">返回当前目录：os.getcwd()</span></li><li><span class="name">返回上一级目录：os.chdir("..")</span></li></ul></li><li><span class="name">文件夹和文件的存在性</span><ul><li><span class="name">是否存在：os.path.exists()</span></li><li><span class="name">是否为文件：os.path.isfile()</span></li><li><span class="name">是否为目录：os.path.isdir()</span></li></ul></li><li><span class="name">文件夹的新建和删除</span><ul><li><span class="name">新建单级目录：os.mkdir(path)</span></li><li><span class="name">新建多级目录：os.makedirs(path)</span></li><li><span class="name">删除单层目录： os.rmdir(path). 要求是空目录</span></li><li><span class="name">删除多层目录：os.removedirs(path)， 递归删除目录和子目录，要求都是空目录。</span></li></ul></li><li><span class="name">文件夹和文件的遍历：</span><ul><li><span class="name">os.listdir(path)</span><ul><li><span class="name">返回指定文件夹包含的文件或子文件夹的名字的列表。这个列表以字母顺序，不包括 '.' 和'..' 。</span></li><li><span class="name">只支持在 Unix, Windows 下使用。</span></li><li><span class="name">myDirs = os.listdir("/var/www/html/")</span></li><li><span class="name">for file in myDirs:</span><ul><li><span class="name">print file</span></li></ul></li></ul></li><li><span class="name">os.walk(path)</span><ul><li><span class="name">os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</span><ul><li><span class="name"><b>topdown</b>&nbsp;--可选，为 True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。如果 topdown 参数为 True，walk 会遍历top文件夹，与top 文件夹中每一个子目录。</span></li><li><span class="name"><b>onerror</b>&nbsp;-- 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。</span></li><li><span class="name"><b>followlinks</b>&nbsp;-- 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。</span></li></ul></li><li><span class="name">返回指定文件夹包含的文件或子文件夹的名字的三元组。</span></li><li><span class="name">返回值格式是 (当前路径, [包含子目录], [包含文件]) 的元组。</span></li><li><span class="name">for root, dirs, files in os.walk(".", topdown=False):</span><ul><li><span class="name">for name in files:</span><ul><li><span class="name">print(os.path.join(root, name))</span></li></ul></li><li><span class="name">for name in dirs:</span><ul><li><span class="name">print(os.path.join(root, name))</span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name">文件的打开模式</span><ul><li><span class="name">‘r’&nbsp;&nbsp;&nbsp;&nbsp; 只读模式。如果文件不存在，返回异常FileNotFoundError, 默认值。</span></li><li><span class="name">‘w’&nbsp;&nbsp;&nbsp; 覆盖写模式，文件不存在则创建，存在则完全覆盖；</span></li><li><span class="name">'x'&nbsp;&nbsp;&nbsp;&nbsp; 创建写模式，文件不存在则创建，存在则返回异常FileExistError；</span></li><li><span class="name">‘a’&nbsp;&nbsp;&nbsp; 追加写模式，文件不存在则创建，存在则在文件最后追加内容；</span></li><li><span class="name">‘t’&nbsp;&nbsp;&nbsp;  文本文件模式，默认值；</span></li><li><span class="name">‘b’ &nbsp;&nbsp; 二进制文件模式；</span></li><li><span class="name">'+'&nbsp;&nbsp;&nbsp; 与r/w/x/a一同使用，在原功能的基础上增加同时读写的功能。</span></li></ul></li><li><span class="name">文件的读、写、新建</span><ul><li><span class="name">myFile = open('test.log', 'w')  </span></li><li><span class="name">myFile.seek(-128, 2)   # 参见后面解释</span></li><li><span class="name">myFile.write('test succeeded')</span></li><li><span class="name">myFile.close()</span></li><li><span class="name">file('test.log').read()    # 读出整个文件</span></li></ul></li><li><span class="name">遍历文件：<b>seek</b></span><ul><li><span class="name">seek(offset[,whence])，将文件读写操作标记移到offset的位置。</span></li><li><span class="name">第一个参数：offset一般是相对于文件的开头来计算的，一般为正数。</span></li><li><span class="name">第二个参数：whence参数，为0表示从头开始计算，1表示以当前位置开始计算。2表示以文件末尾为原点进行计算。</span></li><li><span class="name">需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span></li></ul></li><li><span class="name">文件的删除:&nbsp;os.remove()</span></li><li><span class="name">文件改名、修改属性:&nbsp;</span><ul><li><span class="name">os.rename("oldname","newname")   # 文件或目录都是使用这条命令</span></li></ul></li><li><span class="name">行读</span><ul><li><span class="name">myFile.<b>readline</b>([size])  # 读一行，如果定义了size，有可能返回的是一行的一部分</span></li><li><span class="name">myFile.<b>readlines</b>([size])  # 把文件每一行作为一个list的一个成员，并返回这个list。</span><ul><li><span class="name">其实它的内部是通过循环调用readline()来实现的。</span></li><li><span class="name">size指定读取内容的总长，给定size值则可能只读到文件的一部分。</span></li></ul></li></ul></li><li><span class="name">把整个文件读入列表中</span><ul><li><span class="name">myFile.seek(0,0)</span></li><li><span class="name">for eachLine in myFile:</span><ul><li><span class="name">print(eachLine)</span></li></ul></li></ul></li><li><span class="name">with…as  （推荐使用）</span><ul><li><span class="name">with open('nothing.txt','r') as f:</span><ul><li><span class="name">f.read()</span></li><li><span class="name">print 2/0</span></li></ul></li><li><span class="name">print 'continue'</span></li><li><span class="name">with语句块完毕之后，会隐含的自动关闭文件。避免在各异常分支都要关闭文件。</span></li></ul></li></ul></li><li><span class="name">类的进一步讨论</span><ul><li><span class="name">继承</span><ul><li><span class="name"># 父类</span></li><li><span class="name">class AddBook(object):</span><ul><li><span class="name">def __init__(self, name, phone):</span><ul><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.name">self.name</a> = name</span></li><li><span class="name">self.phone = phone</span></li></ul></li><li><span class="name">def get_phone(self):</span><ul><li><span class="name">return self.phone</span></li></ul></li></ul></li><li><span class="name"># 子类</span></li><li><span class="name">class EmplEmail(AddBook):</span><ul><li><span class="name">def __init__(self, nm, ph, email):</span><ul><li><span class="name"># AddBook.__init__(self, nm, ph) # 调用父类方法一</span></li><li><span class="name">super(EmplEmail, self).__init__(nm, ph) # 调用父类方法二</span></li><li><span class="name">self.email = email</span></li></ul></li><li><span class="name">def get_email(self):</span><ul><li><span class="name">return self.email</span></li></ul></li></ul></li><li><span class="name"># 调用</span></li><li><span class="name">if __name__ == "__main__":</span><ul><li><span class="name">Detian = AddBook('handetian', '18210413001')</span></li><li><span class="name">print Detian.get_phone()</span></li><li><span class="name">alice = EmplEmail('alice', '18210418888', '<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:alice@xkops.com">alice@xkops.com</a>')</span></li><li><span class="name">print alice.get_email(), alice.get_phone()</span></li></ul></li></ul></li><li><span class="name">组合</span><ul><li><span class="name"># A类</span></li><li><span class="name">class Info(object):</span><ul><li><span class="name">def __init__(self, phone, email):</span><ul><li><span class="name">self.phone = phone</span></li><li><span class="name">self.email = email</span></li></ul></li><li><span class="name">def get_phone(self):</span><ul><li><span class="name">return self.phone</span></li></ul></li><li><span class="name">def update_phone(self, newphone):</span><ul><li><span class="name">self.phone = newphone</span></li></ul></li></ul></li><li><span class="name"># B类。B包含A。</span></li><li><span class="name">class AddrBook(object):</span><ul><li><span class="name">def __init__(self, name, phone, email):</span><ul><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.name">self.name</a> = name</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.info">self.info</a> = Info(phone, email)</span></li></ul></li></ul></li><li><span class="name">if __name__ == "__main__":</span><ul><li><span class="name">Detian = AddrBook('handetian', '18210413001', '<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:detian@xkops.com">detian@xkops.com</a>', '123456')</span></li></ul></li></ul></li><li><span class="name">类的预置函数</span><ul><li><span class="name">__init__ 就是预置函数，前面已介绍了。其它还有：</span></li><li><span class="name">def __str__(self): &nbsp; &nbsp; &nbsp;# 打印对象时调用。</span></li><li><span class="name">def __repr__(self):&nbsp;&nbsp; &nbsp;&nbsp;# 和上面类似，但是是在交互执行的模式下打印。</span></li><li><span class="name">def __call__(self):&nbsp;&nbsp; &nbsp;&nbsp;# 这个有点特殊，定义后可以让对象象函数一样被调用。</span></li></ul></li><li><span class="name">对象的序列化</span><ul><li><span class="name">即把对象保存到文件，以及从文件中恢复的技术。</span></li><li><span class="name">import pickle</span></li><li><span class="name">myList = [1, 2, 3.14, "abc", [1, 2]]</span></li><li><span class="name">pickle_file = open("d:\\<a class="contentLink" target="_blank" rel="noreferrer" href="http://my.pk">my.pk</a>", 'wb')</span></li><li><span class="name">pickle.<b>dump</b>(myList, pickle_file)   # 把对象写入文件</span></li><li><span class="name">myList2 = pickle.<b>load</b>(pickle_file)   # 读取对象</span></li><li><span class="name">pickle_file.close()</span></li></ul></li></ul></li><li><span class="name">列表, list</span><ul><li><span class="name">定义数组</span><ul><li><span class="name">python中的数组叫list, list用 [] 来初始化。</span><ul><li><span class="name">&gt;&gt;&gt; myList = ["a", "b", "mpilgrim", "z", "example"], myList为一个5元素的list，每个元素都是个字符串。</span></li></ul></li><li><span class="name"><b>不同类型的元素可以放在同一个数组中。</b></span></li><li><span class="name">初始化之后, 就不可以改变元素的类型.</span></li><li><span class="name">空数组的初始化: myList = []</span></li></ul></li><li><span class="name"><b>range</b>函数</span><ul><li><span class="name">list的递增赋值:&nbsp;range(n) 会生成一个0 到 n-1 的list。</span></li><li><span class="name">range(start=0, stop[, step=1]): 计数从 start 开始, 到 stop 结束, 步长为 step.</span></li><li><span class="name">一个很酷的技巧是利用 range 和 tuple配合，生成枚举量。比如: (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7). 然后 MONDAY=0，TUESDAY=1.</span></li></ul></li><li><span class="name">遍历数组</span><ul><li><span class="name">通过下标取元素。下标可以是负值，表示从尾部取，最后一个元素的负下标是 -1.</span><ul><li><span class="name">&gt;&gt;&gt; myList[0]</span></li><li><span class="name">输出: ‘a’</span></li><li><span class="name">&gt;&gt;&gt; myList[-1]</span></li><li><span class="name">输出: 'example'</span></li></ul></li><li><span class="name">由值获取index</span><ul><li><span class="name">&gt;&gt;&gt; myList.index("example")</span></li><li><span class="name">输出: 5</span></li></ul></li><li><span class="name">判断元素的存在性:</span><ul><li><span class="name">&gt;&gt;&gt; "c" in&nbsp;myList</span></li><li><span class="name">输出: False</span></li></ul></li></ul></li><li><span class="name">数组的size:&nbsp;len(myList)</span></li><li><span class="name">元素增加</span><ul><li><span class="name">myList.<b>append</b>("new")   # 在最后位置添加。</span></li><li><span class="name">myList.<b>insert</b>(2, "new")   # 在指定位置添加</span></li></ul></li><li><span class="name">元素删除</span><ul><li><span class="name">有两种方式: </span></li><li><span class="name">第一种: <b>remove.</b></span><ul><li><span class="name">&gt;&gt;&gt; myList.<b>remove</b>("z")</span></li><li><span class="name">&gt;&gt;&gt;&nbsp;myList</span></li><li><span class="name">['a', 'b', 'new', 'mpilgrim']</span></li></ul></li><li><span class="name">注意：remove只删除第一次出现的元素。</span></li><li><span class="name">第二种,  用 <b>del </b>删除. </span><ul><li><span class="name"><b>del</b>&nbsp;myList[0] &nbsp;# 删除第一个元素</span></li><li><span class="name">del myList  # 删除整个列表</span></li></ul></li></ul></li><li><span class="name">pop: 弹出一个元素, 并返回该元素</span><ul><li><span class="name">&gt;&gt;&gt; myList.<b>pop</b>()</span></li><li><span class="name">'mpilgrim'</span></li><li><span class="name">&gt;&gt;&gt;&nbsp;myList</span></li><li><span class="name">['a', 'b', 'new’]</span></li><li><span class="name">也可以指定index, 比如: pop(2)  # 弹出第三个元素</span></li></ul></li><li><span class="name">两个数组的连接</span><ul><li><span class="name">myList.<b>extend</b>(["two", "elements"])</span></li><li><span class="name">注意：["two", "elements"] 为一个新的list。</span></li></ul></li><li><span class="name">数组的分片</span><ul><li><span class="name">数组的分片指返回当前list的子集, 也是一个list.</span></li><li><span class="name"><b> [m:n] </b>表示从头数第m个元素到第n个元素的分片（从0开始计数, 不包括n），负数表示从后面往前算. </span><ul><li><span class="name">&gt;&gt;&gt;&nbsp;myList</span></li><li><span class="name">['a', 'b', 'mpilgrim', 'z', 'example’] &nbsp;# 整体</span></li><li><span class="name">&gt;&gt;&gt; myList[0:3]</span></li><li><span class="name">['a', 'b', ‘mpilgrim']</span></li><li><span class="name">&gt;&gt;&gt; myList[1:-1]</span></li><li><span class="name">['b', 'mpilgrim', 'z']</span></li></ul></li><li><span class="name">[:2]   # 等价于[0:2]</span></li><li><span class="name">[2:]   # 等价于[2:最后一个]</span></li><li><span class="name">[0:9:2]  # 第三个参数表示步长, 2 表示每两个取一个. 如果步长是负数, 则从后面向前取</span></li><li><span class="name">[::-1]  # 相当于取到一个反转的列表.</span></li></ul></li></ul></li><li><span class="name">元组, tuple</span><ul><li><span class="name">元组也是属于序列的一种，但是元组恰恰和列表相反，元组是不可变的，即定义之后，不能再改变元素。</span></li><li><span class="name">创建元组使用小括号.</span></li><li><span class="name">&gt;&gt;&gt; myTuple&nbsp;= ("a", "b", "mpilgrim", "z", "example")</span></li><li><span class="name">&gt;&gt;&gt; myTuple[0]</span></li><li><span class="name">'a'</span></li><li><span class="name">&gt;&gt;&gt; myTuple[-1]</span></li><li><span class="name">'example'</span></li><li><span class="name">&gt;&gt;&gt; myTuple[1:3]</span></li><li><span class="name">('b', 'mpilgrim')</span></li></ul></li><li><span class="name">序列</span><ul><li><span class="name">python内建了6种序列：列表、元组、字符串、unicode字符串、buffer对象、xrange对象。</span></li><li><span class="name">所有序列都可以进行某些特定的操作：索引、分片、加、乘、检查某个元素是否属于序列的成员（成员资格）、内建函数（长度、最小值、最大值）, 以及迭代。</span></li><li><span class="name">索引</span><ul><li><span class="name">序列中所有元素都是有下标的. 从0开始，可通过下标进行访问。</span></li><li><span class="name">通过情况下下标为正数，但是python中也可以为负数，代表从右开始计数。若为负数时，开头第一位数为-1，而不是0，这样避免了与从左开始的第一个元素重合。</span></li></ul></li><li><span class="name">分片</span><ul><li><span class="name">即取序列的一部分. 通过指定起止下标来获取序列的子集.</span></li><li><span class="name">和索引一样, 分片时也允许负数. 而且有多种简写形式.</span></li><li><span class="name">numbers=[1,2,3,4,5,6,7,8,9,10]</span></li><li><span class="name">numbers[3:6]</span></li><li><span class="name">numbers[0:1]</span></li><li><span class="name">numbers[-5:-1]</span></li><li><span class="name">numbers[-11:0]</span></li><li><span class="name">numbers[-3:]</span></li><li><span class="name">numbers[:3]</span></li><li><span class="name">numbers[:]</span></li><li><span class="name">分片时还可以指定步长，步长通常不指定，取其默认值1. 如果设置则会按照步长来遍历序列中的元素。</span></li></ul></li><li><span class="name">序列相加</span><ul><li><span class="name">使用+运算符进行序列的连接操作.</span></li><li><span class="name">同一类型可以进行连接，不然会抛出异常。</span></li></ul></li><li><span class="name">成员资格</span><ul><li><span class="name">成员资格即检查当前元素是否在当前序列中。若存在，返回true，否则返回false。</span></li><li><span class="name">str='python'</span></li><li><span class="name">'p' in str  ==&gt; true</span></li></ul></li><li><span class="name">长度、最小值和最大值</span><ul><li><span class="name">最大：max</span></li><li><span class="name">长度：len</span></li><li><span class="name">最小：min</span></li></ul></li><li><span class="name">迭代</span></li></ul></li><li><span class="name">Dict（字典，hash表）</span><ul><li><span class="name">hash表的特点是基于key字符串存取数据。</span></li><li><span class="name">Python中的hash表即dictionary，字典。它的特点是<b>key</b>除了字符串之外，还可以是任何对象，包括整数。</span></li><li><span class="name">字典是Python支持的唯一的映射类型。</span></li><li><span class="name">dict的定义</span><ul><li><span class="name">myDict = {}    # 定义一个空字典</span></li><li><span class="name">myDict = {"server":"mpilgrim", "database":"master"}    # 定义一个有两个元素的字典</span></li><li><span class="name">myDict = dict(Fs=70, ii=105, s=115)  # 注意key不要加引号。这种方式比较自然。</span></li><li><span class="name">其中：定义dictionary 使用 {}，key-value 对用逗号分隔；前面为key，后面为value。</span></li><li><span class="name">key 不可重复（大小写敏感）, value 可重复。</span></li><li><span class="name">dict 中的元素是无序的。</span></li></ul></li><li><span class="name">dict的size: len(myDict)</span></li><li><span class="name">dict的遍历</span><ul><li><span class="name">通过key 访问 value，反过来不行。</span></li><li><span class="name">dictionary 的 keys, values 和 items 函数，输出为list。</span></li><li><span class="name">myDict.<b>keys</b>()  ==&gt; ['server', 'database']    # 返回所有key的列表</span></li><li><span class="name">myDict.<b>values</b>() ==&gt;['mpilgrim', 'master']     # 返回所有value的列表</span></li><li><span class="name">myDict.<b>items</b>() ==&gt;[('server', 'mpilgrim'), ('database', 'master')]  # 返回一个形如 (key, value) 的 tuple 的 list。</span></li><li><span class="name">["%s=%s" % (k, v) for k, v in myDict.<b>items</b>()]  ==&gt;['server=mpilgrim', 'database=master']</span></li><li><span class="name">myDict.<b>get</b>(key, default=None)   # 返回指定键的值。如果值不在字典中则返回default值</span></li><li><span class="name">myDict.<b>setdefault</b>(key, default=None)   # 返回指定键的值。如果键不存在于字典中，将会添加键并将值设为default</span></li><li><span class="name">myDict.<b>has_key</b>(key)  # 如果键在字典dict里返回true，否则返回false</span></li></ul></li><li><span class="name">dict成员的修改、新增、删除</span><ul><li><span class="name">修改和新增</span><ul><li><span class="name">myDict = {}</span></li><li><span class="name">myDict["key1"] = "value"   # 新增</span></li><li><span class="name">myDict["key1"] = "value2"   # 修改值</span></li><li><span class="name">myDict[42] = "value3"  # 新增。注意, 42是个key, 而不是下标.</span></li><li><span class="name">myDict.update(42="狗")     # 更新指定key的值。</span></li><li><span class="name">myDict ==&gt; {'key1': 'value2', 42: '狗'}</span></li></ul></li><li><span class="name">删除</span><ul><li><span class="name">del myDict[42]    # 按key删除</span></li><li><span class="name">del myDict["retrycount"]   # 按key删除</span></li><li><span class="name">myDict.clear()    # 删除所有</span></li></ul></li><li><span class="name">弹出</span><ul><li><span class="name">myDict.<b>pop</b>(key[,default])   # 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。如果key不存在，则返回default</span></li><li><span class="name">myDict.<b>popitem</b>()  # 返回并删除字典中的最后一对键和值</span></li></ul></li></ul></li><li><span class="name">dict 复制</span><ul><li><span class="name">myDict.<b>copy</b>()  # 返回字典的浅复制。</span></li></ul></li></ul></li><li><span class="name">集合，Set</span><ul><li><span class="name">集合在Python中用处不大，主要用于去掉重复值。</span></li><li><span class="name">使用多个量来定义集合，最终集合中只留下非重复的值。</span></li><li><span class="name">mySet = {1, 2, 3, 1, 2, 3}</span></li><li><span class="name">mySet ==&gt; {1, 2, 3}</span></li><li><span class="name">所以要去掉列表中的重复值，可以这样： myList = list(set(myList))</span></li></ul></li><li><span class="name">异常处理</span><ul><li><span class="name">异常处理的关键字是 try，except，else，finally。如：</span></li><li><span class="name">myStr = 'Hello girl!'</span></li><li><span class="name">try:</span><ul><li><span class="name">print myStr[100]</span></li></ul></li><li><span class="name">except IndexError:   # 指定捕捉这种异常。如果不指定，则捕捉任何异常。可以跟多个异常。</span><ul><li><span class="name">print 'IndexError error'</span></li></ul></li><li><span class="name">finally:</span><ul><li><span class="name">print 'error handled'  # 无论异常发生与否，finally中的语句都要执行。</span></li></ul></li><li><span class="name">print 'continue'   # 异常处理完，继续执行下面的代码。</span></li><li><span class="name">使用 raise 语句可主动触发异常。</span></li><li><span class="name">Python内置的异常种类</span><ul><li><span class="name">BaseException&nbsp; # 所有异常的基类</span><ul><li><span class="name">+-- SystemExit&nbsp; # 解释器请求退出</span></li><li><span class="name">+-- KeyboardInterrupt&nbsp; # 用户中断执行(通常是输入^C)</span></li><li><span class="name">+-- GeneratorExit&nbsp; # 生成器(generator)发生异常来通知退出</span></li><li><span class="name">+-- Exception&nbsp; # 常规异常的基类</span><ul><li><span class="name">+-- StopIteration&nbsp; # 迭代器没有更多的值</span></li><li><span class="name">+-- StopAsyncIteration&nbsp; # 必须通过异步迭代器对象的__anext__()方法引发以停止迭代</span></li><li><span class="name">+-- ArithmeticError&nbsp; # 各种算术错误引发的内置异常的基类</span></li><li><span class="name">|&nbsp; &nbsp; +-- FloatingPointError&nbsp; # 浮点计算错误</span></li><li><span class="name">|&nbsp; &nbsp; +-- OverflowError&nbsp; # 数值运算结果太大无法表示</span></li><li><span class="name">|&nbsp; &nbsp; +-- ZeroDivisionError&nbsp; # 除(或取模)零 (所有数据类型)</span></li><li><span class="name">+-- AssertionError&nbsp; # 当assert语句失败时引发</span></li><li><span class="name">+-- AttributeError&nbsp; # 属性引用或赋值失败</span></li><li><span class="name">+-- BufferError&nbsp; # 无法执行与缓冲区相关的操作时引发</span></li><li><span class="name">+-- EOFError&nbsp; # 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发</span></li><li><span class="name">+-- ImportError&nbsp; # 导入模块/对象失败</span></li><li><span class="name">|&nbsp; &nbsp; +-- ModuleNotFoundError&nbsp; # 无法找到模块或在在sys.modules中找到None</span></li><li><span class="name">+-- LookupError&nbsp; # 映射或序列上使用的键或索引无效时引发的异常的基类</span></li><li><span class="name">|&nbsp; &nbsp; +-- IndexError&nbsp; # 序列中没有此索引(index)</span></li><li><span class="name">|&nbsp; &nbsp; +-- KeyError&nbsp; # 映射中没有这个键</span></li><li><span class="name">+-- MemoryError&nbsp; # 内存溢出错误(对于Python 解释器不是致命的)</span></li><li><span class="name">+-- NameError&nbsp; # 未声明/初始化对象 (没有属性)</span></li><li><span class="name">|&nbsp; &nbsp; +-- UnboundLocalError&nbsp; # 访问未初始化的本地变量</span></li><li><span class="name">+-- OSError&nbsp; # 操作系统错误，EnvironmentError，IOError，WindowsError，socket.error，select.error和mmap.error已合并到OSError中，构造函数可能返回子类</span></li><li><span class="name">|&nbsp; &nbsp; +-- BlockingIOError&nbsp; # 操作将阻塞对象(e.g. socket)设置为非阻塞操作</span></li><li><span class="name">|&nbsp; &nbsp; +-- ChildProcessError&nbsp; # 在子进程上的操作失败</span></li><li><span class="name">|&nbsp; &nbsp; +-- ConnectionError&nbsp; # 与连接相关的异常的基类</span></li><li><span class="name">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- BrokenPipeError&nbsp; # 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入</span></li><li><span class="name">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- ConnectionAbortedError&nbsp; # 连接尝试被对等方中止</span></li><li><span class="name">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- ConnectionRefusedError&nbsp; # 连接尝试被对等方拒绝</span></li><li><span class="name">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- ConnectionResetError&nbsp; &nbsp; # 连接由对等方重置</span></li><li><span class="name">|&nbsp; &nbsp; +-- FileExistsError&nbsp; # 创建已存在的文件或目录</span></li><li><span class="name">|&nbsp; &nbsp; +-- FileNotFoundError&nbsp; # 请求不存在的文件或目录</span></li><li><span class="name">|&nbsp; &nbsp; +-- InterruptedError&nbsp; # 系统调用被输入信号中断</span></li><li><span class="name">|&nbsp; &nbsp; +-- IsADirectoryError&nbsp; # 在目录上请求文件操作(例如 os.remove())</span></li><li><span class="name">|&nbsp; &nbsp; +-- NotADirectoryError&nbsp; # 在不是目录的事物上请求目录操作(例如 os.listdir())</span></li><li><span class="name">|&nbsp; &nbsp; +-- PermissionError&nbsp; # 尝试在没有足够访问权限的情况下运行操作</span></li><li><span class="name">|&nbsp; &nbsp; +-- ProcessLookupError&nbsp; # 给定进程不存在</span></li><li><span class="name">|&nbsp; &nbsp; +-- TimeoutError&nbsp; # 系统函数在系统级别超时</span></li><li><span class="name">+-- ReferenceError&nbsp; # weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象</span></li><li><span class="name">+-- RuntimeError&nbsp; # 在检测到不属于任何其他类别的错误时触发</span></li><li><span class="name">|&nbsp; &nbsp; +-- NotImplementedError&nbsp; # 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现</span></li><li><span class="name">|&nbsp; &nbsp; +-- RecursionError&nbsp; # 解释器检测到超出最大递归深度</span></li><li><span class="name">+-- SyntaxError&nbsp; # Python 语法错误</span></li><li><span class="name">|&nbsp; &nbsp; +-- IndentationError&nbsp; # 缩进错误</span></li><li><span class="name">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- TabError&nbsp; # Tab和空格混用</span></li><li><span class="name">+-- SystemError&nbsp; # 解释器发现内部错误</span></li><li><span class="name">+-- TypeError&nbsp; # 操作或函数应用于不适当类型的对象</span></li><li><span class="name">+-- ValueError&nbsp; # 操作或函数接收到具有正确类型但值不合适的参数</span></li><li><span class="name">|&nbsp; &nbsp; +-- UnicodeError&nbsp; # 发生与Unicode相关的编码或解码错误</span></li><li><span class="name">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- UnicodeDecodeError&nbsp; # Unicode解码错误</span></li><li><span class="name">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- UnicodeEncodeError&nbsp; # Unicode编码错误</span></li><li><span class="name">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- UnicodeTranslateError&nbsp; # Unicode转码错误</span></li><li><span class="name">+-- Warning&nbsp; # 警告的基类</span><ul><li><span class="name">+-- DeprecationWarning&nbsp; # 有关已弃用功能的警告的基类</span></li><li><span class="name">+-- PendingDeprecationWarning&nbsp; # 有关不推荐使用功能的警告的基类</span></li><li><span class="name">+-- RuntimeWarning&nbsp; # 有关可疑的运行时行为的警告的基类</span></li><li><span class="name">+-- SyntaxWarning&nbsp; # 关于可疑语法警告的基类</span></li><li><span class="name">+-- UserWarning&nbsp; # 用户代码生成警告的基类</span></li><li><span class="name">+-- FutureWarning&nbsp; # 有关已弃用功能的警告的基类</span></li><li><span class="name">+-- ImportWarning&nbsp; # 关于模块导入时可能出错的警告的基类</span></li><li><span class="name">+-- UnicodeWarning&nbsp; # 与Unicode相关的警告的基类</span></li><li><span class="name">+-- BytesWarning&nbsp; # 与bytes和bytearray相关的警告的基类</span></li><li><span class="name">+-- ResourceWarning&nbsp; # 与资源使用相关的警告的基类。被默认警告过滤器忽略。</span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name">定义一个装饰器实现非常规try except，装饰器中定义一个默认参数来决定是否打印异常</span><ul><li><span class="name">def tryfun(printdebug=True):</span><ul><li><span class="name">def inner1(f):</span><ul><li><span class="name">def inner2(*args, **kwargs):</span><ul><li><span class="name">try:</span><ul><li><span class="name">res = f(*args, **kwargs)</span></li></ul></li><li><span class="name">except Exception as err:</span><ul><li><span class="name">if <b>printdebug</b>:</span><ul><li><span class="name">import sys</span></li><li><span class="name">info = sys.exc_info()[2].tb_frame.f_back</span></li><li><span class="name">temp = "filename:{}\nlines:{}\tfuncation:{}\terror:{}"</span></li><li><span class="name">print(temp.format(<a class="contentLink" target="_blank" rel="noreferrer" href="http://info.f_code.co">info.f_code.co</a>_filename, info.f_lineno, f.__name__, repr(err)))</span></li></ul></li><li><span class="name">res = None</span></li></ul></li><li><span class="name">return res</span></li></ul></li><li><span class="name">return inner2</span></li></ul></li><li><span class="name">return inner1</span></li></ul></li><li><span class="name">使用时：</span><ul><li><span class="name"><span class="contentTag" title="Filter @tryfun">@<span class="contentTagText">tryfun</span><span class="contentTagNub"></span></span>()</span></li><li><span class="name">def div(a, b):</span><ul><li><span class="name">return float(a) / float(b)</span></li></ul></li><li><span class="name">ret = div(3, 'mo')</span></li><li><span class="name">print(ret)</span></li></ul></li></ul></li><li><span class="name">断言</span><ul><li><span class="name">assert exp: exp 为假时, 程序自动崩溃, 并抛出 AssertionError 异常. </span></li></ul></li></ul></li><li><span class="name">UT</span><ul><li><span class="name">把ut代码放在：&nbsp;if __name__ == "__main__": 分支中，可以保证当模块被包含时这些代码自动不生效。</span></li></ul></li><li><span class="name">平台兼容性</span><ul><li><span class="name">获取操作系统名称：<a class="contentLink" target="_blank" rel="noreferrer" href="http://os.name">os.name</a></span><ul><li><span class="name">对于Windows，它是'nt'；</span></li><li><span class="name">对于Linux/Unix，它是'posix'。</span></li></ul></li><li><span class="name">运行系统shell命令：os.system</span><ul><li><span class="name">os.system("calc")   # 打开系统计算器</span></li></ul></li></ul></li><li><span class="name">泛型</span></li></ul>
  </body>
</html>