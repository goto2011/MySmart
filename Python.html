<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>Python  <span class="contentTag" title="Filter #Work">#<span class="contentTagText">Work</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">环境</span></span><ul><li><span class="name"><span class="innerContentContainer">Virtualenv --有效</span></span><ul><li><span class="name"><span class="innerContentContainer">http://blog.csdn.net/x32sky/article/details/52733746</span></span></li><li><span class="name"><span class="innerContentContainer">进入环境：source ~/tensorflow/bin/activate</span></span></li><li><span class="name"><span class="innerContentContainer">退出环境：deactivate</span></span></li><li><span class="name"><span class="innerContentContainer">文件在： ~/tensorflow/</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>anaconda --好用</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>anaconda</b>:一个开源的Python发行版本,包含了conda、Python等180多个科学包及其依赖项。因为包含了大量的科学包，Anaconda 的下载文件比较大（约 500 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。  <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.anaconda.com/download/#windows">https://www.anaconda.com/download/#windows</a></span></span><ul><li><span class="name"><span class="innerContentContainer">Windows安装在 C:\ProgramData\Anaconda3</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Mac: echo 'export PATH="~/anaconda3/bin:$PATH"' &gt;&gt; ~/.bashrc</span></span><ul><li><span class="name"><span class="innerContentContainer">source ~/.bashrc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Windows: 使用快捷方式 Anaconda Prompt</span></span></li><li><span class="name"><span class="innerContentContainer">输入命令 conda list, 查看已安装的Python组件</span></span></li><li><span class="name"><span class="innerContentContainer">conda update --all, 更新所有组件</span></span></li><li><span class="name"><span class="innerContentContainer">conda install tensorflow, 安装TensorFlow</span></span></li><li><span class="name"><span class="innerContentContainer">pip install tensorflow, 安装TensorFlow</span></span></li><li><span class="name"><span class="innerContentContainer">使用清华大学开源软件镜像. 执行如下命令:</span></span><ul><li><span class="name"><span class="innerContentContainer">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span></li><li><span class="name"><span class="innerContentContainer">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span></li><li><span class="name"><span class="innerContentContainer">conda config --set show_channel_urls yes</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Python 版本: </span></span><ul><li><span class="name"><span class="innerContentContainer">import sys; print('Python %s on %s' % (sys.version, sys.platform))</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Python 安装路径: </span></span><ul><li><span class="name"><span class="innerContentContainer">1. import sys; sys.path</span></span></li><li><span class="name"><span class="innerContentContainer">2. where python  两种方法都可以</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">代码组织方式</span></span><ul><li><span class="name"><span class="innerContentContainer">最小编程规范</span></span><ul><li><span class="name"><span class="innerContentContainer">模板名/文件名: 全小写，单词间用下划线分割.</span></span></li><li><span class="name"><span class="innerContentContainer">类名: 各单词首字母大写.</span></span></li><li><span class="name"><span class="innerContentContainer">方法名:第一个单词小写, 其它单词首字母大写; （Python之父推荐用这种：lower_with_under()）</span></span></li><li><span class="name"><span class="innerContentContainer">属性名:前缀m, 各单词首字母大写;</span></span></li><li><span class="name"><span class="innerContentContainer">局部变量:前缀my, 各单词首字母大写.</span></span></li><li><span class="name"><span class="innerContentContainer">适当的空格：变量命前空格，符号前后都不要加。使用空格要节制。</span></span></li><li><span class="name"><span class="innerContentContainer">适当的空行：类之间可空两行， 其它均空一行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导入其它模块</span></span><ul><li><span class="name"><span class="innerContentContainer">通过 import + 文件名. 比如:&nbsp;import mymodule</span></span></li><li><span class="name"><span class="innerContentContainer">包括两种：py文件（Python写的）和sys文件（c写的）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导入后如何调用函数?</span></span><ul><li><span class="name"><span class="innerContentContainer">mymodule.myFunc(params)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">模块导入的搜索路径  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">在 sys.path 中维护路径.</span></span></li><li><span class="name"><span class="innerContentContainer">运行时可以新增路径，即：sys.path.append('/Volumes/Data/TensorFlow/abc/')，退出后该路径即不生效。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码块定义</span></span><ul><li><span class="name"><span class="innerContentContainer">Python的核心特色就是通过缩进来表达代码的逻辑关系。</span></span></li><li><span class="name"><span class="innerContentContainer">代码块通过它们的缩进来定义的。 "代码块" 包括函数、if 语句、for 循环、while 循环, 等等。</span></span></li><li><span class="name"><span class="innerContentContainer">def myFunc(param):</span></span><ul><li><span class="name"><span class="innerContentContainer">if param&nbsp;&gt; 1:</span></span><ul><li><span class="name"><span class="innerContentContainer">return param&nbsp;* myFunc(param&nbsp;- 1)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">else:</span></span><ul><li><span class="name"><span class="innerContentContainer">return 1</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">这是一个名为 myFunc&nbsp;的函数, 有一个参数 param。在函数内的所有代码都是缩进的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码执行入口  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">if __name__ == '__main__’:</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">类</span></span><ul><li><span class="name"><span class="innerContentContainer">“万物皆对象”：在Python中，变量是对象，字符串是对象，列表时对象，函数是对象，模块也是对象。</span></span></li><li><span class="name"><span class="innerContentContainer">定义类：</span></span></li><li><span class="name"><span class="innerContentContainer">class MyClass(object):</span></span><ul><li><span class="name"><span class="innerContentContainer">tax = 50</span></span></li><li><span class="name"><span class="innerContentContainer">def __init__(self, room, cf=1.0, addr):</span></span><ul><li><span class="name"><span class="innerContentContainer">self.room = room</span></span></li><li><span class="name"><span class="innerContentContainer">self.cf = cf</span></span></li><li><span class="name"><span class="innerContentContainer">self.__addr = addr    # 私有属性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">def cacl_all(self, days=1):</span></span><ul><li><span class="name"><span class="innerContentContainer">return (MyClass.tax + self.room * self.cf ) * days</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">类名后面的括号表示类的继承关系。object是所有类的基类。推荐显式定义对object的继承。</span></span></li><li><span class="name"><span class="innerContentContainer">Python 支持多重继承。</span></span></li><li><span class="name"><span class="innerContentContainer">__init__ 是构造方法。构造方法的返回值总是None。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">self 为所有对象方法的第一个参数。固定如此。self 表示对对象实例的引用。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>对象属性</b>使用 self.room 这种方式访问。  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">对象属性不需要在方法外单独申明，在方法中使用 self.*** 定义后就可以使用。</span></span></li><li><span class="name"><span class="innerContentContainer">对象属性是一个对象一个，各自独立。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定义在方法外的变量即为 <b>类属性</b>。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">类属性为所有的对象共享。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 MyClass.tax 来访问。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">私有属性和方法</span></span><ul><li><span class="name"><span class="innerContentContainer">默认对象的属性和方法都是公有的，即可在类外只有访问的。</span></span></li><li><span class="name"><span class="innerContentContainer">但是Python也提供了间接的定义私有属性和私有方法的办法：在属性名或方法名加前缀 __，就可以把它隐藏起来。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">其实这只是一种名字改编，在类外如果用 _类名__属性名， 即可正常访问。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类属性建议不要用。因为其结果不好预测。</span></span><ul><li><span class="name"><span class="innerContentContainer">比如一个类有3个实例。对象A对某个类属性进行赋值，对象B和C没有赋值，那么同样使用类名.属性名来访问，B和C访问的是公共的那个，但是A访问的是自己的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类方法 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">类内以 @ classmethod 定义的函数是类方法.</span></span></li><li><span class="name"><span class="innerContentContainer">第一个参数是本类的实例名. 可访问类属性和其它类方法, 并通过实例名访问实例属性和实例方法.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静态方法 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">类内以 @ staticmethod 定义的函数是静态方法. </span></span></li><li><span class="name"><span class="innerContentContainer">静态方法不能访问类的属性和方法. 目的是为全局函数找个地方放, 和本类没关系. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用类的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">std_room = MyClass(200)</span></span></li><li><span class="name"><span class="innerContentContainer">big_room = MyClass(230, 0.9)</span></span></li><li><span class="name"><span class="innerContentContainer">std_room.cacl_all()</span></span></li><li><span class="name"><span class="innerContentContainer">big_room.cacl_all(3)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Hello World！</span></span><ul><li><span class="name"><span class="innerContentContainer">helloworld.py中如下. 其中第一行是必须的.</span></span></li><li><span class="name"><span class="innerContentContainer">#!/usr/bin/python</span></span></li><li><span class="name"><span class="innerContentContainer">print 'Hello World'</span></span></li><li><span class="name"><span class="innerContentContainer">运行：使用命令行输入命令，python <a class="contentLink" target="_blank" rel="noreferrer" href="http://helloworld.py">helloworld.py</a>。</span></span></li><li><span class="name"><span class="innerContentContainer">使用 pyinstaller 对py文件进行二进制打包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注释</span></span><ul><li><span class="name"><span class="innerContentContainer"># 号开始的行是注释，只影响本行。</span></span></li><li><span class="name"><span class="innerContentContainer">连续3个引号 """ 定义一个多行注释，截止也是3个引号。</span></span></li><li><span class="name"><span class="innerContentContainer">函数体最开始的注释为函数文档，可以被IDE、代码访问。文档和代码融为一体。</span></span><ul><li><span class="name"><span class="innerContentContainer">myFunc.__doc__ 即可打印myFunc的函数级注释。</span></span></li><li><span class="name"><span class="innerContentContainer">可通过关键字 help 访问函数文档, help(myFunc)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">log打印</span></span><ul><li><span class="name"><span class="innerContentContainer">打印到控制台： 直接print()</span></span><ul><li><span class="name"><span class="innerContentContainer">print() 仅支持string常量，如果是变量需要用 str() 转一下。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印到log文件</span></span><ul><li><span class="name"><span class="innerContentContainer">Python内置了一个log模块logging。例如：</span></span></li><li><span class="name"><span class="innerContentContainer">import logging</span></span></li><li><span class="name"><span class="innerContentContainer">LOG_FILENAME="~/log.txt" //// 打印到文件</span></span></li><li><span class="name"><span class="innerContentContainer">logging.basicConfig(filename=LOG_FILENAME,level=<a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.INFO">logging.INFO</a>) //// 设置基准等级</span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.info">logging.info</a>("This message should go to the log file") //// 按info等级打印。</span></span></li><li><span class="name"><span class="innerContentContainer">其中，有6级log打印级别，分别是 CRITICAL、ERROR、WARNING、INFO、DEBUG、NOTSET，默认为WARNING。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">函数（传值、传址、传引用）</span></span><ul><li><span class="name"><span class="innerContentContainer">函数定义</span></span><ul><li><span class="name"><span class="innerContentContainer">def myFunc(params, spacing=10, collapse=1):</span></span><ul><li><span class="name"><span class="innerContentContainer">"""Build a connection string from a dictionary of parameters.</span></span></li><li><span class="name"><span class="innerContentContainer">Returns string."""</span></span></li><li><span class="name"><span class="innerContentContainer">return ";".join(["%s=%s" % (k, v) for k, v in params.items()])</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中：</span></span></li><li><span class="name"><span class="innerContentContainer">def：关键字，表示开始定义函数。</span></span></li><li><span class="name"><span class="innerContentContainer">myFunc：为函数名。<b>不需要定义返回值类型。</b></span></span></li><li><span class="name"><span class="innerContentContainer">params：参数，也不需要指定类型。spacing=10即参数默认值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">命名参数</span></span><ul><li><span class="name"><span class="innerContentContainer">Python支持命名参数. 命名参数的一个好处是代码可读性强，另一个好处参数不在依赖顺序.</span></span></li><li><span class="name"><span class="innerContentContainer">比如 def myFunc(params, spacing=10, collapse=1) 这个函数，如果要指定 collapse（第三个）的值，同时第二个参数使用默认值, 使用如下形式:</span></span></li><li><span class="name"><span class="innerContentContainer">myFunc(sqlStrings, collapse=0)  # 第一个参数按普通方式传递.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">参数默认值： 定义时给出指定值的参数. 调用时不赋值则使用默认值。</span></span></li><li><span class="name"><span class="innerContentContainer">传值、传址、传引用</span></span><ul><li><span class="name"><span class="innerContentContainer">Python不允许选择采用传值还是传址。</span></span></li><li><span class="name"><span class="innerContentContainer">Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传址的综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值, 相当于传址。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象, 相当于传值。</span></span></li><li><span class="name"><span class="innerContentContainer">传值的参数类型：数字，字符串，元组</span></span></li><li><span class="name"><span class="innerContentContainer">传址的参数类型：列表，字典</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">支持多返回值 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Python支持多返回值.  这是最方便的地方! <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">def <b>move</b>(x, y, step, angle=0):</span></span><ul><li><span class="name"><span class="innerContentContainer">nx = x + step * math.cos(angle)</span></span></li><li><span class="name"><span class="innerContentContainer">ny = y - step * math.sin(angle)</span></span></li><li><span class="name"><span class="innerContentContainer">return nx, ny</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">x, y = <b>move</b>(100, 100, 60, math.pi / 6)   # 使用时这样做。</span></span></li><li><span class="name"><span class="innerContentContainer">对于调用方, 如果要忽略某个返回值, 可以用 _ 代替.</span></span></li><li><span class="name"><span class="innerContentContainer">实际上返回的是一个 tuple。由于按Python的语法，多个变量可以同时接收一个tuple，按位置赋给对应的值。这样更简洁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可变参数</span></span><ul><li><span class="name"><span class="innerContentContainer">参数表加 * 表示可变参数. 比如:</span></span></li><li><span class="name"><span class="innerContentContainer">def myFunc (* params):</span></span><ul><li><span class="name"><span class="innerContentContainer">len(params)       # 参数的数量</span></span></li><li><span class="name"><span class="innerContentContainer">print params[0]   # 第一个参数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可见, Python 把参数打包为一个元组.</span></span></li><li><span class="name"><span class="innerContentContainer">可变参数一般应该放在参数表的最后面. 如果不是这样, 则普通参数需要用命名参数方式. </span></span><ul><li><span class="name"><span class="innerContentContainer">def myFunc (* params, extra)</span></span></li><li><span class="name"><span class="innerContentContainer">使用时 myFunc(1, 2, 3, extra=4)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">函数递归</span></span><ul><li><span class="name"><span class="innerContentContainer">递归就是函数调用自身。</span></span></li><li><span class="name"><span class="innerContentContainer">Python对递归深度默认限制为最多1000层。</span></span></li><li><span class="name"><span class="innerContentContainer">可以自定义递归深度：</span></span></li><li><span class="name"><span class="innerContentContainer">import sys</span></span></li><li><span class="name"><span class="innerContentContainer">sys.setrecursionlimit(1000000) # 改为100万层</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">整数&amp;布尔量&amp;枚举量</span></span><ul><li><span class="name"><span class="innerContentContainer">整数是int性的. 变量通过首次赋值产生. 整数就是: myParams = 5</span></span></li><li><span class="name"><span class="innerContentContainer">Python 整数支持无限大的整数.</span></span></li><li><span class="name"><span class="innerContentContainer">布尔量</span></span><ul><li><span class="name"><span class="innerContentContainer">True(1). 只有1是True, 其它值不是.</span></span></li><li><span class="name"><span class="innerContentContainer">False(0). 只有0是False, 其它值不是.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">枚举量</span></span><ul><li><span class="name"><span class="innerContentContainer">导入enum模块; 用class关键字定义枚举，且继承Enum类。 如:</span></span></li><li><span class="name"><span class="innerContentContainer">from enum import Enum</span></span></li><li><span class="name"><span class="innerContentContainer">class MyEnmu(Enum):</span></span><ul><li><span class="name"><span class="innerContentContainer">red = 1</span></span></li><li><span class="name"><span class="innerContentContainer">orange = 2</span></span></li><li><span class="name"><span class="innerContentContainer">yellow = 3</span></span></li><li><span class="name"><span class="innerContentContainer">green = 4</span></span></li><li><span class="name"><span class="innerContentContainer">blue = 5</span></span></li><li><span class="name"><span class="innerContentContainer">indigo = 6</span></span></li><li><span class="name"><span class="innerContentContainer">purple = 7</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用时用:&nbsp;MyEnmu.red</span></span></li><li><span class="name"><span class="innerContentContainer">还可以这么用:&nbsp;print(MyEnmu(1)). 输出:&nbsp;MyEnmu.red</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">浮点数</span></span><ul><li><span class="name"><span class="innerContentContainer">myParams = 5.5</span></span></li><li><span class="name"><span class="innerContentContainer">浮点数还有一种表达方式：科学计数法。352.3E-4，E标记表示10的幂，52.3E-4表示52.3 * 10-4。</span></span></li><li><span class="name"><span class="innerContentContainer">复数定义</span></span><ul><li><span class="name"><span class="innerContentContainer">用a+/-bj的方式定义, a和b皆为数字. 如: </span></span></li><li><span class="name"><span class="innerContentContainer">my = -5+4j</span></span></li><li><span class="name"><span class="innerContentContainer">print my.real &nbsp;  # 打印复数的实部</span></span></li><li><span class="name"><span class="innerContentContainer">print my.imag &nbsp; # 打印复数的虚部</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">常量&amp;全局变量&amp;静态变量</span></span><ul><li><span class="name"><span class="innerContentContainer">常量: python无此概念。5.5就是数字常量，‘123’就是字符串常量。</span></span></li><li><span class="name"><span class="innerContentContainer">全局变量</span></span><ul><li><span class="name"><span class="innerContentContainer">在类外定义的变量为全局变量, 全局可见, 直接读取.</span></span></li><li><span class="name"><span class="innerContentContainer">但是如果尝试改写全局变量, 则不会成功. Python会创建一个同名的局部变量, 修改的是该局部变量.</span></span></li><li><span class="name"><span class="innerContentContainer">如果一定要改写全局变量, 则要用 global 关键字申明.  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">count = 5</span></span></li><li><span class="name"><span class="innerContentContainer">def myFunc():</span></span><ul><li><span class="name"><span class="innerContentContainer">global count</span></span></li><li><span class="name"><span class="innerContentContainer">count = 10</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">静态变量:&nbsp;类内函数外定义的变量是类变量, 和静态变量的概念类似.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运算符表 (优先级递减)</span></span><ul><li><span class="name"><span class="innerContentContainer">正负号: +x, -x</span></span></li><li><span class="name"><span class="innerContentContainer">乘法、除法、取余数、取整数、幂运算: *, / ,%, //,&nbsp;&nbsp;**(返回x的y次幂, 如2**4 = 16)</span></span><ul><li><span class="name"><span class="innerContentContainer">其中: / 为普通除法. 两个整数相除, 可能得到一个浮点数.</span></span></li><li><span class="name"><span class="innerContentContainer">// 为地板除法, 比如 3//2 = 1, 3.0//2 == 1.0</span></span></li><li><span class="name"><span class="innerContentContainer">% 为取余数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">加法与减法: +, -</span></span></li><li><span class="name"><span class="innerContentContainer">移位: &lt;&lt;, &gt;&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">按位与: &amp;</span></span></li><li><span class="name"><span class="innerContentContainer">按位异或: ^</span></span></li><li><span class="name"><span class="innerContentContainer">按位或: |</span></span></li><li><span class="name"><span class="innerContentContainer">比较: &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></span></li><li><span class="name"><span class="innerContentContainer">赋值: =, +=, -=, *=, /=, %=, **=, //==</span></span></li><li><span class="name"><span class="innerContentContainer">身份运算符: is, is not</span></span><ul><li><span class="name"><span class="innerContentContainer">is:&nbsp;判断两个标识符是不是引用自一个对象.&nbsp;x is y, 等价于 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False.</span></span></li><li><span class="name"><span class="innerContentContainer">is not: 和is相反.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">成员运算符: in, not in</span></span><ul><li><span class="name"><span class="innerContentContainer">成员运算符负责测试集合中是否包括指定成员，支持的集合包括字符串，列表或元组。</span></span></li><li><span class="name"><span class="innerContentContainer">in:&nbsp;如果在集合中找到值返回 True，否则返回 False。如:</span></span><ul><li><span class="name"><span class="innerContentContainer">a = 10</span></span></li><li><span class="name"><span class="innerContentContainer">myList = [1, 2, 3, 4, 5]</span></span></li><li><span class="name"><span class="innerContentContainer">if ( a in myList&nbsp;):</span></span><ul><li><span class="name"><span class="innerContentContainer">print&nbsp;“找到了”</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">not in: 与in相反.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">逻辑运算符: not, and, or</span></span></li><li><span class="name"><span class="innerContentContainer">Lambda 表达式</span></span><ul><li><span class="name"><span class="innerContentContainer">Lambda表达式类似于c中的宏定义函数, 它定义了一个匿名函数，有参数, 函数体和返回值。使用时直接传入参数即可. 适合简单运算的函数.</span></span></li><li><span class="name"><span class="innerContentContainer">定义时，冒号左边是参数，右边是返回值。</span></span></li><li><span class="name"><span class="innerContentContainer">func=<b>lambda </b>x:x+1</span></span></li><li><span class="name"><span class="innerContentContainer">print(func(1)) &nbsp;# 返回2</span></span></li><li><span class="name"><span class="innerContentContainer">其作用在于：</span></span><ul><li><span class="name"><span class="innerContentContainer">不需要考虑函数命名。大型项目中函数命名是一个很大的负担。</span></span></li><li><span class="name"><span class="innerContentContainer">函数做参数时可直接在调用处定义，简洁，可读性强。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>和 Lambda 表达式配合的3大内置函数：filter、map, reduce</b></span></span><ul><li><span class="name"><span class="innerContentContainer">filter</span></span><ul><li><span class="name"><span class="innerContentContainer">filter(function, iterable)</span></span></li><li><span class="name"><span class="innerContentContainer">两个参数: 第一个可以是None, 也可以是函数, 指定过滤方法. 第二个是个序列, 指定过滤对象. </span></span></li><li><span class="name"><span class="innerContentContainer">如果第一个参数是None, 则直接把第二个参数中为True或1的值筛选出来, 放在一个序列中返回.</span></span></li><li><span class="name"><span class="innerContentContainer">如果第二个参数是函数, 则把第二个参数中的每个元素作为函数的参数进行运行, 结果为True或1 的值筛选出来, 放在一个序列中返回.</span></span></li><li><span class="name"><span class="innerContentContainer">myList = filter(<b>lambda x : x </b>% 2 == 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])   # 过滤出列表中的所有奇数</span></span></li><li><span class="name"><span class="innerContentContainer">==&gt;[1, 3, 5, 7, 9]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">map</span></span><ul><li><span class="name"><span class="innerContentContainer">map(function, iterable, ...)</span></span></li><li><span class="name"><span class="innerContentContainer">两个参数： 第一个是函数；第二个是一个或可迭代序列。</span></span></li><li><span class="name"><span class="innerContentContainer">功能是将序列的每一个元素作为函数的入参进行调用，然后把返回值放在一个序列中返回。</span></span></li><li><span class="name"><span class="innerContentContainer">map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 计算平方数</span></span></li><li><span class="name"><span class="innerContentContainer">==&gt;[1, 4, 9, 16, 25]</span></span></li><li><span class="name"><span class="innerContentContainer">map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])  # 两个列表，对相同位置的列表数据进行相加</span></span></li><li><span class="name"><span class="innerContentContainer">==&gt;[3, 7, 11, 15, 19]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">reduce</span></span><ul><li><span class="name"><span class="innerContentContainer">reduce(function, iterable[, initializer])</span></span><ul><li><span class="name"><span class="innerContentContainer">function -- 函数，必须有两个参数</span></span></li><li><span class="name"><span class="innerContentContainer">iterable -- 可迭代对象</span></span></li><li><span class="name"><span class="innerContentContainer">initializer -- 可选，初始参数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对参数序列中元素进行挨个累积。</span></span></li><li><span class="name"><span class="innerContentContainer">reduce(lambda x, y: x+y, [1,2,3,4,5])  ？# 求和</span></span></li><li><span class="name"><span class="innerContentContainer">==&gt; 15</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">三元运算符: exp1 if exp2 else exp3</span></span><ul><li><span class="name"><span class="innerContentContainer">exp2 == True, 则返回 exp1, 否则返回 exp3.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内嵌函数(内部函数) 和闭包</span></span><ul><li><span class="name"><span class="innerContentContainer">在函数内部可定义另外一个函数. 该函数叫内嵌函数. </span></span></li><li><span class="name"><span class="innerContentContainer">内嵌函数仅可被宿主函数调用. </span></span></li><li><span class="name"><span class="innerContentContainer">闭包 (closure)</span></span><ul><li><span class="name"><span class="innerContentContainer">如果在一个内部函数中, 对在外部作用域(但不是在全局作用域) 的变量进行应用, 那么此内部函数被视为闭包. 例如:</span></span></li><li><span class="name"><span class="innerContentContainer">def out(x):</span></span><ul><li><span class="name"><span class="innerContentContainer">def in(y):</span></span><ul><li><span class="name"><span class="innerContentContainer">return x+y</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return in  # 外部函数把内部函数作为返回值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">外部使用时用这种格式: out(8)(5)   ==&gt; 13</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">闭包主要用于装饰模式.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对象判空</span></span><ul><li><span class="name"><span class="innerContentContainer">对象判空  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">if <b>any</b>(myObject): &nbsp; #&nbsp;myObject为空则返回true.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">list判空</span></span><ul><li><span class="name"><span class="innerContentContainer">if len(myList): &nbsp;# myList 不为空则返回true.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">类和对象的元操作</span></span><ul><li><span class="name"><span class="innerContentContainer">type(): 返回任意对象的数据类型</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; type(1)</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;type 'int’&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList = [ ]</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; type(myList)</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;type 'list’&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; import odbchelper</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; type(odbchelper)</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;type 'module’&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; import types</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; type(odbchelper) == types.ModuleType</span></span><ul><li><span class="name"><span class="innerContentContainer">True</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">id(): 返回对象或变量的内存地址</span></span><ul><li><span class="name"><span class="innerContentContainer">a=1</span></span></li><li><span class="name"><span class="innerContentContainer">print(id(a)) &nbsp;///&nbsp;&nbsp;&nbsp; &nbsp;11246696</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dir(): 列出类支持的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">比如 list类, 使用 dir(list)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">isinstance(A, objA) ：如果A是objA类型，则返回true。</span></span></li><li><span class="name"><span class="innerContentContainer">issubclass(subclass, class): 判断子类关系</span></span><ul><li><span class="name"><span class="innerContentContainer">如果参数1是参数2的子类，则返回True</span></span></li><li><span class="name"><span class="innerContentContainer">参数2有个扩展，可以是一个类的元组，即多个类，只要参数1是其中任何一个类的子类，都返回True。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">hasattr(class, attr): 测试类是否存在指定属性。</span></span></li><li><span class="name"><span class="innerContentContainer">getattr(object, attr, default): 返回对象的指定属性的值。如果不存在，则返回 default。</span></span></li><li><span class="name"><span class="innerContentContainer">setattr(object, attr, value): 设置指定属性的值。如果属性不存在，则新增该属性并赋值。</span></span></li><li><span class="name"><span class="innerContentContainer">delattr(object, attr): 删除指定属性。如果属性不存在，则抛出 AttributeError 异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">for &amp; while</span></span><ul><li><span class="name"><span class="innerContentContainer">python的 list 很强大， 所以一般情况下你并不需要for循环。</span></span></li><li><span class="name"><span class="innerContentContainer">遍历一个list（当然有更简洁的方式）：</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList = ['a', 'b', 'e']</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; for my in myList:   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">print my</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">还有一种方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; for my in range(len(myList)):</span></span></li><li><span class="name"><span class="innerContentContainer">print myList[my]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">循环数字</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; for i in range(4):</span></span><ul><li><span class="name"><span class="innerContentContainer">print i</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">遍历一个dictionary</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; import os</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; for k, v in os.environ.items():  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">print "%s=%s" % (k, v)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">输出:</span></span></li><li><span class="name"><span class="innerContentContainer">USERPROFILE=C:\Documents and Settings\mpilgrim</span></span></li><li><span class="name"><span class="innerContentContainer">OS=Windows_NT</span></span></li><li><span class="name"><span class="innerContentContainer">COMPUTERNAME=MPILGRIM</span></span></li><li><span class="name"><span class="innerContentContainer">USERNAME=mpilgrim</span></span></li><li><span class="name"><span class="innerContentContainer">其中：os.environ.items() 返回一个 tuple 的 list：[(key1, value1), (key2, value2), ...]。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">while</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>while</b> ii &lt; 100: </span></span><ul><li><span class="name"><span class="innerContentContainer">ii += 1</span></span></li><li><span class="name"><span class="innerContentContainer">if i &gt; 10:</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>break</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">if ii%2 &gt; 0:</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>continue</b></span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">while ... else ... 结构</span></span><ul><li><span class="name"><span class="innerContentContainer">while count &lt; 5:</span></span><ul><li><span class="name"><span class="innerContentContainer">print count, " is  less than 5"</span></span></li><li><span class="name"><span class="innerContentContainer">count = count + 1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">else:</span></span><ul><li><span class="name"><span class="innerContentContainer">print count, " is not less than 5"</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">if &amp; swith</span></span><ul><li><span class="name"><span class="innerContentContainer">def fib(n):</span></span><ul><li><span class="name"><span class="innerContentContainer">if n &gt; 1:</span></span><ul><li><span class="name"><span class="innerContentContainer">return n * fib(n - 1)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">else:</span></span><ul><li><span class="name"><span class="innerContentContainer">print 'end of the line'</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return 1</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">字符串定义</span></span><ul><li><span class="name"><span class="innerContentContainer">字符串可以使用单引号、双引号、三引号（'''）。</span></span></li><li><span class="name"><span class="innerContentContainer">其中单引号和双引号是同一个功能. 而三引号则可以定义多行字符串，且其间可以使用单引号和双引号。如：</span></span><ul><li><span class="name"><span class="innerContentContainer">uid = '''This is a multi-line string. This is the first line.</span></span></li><li><span class="name"><span class="innerContentContainer">"What's your name?," I asked.</span></span></li><li><span class="name"><span class="innerContentContainer">He said "Bond, James Bond."</span></span></li><li><span class="name"><span class="innerContentContainer">‘''</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">转移符\。当需要在字符串中使用引号时，需要使用转义符：\', \", \\</span></span></li><li><span class="name"><span class="innerContentContainer">字符串常量，多用于正则表达式和文件路径。前面加r。比如：r'\1’。</span></span></li><li><span class="name"><span class="innerContentContainer">字符串判空:&nbsp;len(myStr)==0</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Unicode字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">需要在字符串前加上前缀u或U。例如，u"This is a Unicode string."。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串转化</span></span><ul><li><span class="name"><span class="innerContentContainer">int(str): 将符合整数规定的字符串转换成int型</span></span></li><li><span class="name"><span class="innerContentContainer">float(str): 将符合浮点型规定的字符串转换成float型</span></span></li><li><span class="name"><span class="innerContentContainer">str(num): 将整数、浮点型转换成字符串型的</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">取长: len(myStr)</span></span></li><li><span class="name"><span class="innerContentContainer">去空格</span></span><ul><li><span class="name"><span class="innerContentContainer">去两边空格：myStr.strip()</span></span></li><li><span class="name"><span class="innerContentContainer">去左空格：myStr.lstrip()</span></span></li><li><span class="name"><span class="innerContentContainer">去右空格：myStr.rstrip()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串连接  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">用 + 运算符. 如:  “Hello” +&nbsp;“world!"</span></span></li><li><span class="name"><span class="innerContentContainer">用join()合并多个字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myDict = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret”}</span></span></li><li><span class="name"><span class="innerContentContainer">print ";".join(["%s=%s" % (k, v) for k, v in myDict.items()])</span></span></li><li><span class="name"><span class="innerContentContainer">==&gt; 'server=mpilgrim;uid=sa;database=master;pwd=secret’</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">join 比 + 性能高, 因为+会引起内存复制和GC.</span></span></li><li><span class="name"><span class="innerContentContainer">应避免在循环中用+和+=操作符来累加字符串. </span></span><ul><li><span class="name"><span class="innerContentContainer">由于字符串是不可变的, 这样做会创建不必要的临时对象。</span></span></li><li><span class="name"><span class="innerContentContainer">替代方案是将每个子串加入列表, 然后在循环结束后用&nbsp;.join&nbsp;连接列表。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串截取</span></span><ul><li><span class="name"><span class="innerContentContainer">myStr = "abcdef"</span></span></li><li><span class="name"><span class="innerContentContainer">myStr2&nbsp;= myStr<b>[1:2]  </b>&nbsp;#&nbsp;myStr2是myStr从下标1开始，到2结束的连续子串。</span></span></li><li><span class="name"><span class="innerContentContainer">获取固定长度，右对齐，左边不够用空格补齐： myStr.rjust(width)</span></span></li><li><span class="name"><span class="innerContentContainer">获取固定长度，左对齐，右边不够用空格补齐： myStr.ljust(width)</span></span></li><li><span class="name"><span class="innerContentContainer">获取固定长度，中间对齐，两边不够用空格补齐： .center(width)</span></span></li><li><span class="name"><span class="innerContentContainer">获取固定长度，右对齐，左边不足用0补齐： myStr.myStrzfill(width)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串比较</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 is equal 或 == 操作符比较字符串, 使用例如 &gt;= 或 &lt; 的运算符来确定几个字符串的排列顺序。</span></span><ul><li><span class="name"><span class="innerContentContainer">if myStr1 == myStr2:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">是否以start开头：myStr.startswith('start')</span></span></li><li><span class="name"><span class="innerContentContainer">是否以end结尾：myStr.endswith('end’)</span></span></li><li><span class="name"><span class="innerContentContainer">是否全为字母或数字：myStr.isalnum()</span></span></li><li><span class="name"><span class="innerContentContainer">是否全字母：myStr.isalpha()</span></span></li><li><span class="name"><span class="innerContentContainer">是否全数字：myStr.isdigit()</span></span></li><li><span class="name"><span class="innerContentContainer">是否全小写：myStr.islower()</span></span></li><li><span class="name"><span class="innerContentContainer">是否全大写：myStr.isupper()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串查找</span></span><ul><li><span class="name"><span class="innerContentContainer">搜索指定字符串，没有返回-1：myStr.find('t')</span></span></li><li><span class="name"><span class="innerContentContainer">指定起始位置搜索：myStr.find('t',start)</span></span></li><li><span class="name"><span class="innerContentContainer">指定起始及结束位置搜索：myStr.find('t',start,end)</span></span></li><li><span class="name"><span class="innerContentContainer">从右边开始查找：myStr.rfind('t')</span></span></li><li><span class="name"><span class="innerContentContainer">搜索到多少个指定字符串：myStr.count('t’)</span></span></li><li><span class="name"><span class="innerContentContainer">上面所有方法都可用 myStr.index 代替，不同的是使用index查找不到会抛异常，而find返回-1.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串替换</span></span><ul><li><span class="name"><span class="innerContentContainer">替换old为new: myStr.replace('old','new')</span></span></li><li><span class="name"><span class="innerContentContainer">指定替换次数：myStr.replace('old’, 'new’, 5) &nbsp;# 最多替换5次</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串切分</span></span><ul><li><span class="name"><span class="innerContentContainer">myStr&nbsp;= 'server=mpilgrim;uid=sa;database=master;pwd=secret'</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myStr.split(";")</span></span></li><li><span class="name"><span class="innerContentContainer">返回: ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']</span></span></li><li><span class="name"><span class="innerContentContainer">split() 指定的分隔符可以是字符，也可以是子串.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">格式转化</span></span><ul><li><span class="name"><span class="innerContentContainer">字符串格式化使用与 C 中 sprintf 函数类似的语法.</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myStr1&nbsp;= "uid"</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myStr2&nbsp;= "sa"</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; "%s=%s" % (myStr1, myStr2)</span></span></li><li><span class="name"><span class="innerContentContainer">其中: %s 为占位符, 引号外的 % 为分隔符.</span></span></li><li><span class="name"><span class="innerContentContainer">占位符有如下格式:</span></span><ul><li><span class="name"><span class="innerContentContainer">%d，%i	转换为带符号的十进制形式的整数</span></span></li><li><span class="name"><span class="innerContentContainer">%o	转换为带符号的八进制形式的整数</span></span></li><li><span class="name"><span class="innerContentContainer">%x，%X	转换为带符号的十六进制形式的整数</span></span></li><li><span class="name"><span class="innerContentContainer">%e	转化为科学计数法表示的浮点数（e 小写）</span></span></li><li><span class="name"><span class="innerContentContainer">%E	转化为科学计数法表示的浮点数（E 大写）</span></span></li><li><span class="name"><span class="innerContentContainer">%f，%F	转化为十进制形式的浮点数</span></span></li><li><span class="name"><span class="innerContentContainer">%g	智能选择使用 %f 或 %e 格式</span></span></li><li><span class="name"><span class="innerContentContainer">%G	智能选择使用 %F 或 %E 格式</span></span></li><li><span class="name"><span class="innerContentContainer">%c	格式化字符及其&nbsp;ASCII&nbsp;码</span></span></li><li><span class="name"><span class="innerContentContainer">%r	使用 repr() 将变量或表达式转换为字符串</span></span></li><li><span class="name"><span class="innerContentContainer">%s	使用 str() 将变量或表达式转换为字符串</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">占位符还有规定缩进对齐的功能. 放在%和后面的字母之间:</span></span><ul><li><span class="name"><span class="innerContentContainer">默认是右对齐. </span></span></li><li><span class="name"><span class="innerContentContainer">-：指定左对齐。</span></span></li><li><span class="name"><span class="innerContentContainer">+：表示数值总要带着符号（正数带“+”，负数带“-”）。</span></span></li><li><span class="name"><span class="innerContentContainer">0：表示不补充空格，而是补充 0。</span></span></li><li><span class="name"><span class="innerContentContainer">数字: 表示位数.</span></span></li><li><span class="name"><span class="innerContentContainer">以上可以同时出现. 比如 %-6s, %-06d, %+4.2f (带正负号, 4位整数, 2位小数)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">大小写转换</span></span><ul><li><span class="name"><span class="innerContentContainer">全部大写：myStr.upper()</span></span></li><li><span class="name"><span class="innerContentContainer">全部小写：myStr.lower()</span></span></li><li><span class="name"><span class="innerContentContainer">大小写互换：myStr.swapcase()</span></span></li><li><span class="name"><span class="innerContentContainer">首字母大写：myStr.title()</span></span></li><li><span class="name"><span class="innerContentContainer">首字母大写，其余小写：myStr.capitalize()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">对时间的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">import time, datetime</span></span></li><li><span class="name"><span class="innerContentContainer">获取系统时间</span></span><ul><li><span class="name"><span class="innerContentContainer">time.time() &nbsp; # 返回从1970年1月1日0点到现在的秒数(用浮点数表示)，用的是UTC时间。</span></span></li><li><span class="name"><span class="innerContentContainer">time.localtime()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时间到字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">strftime() &nbsp;# 用来将时间格式化成字符串.如:</span></span><ul><li><span class="name"><span class="innerContentContainer">print time.strftime("%Y-%m-%d %X", "2011-09-28 10:00:00”)&nbsp;# 第二个参数是系统可识别的时间字符串.&nbsp;“可识别"这个概念就有一定的灰度了.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果需要对时间做计算, 一般把时间转化为&nbsp;struct_time 结构，然后再转化为epoch时间(即秒数), 这是个数字 比较方便计算。</span></span></li><li><span class="name"><span class="innerContentContainer">time.gmtime(t) &nbsp; &nbsp;#&nbsp;用UTC时间转为struct_time结构.如果不传参数, 则time.time()取系统当前时间.</span></span></li><li><span class="name"><span class="innerContentContainer">time.localtime(t) # 和上面同. 但使用本地时区调整过.</span></span></li><li><span class="name"><span class="innerContentContainer">calendar.timegm() # 把UTC的struct_time(gmtime的返回对象)转为从epoch开始的秒数</span></span></li><li><span class="name"><span class="innerContentContainer">time.mktime() # 把用时区调整过的struct_time(即localtime的返回对象)对象转为从epoch开始的秒数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串到时间</span></span><ul><li><span class="name"><span class="innerContentContainer">time.strptime() &nbsp;#&nbsp;将字符串解析成时间如:</span></span><ul><li><span class="name"><span class="innerContentContainer">myTime = time.strptime("2009-08-08", "%Y - %m - %d”) &nbsp;# 返回struct_time对象</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">strftime()和strptime()的format参数由如下占位符构成</span></span><ul><li><span class="name"><span class="innerContentContainer">%a 英文星期简写</span></span></li><li><span class="name"><span class="innerContentContainer">%A 英文星期的完全</span></span></li><li><span class="name"><span class="innerContentContainer">%b 英文月份的简写</span></span></li><li><span class="name"><span class="innerContentContainer">%B 英文月份的完全</span></span></li><li><span class="name"><span class="innerContentContainer">%c 显示本地日期时间</span></span></li><li><span class="name"><span class="innerContentContainer">%d 日期，取1-31</span></span></li><li><span class="name"><span class="innerContentContainer">%H 小时， 0-23</span></span></li><li><span class="name"><span class="innerContentContainer">%I 小时， 0-12</span></span></li><li><span class="name"><span class="innerContentContainer">%m 月， 01 -12</span></span></li><li><span class="name"><span class="innerContentContainer">%M 分钟，1-59</span></span></li><li><span class="name"><span class="innerContentContainer">%j 年中当天的天数</span></span></li><li><span class="name"><span class="innerContentContainer">%w 显示今天是星期几</span></span></li><li><span class="name"><span class="innerContentContainer">%W 第几周</span></span></li><li><span class="name"><span class="innerContentContainer">%x 当天日期</span></span></li><li><span class="name"><span class="innerContentContainer">%X 本地的当天时间</span></span></li><li><span class="name"><span class="innerContentContainer">%y 年份 00-99间</span></span></li><li><span class="name"><span class="innerContentContainer">%Y 年份的完整拼写</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它函数</span></span><ul><li><span class="name"><span class="innerContentContainer">time.asctime():&nbsp;将一个struct_time对象转为标准24字符的字符串，如:</span></span><ul><li><span class="name"><span class="innerContentContainer">Sun Jun 20 23:21:05 1993</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">time.ctime(): 将一个秒数转化为标准24字符的字符串, 如上.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统延迟  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">time.sleep(1)  # 单位是秒。0.1秒则代表100毫秒。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">import gc</span></span></li><li><span class="name"><span class="innerContentContainer">python 不需要做内存管理. 但理解内存模式还是很有价值的. Python提供如下函数帮助我们理解:</span></span></li><li><span class="name"><span class="innerContentContainer">id(my) &nbsp;# my是一个对象, id()返回它的内存地址.</span></span></li><li><span class="name"><span class="innerContentContainer">使用sys包中的getrefcount()，来查看某个对象的引用计数。注意,&nbsp;getrefcount()所得到的结果，会比期望的多1。因为它自己也会创建一次应用.</span></span></li><li><span class="name"><span class="innerContentContainer">globals(): 获取保存所有全局变量的词典. Python用统一的字典维护所有的全局变量.</span></span></li><li><span class="name"><span class="innerContentContainer">容器对象的引用可能构成很复杂的拓扑结构。我们可以用 objgraph包 来绘制其引用关系，比如:</span></span><ul><li><span class="name"><span class="innerContentContainer">import objgraph</span></span></li><li><span class="name"><span class="innerContentContainer">objgraph.show_refs([z], filename='ref_topo.png’)</span></span></li><li><span class="name"><span class="innerContentContainer">objgraph是Python的一个第三方包。安装之前需要安装xdot。 参见:&nbsp;http://mg.pov.lt/objgraph/</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">垃圾回收机制</span></span><ul><li><span class="name"><span class="innerContentContainer">当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。</span></span></li><li><span class="name"><span class="innerContentContainer">但是减肥是个昂贵而费力的事情。Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</span></span></li><li><span class="name"><span class="innerContentContainer">通过gc模块的get_threshold()方法，查看该阈值:</span></span><ul><li><span class="name"><span class="innerContentContainer">print(gc.get_threshold())</span></span></li><li><span class="name"><span class="innerContentContainer">返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">我们也可以手动启动垃圾回收，即使用gc.collect()。</span></span></li><li><span class="name"><span class="innerContentContainer">Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</span></span></li><li><span class="name"><span class="innerContentContainer">Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</span></span></li><li><span class="name"><span class="innerContentContainer">这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</span></span></li><li><span class="name"><span class="innerContentContainer">同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</span></span><ul><li><span class="name"><span class="innerContentContainer">gc.set_threshold(700, 10, 5)</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">文件</span></span><ul><li><span class="name"><span class="innerContentContainer">Python 文件文件夹方法参见： https://www.runoob.com/python/os-file-methods.html</span></span></li><li><span class="name"><span class="innerContentContainer">Python 文件方法参见： https://www.runoob.com/python/file-methods.html</span></span></li><li><span class="name"><span class="innerContentContainer">获取路径分隔符： os.sep</span></span><ul><li><span class="name"><span class="innerContentContainer">Windows上是'\'</span></span></li><li><span class="name"><span class="innerContentContainer">Linux上是'/'</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取行终止符： os.linesp</span></span><ul><li><span class="name"><span class="innerContentContainer">Windows使用 '\r\n'</span></span></li><li><span class="name"><span class="innerContentContainer">Linux使用 '\n'</span></span></li><li><span class="name"><span class="innerContentContainer">Mac使用 '\r'</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取特定目录</span></span><ul><li><span class="name"><span class="innerContentContainer">返回当前目录：os.getcwd()</span></span></li><li><span class="name"><span class="innerContentContainer">返回上一级目录：os.chdir("..")</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件夹和文件的存在性</span></span><ul><li><span class="name"><span class="innerContentContainer">是否存在：os.path.exists()</span></span></li><li><span class="name"><span class="innerContentContainer">是否为文件：os.path.isfile()</span></span></li><li><span class="name"><span class="innerContentContainer">是否为目录：os.path.isdir()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件夹的新建和删除</span></span><ul><li><span class="name"><span class="innerContentContainer">新建单级目录：os.mkdir(path)</span></span></li><li><span class="name"><span class="innerContentContainer">新建多级目录：os.makedirs(path)</span></span></li><li><span class="name"><span class="innerContentContainer">删除单层目录： os.rmdir(path). 要求是空目录</span></span></li><li><span class="name"><span class="innerContentContainer">删除多层目录：os.removedirs(path)， 递归删除目录和子目录，要求都是空目录。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件夹和文件的遍历：</span></span><ul><li><span class="name"><span class="innerContentContainer">os.listdir(path)</span></span><ul><li><span class="name"><span class="innerContentContainer">返回指定文件夹包含的文件或子文件夹的名字的列表。这个列表以字母顺序，不包括 '.' 和'..' 。</span></span></li><li><span class="name"><span class="innerContentContainer">只支持在 Unix, Windows 下使用。</span></span></li><li><span class="name"><span class="innerContentContainer">myDirs = os.listdir("/var/www/html/")</span></span></li><li><span class="name"><span class="innerContentContainer">for file in myDirs:</span></span><ul><li><span class="name"><span class="innerContentContainer">print file</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">os.walk(path)</span></span><ul><li><span class="name"><span class="innerContentContainer">os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>topdown</b>&nbsp;--可选，为 True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。如果 topdown 参数为 True，walk 会遍历top文件夹，与top 文件夹中每一个子目录。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onerror</b>&nbsp;-- 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>followlinks</b>&nbsp;-- 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回指定文件夹包含的文件或子文件夹的名字的三元组。</span></span></li><li><span class="name"><span class="innerContentContainer">返回值格式是 (当前路径, [包含子目录], [包含文件]) 的元组。</span></span></li><li><span class="name"><span class="innerContentContainer">for root, dirs, files in os.walk(".", topdown=False):</span></span><ul><li><span class="name"><span class="innerContentContainer">for name in files:</span></span><ul><li><span class="name"><span class="innerContentContainer">print(os.path.join(root, name))</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">for name in dirs:</span></span><ul><li><span class="name"><span class="innerContentContainer">print(os.path.join(root, name))</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">文件的打开模式</span></span><ul><li><span class="name"><span class="innerContentContainer">‘r’&nbsp;&nbsp;&nbsp;&nbsp; 只读模式。如果文件不存在，返回异常FileNotFoundError, 默认值。</span></span></li><li><span class="name"><span class="innerContentContainer">‘w’&nbsp;&nbsp;&nbsp; 覆盖写模式，文件不存在则创建，存在则完全覆盖；</span></span></li><li><span class="name"><span class="innerContentContainer">'x'&nbsp;&nbsp;&nbsp;&nbsp; 创建写模式，文件不存在则创建，存在则返回异常FileExistError；</span></span></li><li><span class="name"><span class="innerContentContainer">‘a’&nbsp;&nbsp;&nbsp; 追加写模式，文件不存在则创建，存在则在文件最后追加内容；</span></span></li><li><span class="name"><span class="innerContentContainer">‘t’&nbsp;&nbsp;&nbsp;  文本文件模式，默认值；</span></span></li><li><span class="name"><span class="innerContentContainer">‘b’ &nbsp;&nbsp; 二进制文件模式；</span></span></li><li><span class="name"><span class="innerContentContainer">'+'&nbsp;&nbsp;&nbsp; 与r/w/x/a一同使用，在原功能的基础上增加同时读写的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件的读、写、新建</span></span><ul><li><span class="name"><span class="innerContentContainer">myFile = open('test.log', 'w')  </span></span></li><li><span class="name"><span class="innerContentContainer">myFile.seek(-128, 2)   # 参见后面解释</span></span></li><li><span class="name"><span class="innerContentContainer">myFile.write('test succeeded')</span></span></li><li><span class="name"><span class="innerContentContainer">myFile.close()</span></span></li><li><span class="name"><span class="innerContentContainer">file('test.log').read()    # 读出整个文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">遍历文件：<b>seek</b></span></span><ul><li><span class="name"><span class="innerContentContainer">seek(offset[,whence])，将文件读写操作标记移到offset的位置。</span></span></li><li><span class="name"><span class="innerContentContainer">第一个参数：offset一般是相对于文件的开头来计算的，一般为正数。</span></span></li><li><span class="name"><span class="innerContentContainer">第二个参数：whence参数，为0表示从头开始计算，1表示以当前位置开始计算。2表示以文件末尾为原点进行计算。</span></span></li><li><span class="name"><span class="innerContentContainer">需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件的删除:&nbsp;os.remove()</span></span></li><li><span class="name"><span class="innerContentContainer">文件改名、修改属性:&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">os.rename("oldname","newname")   # 文件或目录都是使用这条命令</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">行读</span></span><ul><li><span class="name"><span class="innerContentContainer">myFile.<b>readline</b>([size])  # 读一行，如果定义了size，有可能返回的是一行的一部分</span></span></li><li><span class="name"><span class="innerContentContainer">myFile.<b>readlines</b>([size])  # 把文件每一行作为一个list的一个成员，并返回这个list。</span></span><ul><li><span class="name"><span class="innerContentContainer">其实它的内部是通过循环调用readline()来实现的。</span></span></li><li><span class="name"><span class="innerContentContainer">size指定读取内容的总长，给定size值则可能只读到文件的一部分。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">把整个文件读入列表中</span></span><ul><li><span class="name"><span class="innerContentContainer">myFile.seek(0,0)</span></span></li><li><span class="name"><span class="innerContentContainer">for eachLine in myFile:</span></span><ul><li><span class="name"><span class="innerContentContainer">print(eachLine)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">with…as  （推荐使用）</span></span><ul><li><span class="name"><span class="innerContentContainer">with open('nothing.txt','r') as f:</span></span><ul><li><span class="name"><span class="innerContentContainer">f.read()</span></span></li><li><span class="name"><span class="innerContentContainer">print 2/0</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">print 'continue'</span></span></li><li><span class="name"><span class="innerContentContainer">with语句块完毕之后，会隐含的自动关闭文件。避免在各异常分支都要关闭文件。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">类的进一步讨论</span></span><ul><li><span class="name"><span class="innerContentContainer">继承</span></span><ul><li><span class="name"><span class="innerContentContainer"># 定义父类</span></span></li><li><span class="name"><span class="innerContentContainer">class AddBook(object):</span></span><ul><li><span class="name"><span class="innerContentContainer">def __init__(self, name, phone):</span></span><ul><li><span class="name"><span class="innerContentContainer">self.name = name</span></span></li><li><span class="name"><span class="innerContentContainer">self.phone = phone</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">def get_phone(self):</span></span><ul><li><span class="name"><span class="innerContentContainer">return self.phone</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"># 定义子类</span></span></li><li><span class="name"><span class="innerContentContainer">class EmplEmail(AddBook):</span></span><ul><li><span class="name"><span class="innerContentContainer">def __init__(self, nm, ph, email):</span></span><ul><li><span class="name"><span class="innerContentContainer">AddBook.__init__(self, nm, ph)   # 调用父类的构造方法。一般必须如此。  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">super(EmplEmail, self).__init__(nm, ph) # 另外一种调用父类构造方法  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">self.email = email</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">def get_email(self):</span></span><ul><li><span class="name"><span class="innerContentContainer">return self.email</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"># 使用这些类</span></span></li><li><span class="name"><span class="innerContentContainer">if __name__ == "__main__":</span></span><ul><li><span class="name"><span class="innerContentContainer">Detian = AddBook('handetian', '18210413001')</span></span></li><li><span class="name"><span class="innerContentContainer">print Detian.get_phone()</span></span></li><li><span class="name"><span class="innerContentContainer">alice = EmplEmail('alice', '18210418888', '<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:alice@xkops.com">alice@xkops.com</a>')</span></span></li><li><span class="name"><span class="innerContentContainer">print alice.get_email(), alice.get_phone()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">组合</span></span><ul><li><span class="name"><span class="innerContentContainer"># A类</span></span></li><li><span class="name"><span class="innerContentContainer">class Info(object):</span></span><ul><li><span class="name"><span class="innerContentContainer">def __init__(self, phone, email):</span></span><ul><li><span class="name"><span class="innerContentContainer">self.phone = phone</span></span></li><li><span class="name"><span class="innerContentContainer">self.email = email</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">def get_phone(self):</span></span><ul><li><span class="name"><span class="innerContentContainer">return self.phone</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">def update_phone(self, newphone):</span></span><ul><li><span class="name"><span class="innerContentContainer">self.phone = newphone</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"># B类。B包含A。</span></span></li><li><span class="name"><span class="innerContentContainer">class AddrBook(object):</span></span><ul><li><span class="name"><span class="innerContentContainer">def __init__(self, name, phone, email):</span></span><ul><li><span class="name"><span class="innerContentContainer">self.name = name</span></span></li><li><span class="name"><span class="innerContentContainer">self.info = Info(phone, email)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">if __name__ == "__main__":</span></span><ul><li><span class="name"><span class="innerContentContainer">Detian = AddrBook('handetian', '18210413001', '<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:detian@xkops.com">detian@xkops.com</a>', '123456')</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">类的预置函数</span></span><ul><li><span class="name"><span class="innerContentContainer">def __str__(self): &nbsp; &nbsp; &nbsp; # 打印对象时调用。</span></span></li><li><span class="name"><span class="innerContentContainer">def __repr__(self):&nbsp;&nbsp; &nbsp;&nbsp;# 和上面类似，但是是在交互执行的模式下打印。</span></span></li><li><span class="name"><span class="innerContentContainer">def __call__(self):&nbsp;&nbsp; &nbsp;&nbsp;# 这个有点特殊，定义后可以让对象象函数一样被调用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运算符重载（用预置函数实现）</span></span><ul><li><span class="name"><span class="innerContentContainer">__add__	 运算符+	如果没有_iadd_， X+Y， X+=Y</span></span></li><li><span class="name"><span class="innerContentContainer">__sub__   运算符-</span></span></li><li><span class="name"><span class="innerContentContainer">__or__	运算符|	如果没有_ior_，X|Y, X|=Y</span></span></li><li><span class="name"><span class="innerContentContainer">__getitem__	索引运算	X[key]，X[i:j]</span></span></li><li><span class="name"><span class="innerContentContainer">__setitem__	索引赋值语句	X[key]，X[i:j]=sequence</span></span></li><li><span class="name"><span class="innerContentContainer">__delitem__	索引和分片删除	del X[key]，del X[i:j]</span></span></li><li><span class="name"><span class="innerContentContainer">__len__	长度	len(X)，如果没有__bool__，真值测试</span></span></li><li><span class="name"><span class="innerContentContainer">__bool__	布尔测试	bool(X)</span></span></li><li><span class="name"><span class="innerContentContainer">__lt__, __gt__, __le__, __ge__, __eq__, __ne__	特定的比较	X&lt;Y，X&gt;Y，X&lt;=Y，X&gt;=Y，X==Y，X!=Y</span></span></li><li><span class="name"><span class="innerContentContainer">__radd__	   右侧加法	other+X</span></span></li><li><span class="name"><span class="innerContentContainer">__iadd__	实地（增强的）加法	X+=Y(or else __add__)</span></span></li><li><span class="name"><span class="innerContentContainer">__iter__, __next__	迭代环境	I=iter(X), next()</span></span></li><li><span class="name"><span class="innerContentContainer">__contains__	成员关系测试	item in X(任何可迭代)</span></span></li><li><span class="name"><span class="innerContentContainer">__index__	整数值	hex(X), bin(X),&nbsp; oct(X)</span></span></li><li><span class="name"><span class="innerContentContainer">__get__, __set__,</span></span></li><li><span class="name"><span class="innerContentContainer">__delete__	描述符属性	X.attr, X.attr=value, del X.attr</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对象的序列化</span></span><ul><li><span class="name"><span class="innerContentContainer">即把对象保存到文件，以及从文件中恢复的技术。</span></span></li><li><span class="name"><span class="innerContentContainer">import pickle</span></span></li><li><span class="name"><span class="innerContentContainer">myList = [1, 2, 3.14, "abc", [1, 2]]</span></span></li><li><span class="name"><span class="innerContentContainer">pickle_file = open("d:\\my.pk", 'wb')</span></span></li><li><span class="name"><span class="innerContentContainer">pickle.<b>dump</b>(myList, pickle_file)   # 把对象写入文件</span></span></li><li><span class="name"><span class="innerContentContainer">myList2 = pickle.<b>load</b>(pickle_file)   # 读取对象</span></span></li><li><span class="name"><span class="innerContentContainer">pickle_file.close()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">列表, list</span></span><ul><li><span class="name"><span class="innerContentContainer">定义列表</span></span><ul><li><span class="name"><span class="innerContentContainer">python中的数组叫list, list用 [] 来初始化。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList = ["a", "b", "mpilgrim", "z", "example"], myList为一个5元素的list，每个元素都是个字符串。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>不同类型的元素可以放在同一个数组中。</b></span></span></li><li><span class="name"><span class="innerContentContainer">初始化之后, 就不可以改变元素的类型.</span></span></li><li><span class="name"><span class="innerContentContainer">空数组的初始化: myList = []</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>range</b>函数</span></span><ul><li><span class="name"><span class="innerContentContainer">list的递增赋值:&nbsp;range(n) 会生成一个0 到 n-1 的list。</span></span></li><li><span class="name"><span class="innerContentContainer">range(start=0, stop[, step=1]): 计数从 start 开始, 到 stop 结束, 步长为 step.</span></span></li><li><span class="name"><span class="innerContentContainer">一个很酷的技巧是利用 range 和 tuple配合，生成枚举量。比如: (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7). 然后 MONDAY=0，TUESDAY=1.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">遍历数组</span></span><ul><li><span class="name"><span class="innerContentContainer">通过下标取元素。下标可以是负值，表示从尾部取，最后一个元素的负下标是 -1.</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList[0]</span></span></li><li><span class="name"><span class="innerContentContainer">输出: ‘a’</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList[-1]</span></span></li><li><span class="name"><span class="innerContentContainer">输出: 'example'</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">由值获取index</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList.index("example")</span></span></li><li><span class="name"><span class="innerContentContainer">输出: 5</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">判断元素的存在性:</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; "c" in&nbsp;myList</span></span></li><li><span class="name"><span class="innerContentContainer">输出: False</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">数组的size:&nbsp;len(myList)</span></span></li><li><span class="name"><span class="innerContentContainer">元素增加</span></span><ul><li><span class="name"><span class="innerContentContainer">myList.<b>append</b>("new")   # 在最后位置添加。</span></span></li><li><span class="name"><span class="innerContentContainer">myList.<b>insert</b>(2, "new")   # 在指定位置添加</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">元素删除</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种方式: </span></span></li><li><span class="name"><span class="innerContentContainer">第一种: <b>remove.</b></span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList.<b>remove</b>("z")</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt;&nbsp;myList</span></span></li><li><span class="name"><span class="innerContentContainer">['a', 'b', 'new', 'mpilgrim']</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意：remove只删除第一次出现的元素。</span></span></li><li><span class="name"><span class="innerContentContainer">第二种,  用 <b>del </b>删除. </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>del</b>&nbsp;myList[0] &nbsp;# 删除第一个元素</span></span></li><li><span class="name"><span class="innerContentContainer">del myList  # 删除整个列表</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">pop: 弹出一个元素, 并返回该元素</span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList.<b>pop</b>()</span></span></li><li><span class="name"><span class="innerContentContainer">'mpilgrim'</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt;&nbsp;myList</span></span></li><li><span class="name"><span class="innerContentContainer">['a', 'b', 'new’]</span></span></li><li><span class="name"><span class="innerContentContainer">也可以指定index, 比如: pop(2)  # 弹出第三个元素</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">两个数组的连接</span></span><ul><li><span class="name"><span class="innerContentContainer">myList.<b>extend</b>(["two", "elements"])</span></span></li><li><span class="name"><span class="innerContentContainer">注意：["two", "elements"] 为一个新的list。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数组的分片</span></span><ul><li><span class="name"><span class="innerContentContainer">数组的分片指返回当前list的子集, 也是一个list.</span></span></li><li><span class="name"><span class="innerContentContainer"><b> [m:n] </b>表示从头数第m个元素到第n个元素的分片（从0开始计数, 不包括n），负数表示从后面往前算. </span></span><ul><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt;&nbsp;myList</span></span></li><li><span class="name"><span class="innerContentContainer">['a', 'b', 'mpilgrim', 'z', 'example’] &nbsp;# 整体</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList[0:3]</span></span></li><li><span class="name"><span class="innerContentContainer">['a', 'b', ‘mpilgrim']</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myList[1:-1]</span></span></li><li><span class="name"><span class="innerContentContainer">['b', 'mpilgrim', 'z']</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">[:2]   # 等价于[0:2]</span></span></li><li><span class="name"><span class="innerContentContainer">[2:]   # 等价于[2:最后一个]</span></span></li><li><span class="name"><span class="innerContentContainer">[0:9:2]  # 第三个参数表示步长, 2 表示每两个取一个. 如果步长是负数, 则从后面向前取</span></span></li><li><span class="name"><span class="innerContentContainer">[::-1]  # 相当于取到一个反转的列表.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">元组, tuple</span></span><ul><li><span class="name"><span class="innerContentContainer">元组也是属于序列的一种，但是元组是不可变的，定义之后，不能再改变元素。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">创建元组使用小括号.  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myTuple&nbsp;= ("a", "b", "mpilgrim", "z", "example")</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myTuple[0]</span></span></li><li><span class="name"><span class="innerContentContainer">'a'</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myTuple[-1]</span></span></li><li><span class="name"><span class="innerContentContainer">'example'</span></span></li><li><span class="name"><span class="innerContentContainer">&gt;&gt;&gt; myTuple[1:3]</span></span></li><li><span class="name"><span class="innerContentContainer">('b', 'mpilgrim')</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">序列</span></span><ul><li><span class="name"><span class="innerContentContainer">python内建了6种序列：列表、元组、字符串、unicode字符串、buffer对象、xrange对象。</span></span></li><li><span class="name"><span class="innerContentContainer">所有序列都可以进行某些特定的操作：索引、分片、加、乘、检查某个元素是否属于序列的成员（成员资格）、内建函数（长度、最小值、最大值）, 以及迭代。</span></span></li><li><span class="name"><span class="innerContentContainer">索引</span></span><ul><li><span class="name"><span class="innerContentContainer">序列中所有元素都是有下标的. 从0开始，可通过下标进行访问。</span></span></li><li><span class="name"><span class="innerContentContainer">通过情况下下标为正数，但是python中也可以为负数，代表从右开始计数。若为负数时，开头第一位数为-1，而不是0，这样避免了与从左开始的第一个元素重合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分片</span></span><ul><li><span class="name"><span class="innerContentContainer">即取序列的一部分. 通过指定起止下标来获取序列的子集.</span></span></li><li><span class="name"><span class="innerContentContainer">和索引一样, 分片时也允许负数. 而且有多种简写形式.</span></span></li><li><span class="name"><span class="innerContentContainer">numbers=[1,2,3,4,5,6,7,8,9,10]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[3:6]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[0:1]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[-5:-1]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[-11:0]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[-3:]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[:3]</span></span></li><li><span class="name"><span class="innerContentContainer">numbers[:]</span></span></li><li><span class="name"><span class="innerContentContainer">分片时还可以指定步长，步长通常不指定，取其默认值1. 如果设置则会按照步长来遍历序列中的元素。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">序列相加</span></span><ul><li><span class="name"><span class="innerContentContainer">使用+运算符进行序列的连接操作.</span></span></li><li><span class="name"><span class="innerContentContainer">同一类型可以进行连接，不然会抛出异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">成员资格</span></span><ul><li><span class="name"><span class="innerContentContainer">即检查当前元素是否在指定序列中。若存在，返回true，否则返回false。</span></span></li><li><span class="name"><span class="innerContentContainer">str='python'</span></span></li><li><span class="name"><span class="innerContentContainer">'p' in str  ==&gt; true</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">长度、最小值和最大值</span></span><ul><li><span class="name"><span class="innerContentContainer">最大：max</span></span></li><li><span class="name"><span class="innerContentContainer">长度：len</span></span></li><li><span class="name"><span class="innerContentContainer">最小：min</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">迭代</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dict（字典，hash表）</span></span><ul><li><span class="name"><span class="innerContentContainer">hash表的特点是基于key字符串存取数据。</span></span></li><li><span class="name"><span class="innerContentContainer">Python中的hash表即dictionary，字典。它的特点是<b>key</b>除了字符串之外，还可以是任何对象，包括整数。</span></span></li><li><span class="name"><span class="innerContentContainer">字典是Python支持的唯一的映射类型。</span></span></li><li><span class="name"><span class="innerContentContainer">dict的定义</span></span><ul><li><span class="name"><span class="innerContentContainer">myDict = {}    # 定义一个空字典</span></span></li><li><span class="name"><span class="innerContentContainer">myDict = {"server":"mpilgrim", "database":"master"}    # 定义一个有两个元素的字典</span></span></li><li><span class="name"><span class="innerContentContainer">myDict = dict(Fs=70, ii=105, s=115)  # 注意key不要加引号, 但是真正存的是字符串。这种方式比较自然。</span></span></li><li><span class="name"><span class="innerContentContainer">其中：定义dictionary 使用 {}，key-value 对用逗号分隔；前面为key，后面为value。</span></span></li><li><span class="name"><span class="innerContentContainer">key 不可重复（大小写敏感）, value 可重复。</span></span></li><li><span class="name"><span class="innerContentContainer">dict 中的元素是无序的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dict的size: len(myDict)</span></span></li><li><span class="name"><span class="innerContentContainer">dict的遍历</span></span><ul><li><span class="name"><span class="innerContentContainer">通过key 访问 value，反过来不行。</span></span></li><li><span class="name"><span class="innerContentContainer">dictionary 的 keys, values 和 items 函数，输出为list。</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>keys</b>()  ==&gt; ['server', 'database']    # 返回所有key的列表</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>values</b>() ==&gt;['mpilgrim', 'master']     # 返回所有value的列表</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>items</b>() ==&gt;[('server', 'mpilgrim'), ('database', 'master')]  # 返回一个形如 (key, value) 的 tuple 的 list。</span></span></li><li><span class="name"><span class="innerContentContainer">["%s=%s" % (k, v) for k, v in myDict.<b>items</b>()]  ==&gt;['server=mpilgrim', 'database=master']</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>get</b>(key, default=None)   # 返回指定键的值。如果值不在字典中则返回default值</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>setdefault</b>(key, default=None)   # 返回指定键的值。如果键不存在于字典中，将会添加键并将值设为default</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>has_key</b>(key)  # 如果键在字典dict里返回true，否则返回false</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dict成员的修改、新增、删除</span></span><ul><li><span class="name"><span class="innerContentContainer">修改和新增</span></span><ul><li><span class="name"><span class="innerContentContainer">myDict = {}</span></span></li><li><span class="name"><span class="innerContentContainer">myDict["key1"] = "value"   # 新增</span></span></li><li><span class="name"><span class="innerContentContainer">myDict["key1"] = "value2"   # 修改值</span></span></li><li><span class="name"><span class="innerContentContainer">myDict[42] = "value3"  # 新增。注意, 42是个key, 而不是下标.</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.update(42="狗")     # 更新指定key的值。</span></span></li><li><span class="name"><span class="innerContentContainer">myDict ==&gt; {'key1': 'value2', 42: '狗'}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">删除</span></span><ul><li><span class="name"><span class="innerContentContainer">del myDict[42]    # 按key删除</span></span></li><li><span class="name"><span class="innerContentContainer">del myDict["retrycount"]   # 按key删除</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.clear()    # 删除所有</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">弹出</span></span><ul><li><span class="name"><span class="innerContentContainer">myDict.<b>pop</b>(key[,default])   # 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。如果key不存在，则返回default</span></span></li><li><span class="name"><span class="innerContentContainer">myDict.<b>popitem</b>()  # 返回并删除字典中的最后一对键和值</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">dict 复制</span></span><ul><li><span class="name"><span class="innerContentContainer">myDict.<b>copy</b>()  # 返回字典的浅复制。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">集合，set</span></span><ul><li><span class="name"><span class="innerContentContainer">集合在Python中用处不大，主要用于去掉重复值。</span></span></li><li><span class="name"><span class="innerContentContainer">使用多个量来定义集合，最终集合中只留下非重复的值。</span></span></li><li><span class="name"><span class="innerContentContainer">mySet = {1, 2, 3, 1, 2, 3}</span></span></li><li><span class="name"><span class="innerContentContainer">mySet ==&gt; {1, 2, 3}</span></span></li><li><span class="name"><span class="innerContentContainer">所以要去掉列表中的重复值，可以这样： myList = list(set(myList))</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">异常处理</span></span><ul><li><span class="name"><span class="innerContentContainer">异常处理的关键字是 try，except，else，finally。如： <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">myStr = 'Hello girl!'</span></span></li><li><span class="name"><span class="innerContentContainer">try:</span></span><ul><li><span class="name"><span class="innerContentContainer">print myStr[100]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">except IndexError:   # 指定捕捉这种异常。如果不指定，则捕捉任何异常。可以跟多个异常。</span></span><ul><li><span class="name"><span class="innerContentContainer">print 'IndexError error'</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">finally:</span></span><ul><li><span class="name"><span class="innerContentContainer">print 'error handled'  # 无论异常发生与否，finally中的语句都要执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">print 'continue'   # 异常处理完，继续执行下面的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">使用 raise 语句可主动触发异常。</span></span></li><li><span class="name"><span class="innerContentContainer">Python内置的异常种类</span></span><ul><li><span class="name"><span class="innerContentContainer">BaseException&nbsp; # 所有异常的基类</span></span><ul><li><span class="name"><span class="innerContentContainer">+-- SystemExit&nbsp; # 解释器请求退出</span></span></li><li><span class="name"><span class="innerContentContainer">+-- KeyboardInterrupt&nbsp; # 用户中断执行(通常是输入^C)</span></span></li><li><span class="name"><span class="innerContentContainer">+-- GeneratorExit&nbsp; # 生成器(generator)发生异常来通知退出</span></span></li><li><span class="name"><span class="innerContentContainer">+-- Exception&nbsp; # 常规异常的基类</span></span><ul><li><span class="name"><span class="innerContentContainer">+-- StopIteration&nbsp; # 迭代器没有更多的值</span></span></li><li><span class="name"><span class="innerContentContainer">+-- StopAsyncIteration&nbsp; # 必须通过异步迭代器对象的__anext__()方法引发以停止迭代</span></span></li><li><span class="name"><span class="innerContentContainer">+-- ArithmeticError&nbsp; # 各种算术错误引发的内置异常的基类</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- FloatingPointError&nbsp; # 浮点计算错误</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- OverflowError&nbsp; # 数值运算结果太大无法表示</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- ZeroDivisionError&nbsp; # 除(或取模)零 (所有数据类型)</span></span></li><li><span class="name"><span class="innerContentContainer">+-- AssertionError&nbsp; # 当assert语句失败时引发</span></span></li><li><span class="name"><span class="innerContentContainer">+-- AttributeError&nbsp; # 属性引用或赋值失败</span></span></li><li><span class="name"><span class="innerContentContainer">+-- BufferError&nbsp; # 无法执行与缓冲区相关的操作时引发</span></span></li><li><span class="name"><span class="innerContentContainer">+-- EOFError&nbsp; # 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发</span></span></li><li><span class="name"><span class="innerContentContainer">+-- ImportError&nbsp; # 导入模块/对象失败</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- ModuleNotFoundError&nbsp; # 无法找到模块或在在sys.modules中找到None</span></span></li><li><span class="name"><span class="innerContentContainer">+-- LookupError&nbsp; # 映射或序列上使用的键或索引无效时引发的异常的基类</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- IndexError&nbsp; # 序列中没有此索引(index)</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- KeyError&nbsp; # 映射中没有这个键</span></span></li><li><span class="name"><span class="innerContentContainer">+-- MemoryError&nbsp; # 内存溢出错误(对于Python 解释器不是致命的)</span></span></li><li><span class="name"><span class="innerContentContainer">+-- NameError&nbsp; # 未声明/初始化对象 (没有属性)</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- UnboundLocalError&nbsp; # 访问未初始化的本地变量</span></span></li><li><span class="name"><span class="innerContentContainer">+-- OSError&nbsp; # 操作系统错误，EnvironmentError，IOError，WindowsError，socket.error，select.error和mmap.error已合并到OSError中，构造函数可能返回子类</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- BlockingIOError&nbsp; # 操作将阻塞对象(e.g. socket)设置为非阻塞操作</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- ChildProcessError&nbsp; # 在子进程上的操作失败</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- ConnectionError&nbsp; # 与连接相关的异常的基类</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- BrokenPipeError&nbsp; # 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- ConnectionAbortedError&nbsp; # 连接尝试被对等方中止</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- ConnectionRefusedError&nbsp; # 连接尝试被对等方拒绝</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; |&nbsp; &nbsp; +-- ConnectionResetError&nbsp; &nbsp; # 连接由对等方重置</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- FileExistsError&nbsp; # 创建已存在的文件或目录</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- FileNotFoundError&nbsp; # 请求不存在的文件或目录</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- InterruptedError&nbsp; # 系统调用被输入信号中断</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- IsADirectoryError&nbsp; # 在目录上请求文件操作(例如 os.remove())</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- NotADirectoryError&nbsp; # 在不是目录的事物上请求目录操作(例如 os.listdir())</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- PermissionError&nbsp; # 尝试在没有足够访问权限的情况下运行操作</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- ProcessLookupError&nbsp; # 给定进程不存在</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- TimeoutError&nbsp; # 系统函数在系统级别超时</span></span></li><li><span class="name"><span class="innerContentContainer">+-- ReferenceError&nbsp; # weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象</span></span></li><li><span class="name"><span class="innerContentContainer">+-- RuntimeError&nbsp; # 在检测到不属于任何其他类别的错误时触发</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- NotImplementedError&nbsp; # 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- RecursionError&nbsp; # 解释器检测到超出最大递归深度</span></span></li><li><span class="name"><span class="innerContentContainer">+-- SyntaxError&nbsp; # Python 语法错误</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- IndentationError&nbsp; # 缩进错误</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- TabError&nbsp; # Tab和空格混用</span></span></li><li><span class="name"><span class="innerContentContainer">+-- SystemError&nbsp; # 解释器发现内部错误</span></span></li><li><span class="name"><span class="innerContentContainer">+-- TypeError&nbsp; # 操作或函数应用于不适当类型的对象</span></span></li><li><span class="name"><span class="innerContentContainer">+-- ValueError&nbsp; # 操作或函数接收到具有正确类型但值不合适的参数</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; +-- UnicodeError&nbsp; # 发生与Unicode相关的编码或解码错误</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- UnicodeDecodeError&nbsp; # Unicode解码错误</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- UnicodeEncodeError&nbsp; # Unicode编码错误</span></span></li><li><span class="name"><span class="innerContentContainer">|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+-- UnicodeTranslateError&nbsp; # Unicode转码错误</span></span></li><li><span class="name"><span class="innerContentContainer">+-- Warning&nbsp; # 警告的基类</span></span><ul><li><span class="name"><span class="innerContentContainer">+-- DeprecationWarning&nbsp; # 有关已弃用功能的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- PendingDeprecationWarning&nbsp; # 有关不推荐使用功能的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- RuntimeWarning&nbsp; # 有关可疑的运行时行为的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- SyntaxWarning&nbsp; # 关于可疑语法警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- UserWarning&nbsp; # 用户代码生成警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- FutureWarning&nbsp; # 有关已弃用功能的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- ImportWarning&nbsp; # 关于模块导入时可能出错的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- UnicodeWarning&nbsp; # 与Unicode相关的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- BytesWarning&nbsp; # 与bytes和bytearray相关的警告的基类</span></span></li><li><span class="name"><span class="innerContentContainer">+-- ResourceWarning&nbsp; # 与资源使用相关的警告的基类。被默认警告过滤器忽略。</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">定义一个装饰器实现非常规try except，装饰器中定义一个默认参数来决定是否打印异常</span></span><ul><li><span class="name"><span class="innerContentContainer">def tryfun(printdebug=True):</span></span><ul><li><span class="name"><span class="innerContentContainer">def inner1(f):</span></span><ul><li><span class="name"><span class="innerContentContainer">def inner2(*args, **kwargs):</span></span><ul><li><span class="name"><span class="innerContentContainer">try:</span></span><ul><li><span class="name"><span class="innerContentContainer">res = f(*args, **kwargs)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">except Exception as err:</span></span><ul><li><span class="name"><span class="innerContentContainer">if <b>printdebug</b>:</span></span><ul><li><span class="name"><span class="innerContentContainer">import sys</span></span></li><li><span class="name"><span class="innerContentContainer">info = sys.exc_info()[2].tb_frame.f_back</span></span></li><li><span class="name"><span class="innerContentContainer">temp = "filename:{}\nlines:{}\tfuncation:{}\terror:{}"</span></span></li><li><span class="name"><span class="innerContentContainer">print(temp.format(info.f_code.co_filename, info.f_lineno, f.__name__, repr(err)))</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">res = None</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return res</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return inner2</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return inner1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用时：</span></span><ul><li><span class="name"><span class="innerContentContainer">@ tryfun()</span></span></li><li><span class="name"><span class="innerContentContainer">def div(a, b):</span></span><ul><li><span class="name"><span class="innerContentContainer">return float(a) / float(b)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ret = div(3, 'mo')</span></span></li><li><span class="name"><span class="innerContentContainer">print(ret)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">断言</span></span><ul><li><span class="name"><span class="innerContentContainer">assert exp: exp 为假时, 程序自动崩溃, 并抛出 AssertionError 异常. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">UT</span></span><ul><li><span class="name"><span class="innerContentContainer">把ut代码放在：&nbsp;if __name__ == "__main__": 分支中，可以保证当模块被包含时这些代码自动不生效。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">平台兼容性</span></span><ul><li><span class="name"><span class="innerContentContainer">获取操作系统名称：os.name</span></span><ul><li><span class="name"><span class="innerContentContainer">对于Windows，它是'nt'；</span></span></li><li><span class="name"><span class="innerContentContainer">对于Linux/Unix，它是'posix'。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运行系统shell命令：os.system</span></span><ul><li><span class="name"><span class="innerContentContainer">os.system("calc")   # 打开系统计算器</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">泛型</span></span></li></ul>
  </body>
</html>