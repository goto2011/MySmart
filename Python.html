<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">Python</span><ul><li><span class="name">代码组织方式</span><ul><li><span class="name">最小编程规范</span><ul><li><span class="name">模板名/文件名: 全小写.</span></li><li><span class="name">类名:各单词首字母大写.</span></li><li><span class="name">方法名:第一个单词小写, 其它单词首字母大写;</span></li><li><span class="name">属性名:前缀m, 各单词首字母大写;</span></li><li><span class="name">局部变量:前缀my, 各单词首字母大写.</span></li></ul></li><li><span class="name">导入其它模块</span><ul><li><span class="name">通过 import + 文件名. 比如:&nbsp;import mymodule</span></li><li><span class="name">包括两种：py文件（Python写的）和sys文件（c写的）。</span></li></ul></li><li><span class="name">导入后如何调用函数?</span><ul><li><span class="name">mymodule.myFunc(params)</span></li></ul></li><li><span class="name">模块导入的搜索路径</span><ul><li><span class="name">在 sys.path 中维护路径.</span></li><li><span class="name">运行时可以新增路径，即：sys.path.append('/Volumes/Data/TensorFlow/abc/')，退出后该路径即不生效。</span></li></ul></li><li><span class="name">代码块定义</span><ul><li><span class="name">Python的核心特色就是通过缩进来表达代码的逻辑关系。</span></li><li><span class="name">代码块通过它们的缩进来定义的。 "代码块" 包括函数、if 语句、for 循环、while 循环, 等等。</span></li><li><span class="name">def myFunc(param):</span><ul><li><span class="name">if param&nbsp;&gt; 1:</span><ul><li><span class="name">return param&nbsp;* myFunc(param&nbsp;- 1)</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">return 1</span></li></ul></li></ul></li><li><span class="name">这是一个名为 myFunc&nbsp;的函数, 有一个参数 param。在函数内的所有代码都是缩进的。</span></li></ul></li><li><span class="name">模块执行入口</span><ul><li><span class="name">if __name__ == '__main__’:</span></li></ul></li></ul></li><li><span class="name">类和对象</span><ul><li><span class="name">“万物皆对象”：在Python中，变量是对象，字符串是对象，列表时对象，函数是对象，模块也是对象。但Python的对象定义比较松散。很多对象既没有属性没有方法，也不能子类化。</span></li><li><span class="name">申明类。注意，object是所有类的基类, 括号表示继承关系。</span><ul><li><span class="name">class MyClass(object):</span><ul><li><span class="name"># 构造方法。第一个参数是self。</span></li><li><span class="name">def __init__(self, room, cf=1.0):</span><ul><li><span class="name">self.room = room  # 引用属性，并赋值。</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.cf">self.cf</a> = cf</span></li></ul></li><li><span class="name"># 定义其它类方法</span></li><li><span class="name">def cacl_all(self, days=1):</span><ul><li><span class="name">return (self.room * <a class="contentLink" target="_blank" rel="noreferrer" href="http://self.cf">self.cf</a> + <a class="contentLink" target="_blank" rel="noreferrer" href="http://self.br">self.br</a>) * days</span></li></ul></li></ul></li></ul></li><li><span class="name">实例属性</span><ul><li><span class="name">self.room 即为对象属性, 实例化后一个对象一个. 在类方法中用&nbsp;self.room 引用.</span></li></ul></li><li><span class="name">类属性</span><ul><li><span class="name">在类内部,且在函数外定义的变量即为类属性. 为所有实例共享. 且可通过 类名.属性名 访问.&nbsp;</span></li></ul></li><li><span class="name">实例方法</span><ul><li><span class="name">def cacl_all(self, days=1):   # 注意: 第一个参数永远是 self.</span></li></ul></li><li><span class="name">类方法</span><ul><li><span class="name">类内以 <span class="contentTag" title="Filter @classmethod">@<span class="contentTagText">classmethod</span><span class="contentTagNub"></span></span> 定义的函数是类方法.</span></li><li><span class="name">第一个参数是本类的实例名. 可访问类属性和其它类方法, 并通过实例名访问实例属性和实例方法.</span></li></ul></li><li><span class="name">静态方法</span><ul><li><span class="name">类内以 <span class="contentTag" title="Filter @staticmethod">@<span class="contentTagText">staticmethod</span><span class="contentTagNub"></span></span> 定义的函数是静态方法.静态方法不能访问类的任何属性和方法. </span></li><li><span class="name">目的是为全局函数找个地方放, 和本类没关系. <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></li></ul></li><li><span class="name">调用类</span><ul><li><span class="name"># 定义类。注意初始化的方式。</span></li><li><span class="name">std_room = MyClass(200)</span></li><li><span class="name">big_room = MyClass(230, 0.9)</span></li><li><span class="name"># 调用类的方法</span></li><li><span class="name">print std_room.cacl_all()</span></li><li><span class="name">print big_room.cacl_all(3)</span></li></ul></li></ul></li><li><span class="name">Hello World！（含编译命令）</span><ul><li><span class="name">helloworld.py中如下. 其中第一行是必须的.</span></li><li><span class="name">#!/usr/bin/python</span></li><li><span class="name">print 'Hello World'</span></li><li><span class="name">运行：使用命令行输入命令，python <a class="contentLink" target="_blank" rel="noreferrer" href="http://helloworld.py">helloworld.py</a>。</span></li></ul></li><li><span class="name">注释</span><ul><li><span class="name"># 号开始的行是注释，只影响本行。</span></li><li><span class="name">连续3个引号 """ 定义一个多行注释，截止也是3个引号。</span></li><li><span class="name">函数体最开始的注释为函数文档，可以被IDE、代码访问。文档和代码融为一体。</span><ul><li><span class="name">myFunc.__doc__ 即可打印myFunc的函数级注释。</span></li><li><span class="name">可通过关键字 help 访问函数文档, help(myFunc)</span></li></ul></li></ul></li><li><span class="name">log打印</span><ul><li><span class="name">Python内置了一个log模块logging。例如：</span></li><li><span class="name">import logging</span></li><li><span class="name">LOG_FILENAME="~/log.txt" //// 打印到文件</span></li><li><span class="name">logging.basicConfig(filename=LOG_FILENAME,level=<a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.INFO">logging.INFO</a>) //// 设置基准等级</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.info">logging.info</a>("This message should go to the log file") //// 按info等级打印。</span></li><li><span class="name">其中，有6级log打印级别，分别是 CRITICAL、ERROR、WARNING、INFO、DEBUG、NOTSET，默认为WARNING。</span></li></ul></li><li><span class="name">函数（传值、传址、传引用）</span><ul><li><span class="name">函数定义</span><ul><li><span class="name">def myFunc(params, spacing=10, collapse=1):</span><ul><li><span class="name">"""Build a connection string from a dictionary of parameters.</span></li><li><span class="name">Returns string."""</span></li><li><span class="name">return ";".join(["%s=%s" % (k, v) for k, v in params.items()])</span></li></ul></li><li><span class="name">其中：</span></li><li><span class="name">def：关键字，表示开始定义函数。</span></li><li><span class="name">myFunc：为函数名。<b>不需要定义返回值类型。</b></span></li><li><span class="name">params：参数，也不需要指定类型。spacing=10即参数默认值.</span></li></ul></li><li><span class="name">命名参数</span><ul><li><span class="name">Python支持命名参数. 命名参数的一个好处是代码可读性强，另一个好处参数不在依赖顺序，比如myFunc()这个函数，如果要指定 collapse（第三个）的值，同时第二个参数使用默认值：</span></li><li><span class="name">myFunc(sqlStrings, collapse=0)</span></li></ul></li><li><span class="name">传值、传址、传引用</span><ul><li><span class="name">Python不允许选择采用传值还是传址。</span></li><li><span class="name">Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传址的综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值, 相当于传址。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象, 相当于传值。</span></li><li><span class="name">传值的参数类型：数字，字符串，元组</span></li><li><span class="name">传址的参数类型：列表，字典</span></li></ul></li><li><span class="name">支持多返回值</span><ul><li><span class="name">Python支持多返回值.  这是最方便的地方了! <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></li><li><span class="name">对于调用方, 如果要忽略某个返回值, 可以用 _ 代替.</span></li></ul></li><li><span class="name">可变参数</span><ul><li><span class="name">参数表加 * 表示可变参数. 比如:</span></li><li><span class="name">def myFunc (* params):</span><ul><li><span class="name">len(params)       # 参数的数量</span></li><li><span class="name">print params[0]   # 第一个参数</span></li></ul></li><li><span class="name">可见, Python 把参数打包为一个元组.</span></li><li><span class="name">可变参数一般应该放在参数表的最后面. 如果不是这样, 则普通参数需要用命名参数方式. </span><ul><li><span class="name">def myFunc (* params, extra)</span></li><li><span class="name">使用时 myFunc(1, 2, 3, extra=4)</span></li></ul></li><li><span class="name">如果</span></li></ul></li><li><span class="name">默认参数</span><ul><li><span class="name">定义是给出指定值的参数. 使用时不定义则使用默认值, 定义了就用指定的值.</span></li></ul></li></ul></li><li><span class="name">整数&amp;布尔量&amp;枚举量</span><ul><li><span class="name">整数:&nbsp;变量通过首次赋值产生. 整数就是: myParams = 5</span></li><li><span class="name">布尔量</span><ul><li><span class="name">True(1). 只有1是True, 其它值不是.</span></li><li><span class="name">False(0). 只有0是False, 其它值不是.</span></li></ul></li><li><span class="name">枚举量</span><ul><li><span class="name">导入enum模块; 用class关键字定义枚举，且继承Enum类。 如:</span></li><li><span class="name">from enum import Enum</span></li><li><span class="name">class MyEnmu(Enum):</span><ul><li><span class="name">red = 1</span></li><li><span class="name">orange = 2</span></li><li><span class="name">yellow = 3</span></li><li><span class="name">green = 4</span></li><li><span class="name">blue = 5</span></li><li><span class="name">indigo = 6</span></li><li><span class="name">purple = 7</span></li></ul></li><li><span class="name">使用时用:&nbsp;MyEnmu.red</span></li><li><span class="name">还可以这么用:&nbsp;print(MyEnmu(1)). 输出:&nbsp;MyEnmu.red</span></li></ul></li></ul></li><li><span class="name">浮点数</span><ul><li><span class="name">myParams = 5.5</span></li><li><span class="name">浮点数还有一种表达方式：科学计数法。352.3E-4，E标记表示10的幂，52.3E-4表示52.3 * 10-4。</span></li><li><span class="name">还有一种数，即复数. 用a+/-bj的方式定义, a和b皆为数字. 如: my = -5+4j</span><ul><li><span class="name">print my.real &nbsp;  # 打印复数的实部</span></li><li><span class="name">print my.imag &nbsp; # 打印复数的虚部</span></li></ul></li></ul></li><li><span class="name">常量&amp;全局变量&amp;静态变量</span><ul><li><span class="name">常量: python无此概念。5.5就是数字常量，‘123’就是字符串常量。</span></li><li><span class="name">全局变量</span><ul><li><span class="name">在类外定义的变量为全局变量, 全局可见, 直接读取.</span></li><li><span class="name">但是如果尝试改写全局变量, 则不会成功. Python会创建一个同名的局部变量, 修改的是该局部变量.</span></li><li><span class="name">如果一定要改写全局变量, 则要用 global 关键字申明.</span><ul><li><span class="name">count = 5</span></li><li><span class="name">def myFunc():</span><ul><li><span class="name">global count</span></li><li><span class="name">count = 10</span></li></ul></li></ul></li></ul></li><li><span class="name">静态变量:&nbsp;类内函数外定义的变量是类变量, 和静态变量的概念类似.</span></li></ul></li><li><span class="name">运算符表</span><ul><li><span class="name">以下运算符的优先级依次递减：</span></li><li><span class="name">正负号: +x, -x</span></li><li><span class="name">乘法、除法、取余数、取整数、幂运算: *, / ,%, //,&nbsp;&nbsp;**(返回x的y次幂, 如2**4 = 16)</span></li><li><span class="name">加法与减法: +, -</span></li><li><span class="name">移位: &lt;&lt;, &gt;&gt;</span></li><li><span class="name">按位与: &amp;</span></li><li><span class="name">按位异或: ^</span></li><li><span class="name">按位或: |</span></li><li><span class="name">比较: &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></li><li><span class="name">赋值: =, +=, -=, *=, /=, %=, **=, //==</span></li><li><span class="name">身份运算符: is, is not</span><ul><li><span class="name">is:&nbsp;判断两个标识符是不是引用自一个对象.&nbsp;x is y, 等价于 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False.</span></li><li><span class="name">is not: 和is相反.</span></li></ul></li><li><span class="name">成员运算符: in, not in</span><ul><li><span class="name">成员运算符负责测试集合中是否包括指定成员，支持的集合包括字符串，列表或元组。</span></li><li><span class="name">in:&nbsp;如果在指定的集合中找到值返回 True，否则返回 False。如:</span><ul><li><span class="name">a = 10</span></li><li><span class="name">myList = [1, 2, 3, 4, 5 ];</span></li><li><span class="name">if ( a in myList&nbsp;):</span><ul><li><span class="name">print&nbsp;“找到了”</span></li></ul></li></ul></li><li><span class="name">not in: 与in相反.</span></li></ul></li><li><span class="name">逻辑运算符: not</span></li><li><span class="name">逻辑运算符: and</span></li><li><span class="name">逻辑运算符: or</span></li><li><span class="name">Lambda</span><ul><li><span class="name">Lambda表达式类似于c语言中的宏定义函数, 它定义了一个匿名函数，有参数, 函数体和返回值。使用时直接传入参数即可. 适合简单运算的函数.</span><ul><li><span class="name">func=lambda x:x+1</span></li><li><span class="name">print(func(1)) &nbsp;# 返回2</span></li></ul></li><li><span class="name">有几个定义好的全局Lambda表达式方便使用，filter, map, reduce。</span><ul><li><span class="name">from functools import reduce</span></li><li><span class="name">foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]</span></li><li><span class="name">print (list(filter(lambda x: x % 3 == 0, foo)))  # 过滤</span><ul><li><span class="name">#[18, 9, 24, 12, 27]</span></li></ul></li><li><span class="name">print (list(map(lambda x: x * 2 + 10, foo)))   # 计算</span><ul><li><span class="name">#[14, 46, 28, 54, 44, 58, 26, 34, 64]</span></li></ul></li><li><span class="name">print (reduce(lambda x, y: x + y, foo))  # 啥语法? 统计和</span><ul><li><span class="name">#139</span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name">数据的拆箱和装箱 --无</span></li><li><span class="name">指针&amp;引用 --无</span></li><li><span class="name">内嵌函数(内部函数) 和闭包</span><ul><li><span class="name">在函数内部可定义另外一个函数. 该函数叫内嵌函数. </span></li><li><span class="name">内嵌函数仅可被宿主函数调用. </span></li><li><span class="name">闭包 (closure)</span><ul><li><span class="name">如果在一个内部函数中, 对在外部作用域(但不是在全局作用域) 的变量进行应用, 那么此内部函数被视为闭包.</span></li></ul></li></ul></li><li><span class="name">对象判空</span><ul><li><span class="name">对象判空</span><ul><li><span class="name">if any(myObject): &nbsp;#&nbsp;myObject为空则返回true.&nbsp;</span></li></ul></li><li><span class="name">list判空</span><ul><li><span class="name">if len(myList): &nbsp;# myList 不为空则返回true.</span></li></ul></li></ul></li><li><span class="name">对象的元属性</span><ul><li><span class="name">type 函数返回任意对象的数据类型</span><ul><li><span class="name">&gt;&gt;&gt; type(1)</span><ul><li><span class="name">&lt;type 'int’&gt;</span></li></ul></li><li><span class="name">&gt;&gt;&gt; myList = [ ]</span></li><li><span class="name">&gt;&gt;&gt; type(myList)</span><ul><li><span class="name">&lt;type 'list’&gt;</span></li></ul></li><li><span class="name">&gt;&gt;&gt; import odbchelper</span></li><li><span class="name">&gt;&gt;&gt; type(odbchelper)</span><ul><li><span class="name">&lt;type 'module’&gt;</span></li></ul></li><li><span class="name">&gt;&gt;&gt; import types</span></li><li><span class="name">&gt;&gt;&gt; type(odbchelper) == types.ModuleType</span><ul><li><span class="name">True</span></li></ul></li></ul></li><li><span class="name">isinstance(A, objA) ，如果A是objA类型，则返回true。</span></li><li><span class="name">id(): 返回对象或变量的内存地址.</span><ul><li><span class="name">a=1</span></li><li><span class="name">print(id(a)) &nbsp;///&nbsp;&nbsp;&nbsp; &nbsp;11246696</span></li></ul></li></ul></li><li><span class="name">for &amp; while</span><ul><li><span class="name">python的 list 很强大， 所以一般情况下你并不需要for循环。</span></li><li><span class="name">循环一个list（当然有更简洁的方式）：</span><ul><li><span class="name">&gt;&gt;&gt; myList = ['a', 'b', 'e']</span></li><li><span class="name">&gt;&gt;&gt; for my in myList:</span></li><li><span class="name">print my</span></li></ul></li><li><span class="name">还有一种方式：</span><ul><li><span class="name">&gt;&gt;&gt; for my in range(len(myList)):</span></li><li><span class="name">print myList[my]</span></li></ul></li><li><span class="name">循环数字</span><ul><li><span class="name">&gt;&gt;&gt; for i in range(4):</span></li><li><span class="name">print i</span></li></ul></li><li><span class="name">遍历一个dictionary</span><ul><li><span class="name">&gt;&gt;&gt; import os</span></li><li><span class="name">&gt;&gt;&gt; for k, v in os.environ.items():</span></li><li><span class="name">print "%s=%s" % (k, v)</span></li><li><span class="name">输出:</span></li><li><span class="name">USERPROFILE=C:\Documents and Settings\mpilgrim</span></li><li><span class="name">OS=Windows_NT</span></li><li><span class="name">COMPUTERNAME=MPILGRIM</span></li><li><span class="name">USERNAME=mpilgrim</span></li><li><span class="name">其中：os.environ.items() 返回一个 tuple 的 list：[(key1, value1), (key2, value2), ...]。</span></li></ul></li><li><span class="name">while</span><ul><li><span class="name"><b>while</b> ii &lt; 100: </span><ul><li><span class="name">ii += 1</span></li><li><span class="name">if i &gt; 10:</span><ul><li><span class="name"><b>break</b></span></li></ul></li><li><span class="name">if ii%2 &gt; 0:</span><ul><li><span class="name"><b>continue</b></span></li></ul></li></ul></li></ul></li><li><span class="name">while ... else ... 结构</span><ul><li><span class="name">while count &lt; 5:</span><ul><li><span class="name">print count, " is  less than 5"</span></li><li><span class="name">count = count + 1</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">print count, " is not less than 5"</span></li></ul></li></ul></li></ul></li><li><span class="name">if &amp; swith</span><ul><li><span class="name">def fib(n):</span><ul><li><span class="name">if n &gt; 1:</span><ul><li><span class="name">return n * fib(n - 1)</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">print 'end of the line'</span></li></ul></li><li><span class="name">return 1</span></li></ul></li></ul></li><li><span class="name">字符串的使用</span><ul><li><span class="name">字符串定义</span><ul><li><span class="name">字符串可以使用单引号、双引号、三引号（'''）。</span></li><li><span class="name">其中单引号和双引号是同一个功能. 而三引号则可以定义多行字符串，且其间可以使用单引号和双引号。如：</span><ul><li><span class="name">uid = '''This is a multi-line string. This is the first line.</span></li><li><span class="name">"What's your name?," I asked.</span></li><li><span class="name">He said "Bond, James Bond."</span></li><li><span class="name">‘''</span></li></ul></li><li><span class="name">转移符\。当需要在字符串中使用引号时，需要使用转义符：\', \"</span></li><li><span class="name">自然字符串。一般用于正则表达式和文件路径。前面加r。比如：r'\1’。</span></li><li><span class="name">字符串判空:&nbsp;len(myStr)==0</span></li></ul></li><li><span class="name">Unicode字符串</span><ul><li><span class="name">需要在字符串前加上前缀u或U。例如，u"This is a Unicode string."。</span></li></ul></li><li><span class="name">字符串转化</span><ul><li><span class="name">int(str): 将符合整数规定的字符串转换成int型</span></li><li><span class="name">float(str): 将符合浮点型规定的字符串转换成float型</span></li><li><span class="name">str(num): 将整数、浮点型转换成字符串型的</span></li></ul></li><li><span class="name">取长: len(myStr)</span></li><li><span class="name">去空格</span><ul><li><span class="name">去两边空格：myStr.strip()</span></li><li><span class="name">去左空格：myStr.lstrip()</span></li><li><span class="name">去右空格：myStr.rstrip()</span></li></ul></li><li><span class="name">字符串拼接</span><ul><li><span class="name">用 + 运算符. 如:  “Hello” +&nbsp;“world!"</span></li><li><span class="name">用join合并多个字符串</span><ul><li><span class="name">&gt;&gt;&gt; myDict = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret”}</span></li><li><span class="name">print ";".join(["%s=%s" % (k, v) for k, v in myDict.items()])</span></li><li><span class="name">输出: 'server=mpilgrim;uid=sa;database=master;pwd=secret’</span></li></ul></li></ul></li><li><span class="name">字符串截取</span><ul><li><span class="name">myStr = "abcdef"</span></li><li><span class="name">myStr2&nbsp;= myStr<b>[1:2]  </b>&nbsp;#&nbsp;myStr2是myStr从下标1开始，到2结束的连续子串。</span></li><li><span class="name">获取固定长度，右对齐，左边不够用空格补齐： myStr.rjust(width)</span></li><li><span class="name">获取固定长度，左对齐，右边不够用空格补齐： myStr.ljust(width)</span></li><li><span class="name">获取固定长度，中间对齐，两边不够用空格补齐： .center(width)</span></li><li><span class="name">获取固定长度，右对齐，左边不足用0补齐： myStr.myStrzfill(width)</span></li></ul></li><li><span class="name">字符串比较</span><ul><li><span class="name">使用 is equal 或 == 操作符比较字符串, 使用例如 &gt;= 或 &lt; 的运算符来确定几个字符串的排列顺序。</span><ul><li><span class="name">if myStr1 == myStr2:</span></li></ul></li><li><span class="name">是否以start开头：myStr.startswith('start')</span></li><li><span class="name">是否以end结尾：myStr.endswith('end’)</span></li><li><span class="name">是否全为字母或数字：myStr.isalnum()</span></li><li><span class="name">是否全字母：myStr.isalpha()</span></li><li><span class="name">是否全数字：myStr.isdigit()</span></li><li><span class="name">是否全小写：myStr.islower()</span></li><li><span class="name">是否全大写：myStr.isupper()</span></li></ul></li><li><span class="name">字符串查找</span><ul><li><span class="name">搜索指定字符串，没有返回-1：myStr.find('t')</span></li><li><span class="name">指定起始位置搜索：myStr.find('t',start)</span></li><li><span class="name">指定起始及结束位置搜索：myStr.find('t',start,end)</span></li><li><span class="name">从右边开始查找：myStr.rfind('t')</span></li><li><span class="name">搜索到多少个指定字符串：myStr.count('t’)</span></li><li><span class="name">上面所有方法都可用 myStr.index 代替，不同的是使用index查找不到会抛异常，而find返回-1.</span></li></ul></li><li><span class="name">字符串替换</span><ul><li><span class="name">替换old为new: myStr.replace('old','new')</span></li><li><span class="name">指定替换次数：myStr.replace('old’, 'new’, 5) &nbsp;# 最多替换5次</span></li></ul></li><li><span class="name">字符串切分</span><ul><li><span class="name">myStr&nbsp;= 'server=mpilgrim;uid=sa;database=master;pwd=secret'</span></li><li><span class="name">&gt;&gt;&gt; myStr.split(";")</span></li><li><span class="name">返回: ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']</span></li><li><span class="name">split() 指定的分隔符可以是字符，也可以是子串.</span></li></ul></li><li><span class="name">字符串的格式化输出、输入</span><ul><li><span class="name">字符串格式化使用与 C 中 sprintf 函数类似的语法.</span><ul><li><span class="name">&gt;&gt;&gt; myStr1&nbsp;= "uid"</span></li><li><span class="name">&gt;&gt;&gt; myStr2&nbsp;= "sa"</span></li><li><span class="name">&gt;&gt;&gt; "%s=%s" % (myStr1, myStr2)</span></li></ul></li></ul></li><li><span class="name">大小写转换</span><ul><li><span class="name">全部大写：myStr.upper()</span></li><li><span class="name">全部小写：myStr.lower()</span></li><li><span class="name">大小写互换：myStr.swapcase()</span></li><li><span class="name">首字母大写：myStr.title()</span></li><li><span class="name">首字母大写，其余小写：myStr.capitalize()</span></li></ul></li></ul></li><li><span class="name">对时间的处理</span><ul><li><span class="name">import time, datetime</span></li><li><span class="name">获取系统时间</span><ul><li><span class="name">time.time() &nbsp; # 返回从1970年1月1日0点到现在的秒数(用浮点数表示)，用的是UTC时间。</span></li><li><span class="name">time.localtime()</span></li></ul></li><li><span class="name">时间到字符串</span><ul><li><span class="name">strftime() &nbsp;# 用来将时间格式化成字符串.如:</span><ul><li><span class="name">print time.strftime("%Y-%m-%d %X", "2011-09-28 10:00:00”)&nbsp;# 第二个参数是系统可识别的时间字符串.&nbsp;“可识别"这个概念就有一定的灰度了.</span></li></ul></li><li><span class="name">如果需要对时间做计算, 一般把时间转化为&nbsp;struct_time 结构，然后再转化为epoch时间(即秒数), 这是个数字 比较方便计算。</span></li><li><span class="name">time.gmtime(t) &nbsp; &nbsp;#&nbsp;用UTC时间转为struct_time结构.如果不传参数, 则time.time()取系统当前时间.</span></li><li><span class="name">time.localtime(t) # 和上面同. 但使用本地时区调整过.</span></li><li><span class="name">calendar.timegm() # 把UTC的struct_time(gmtime的返回对象)转为从epoch开始的秒数</span></li><li><span class="name">time.mktime() # 把用时区调整过的struct_time(即localtime的返回对象)对象转为从epoch开始的秒数</span></li></ul></li><li><span class="name">字符串到时间</span><ul><li><span class="name">time.strptime() &nbsp;#&nbsp;将字符串解析成时间如:</span><ul><li><span class="name">myTime = time.strptime("2009-08-08", "%Y - %m - %d”) &nbsp;# 返回struct_time对象</span></li></ul></li></ul></li><li><span class="name">strftime()和strptime()的format参数由如下占位符构成</span><ul><li><span class="name">%a 英文星期简写</span></li><li><span class="name">%A 英文星期的完全</span></li><li><span class="name">%b 英文月份的简写</span></li><li><span class="name">%B 英文月份的完全</span></li><li><span class="name">%c 显示本地日期时间</span></li><li><span class="name">%d 日期，取1-31</span></li><li><span class="name">%H 小时， 0-23</span></li><li><span class="name">%I 小时， 0-12</span></li><li><span class="name">%m 月， 01 -12</span></li><li><span class="name">%M 分钟，1-59</span></li><li><span class="name">%j 年中当天的天数</span></li><li><span class="name">%w 显示今天是星期几</span></li><li><span class="name">%W 第几周</span></li><li><span class="name">%x 当天日期</span></li><li><span class="name">%X 本地的当天时间</span></li><li><span class="name">%y 年份 00-99间</span></li><li><span class="name">%Y 年份的完整拼写</span></li></ul></li><li><span class="name">其它函数</span><ul><li><span class="name">time.asctime():&nbsp;将一个struct_time对象转为标准24字符的字符串，如:</span><ul><li><span class="name">Sun Jun 20 23:21:05 1993</span></li></ul></li><li><span class="name">time.ctime(): 将一个秒数转化为标准24字符的字符串, 如上.</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">数组, list</span><ul><li><span class="name">定义数组</span><ul><li><span class="name">python中的数组叫list, list用 <b>[ ]</b> 来初始化。</span></li><li><span class="name">&gt;&gt;&gt; myList = ["a", "b", "mpilgrim", "z", "example"]</span></li><li><span class="name">myList为一个5元素的list，每个元素都是个字符串。不同类型的元素可以放在同一个数组中。初始化之后, 不可以改变元素的类型.</span></li><li><span class="name">list的递增赋值:&nbsp;range(n) 会生成一个0 到 n-1 的list。</span></li><li><span class="name">一个很酷的技巧是利用 range 和 tuple配合，生成枚举量。</span></li><li><span class="name">(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)</span></li><li><span class="name">然后 MONDAY=0，TUESDAY=1.</span></li></ul></li><li><span class="name">遍历数组</span><ul><li><span class="name">通过下标取元素。下标可以是负值，表示从尾部取，最后一个元素的负下标是 -1.</span><ul><li><span class="name">&gt;&gt;&gt; myList[0]</span></li><li><span class="name">输出: ‘a’</span></li><li><span class="name">&gt;&gt;&gt; myList[-1]</span></li><li><span class="name">输出: 'example'</span></li></ul></li><li><span class="name">由值获取index</span><ul><li><span class="name">&gt;&gt;&gt; myList.index("example")</span></li><li><span class="name">输出: 5</span></li></ul></li><li><span class="name">判断元素的存在性:</span><ul><li><span class="name">&gt;&gt;&gt; "c" in&nbsp;myList</span></li><li><span class="name">输出: False</span></li></ul></li></ul></li><li><span class="name">数组的size:&nbsp;len(myList)</span></li><li><span class="name">元素的增加/删除</span><ul><li><span class="name">增加</span><ul><li><span class="name">myList.<b>append</b>("new")   # 在最后位置添加。</span></li><li><span class="name">myList.<b>insert</b>(2, "new")   # 在指定位置添加</span></li></ul></li><li><span class="name">删除</span><ul><li><span class="name">&gt;&gt;&gt; myList.<b>remove</b>("z")</span></li><li><span class="name">&gt;&gt;&gt;&nbsp;myList</span></li><li><span class="name">['a', 'b', 'new', 'mpilgrim']</span></li><li><span class="name">注意：remove只删除第一次出现的元素。</span></li><li><span class="name">也可以用 <b>del</b>(index)删除. 如: <b>del</b>&nbsp;myList[0] &nbsp;# 删除第一个元素</span></li></ul></li><li><span class="name">删除元素并返回 pop</span><ul><li><span class="name">&gt;&gt;&gt; myList.<b>pop</b>()</span></li><li><span class="name">'mpilgrim'</span></li><li><span class="name">&gt;&gt;&gt;&nbsp;myList</span></li><li><span class="name">['a', 'b', 'new’]</span></li></ul></li></ul></li><li><span class="name">两个数组的连接</span><ul><li><span class="name">myList.<b>extend</b>(["two", "elements"])</span></li><li><span class="name">注意：["two", "elements"] 为一个新的list。</span></li></ul></li><li><span class="name">数组的切分</span><ul><li><span class="name">list 的切分是python比较有特色的语法结构，<b>[m:n] </b>表示从头数第m个元素到第n个元素的分片（从0开始计数, 不包括n），负数表示从后面往前算. 返回当前list的子集, 且也是一个list.</span></li><li><span class="name">&gt;&gt;&gt;&nbsp;myList</span></li><li><span class="name">['a', 'b', 'mpilgrim', 'z', 'example’] &nbsp;# 整体</span></li><li><span class="name">&gt;&gt;&gt; myList[0:3]</span></li><li><span class="name">['a', 'b', ‘mpilgrim']</span></li><li><span class="name">&gt;&gt;&gt; myList[1:-1]</span></li><li><span class="name">['b', 'mpilgrim', 'z']</span></li></ul></li><li><span class="name">不可变数组Tuple</span><ul><li><span class="name">Tuple 是不可变 list。 一旦创建了一个 tuple 就不能添加、删除、查找元素。如: </span><ul><li><span class="name">&gt;&gt;&gt; myTuple&nbsp;= ("a", "b", "mpilgrim", "z", "example")</span></li><li><span class="name">&gt;&gt;&gt; myTuple[0]</span></li><li><span class="name">'a'</span></li><li><span class="name">&gt;&gt;&gt; myTuple[-1]</span></li><li><span class="name">'example'</span></li><li><span class="name">&gt;&gt;&gt; myTuple[1:3]</span></li><li><span class="name">('b', 'mpilgrim')</span></li></ul></li></ul></li></ul></li><li><span class="name">内存管理</span><ul><li><span class="name">import gc</span></li><li><span class="name">python 不需要做内存管理. 但理解内存模式还是很有价值的. Python提供如下函数帮助我们理解:</span></li><li><span class="name">id(my) &nbsp;# my是一个对象, id()返回它的内存地址.</span></li><li><span class="name">使用sys包中的getrefcount()，来查看某个对象的引用计数。注意,&nbsp;getrefcount()所得到的结果，会比期望的多1。因为它自己也会创建一次应用.</span></li><li><span class="name">globals(): 获取保存所有全局变量的词典. Python用统一的字典维护所有的全局变量.</span></li><li><span class="name">容器对象的引用可能构成很复杂的拓扑结构。我们可以用 objgraph包 来绘制其引用关系，比如:</span><ul><li><span class="name">import objgraph</span></li><li><span class="name">objgraph.show_refs([z], filename='ref_topo.png’)</span></li><li><span class="name">objgraph是Python的一个第三方包。安装之前需要安装xdot。 参见:&nbsp;<a class="contentLink" target="_blank" rel="noreferrer" href="http://mg.pov.lt/objgraph/">http://mg.pov.lt/objgraph/</a></span></li></ul></li><li><span class="name">垃圾回收机制</span><ul><li><span class="name">当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。</span></li><li><span class="name">但是减肥是个昂贵而费力的事情。Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</span></li><li><span class="name">通过gc模块的get_threshold()方法，查看该阈值:</span><ul><li><span class="name">print(gc.get_threshold())</span></li><li><span class="name">返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</span></li></ul></li><li><span class="name">我们也可以手动启动垃圾回收，即使用gc.collect()。</span></li><li><span class="name">Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</span></li><li><span class="name">Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</span></li><li><span class="name">这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</span></li><li><span class="name">同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</span><ul><li><span class="name">gc.set_threshold(700, 10, 5)</span></li></ul></li></ul></li></ul></li><li><span class="name">文件系统</span><ul><li><span class="name">获取特定目录</span><ul><li><span class="name">返回当前目录：os.getcwd()</span></li><li><span class="name">返回上一级目录：os.chdir("..")</span></li><li><span class="name">返回随机文件路径：??</span></li></ul></li><li><span class="name">文件夹和文件的存在性</span><ul><li><span class="name">是否存在：os.path.exists()</span></li><li><span class="name">是否为文件：os.path.isfile()</span></li><li><span class="name">是否为目录：os.path.isdir()</span></li></ul></li><li><span class="name">文件夹的新建和删除</span><ul><li><span class="name">新建单级目录：os.mkdir("test")</span></li><li><span class="name">新建多级目录：os.makedirs("c:\python\test")</span></li><li><span class="name">删除：os.removedirs("c:\python")</span></li></ul></li><li><span class="name">文件夹和文件的遍历</span><ul><li><span class="name">os.listdir()</span></li></ul></li><li><span class="name">文件的读、写、新建</span><ul><li><span class="name">logfile = open('test.log', 'w')     # "w" 模式将覆盖文件的原有内容。"a" 模式将数据追加到文件尾。</span></li><li><span class="name">logfile.write('test succeeded')</span></li><li><span class="name">seek(-128, 2)</span></li><li><span class="name">logfile.close()</span></li><li><span class="name">print file('test.log').read()</span></li></ul></li><li><span class="name">文件的删除:&nbsp;os.remove()</span></li><li><span class="name">文件改名、修改属性:&nbsp;os.rename("oldname","newname") 文件或目录都是使用这条命令</span></li><li><span class="name">返回文件长度</span><ul><li><span class="name">fp.seek(offset[,whence])，将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span></li></ul></li><li><span class="name">行读</span><ul><li><span class="name">fp.<b>readline</b>([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分</span></li><li><span class="name">fp.<b>readlines</b>([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</span></li></ul></li></ul></li><li><span class="name">类的进一步讨论</span><ul><li><span class="name">继承</span><ul><li><span class="name"># 父类</span></li><li><span class="name">class AddBook(object):</span><ul><li><span class="name">def __init__(self, name, phone):</span><ul><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.name">self.name</a> = name</span></li><li><span class="name">self.phone = phone</span></li></ul></li><li><span class="name">def get_phone(self):</span><ul><li><span class="name">return self.phone</span></li></ul></li></ul></li><li><span class="name"># 子类</span></li><li><span class="name">class EmplEmail(AddBook):</span><ul><li><span class="name">def __init__(self, nm, ph, email):</span><ul><li><span class="name"># AddBook.__init__(self, nm, ph) # 调用父类方法一</span></li><li><span class="name">super(EmplEmail, self).__init__(nm, ph) # 调用父类方法二</span></li><li><span class="name">self.email = email</span></li></ul></li><li><span class="name">def get_email(self):</span><ul><li><span class="name">return self.email</span></li></ul></li></ul></li><li><span class="name"># 调用</span></li><li><span class="name">if __name__ == "__main__":</span><ul><li><span class="name">Detian = AddBook('handetian', '18210413001')</span></li><li><span class="name">print Detian.get_phone()</span></li><li><span class="name">alice = EmplEmail('alice', '18210418888', '<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:alice@xkops.com">alice@xkops.com</a>')</span></li><li><span class="name">print alice.get_email(), alice.get_phone()</span></li></ul></li></ul></li><li><span class="name">组合</span><ul><li><span class="name"># A类</span></li><li><span class="name">class Info(object):</span><ul><li><span class="name">def __init__(self, phone, email):</span><ul><li><span class="name">self.phone = phone</span></li><li><span class="name">self.email = email</span></li></ul></li><li><span class="name">def get_phone(self):</span><ul><li><span class="name">return self.phone</span></li></ul></li><li><span class="name">def update_phone(self, newphone):</span><ul><li><span class="name">self.phone = newphone</span></li></ul></li></ul></li><li><span class="name"># B类。B包含A。</span></li><li><span class="name">class AddrBook(object):</span><ul><li><span class="name">def __init__(self, name, phone, email):</span><ul><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.name">self.name</a> = name</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://self.info">self.info</a> = Info(phone, email)</span></li></ul></li></ul></li><li><span class="name">if __name__ == "__main__":</span><ul><li><span class="name">Detian = AddrBook('handetian', '18210413001', '<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:detian@xkops.com">detian@xkops.com</a>', '123456')</span></li></ul></li></ul></li><li><span class="name">类的预置函数</span><ul><li><span class="name">__init__ 就是预置函数，前面已介绍了。其它还有：</span></li><li><span class="name">def __str__(self): &nbsp; &nbsp; &nbsp;# 打印对象时调用。</span></li><li><span class="name">def __repr__(self):&nbsp;&nbsp; &nbsp;&nbsp;# 和上面类似，但是是在交互执行的模式下打印。</span></li><li><span class="name">def __call__(self):&nbsp;&nbsp; &nbsp;&nbsp;# 这个有点特殊，定义后可以让对象象函数一样被调用。</span></li></ul></li></ul></li><li><span class="name">hash表</span><ul><li><span class="name">hash表的定义</span><ul><li><span class="name">hash表的特点是有key这个概念，可以基于key字符串存取数据。</span></li><li><span class="name">Python中的hash表即dictionary 。dictionary 的一个特点是它的<b>key</b>除了字符串之外，还可以是任何对象，包括整数。</span></li><li><span class="name">&gt;&gt;&gt; myDict = {"server":"mpilgrim", "database":"master"}</span></li><li><span class="name">其中：定义dictionary 使用 {}，key-value 对用逗号分隔；前面为key，后面为value。</span></li><li><span class="name">key 不可重复（大小写敏感哦），并且是无序的。</span></li><li><span class="name">通过key 访问 value，反过来不行。</span></li></ul></li><li><span class="name">hash表的size: len(myDict)</span></li><li><span class="name">hash表的遍历</span><ul><li><span class="name">dictionary 的 keys, values 和 items 函数，输出为list。</span><ul><li><span class="name">&gt;&gt;&gt; myDict.<b>keys</b>()</span></li><li><span class="name">['server', 'database']</span></li><li><span class="name">&gt;&gt;&gt; myDict.<b>values</b>()</span></li><li><span class="name">['mpilgrim', 'master']</span></li><li><span class="name">&gt;&gt;&gt; myDict.<b>items</b>()</span></li><li><span class="name">[('server', 'mpilgrim'), ('database', 'master')]</span></li><li><span class="name">&gt;&gt;&gt; ["%s=%s" % (k, v) for k, v in myDict.items()]</span></li><li><span class="name">['server=mpilgrim', 'database=master']</span></li></ul></li><li><span class="name">其中：Dictionary 的 <b>keys</b>() 返回一个所有键的 list。这个 list 没按 dictionary 定义的顺序输出 (记住, 元素在 dictionary 中是无序的), 但它是一个 list。</span></li><li><span class="name"><b>values</b>() 返回一个所有值的 list。这个 list 以 keys 返回的 list 顺序输出, 所以对于所有的 n, params.values()[n] == params[params.keys()[n]] 。</span></li><li><span class="name"><b>items</b>() 返回一个形如 (key, value) 的 tuple 的 list。这个 list 包括 dictionary 中所有的数据。</span></li></ul></li><li><span class="name">hash表成员的修改、新增、删除</span><ul><li><span class="name">修改和新增</span><ul><li><span class="name">&gt;&gt;&gt; myDict = {}</span></li><li><span class="name">&gt;&gt;&gt; myDict["key"] = "value"</span></li><li><span class="name">&gt;&gt;&gt; myDict["key"] = "other value"   # 修改</span></li><li><span class="name">&gt;&gt;&gt; myDict[42] = "douglas"  # 新增</span></li><li><span class="name">&gt;&gt;&gt; myDict</span></li><li><span class="name">{'key': 'other value', 42: 'douglas'}   # 注意, 42是个key, 而不是下标.</span></li><li><span class="name">为一个已经存在的 key 赋值，则会覆盖该值。</span></li></ul></li><li><span class="name">删除</span><ul><li><span class="name">del myDict[42]    # key=42的元素没了。按序号输出</span></li><li><span class="name">del myDict["retrycount"]   # 按key删除</span></li><li><span class="name">myDict.clear()    # 删除所有</span></li></ul></li></ul></li></ul></li><li><span class="name">字典</span></li><li><span class="name">链表</span></li><li><span class="name">高级数据结构: 二叉树/红黑树</span></li><li><span class="name">异常处理</span><ul><li><span class="name">try:</span><ul><li><span class="name">&lt;语句&gt;   # 运行别的代码</span></li></ul></li><li><span class="name">except &lt;名字&gt;：</span><ul><li><span class="name">&lt;语句&gt;  #  如果在try部份引发了'name'异常</span></li></ul></li><li><span class="name">except &lt;名字&gt;，&lt;数据&gt;:</span><ul><li><span class="name">&lt;语句&gt;  #  如果引发了'name'异常，获得附加的数据</span></li></ul></li><li><span class="name">else:</span><ul><li><span class="name">&lt;语句&gt;  # 如果没有异常发生</span></li></ul></li><li><span class="name">另外，我们可以使用raise语句自己触发异常。</span></li></ul></li><li><span class="name">UT</span><ul><li><span class="name">把ut代码放在：&nbsp;if __name__ == "__main__":</span></li><li><span class="name">分支中，可以保证当模块被包含时这些代码自动不生效。</span></li></ul></li><li><span class="name">平台兼容性</span><ul><li><span class="name">给出当前平台使用的行终止符: os.linesep</span><ul><li><span class="name">Windows使用'\r\n'</span></li><li><span class="name">Linux使用'\n'</span></li><li><span class="name">Mac使用'\r'</span></li></ul></li><li><span class="name">指示你正在使用的平台：<a class="contentLink" target="_blank" rel="noreferrer" href="http://os.name">os.name</a></span><ul><li><span class="name">对于Windows，它是'nt'；</span></li><li><span class="name">对于Linux/Unix，它是'posix'。</span></li></ul></li></ul></li><li><span class="name">泛型</span></li></ul>
  </body>
</html>