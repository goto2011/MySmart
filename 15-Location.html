<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">15-Location</span><ul><li><span class="name">定位种类:</span><ul><li><span class="name">GPS定位,  最准确, 没有移动网络也可以使用, 但缺点也突出:</span><ul><li><span class="name">1. 比较耗电;</span></li><li><span class="name">2. 绝大部分用户默认不开启GPS模块;</span></li><li><span class="name">3. 首次定位, 一般需要较长时间, 甚至可能要几分钟.</span></li><li><span class="name">4. 室内基本无法使用.</span></li><li><span class="name">2和3比较致命.</span></li></ul></li><li><span class="name">基站定位, 大致思路是采集手机上的基站ID(cell ID) 和其它的一些信息(MNC, MCC, LAC等), 然后通过网络访问一些定位服务. 这些服务提供者有一些数据库, 提前做好了cell ID所在位置的经纬度等等信息, 通过查表以及简单算法(比如三点定位法), 获取设备位置. </span><ul><li><span class="name">其精度不如GPS;</span></li><li><span class="name">但好处是比较快, 而且可以在室内用, 只要有网络即可使用.</span></li></ul></li><li><span class="name">WIFI定位, 和基站定位类似, 通过收集设备周围的WIFI, 然后访问网络, 通过服务获取经纬度.</span></li><li><span class="name">基站定位和WIFI定位都需要网络, 所以在Android系统中统称为Network Location.</span></li><li><span class="name">AGPS, 本质是GPS定位, 但是同时采用基站和WIFI信息对GPS定位进行修正. </span><ul><li><span class="name">优势是更快, 而且准确度也略高于GPS.</span></li></ul></li></ul></li><li><span class="name">Android提供的定位接口是异步调用的, 大致流程如下:</span><ul><li><span class="name">locManager = (LocationManager)&nbsp;this.getSystemService(Context.LOCATION_SERVICE);</span></li><li><span class="name">// LocationListener包涵了几个成员函数，它们都是回调函数。</span></li><li><span class="name">locListener =&nbsp;new&nbsp;LocationListener() {</span><ul><li><span class="name">public&nbsp;void&nbsp;onStatusChanged(String provider,&nbsp;int&nbsp;status, Bundle extras) {</span><ul><li><span class="name">// TODO Auto-generated method stub</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public&nbsp;void&nbsp;onProviderEnabled(String provider) {</span><ul><li><span class="name">// TODO Auto-generated method stub</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public&nbsp;void&nbsp;onProviderDisabled(String provider) {</span><ul><li><span class="name">// TODO Auto-generated method stub</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// onLocationChanged是最重要的一个回调，这个函数是在Android获取了新的location信息之后调用的，你可以在这个函数内来实现自己想要的功能。</span></li><li><span class="name">public&nbsp;void&nbsp;onLocationChanged(Location location) {</span><ul><li><span class="name">// TODO Auto-generated method stub</span></li><li><span class="name">mobileLocation = location;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">// 将定义的locationListener注册到定位服务中去。</span></li><li><span class="name">locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,&nbsp;0,&nbsp;0, locListener);</span></li></ul></li><li><span class="name">当onLocationChanged()被调用时, 就可以获得设备的真正GPS位置。</span></li><li><span class="name">问题来, 它什么时候会被调用？没人知道。可以写个小程序测试下. 大部分情况下, 可以在几十毫秒内就返回了，但也有一些时候，时间间隔长达几十秒。</span></li><li><span class="name">这样的方案不应该直接提供给用户使用. 可以优化的几个点是:</span><ul><li><span class="name">不要一直等待 onLocationChanged被调用, 要设置一个timeout机制。</span></li><li><span class="name">如果timeout了，但onLocationChanged仍然没有返回，怎么办？难道只能提示用户无法定位吗？Android还提供了一个函数：getlastKnowLocation。这个函数会返回android平台最后一次获取到的位置信息。</span></li></ul></li><li><span class="name">getlastKnowLocation()的用法</span><ul><li><span class="name">Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);</span></li><li><span class="name">那么 这个的返回值值得信赖吗？</span></li><li><span class="name">需要定义一个标准判断获取到的Location是否可信。Android的Location这个类除了包涵有latitude,longitude，还包含有很多其他的信息，比如何时获取到的，通过哪种方式获取到的，等等。程序员完全可以基于这些信息来判断获取到的Location是否过时或者是否可信。</span></li></ul></li><li><span class="name">Android的官方文档给出了推荐的方案：</span><ul><li><span class="name">首先注册自己的LocationListener，让它同时监听GPS_PROVIDER和NETWORK_PROVIDER；</span></li><li><span class="name">然后可以调用getLastKnownLocation获得一个Location值，这个值可以作为一个备选值；</span></li><li><span class="name">然后在一段用户可接受的时间内，不断接收从onLocationChanged返回的位置，并同之前的值做比较，选取其中的最佳；</span></li><li><span class="name">最后，会剩下一个筛选后的最优结果，你需要判断这个结果是否可接受。如果可以接受，返回给用户，如果不行，告诉用户无法定位。</span></li><li><span class="name">整个过程你需要定义两个重要的函数：一个是比较两个Location信息，返回其中好的那个；另一个函数则用来判断Location信息是否可以被接受。</span></li></ul></li></ul>
  </body>
</html>