<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>10-Input&amp;WMS</b></span></span><ul><li><span class="name"><span class="innerContentContainer">参考</span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/categories/Android/View/">https://www.viseator.com/categories/Android/View/</a> , <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://gityuan.com/2016/12/31/input-ipc/">http://gityuan.com/2016/12/31/input-ipc/</a>,  <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://www.mysixue.com/?p=144">http://www.mysixue.com/?p=144</a>, <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/2017/09/14/android_view_event_1/">https://www.viseator.com/2017/09/14/android_view_event_1/</a></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://blog.csdn.net/guolin_blog/article/details/9097463/">https://blog.csdn.net/guolin_blog/article/details/9097463/</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码静态结构</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinputflinger.so">libinputflinger.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">InputDispatcher.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputManager.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">EventHub.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputListener.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/input/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinput.so">libinput.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Input.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputDevice.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Keyboard.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">KeyCharacterMap.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">IInputFlinger.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/base/services/core/  --  services. jar,  libandroid_services.so</span></span><ul><li><span class="name"><span class="innerContentContainer">java/com/android/server/input/InputManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">jni/com_android_server_input_InputManagerService.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/base/libs/input/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinputservice.so">libinputservice.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">PointerController.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">SpriteController.cpp</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">底层架构</span></span><ul><li><span class="name"><span class="innerContentContainer">用户空间可以用 linux/input.h 中定义的 EVIOCG* ioctls 来获得当前事件编码和参数的状态。</span></span></li><li><span class="name"><span class="innerContentContainer">设备的所支持的上报事件种类也可以通过 sysfs的 class/input/event*/device/capabilities/ 来获取. </span></span></li><li><span class="name"><span class="innerContentContainer">设备的特性和可以通过 class/input/event*/device/properties 来获取。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Native层</b></span></span><ul><li><span class="name"><span class="innerContentContainer">初始化 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>开机过程中, systemserver.java, 调用</b>startOtherServices(), 创建InputManagerService 对象。</span></span></li><li><span class="name"><span class="innerContentContainer">为这个对象设置与 WindowManagerService相关的回调函数，然后调用InputManagerService的start()。</span></span></li><li><span class="name"><span class="innerContentContainer">start()通过JNI调用，进行native层初始化。</span></span></li><li><span class="name"><span class="innerContentContainer">native层初始化代码在 com_android_server_input_InputManagerService.cpp ，它即 NativeInputManager。 这个对象很重要：</span></span><ul><li><span class="name"><span class="innerContentContainer">InputReader 和 InputDispatcher 和Java层的交互由它负责中转。</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader 和 InputDispatcher 按左下键切换到英文 创建时，都需要传入 policy 对象，这个policy就是 NativeInputManager。InputDispatcher 对mPolicy 的调用，都会通过 NativeInputManager 转发到 Java层。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">NativeInputManager先创建 InputManager 对象。后者持有 InputReader 和 InputDispatcher。</span></span></li><li><span class="name"><span class="innerContentContainer">InputManager 负责创建 InputReader 和 InputDispatcher 两个线程。 代码在: InputManager::InputManager().</span></span><ul><li><span class="name"><span class="innerContentContainer">InputReader 构造时, 会持有 QueuedInputListener对象 mQueuedListener;</span></span></li><li><span class="name"><span class="innerContentContainer">mQueuedListener 持有 InputClassifier对象.</span></span></li><li><span class="name"><span class="innerContentContainer">而 InputClassifier 对象则持有 InputDispatcher.</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader 就是这样和 InputDispatcher 通讯的. </span></span></li><li><span class="name"><span class="innerContentContainer">为什么搞得这么复杂? 为什么不让 InputReader 直接持有 InputDispatcher ? 我也不知道. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对象初始化完后，NativeInputManager调用 SM.addService(), 向系统注册 InputManager，并将该service 命名为“inputflinger”.</span></span></li><li><span class="name"><span class="innerContentContainer">最后，Java层的InputManagerService 调用 nativeStart() 启动 InputReader 和 InputDispatcher 两个线程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>InputReader <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/InputReader.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">是 systemserver子线程。</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader 持有 EventHub 和 InputDispatcher , 是Input子系统的核心. </span></span></li><li><span class="name"><span class="innerContentContainer">inputReader通过eventhub从 /dev/input节点获取事件，转换成EventEntry 事件，加入到 inputDispatcher 的mInboundQueue。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>loopOnce</b>() 是核心方式。在线程中死循环，循环一次处理一个事件。流程是：</span></span></li><li><span class="name"><span class="innerContentContainer"><b>1. 接收事件</b></span></span><ul><li><span class="name"><span class="innerContentContainer">mEventHub-&gt;getEvents()   // 通过 threadLoop，周期性的从EventHub中读取事件。</span></span><ul><li><span class="name"><span class="innerContentContainer">这些事件是 rawdata，即没有经过加工处理的事件；</span></span></li><li><span class="name"><span class="innerContentContainer">最终调用 epoll_wait() 来读取 /dev/input/input* 上的事件信息.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>2. 对事件信息进行数据封装</b></span></span><ul><li><span class="name"><span class="innerContentContainer">processEventLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">device-&gt;process(rawEvents, count);   // InputDevice代表输入设备</span></span></li><li><span class="name"><span class="innerContentContainer">mapper-&gt;process(rawEvent);     // InputMapper, 负责定义每种键值事件是如何处理的。</span></span></li><li><span class="name"><span class="innerContentContainer">触摸屏事件有如下处理:</span></span><ul><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::process(const RawEvent* rawEvent)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::sync(nsecs_t when)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::processRawTouches(bool timeout)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::cookAndDispatch(nsecs_t when)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) </span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::<b>dispatchMotion</b>(nsecs_t when...)  // 封装 NotifyArgs事件</span></span></li><li><span class="name"><span class="innerContentContainer">void QueuedInputListener::notifyMotion()</span></span></li><li><span class="name"><span class="innerContentContainer">mArgsQueue.<b>push</b>();   // 事件数据保存到 QueuedInputListener的 mArgsQueue中.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>3. 事件分发</b></span></span><ul><li><span class="name"><span class="innerContentContainer">R上把 inputreader. cpp中的内部类独立出去。所以这部分代码改动较大。</span></span></li><li><span class="name"><span class="innerContentContainer">R上仅剩下调用 mQueuedListener-&gt;flush();  </span></span></li><li><span class="name"><span class="innerContentContainer">mQueuedListener 即 QueuedInputListener, 事件监视器。</span></span></li><li><span class="name"><span class="innerContentContainer">QueuedInputListener 持有 listener对象，这是在 InputReader 初始化时new出的  InputClassifier对象。</span></span></li><li><span class="name"><span class="innerContentContainer">flush() 调用各 Args的 notify()接口，其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">触摸事件是 NotifyMotionArgs</span></span></li><li><span class="name"><span class="innerContentContainer">按键事件是NotifyKeyArgs</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Args的 notify接口只做一件事，就是调用 listener-&gt;notifyMotion() 或notifyKey().</span></span></li><li><span class="name"><span class="innerContentContainer">listener 就是上文提到的InputClassifier。</span></span></li><li><span class="name"><span class="innerContentContainer">其notifyMotion/notifyKey 只做一件事，就是调用持有的 InputDispatcher 对象的同名接口。以后参见后面介绍。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>InputDispatcher <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/InputDispatcher.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher为<b>systemserver子线程。</b></span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher 从mInboundQueue中取出事件，转化为DispatchEntry 事件，加入到各connection 的outboundQueue 队列。然后分发事件，取出outboundQueue事件，放入 waitQueue。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>核心接口是 notifyMotion/notifyKey</b> </span></span><ul><li><span class="name"><span class="innerContentContainer">如前述，由inputReader 调用。</span></span></li><li><span class="name"><span class="innerContentContainer">首先，检查事件的有效性。</span></span></li><li><span class="name"><span class="innerContentContainer">其次，调用Java侧的policy对象（即pwms）的interceptKeyBeforeQueueing和interceptMotionBeforeQueueing，判断当前事件是否要中断分发。中断分发即在fwk层进行处理，不分发给应用。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，调用 filterInputEvent() 进行输入事件的过滤。</span></span></li><li><span class="name"><span class="innerContentContainer">最后，也是最重要的的，即将 inputReader 层的NotifyArgs 数据结构，通过中间结构 MotionEntry/KeyEntry，最终转换成MotionEvent/KeyEvent。</span></span><ul><li><span class="name"><span class="innerContentContainer">MotionEvent/KeyEvent是关键的数据结构，应用层用的也是它。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">然后调用 enqueueInboundEventLocked() 将MotionEvent/KeyEvent放到mInboundQueue队列，并返回 needWake, 确认是否需要唤醒分发线程。如果需要，则调用 mLooper.wake() 进行唤醒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">enqueueInboundEventLocked()  // 将 eventEntry 放入分发队列.</span></span><ul><li><span class="name"><span class="innerContentContainer">首先确认是否需要唤醒分发线程。如果mInboundQueue 为空，则需要；否则不需要，因为队列不空，则分发线程已经被唤醒。</span></span></li><li><span class="name"><span class="innerContentContainer">然后将MotionEvent/KeyEvent放到mInboundQueue队列的尾部。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeQueueing()   // 按键事件在入队列前过滤</span></span><ul><li><span class="name"><span class="innerContentContainer">NativeInputManager.interceptKeyBeforeQueueing</span></span></li><li><span class="name"><span class="innerContentContainer">InputManagerService.interceptKeyBeforeQueueing</span></span></li><li><span class="name"><span class="innerContentContainer">InputMonitor.interceptKeyBeforeQueueing </span></span></li><li><span class="name"><span class="innerContentContainer">PhoneWindowManager.<b>interceptKeyBeforeQueueing()</b></span></span></li><li><span class="name"><span class="innerContentContainer">首先把事件都标记上 PASS_TO_USER，即事件要交给应用程序去处理。在处理过程中还是可能过滤掉这种事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">interceptMotionBeforeQueueing()  // 触摸事件在入队列前过滤</span></span><ul><li><span class="name"><span class="innerContentContainer">调用链和之前类似。最终调用到 PhoneWindowManager。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dispatchOnce()   // 循环执行事件分发. 这是线程 InputDispatcherThread 的主体。</span></span><ul><li><span class="name"><span class="innerContentContainer">与InputReader 一个循环可以处理多个事件不同，InputDispather 至少需要一次循环处理处理一个事件。这么做的原因是： </span></span><ul><li><span class="name"><span class="innerContentContainer">事件的目标窗口可能正在处理上一个事件，在窗口处理完之前，分发线程不能向该窗口发送新事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当命令队列中没有命令时，调用 dispatchOnceInnerLocked()进行事件分发。 其中传出参数 nextWakeupTime 决定下一次分发线程的循环超时时间。其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">max为无限等待；</span></span></li><li><span class="name"><span class="innerContentContainer">min表示不等待，马上开始下一次循环</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">然后执行命令队列 mCommandQueue中的命令。</span></span><ul><li><span class="name"><span class="innerContentContainer">命令是一个回调函数，通过 postCommandLocked() 加入队列。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可见命令队列的优先级高于事件队列。只要命令队列不为空，则本轮循环不处理事件队列。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 processAnrsLocked() 检查anr状态。如果有等待中的事件，通过缩小nextWakeupTime来提前唤醒自身。</span></span></li><li><span class="name"><span class="innerContentContainer">最后调用 mLoper.pollOnce() 阻塞自身，阻塞超时即为nextWakeupTime。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dispatchOnceInnerLocked()  // 从 mInboundQueue队列头部取出事件，检查事件是否要丢弃，然后调用 dispatchMotionLocked() 完成分发处理。 关键。</span></span><ul><li><span class="name"><span class="innerContentContainer">首先，检查分发模式是否处在禁用或冻结模式。模式包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">正常。</span></span></li><li><span class="name"><span class="innerContentContainer">禁用，会导致事件被丢弃。</span></span></li><li><span class="name"><span class="innerContentContainer">冻结，不会导致丢失事件，而是等解冻后继续分发。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 setInputDispatchMode() 维护该分发模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果事件队列为空，则返回。注意，此时返回的超时时间为max。</span></span></li><li><span class="name"><span class="innerContentContainer">然后从队列头部取一个MotionEvent对象下来，并保存到 mPendingEvent 中。</span></span></li><li><span class="name"><span class="innerContentContainer">mPendingEvent 可能已经有值，这意味着上一次循环没有处理完上一个事件，需要在本次循环中处理上一个事件（在这种情况下，本次事件会放到下一个循环中去处理）。</span></span></li><li><span class="name"><span class="innerContentContainer">如果事件是home或者app switch按下，即发生了应用切换，则启动一个0.5秒的定时器，0.5秒之后该窗口会丢弃所有未处理完的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">本轮循环待处理的事件明确后，调用 pokeUserActivityLocked 去搓一下事件所在的窗口。</span></span><ul><li><span class="name"><span class="innerContentContainer">窗口在用户点击后会有会做一定的响应，在这里调用会提升跟手性能。</span></span></li><li><span class="name"><span class="innerContentContainer">其实现方法是产生一个命令对象，然后调用 postCommandLocked 加入到命令队列，等下一个循环会完成调用。</span></span></li><li><span class="name"><span class="innerContentContainer">此命令对象最终会调用到 PowerManagerService的 userActivityFromNative(), 目的是控制屏幕亮灭。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">然后，检查事件是否需要被丢弃。 dropReason 保存丢失原因。原因包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">policy, 事件自身的策略</span></span></li><li><span class="name"><span class="innerContentContainer">disabled, 分发线程处在禁用状态</span></span></li><li><span class="name"><span class="innerContentContainer">app_switch, home键没有及时响应</span></span></li><li><span class="name"><span class="innerContentContainer">stale, 事件过期</span></span></li><li><span class="name"><span class="innerContentContainer">blocked, 事件由于妨碍了其它窗口获得事件而被丢弃。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用 dispatchKeyLocked 分发按键事件，调用 dispatchMotionLocked 分发触摸事件。</span></span></li><li><span class="name"><span class="innerContentContainer">如果事件被丢弃，为了保证窗口收到的事件仍能保持 up/down, enter/exit 的配对，调用 dropInboundEventLocked 对事件进行补发。</span></span></li><li><span class="name"><span class="innerContentContainer">事件处理完后，将 mPendingEvent 清空；如果队列非空，直接进入下一轮循环。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dispatchMotionLocked()&nbsp; // 分发触摸事件. 返回false表示未分发成功，将在下一轮循环中再次尝试。</span></span><ul><li><span class="name"><span class="innerContentContainer">根据事件类型寻找目标窗口，可能是多个；保存在 inputTargets 中。基于坐标点的事件用 findTouchedWindowTargetsLocked(), 其它类型的事件（比如轨迹球）用 findFocusedWindowTargetsLocked().</span></span></li><li><span class="name"><span class="innerContentContainer">如果查询窗口返回 值是 penging，说明找到一个窗口，但窗口处在无法响应状态，那么会直接退出，然后等下一轮循环再尝试。</span></span></li><li><span class="name"><span class="innerContentContainer">如果返回值不为succeeded, 表示无法为本事件寻找到窗口，比如没有窗口处在焦点状态，或者点击位置没有落在如何窗口内，则该事件会被丢弃。</span></span></li><li><span class="name"><span class="innerContentContainer">此处一般为提升跟手性能，会加入针对窗口-事件方面的定制方案。</span></span></li><li><span class="name"><span class="innerContentContainer">如果事件处理不成功，为保证成对，调用 synthesizeCancelationEventsForMonitersLocked() 注入事件。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 addGlobalMoniterTargetsLocked() 提交全局的moniter, 它们可以监听所有事件。</span></span></li><li><span class="name"><span class="innerContentContainer">最终，调用 dispatchEventLocked() 发送事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">findTouchedWindowTargetsLocked()  // 查找触摸事件的目标窗口列表。关键。</span></span><ul><li><span class="name"><span class="innerContentContainer">1、为支持分屏的down事件，以及目标窗口支持悬停或滚动事件的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 findTouchedWindowAtLocked() 根据坐标获取窗口列表。mWindowHandlesByDisplay 中保存所有 displayId 对应的窗口列表。</span></span></li><li><span class="name"><span class="innerContentContainer">检查各窗口，如果该窗口是可见的，</span></span></li><li><span class="name"><span class="innerContentContainer">如果窗口标志位中没有 FLAG_NOT_TOUCHABLE（有这个标志位就不能接收事件），</span></span></li><li><span class="name"><span class="innerContentContainer">如果窗口是模式窗口，即没有 FLAG_NOT_FOCUSABLE 和 FLAG_NOT_TOUCH_MODAL 标志。模式窗口的特点是当它显示在桌面上时，所有的输入事件，不管在窗口内还是窗口外，都会发给该模式窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">或者当前事件的坐标在窗口的内部。窗口的 region 由多个 rect 组成，只要事件在任意一个rect，就算touch到该窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">满足这些条件的窗口即为事件的当前窗口，可以有多个。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，同一个displayId的窗口列表是按zorder顺序从上至下依次排列的，数组索引底的zorder高，反之低则。所以如果某一窗口满足条件，就不需要再循环检查其后的窗口了。</span></span></li><li><span class="name"><span class="innerContentContainer">手势监控器即开发者模式中的显示触摸位置。</span></span></li><li><span class="name"><span class="innerContentContainer">确定当前窗口是否支持分割触摸点。触摸事件支持分割，鼠标事件由于不支持多点所以不支持。</span></span></li><li><span class="name"><span class="innerContentContainer">如果当前窗口不支持分割触摸点，但是触摸事件已分割，则忽略新的touch窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">如果所有窗口都不满足条件，则直接使用前台窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">如果窗口处在paused状态，则将窗口对象置空。</span></span></li><li><span class="name"><span class="innerContentContainer">如果窗口的connect 为空，则将窗口对象置空。</span></span></li><li><span class="name"><span class="innerContentContainer">如果窗口的connect处在响应中状态，也将窗口对象置空。窗口有事件在处理，则不再发事件给它。</span></span></li><li><span class="name"><span class="innerContentContainer">至此，窗口已经找到。</span></span></li><li><span class="name"><span class="innerContentContainer">第一步是给窗口加标志位。首先加 FLAG_FOREGROUND 和 FLAG_DISPATCH_AS_IS。如果有分割触摸事件，则加 FLAG_SPLIT。</span></span></li><li><span class="name"><span class="innerContentContainer">在窗口列表中，检查事件坐标是否还落在其它 非trustedoverlay窗口（trustedoverlay窗口指 输入法、状态栏、导航栏等），如果有则加属性 。</span></span></li><li><span class="name"><span class="innerContentContainer">在窗口列表中，检查是否存在其它trustedoverlay窗口和当前窗口存在重叠，如果有则加属性 。</span></span></li><li><span class="name"><span class="innerContentContainer">如果将当前窗口对象加入到 mTempTouchState 中去。将手势监控器加入到 mTempTouchState的 gestureMonitors中去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2、对于move, up, cancel, 以及非分屏的 down事件</span></span><ul><li><span class="name"><span class="innerContentContainer">如果事件没有对应的 down事件，则直接忽略。</span></span></li><li><span class="name"><span class="innerContentContainer">检查事件是否已经移动出窗口范围。如果是的话则去掉旧窗口的 FLAG_DISPATCH_AS_IS 属性，然后把新窗口加入到 mTempTouchState中去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3、处理带 hover属性的窗口，加入 mTempTouchState。</span></span></li><li><span class="name"><span class="innerContentContainer">4、检查注入事件的权限，确保事件至少有一个前台窗口。</span></span><ul><li><span class="name"><span class="innerContentContainer">injectionState 不为空标识事件为注入事件，不是硬件上报。</span></span></li><li><span class="name"><span class="innerContentContainer">注入事件需要检查注入进程的pid和uid是否具有注入权限。</span></span></li><li><span class="name"><span class="innerContentContainer">如果事件没有touched的窗口接受，则报错退出。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5、如果当前事件是 down事件，并且前台touched窗口存在，那么需要检查所有的非前台的touched的窗口是否具有 FLAG_DISPATCH_AS_OUTSIDE标识。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果有，且该窗口和其它窗口不是在同一个应用（same UID），</span></span></li><li><span class="name"><span class="innerContentContainer">则该窗口加入 tempTouchState, 并添加 FLAG_ZERO_COORDS属性，目的是不显示该事件坐标。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6、如果是down事件，且当前窗口具有墙纸，则需要添加墙纸窗口，以便在触摸手势过程中将其锁定。</span></span><ul><li><span class="name"><span class="innerContentContainer">墙纸窗口仅支持触摸事件，在 hover和scroll事件过程中不做处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">至此，说明前台touched窗口已经准备好接收事件。一切OK。</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 addWindowTargetLocked() 为每个touched窗口创建 inputTarget。为每个手势监控器创建 inputTarget。</span></span></li><li><span class="name"><span class="innerContentContainer">丢弃outside和hover窗口，因为下一次循环中不需要关注它们。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7、错误处理，以及对hover和scroll事件的处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">findTouchedWindowAtLocked()  // 根据事件的坐标点确定目标窗口。如果目标窗口准备时间超时，则进入ANR。关键。</span></span><ul><li><span class="name"><span class="innerContentContainer">按z-order从高到底依次遍历当前displayID的所有窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">判断displayID是否正确；</span></span></li><li><span class="name"><span class="innerContentContainer">判断窗口是否可见；</span></span></li><li><span class="name"><span class="innerContentContainer">如果窗口是否可触摸，而且坐标在窗口范围内，</span></span></li><li><span class="name"><span class="innerContentContainer">并且坐标有效，则返回该窗口对象。</span></span></li><li><span class="name"><span class="innerContentContainer">如果是down事件，那么对于状态栏，虚拟导航栏等窗口，它们具有FLAG_WATCH_OUTSIDE_TOUCH属性，需要监听outside触摸事件，所以应该放入窗口列表。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">findFocusedWindowTargetsLocked()  // 查找目标焦点窗口。针对按键事件和非触摸屏的motion事件，比如滚迹球。</span></span><ul><li><span class="name"><span class="innerContentContainer">获取指定displayID的焦点窗口和焦点应用。注意存在有焦点应用、无焦点窗口的情况：应用进程已启动，但主界面由于某种原因没有显示出来。</span></span></li><li><span class="name"><span class="innerContentContainer">如果焦点窗口和焦点应用都为空，则返回。</span></span></li><li><span class="name"><span class="innerContentContainer">如果有焦点应用，但没有焦点窗口，则启动anr倒计时，倒计时是5秒。在这期间，等待窗口显示出来。</span></span><ul><li><span class="name"><span class="innerContentContainer">仅在分配焦点事件时计时，如果有触摸事件和其它应用交互，则anr取消。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果找到焦点窗口，则取消之前定义的倒计时。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">addGlobalMonitoringTargetsLocked()  // 添加全局手势监听器到 inputTargets 队列中</span></span><ul><li><span class="name"><span class="innerContentContainer">把 mGlobalMonitorsByDisplay 中保存的monitor对象转化为InputTarget 对象，然后保存到inputTargets中去。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，monitor创建的InputTarget对象是没有 pointerIds的，说明该 InputTarget 会接受所有的输入事件。而目标窗口的InputTarget对象只能接受坐标在窗口内部的事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dispatchKeyLocked()  // 分发按键事件</span></span><ul><li><span class="name"><span class="innerContentContainer">寻找当前焦点窗口，然后分发事件给它。</span></span></li><li><span class="name"><span class="innerContentContainer">根据每一个target（一个事件可以有多个）对应的inputChannel找到connection。</span></span></li><li><span class="name"><span class="innerContentContainer">大致逻辑类似于dispatchMotionLocked()， 不赘述。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dispatchMotionLocked() 和dispatchKeyLocked()最终都是调用 dispatchEventLocked() 来完成最终传输动作。</span></span><ul><li><span class="name"><span class="innerContentContainer">循环 inputTargets中的每个对象，获取 InputTarget 对象的 InputChannel 的 connectionToken ，根据后者获取 connection对象。如果后者为空，则说明该窗口或者monitor对象没有向 inputdispatcher注册 InputChannel ，那么它就不能接受事件。</span></span></li><li><span class="name"><span class="innerContentContainer">如果 connection不为空，则调用 prepareDispatchCycleLocked()  做分发前的准备，主要是分割事件。</span></span></li><li><span class="name"><span class="innerContentContainer">触摸事件支持分割（FLAG_SPLIT）。如果窗口的触摸点数和原始事件的点数不同，则需要调用 splitMotionEvent() 分割事件。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 enqueueDispatchEntriesLocked() ，把事件封装为  dispatchEntry，然后加入到目标 connection 的 outbound Queue中。</span></span><ul><li><span class="name"><span class="innerContentContainer">这里有一些对input事件的定制。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">splitMotionEvent()  // 分割事件。</span></span><ul><li><span class="name"><span class="innerContentContainer">根据目标窗口 InputTarget 中触摸点的信息（pointerIds），在原来的全部事件中查找当前窗口的触摸点的信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">startDispatchCycleLocked() // 真正完成事件分发过程。</span></span><ul><li><span class="name"><span class="innerContentContainer">通过InputPublisher. publishKeyEvent() 发布按键事件。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 InputPublisher. publishMotionEvent() 发布触摸事件。</span></span></li><li><span class="name"><span class="innerContentContainer">此处存在大量定制。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">processAnrsLocked()  // 监控事件处理过程是否超时，完成 ANR处理。返回值是下次唤醒的时间。关键。</span></span><ul><li><span class="name"><span class="innerContentContainer">这部分是R上的变化，之前版本上ANR处理放在findwindow 上下文中，现在放到最外层处理，更紧凑。</span></span></li><li><span class="name"><span class="innerContentContainer">检查是否在等待焦点窗口显示出来，如果等待太久则调用 processNoFocusedWindowAnrLocked() - onAnrLocked() 抛出anr。</span></span></li><li><span class="name"><span class="innerContentContainer">检查所有连接的等待队列是否有太旧的事件，如果有，stop 该连接，然后调用 onAnrLocked() 抛出anr。</span></span></li><li><span class="name"><span class="innerContentContainer">抛出anr的方法是调用 mPolicy(这是啥？前文有介绍) 的同名接口，后者的处理是调用Java层 IMS.notifyANR()。</span></span></li><li><span class="name"><span class="innerContentContainer">Java层处理完后，会返回一个新的 nextAnrCheck, 表示继续等待该窗口一段时间。这个会返回给 dispatchOnce，用于计算下一次唤醒的时间。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">addWindowTargetLocked()  // 为找到的window 生成 InputTarget 对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">以 connection 句柄为条件，在用于输出的 inputTargets中查找是否存在和当前touched 窗口重复的窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">如果不存在，则说明 windowHandle 为新窗口，则加入。</span></span></li><li><span class="name"><span class="innerContentContainer">然后增加点。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它关键功能有：</span></span></li><li><span class="name"><span class="innerContentContainer">wms通过 setInputWindows() 接口，更新input的窗口列表，用于查找指针触摸位置的窗口，以及更新焦点窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">viewrRootImpl通过IMS.registerInputChannel() 接口注册connection，用于将事件送到对应窗口的viewrRootImpl中去处理。</span></span></li><li><span class="name"><span class="innerContentContainer">管理系统服务注册的输入监控，用于将特定事件送到监控对象中，比如全局手势监控。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EventHub</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/EventHub.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">EventHub是事件的起源地，所有的事件都是它从驱动中读取出来的。</span></span></li><li><span class="name"><span class="innerContentContainer">负责监视  /dev/input/eventX 多个FD上产生的事件，包括设备添加，移除，以及触摸等事件, 然后把事件封装成 RawEvent 结构体供 InputReader 使用。</span></span></li><li><span class="name"><span class="innerContentContainer">此时的数据结构叫 RawEvent。数据类型参见 log打印。</span></span></li><li><span class="name"><span class="innerContentContainer">对设备节点的监听, 是通过Linux提供的epoll机制来实现。epoll机制简单地说就是 I/O多路复用.</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 epoll_wait()来监听所需要的文件描述符的变化。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">InputMapper</span></span><ul><li><span class="name"><span class="innerContentContainer">InputReader对原始输入事件的处理都是放在InputMapper 中去。</span></span></li><li><span class="name"><span class="innerContentContainer">每种输入设备都有一个InputMapper 类。比如触摸屏有两个，SigleTouchInputMapper 和 MultiTouchInputMapper。</span></span></li><li><span class="name"><span class="innerContentContainer">核心函数是sync。sync的含义是一个完整的事件接收完毕。因为很多事件是分多次上报。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputPublisher</span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp 的内部类.</span></span></li><li><span class="name"><span class="innerContentContainer">调用 InputChannel 发送事件, 并接受finish事件.</span></span></li><li><span class="name"><span class="innerContentContainer">核心函数是：</span></span></li><li><span class="name"><span class="innerContentContainer">publishKeyEvent() //发布按键事件。</span></span></li><li><span class="name"><span class="innerContentContainer">publishMotionEvent()  //发布触摸事件。</span></span></li><li><span class="name"><span class="innerContentContainer">这两者都是先把数据转为 InputMessage ，然后调用 InputChannel.sendMessage() 完成发送。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputConsumer</span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp 的内部类</span></span></li><li><span class="name"><span class="innerContentContainer">消费来自 inputChannel 的事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>InputChannel</b></span></span><ul><li><span class="name"><span class="innerContentContainer">InputChannel 负责管理IMS和各应用activity之间的socket通道。</span></span></li><li><span class="name"><span class="innerContentContainer">通道的server端给 InputDispatcher, client端给窗口window对象管理。</span></span></li><li><span class="name"><span class="innerContentContainer">活跃的activity都有自己的 InputChannel对象。在wms 的ViewRootImpl.<b>setView</b>() 中创建。然后把 InputChannel 传递给 WMS。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 sendMessage() 发送事件。其流程是：</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 send() 向目标fd(socket句柄)的socket流写入数据. 采用异步非阻塞方式。</span></span></li><li><span class="name"><span class="innerContentContainer">在另一边的 epoll_wait()调用，会因fd数据的到来而唤醒，并通过fd找到注册好的request listener.</span></span></li><li><span class="name"><span class="innerContentContainer">进而调用 request中的 NativeInputEventReceiver的 handleEvent()方法，参数就是我们接收到的事件信息与数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过 receiveMessage() 接受事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputFilter</span></span><ul><li><span class="name"><span class="innerContentContainer">这是一个java类，负责对事件进行拦截, 过滤. 比如手势识别, 辅助功能, 盲人模式等模块会用. </span></span></li><li><span class="name"><span class="innerContentContainer">AccessbilityManagerService 负责初始化 InputFilter.</span></span></li><li><span class="name"><span class="innerContentContainer">然后赋值给 InputManagerService. InputManagerService&nbsp;只支持一个InputFilter,&nbsp;新注册的InputFilter会把老的覆盖。</span></span></li><li><span class="name"><span class="innerContentContainer">filterInput()&nbsp;的调用是发生在Input Reader线程里，通过InputManagerService&nbsp;里的&nbsp;InputFilterHost&nbsp;对象通知另外一个线程里的InputFilter&nbsp;开始真正的解析工作。</span></span></li><li><span class="name"><span class="innerContentContainer">InputFilter&nbsp;的工作也分为两个步骤，首先由InputEventConsistencyVerifier&nbsp;对象（InputEventConsistencyVerifier.java）对输入事件的完整性做一个检查，检查事件的ACTION_DOWN&nbsp;和&nbsp;ACTION_UP&nbsp;是否一一配对。</span></span></li><li><span class="name"><span class="innerContentContainer">接下来，进入到 AccessibilityInputFilter&nbsp;的&nbsp;onInputEvent()，这里将把输入事件（主要是MotionEvent)进行处理，根据需要变成另外一个Event，然后通过sendInputEvent() 将事件发回给InputDispatcher。最终调用到injectInputEvent()&nbsp;将这个事件送入&nbsp;mInBoundQueue.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">com_android_server_input_InputManagerService.cpp</span></span><ul><li><span class="name"><span class="innerContentContainer">jni代码，负责承上启下。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>服务层(Java)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">InputManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">InputMoniter.java</span></span></li><li><span class="name"><span class="innerContentContainer">WindowManagerPolicy.java</span></span></li><li><span class="name"><span class="innerContentContainer"><b>PhoneWindowManager.java <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeQueueing()  // 事件入队列前的过滤</span></span><ul><li><span class="name"><span class="innerContentContainer">inputDispatcher 中调用。</span></span></li><li><span class="name"><span class="innerContentContainer">interceptPowerKeyDown(): power按下。处理逻辑较多，包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">调用 wakeUpFromPowerKey() 管理亮灭屏</span></span></li><li><span class="name"><span class="innerContentContainer">长按关机的定时器的启动</span></span></li><li><span class="name"><span class="innerContentContainer">来电来闹钟时按下power静音。</span></span></li><li><span class="name"><span class="innerContentContainer">钱包应用，双击付款。</span></span></li><li><span class="name"><span class="innerContentContainer">亮屏处理一般在100毫秒内处理完为正常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">interceptPowerKeyUp(): power抬起</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 powerPress () 处理power键事件。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeDispatching()  // 事件分发到应用层之前的过滤。</span></span><ul><li><span class="name"><span class="innerContentContainer">inputDispatcher 中调用。</span></span></li><li><span class="name"><span class="innerContentContainer">recent键在这里处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">handleShortPressOnHome()   // home键短按事件</span></span></li><li><span class="name"><span class="innerContentContainer">handleDoubleTapOnHome()  // home键双击事件</span></span></li><li><span class="name"><span class="innerContentContainer">powerLongPress()  // 长按power健，进关机流程</span></span><ul><li><span class="name"><span class="innerContentContainer">系统关机弹框有两个：systemui 维护的 ActionDialog, 这是默认的；</span></span></li><li><span class="name"><span class="innerContentContainer">当ActionDialog 挂掉之后，系统会调用原生的 LegacyGlobalActions 弹框。</span></span></li><li><span class="name"><span class="innerContentContainer">上述判断在 GlobalActions.java 的 showDialog() 中处理。</span></span></li><li><span class="name"><span class="innerContentContainer">用户现在关机后，进入 PowerAction.java 的 onPress() 继续处理。</span></span></li><li><span class="name"><span class="innerContentContainer">最终调用 PhoneWindowManager.java 的 shutdown() 完成关机动作。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Activity -&gt; Windows -&gt; DecorView -&gt; ViewGroup -&gt; 各子View</span></span></li><li><span class="name"><span class="innerContentContainer">Activity中 InputEventReceiver的 <b>onInputEvent ()</b>被回调，开始 java层touch事件传递。</span></span></li><li><span class="name"><span class="innerContentContainer">InputStage的子类有: NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage、EarlyPostImeInputStage、NativePostImeInputStage、ViewPostImeInputStage、SyntheticInputStage.</span></span><ul><li><span class="name"><span class="innerContentContainer">它们构成一个输入事件处理链，如果本阶段对事件没有处理，则传递到下一个对象进行处理，直至事件被处理。</span></span></li><li><span class="name"><span class="innerContentContainer">NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage三个类用来实现输入法的按键派发和处理，如果事件不传递到输入法服务中，这三个类可以跳过。</span></span></li><li><span class="name"><span class="innerContentContainer">EarlyPostImeInputStage对象开始处理，在 ViewPostImeInputStage 对象处理阶段调用了主View 对象（对应PhoneWindow中的DecorView对象）的事件提交函数如（dispatchTouchEvent）函数向视图对象提交输入事件, 在当前窗口的视图树中派发事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MainActivity.&nbsp;<b>DecorView</b> 在传递事件过程中首先将事件传给Activity的 dispatchTouchEvent()方法，所以我们可以重写这个方法来阻止事件继续传递。</span></span></li><li><span class="name"><span class="innerContentContainer">如果 onInterceptTouchEvent() 返回true，<b>ViewGroup </b>就会拦截touch事件，由自己的dispatchTouchEvent()  继续分发. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>ViewGroup.dispatchTouchEvent() 详解:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">TouchTarget链表保存了处理了初始触摸事件的子View，注意只有一系列触摸动作的初始事件（Down事件）才会找到对应的子View并生成TouchTarget的一个节点。后面的系列事件都会分发给TouchTarget链表中保存的子View，这也就意味着，如果一个子View没有处理初始的Down事件，那么它也就不会再接收到后面的move&nbsp;up等事件。</span></span></li><li><span class="name"><span class="innerContentContainer">如果onInterceptTouchEvent()返回true，当前ViewGroup拦截了该事件，那么该事件不会再向下面分发，并且会向TouchTarget中保存的所有子View发送cancel事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会移除分发记录，意味着后面的事件也不再会分发到子View。</span></span></li><li><span class="name"><span class="innerContentContainer">如果是辅助功能的事件，那么会优先分发给支持辅助功能的View，如果不存在这样的view，则进行一般的事件分发。</span></span></li><li><span class="name"><span class="innerContentContainer">1. 判断是否被拦截</span></span></li><li><span class="name"><span class="innerContentContainer">2. 如果未被拦截且为初始事件，找到可以处理事件的子View（在点击范围内且可被点击），分发事件后如果该子View处理了事件（dispatchTouchEvent()方法返回true）则存入TouchTarget链表并停止子View的遍历（后面的子View就没有机会再收到事件），如果该子View没有处理该事件，则继续遍历寻找</span></span></li><li><span class="name"><span class="innerContentContainer">3. 如果事件被拦截，向TouchTarget中的子View发送cancel事件</span></span></li><li><span class="name"><span class="innerContentContainer">4. 将未被2、3情况处理的事件分发给TouchTarget中的子View，如果TouchTarget为空，则交给ViewGroup本身父View的dispatchTouchEvent()方法处理. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当一个触摸事件分发到一个非ViewGroup的View或者ViewGroup不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么View类的dispatchTouchEvent()将会被调用.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>View.dispatchTouchEvent() 详解:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">主要是先检查是否注册了onTouchListener，如果注册了监听并且调用返回了true消耗了该事件，那么说明该View处理了该事件，也会收到后续的事件，</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有注册监听或者没有消耗，就调用View本身的 onTouchEvent()，如果返回true则消耗事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">View<b>.</b>onTouchEvent(), 按事件类型(up, down, move, cancel) 分别处理. 判断是否触发单击、长按、长按等, 并提供了默认的按下、点击、长按的视觉反馈。</span></span></li><li><span class="name"><span class="innerContentContainer">应用层事件封装成 MotionEvent。</span></span><ul><li><span class="name"><span class="innerContentContainer">mAction的低8位（也就是0-7位）是动作类型信息。</span></span></li><li><span class="name"><span class="innerContentContainer">mAction的8-15位，是触控点的索引信息。（即表示是哪一个触控点的事件）。</span></span></li><li><span class="name"><span class="innerContentContainer">MotionEvent有两个方法，一个是getAction(),另一个是getActionMasked(), 二个方法就是通过掩码的方式隐去触控点的索引信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层处理事件</span></span><ul><li><span class="name"><span class="innerContentContainer">Android的事件处理分为 基于监听的机制, 以及基于回调的机制.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>基于监听的机制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">实现方式有多种: </span></span></li><li><span class="name"><span class="innerContentContainer"> 用匿名内部类, 最常见.</span></span><ul><li><span class="name"><span class="innerContentContainer">最常用的一种:直接 setXxxListener后, 重写里面的方法即可.</span></span></li><li><span class="name"><span class="innerContentContainer">使用场景: 匿名类临时使用一次, 复用性不高. 匿名类最大的好处是免得为取名字而费脑筋.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btnshow;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow = (Button) findViewById(R.id.btnshow);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow.<b>setOnClickListener</b>(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">//重写点击事件的处理方法onClick()</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//显示Toast信息</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "你点击了按钮", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用内部类, 比较常见.</span></span><ul><li><span class="name"><span class="innerContentContainer">对监听类进行命名. </span></span></li><li><span class="name"><span class="innerContentContainer">目的是复用. 如果本activity中的多个控件使用同一个监听器类, 则会节省很多代码.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btnshow;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow = (Button) findViewById(R.id.btnshow);</span></span></li><li><span class="name"><span class="innerContentContainer">//直接new一个内部类对象作为参数</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow.<b>setOnClickListener</b>(new BtnClickListener());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法</span></span></li><li><span class="name"><span class="innerContentContainer">class <b>BtnClickListener </b>implements View.OnClickListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用外部类</span></span><ul><li><span class="name"><span class="innerContentContainer">这种形式用的比较少！因为外部类不能直接访问用户界面类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁.</span></span></li><li><span class="name"><span class="innerContentContainer">使用场景是多个activity共用同一个监听器类, 则可以这么用. 但是这样耦合性太高, 不建议.</span></span></li><li><span class="name"><span class="innerContentContainer">将内部类外部化即可, 不累述.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">直接使用Activity作为事件监听器</span></span><ul><li><span class="name"><span class="innerContentContainer">需要让Activity类实现XxxListener事件监听接口, 在Activity中定义重写对应的事件处理器方法.</span></span></li><li><span class="name"><span class="innerContentContainer">// 让Activity方法实现OnClickListener接口</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity implements <b>OnClickListener </b>{</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btnshow;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow = (Button) findViewById(R.id.btnshow);</span></span></li><li><span class="name"><span class="innerContentContainer">// 直接写个this</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow.<b>setOnClickListener</b>(<b>this</b>);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 重写接口中的抽象方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "点击了按钮", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">直接绑定到布局文件</span></span><ul><li><span class="name"><span class="innerContentContainer">就是直接在xml布局文件中对应得Activity中定义一个事件处理方法</span></span></li><li><span class="name"><span class="innerContentContainer">// 布局文件</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">xmlns:tools="http://schemas.android.com/tools"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/LinearLayout1"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:orientation="vertical" &gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;Button</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="按钮"</span></span></li><li><span class="name"><span class="innerContentContainer">// 直接使用函数名</span></span></li><li><span class="name"><span class="innerContentContainer">android:onClick="<b>myclick</b>"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/LinearLayout&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 代码</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 自定义一个方法,传入一个view组件作为参数</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>myclick</b>(View source) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>基于回调的机制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">主要使用场景是自定义view.</span></span></li><li><span class="name"><span class="innerContentContainer">当用户在GUI组件上激发某个事件时, 组件有自己特定的方法会负责处理该事件. 通常用法:继承基本的GUI组件,重写该组件的事件处理方法,即自定义view.</span></span></li><li><span class="name"><span class="innerContentContainer">注意: 在xml布局中使用自定义的view时,需要使用"全限定类名".</span></span></li><li><span class="name"><span class="innerContentContainer">常见的回调方法有:</span></span><ul><li><span class="name"><span class="innerContentContainer">在该组件上触发屏幕事件: boolean&nbsp;<b>onTouchEvent</b>(MotionEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">在该组件上按下某个按钮时: boolean&nbsp;<b>onKeyDown</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">松开组件上的某个按钮时: boolean&nbsp;<b>onKeyUp</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">长按组件某个按钮时: boolean&nbsp;<b>onKeyLongPress</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">键盘快捷键事件发生: boolean&nbsp;<b>onKeyShortcut</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">在组件上触发轨迹球屏事件: boolean&nbsp;onTrackballEvent(MotionEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">当组件的焦点发生改变,和前面的6个不同,这个方法只能够在View中重写哦！ protected void&nbsp;<b>onFocusChanged</b>(boolean gainFocus, int direction, Rect previously FocusedRect)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">自定义view使用事件回调的例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 布局</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">xmlns:tools="http://schemas.android.com/tools"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">tools:context=".MyActivity"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;example.jay.com.mybutton.MyButton</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="按钮"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">// MyButton.java</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyButton extends Button{</span></span><ul><li><span class="name"><span class="innerContentContainer">private static String TAG = "呵呵";</span></span></li><li><span class="name"><span class="innerContentContainer">public MyButton(Context context, AttributeSet attrs) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super(context, attrs);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//重写键盘按下触发的事件</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onKeyDown(int keyCode, KeyEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onKeyDown(keyCode,event);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onKeyDown方法被调用");</span></span></li><li><span class="name"><span class="innerContentContainer"><b>return true;</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//重写弹起键盘触发的事件</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onKeyUp(int keyCode, KeyEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onKeyUp(keyCode,event);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onKeyUp方法被调用");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//组件被触摸了</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouchEvent(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onTouchEvent(event);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onTouchEvent方法被调用");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件冒泡</b></span></span><ul><li><span class="name"><span class="innerContentContainer">这个概念非常关键, 但是理解有难度. 注意好好掌握. </span></span></li><li><span class="name"><span class="innerContentContainer">事件传播的顺序:</span></span><ul><li><span class="name"><span class="innerContentContainer">触发组件绑定的事件监听器</span></span></li><li><span class="name"><span class="innerContentContainer">触发组件提供的回调;</span></span></li><li><span class="name"><span class="innerContentContainer">传播到父view, 也是先事件监听器, 后回调;</span></span></li><li><span class="name"><span class="innerContentContainer">传播到组件所在的activity.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这个链条的每个方法的返回值都是 Boolean, 用于表示该事件是否处理完了. 如果返回 True, 则表示处理完了. 如果返回 False, 则会继续传递.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复杂事件处理: OnTouchListener, 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">onTouch(View v, MotionEvent event):这里面的参数依次是触发触摸事件的组件,触碰事件event 封装了触发事件的详细信息，同样包括事件的类型、触发时间等信息。比如event.getX(),event.getY()</span></span></li><li><span class="name"><span class="innerContentContainer">我们也可以对触摸的动作类型进行判断,使用event.getAction( )再进行判断;如:</span></span></li><li><span class="name"><span class="innerContentContainer">event.getAction == MotionEvent.ACTION_DOWN：按下事件</span></span></li><li><span class="name"><span class="innerContentContainer">event.getAction == MotionEvent.ACTION_MOVE:移动事件</span></span></li><li><span class="name"><span class="innerContentContainer">event.getAction == MotionEvent.ACTION_UP:弹起事件</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyView extends View{</span></span><ul><li><span class="name"><span class="innerContentContainer">public float X = 50;</span></span></li><li><span class="name"><span class="innerContentContainer">public float Y = 50;</span></span></li><li><span class="name"><span class="innerContentContainer">//创建画笔</span></span></li><li><span class="name"><span class="innerContentContainer">Paint paint = new Paint();</span></span></li><li><span class="name"><span class="innerContentContainer">public MyView(Context context,AttributeSet set)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">super(context,set);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onDraw(Canvas canvas) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onDraw(canvas);</span></span></li><li><span class="name"><span class="innerContentContainer">paint.setColor(Color.BLUE);</span></span></li><li><span class="name"><span class="innerContentContainer">canvas.drawCircle(X,Y,30,paint);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouchEvent(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">this.X = event.getX();</span></span></li><li><span class="name"><span class="innerContentContainer">this.Y = event.getY();</span></span></li><li><span class="name"><span class="innerContentContainer">//通知组件进行重绘</span></span></li><li><span class="name"><span class="innerContentContainer">this.invalidate();</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多点触碰</span></span><ul><li><span class="name"><span class="innerContentContainer">多点触碰就是多个手指在屏幕上进行操作，用的最多的估计是放大缩功能吧，比如很多的图片浏览器都支持缩放！理论上Android系统本身可以处理多达256个手指的触摸，当然这取决于手机硬件的支持.</span></span></li><li><span class="name"><span class="innerContentContainer">前面两点都有用到 MotionEvent，可根据event.getAction() &amp; MotionEvent.ACTION_MASK 来判断是哪种操作, 包括按下, 抬起, 移动.</span></span></li><li><span class="name"><span class="innerContentContainer">除了上面介绍的三种单点操作外，还有两个多点专用的操作：</span></span><ul><li><span class="name"><span class="innerContentContainer">MotionEvent.ACTION_POINTER_DOWN:当屏幕上已经有一个点被按住，此时再按下其他点时触发。</span></span></li><li><span class="name"><span class="innerContentContainer">MotionEvent.ACTION_POINTER_UP:当屏幕上有多个点被按住，松开其中一个点时触发（即非最后一个点被放开时）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件上报流程:</span></span><ul><li><span class="name"><span class="innerContentContainer">当我们一个手指触摸屏幕 --&gt; 触发ACTION_DOWN事件</span></span></li><li><span class="name"><span class="innerContentContainer">接着有另一个手指也触摸屏幕 --&gt; 触发ACTION_POINTER_DOWN事件,如果还有其他手指触摸，继续触发</span></span></li><li><span class="name"><span class="innerContentContainer">有一个手指离开屏幕 --&gt; 触发ACTION_POINTER_UP事件，继续有手指离开，继续触发</span></span></li><li><span class="name"><span class="innerContentContainer">当最后一个手指离开屏幕 --&gt; 触发ACTION_UP事件</span></span></li><li><span class="name"><span class="innerContentContainer">而且在整个过程中，ACTION_MOVE事件会一直不停地被触发.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可以通过 event.getX(int)或者 event.getY(int)来获得不同触摸点的位置： 比如 event.getX(0)可以获得第一个接触点的X坐标，event.getX(1)获得第二个接触点的X坐标这样.</span></span></li><li><span class="name"><span class="innerContentContainer">可以通过 MotionEvent.getPointerCount()方法判断当前有多少个手指在触摸. 例如：</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity implements OnTouchListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">private ImageView img_test;</span></span></li><li><span class="name"><span class="innerContentContainer">// 縮放控制</span></span></li><li><span class="name"><span class="innerContentContainer">private Matrix matrix = new Matrix();</span></span></li><li><span class="name"><span class="innerContentContainer">private Matrix savedMatrix = new Matrix();</span></span></li><li><span class="name"><span class="innerContentContainer">// 不同状态的表示：</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int NONE = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int DRAG = 1;</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int ZOOM = 2;</span></span></li><li><span class="name"><span class="innerContentContainer">private int mode = NONE;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义第一个按下的点，两只接触点的重点，以及出事的两指按下的距离：</span></span></li><li><span class="name"><span class="innerContentContainer">private PointF startPoint = new PointF();</span></span></li><li><span class="name"><span class="innerContentContainer">private PointF midPoint = new PointF();</span></span></li><li><span class="name"><span class="innerContentContainer">private float oriDis = 1f;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">img_test = (ImageView) this.findViewById(R.id.img_test);</span></span></li><li><span class="name"><span class="innerContentContainer">img_test.setOnTouchListener(this);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouch(View v, MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView view = (ImageView) v;</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {</span></span></li><li><span class="name"><span class="innerContentContainer">// 单指</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_DOWN:</span></span><ul><li><span class="name"><span class="innerContentContainer">matrix.set(view.getImageMatrix());</span></span></li><li><span class="name"><span class="innerContentContainer">savedMatrix.set(matrix);</span></span></li><li><span class="name"><span class="innerContentContainer">startPoint.set(event.getX(), event.getY());</span></span></li><li><span class="name"><span class="innerContentContainer">mode = DRAG;</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 双指</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_POINTER_DOWN:</span></span><ul><li><span class="name"><span class="innerContentContainer">oriDis = distance(event);</span></span></li><li><span class="name"><span class="innerContentContainer">if (oriDis &gt; 10f) {</span></span><ul><li><span class="name"><span class="innerContentContainer">savedMatrix.set(matrix);</span></span></li><li><span class="name"><span class="innerContentContainer">midPoint = middle(event);</span></span></li><li><span class="name"><span class="innerContentContainer">mode = ZOOM;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 手指放开</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_UP:</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_POINTER_UP:</span></span><ul><li><span class="name"><span class="innerContentContainer">mode = NONE;</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 单指滑动事件</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_MOVE:</span></span><ul><li><span class="name"><span class="innerContentContainer">if (mode == DRAG) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 是一个手指拖动</span></span></li><li><span class="name"><span class="innerContentContainer">matrix.set(savedMatrix);</span></span></li><li><span class="name"><span class="innerContentContainer">matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else if (mode == ZOOM) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 两个手指滑动</span></span></li><li><span class="name"><span class="innerContentContainer">float newDist = distance(event);</span></span></li><li><span class="name"><span class="innerContentContainer">if (newDist &gt; 10f) {</span></span><ul><li><span class="name"><span class="innerContentContainer">matrix.set(savedMatrix);</span></span></li><li><span class="name"><span class="innerContentContainer">float scale = newDist / oriDis;</span></span></li><li><span class="name"><span class="innerContentContainer">matrix.postScale(scale, scale, midPoint.x, midPoint.y);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置ImageView的Matrix</span></span></li><li><span class="name"><span class="innerContentContainer">view.setImageMatrix(matrix);</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 计算两个触摸点之间的距离</span></span></li><li><span class="name"><span class="innerContentContainer">private float distance(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">float x = event.getX(0) - event.getX(1);</span></span><ul><li><span class="name"><span class="innerContentContainer">float y = event.getY(0) - event.getY(1);</span></span></li><li><span class="name"><span class="innerContentContainer">return FloatMath.sqrt(x * x + y * y);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 计算两个触摸点的中点</span></span></li><li><span class="name"><span class="innerContentContainer">private PointF middle(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">float x = event.getX(0) + event.getX(1);</span></span><ul><li><span class="name"><span class="innerContentContainer">float y = event.getY(0) + event.getY(1);</span></span></li><li><span class="name"><span class="innerContentContainer">return new PointF(x / 2, y / 2);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">响应系统设置的事件(Configuration类)</span></span><ul><li><span class="name"><span class="innerContentContainer">Configuration类是用来描述手机设备的配置信息的，比如屏幕方向，触摸屏的触摸方式等，代码在 frameworks/base/core/java/android/content/res/Configuration.java.</span></span></li><li><span class="name"><span class="innerContentContainer">方法列表</span></span><ul><li><span class="name"><span class="innerContentContainer">densityDpi：屏幕密度</span></span></li><li><span class="name"><span class="innerContentContainer">fontScale：当前用户设置的字体的缩放因子</span></span></li><li><span class="name"><span class="innerContentContainer">hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：</span></span><ul><li><span class="name"><span class="innerContentContainer">HARDKEYBOARDHIDDEN_NO,  十六进制的0</span></span></li><li><span class="name"><span class="innerContentContainer">HARDKEYBOARDHIDDEN_YES，十六进制的1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">keyboard：获取当前关联额键盘类型：该属性的返回值：KEYBOARD_12KEY（只有12个键的小键盘）、KEYBOARD_NOKEYS、KEYBOARD_QWERTY（普通键盘）</span></span></li><li><span class="name"><span class="innerContentContainer">keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。</span></span></li><li><span class="name"><span class="innerContentContainer">locale：获取用户当前的语言环境</span></span></li><li><span class="name"><span class="innerContentContainer">mcc：获取移动信号的国家码</span></span></li><li><span class="name"><span class="innerContentContainer">mnc：获取移动信号的网络码</span></span></li><li><span class="name"><span class="innerContentContainer">ps:国家代码和网络代码共同确定当前手机网络运营商</span></span></li><li><span class="name"><span class="innerContentContainer">navigation：判断系统上方向导航设备的类型。该属性的返回值：NAVIGATION_NONAV（无导航）、 NAVIGATION_DPAD(DPAD导航）NAVIGATION_TRACKBALL（轨迹球导航）、NAVIGATION_WHEEL（滚轮导航）</span></span></li><li><span class="name"><span class="innerContentContainer">orientation：获取系统屏幕的方向。该属性的返回值：ORIENTATION_LANDSCAPE（横向屏幕）、ORIENTATION_PORTRAIT（竖向屏幕）</span></span></li><li><span class="name"><span class="innerContentContainer">screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示</span></span></li><li><span class="name"><span class="innerContentContainer">touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_NOTOUCH（无触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_STYLUS（触摸笔式触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_FINGER（接收手指的触摸屏）</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">// 在AndroidManifest.xml添加下述内容</span></span></li><li><span class="name"><span class="innerContentContainer">权限:&nbsp;&lt; uses-permission android:name="android.permission.CHANGE_CONFIGURATION" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">在&lt; activity标签中添加:android:configChanges="orientation"&nbsp;将targetSdkVersion改为12以上的,12也可以.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">Button btn = (Button) findViewById(R.id.btncahange);</span></span></li><li><span class="name"><span class="innerContentContainer">btn.setOnClickListener(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Configuration config = getResources().getConfiguration();</span></span></li><li><span class="name"><span class="innerContentContainer">//如果是横屏的话切换成竖屏</span></span></li><li><span class="name"><span class="innerContentContainer">if(config.orientation == Configuration.ORIENTATION_LANDSCAPE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//如果竖屏的话切换成横屏</span></span></li><li><span class="name"><span class="innerContentContainer">if(config.orientation == Configuration.ORIENTATION_PORTRAIT) {</span></span><ul><li><span class="name"><span class="innerContentContainer">MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onConfigurationChanged(Configuration newConfig) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onConfigurationChanged(newConfig);</span></span></li><li><span class="name"><span class="innerContentContainer">String screen = newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE?"横屏":"竖屏";</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this, "系统屏幕方向发生改变 \n 修改后的方向为" + screen, Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Configuration: 系统状态事件</span></span><ul><li><span class="name"><span class="innerContentContainer">Configuration类是用来描述手机设备的配置信息的，比如屏幕方向， 触摸屏的触摸方式等.</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/base/core/java/android/content/res/Configuration.java</span></span></li><li><span class="name"><span class="innerContentContainer">有如下方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">densityDpi：屏幕密度</span></span></li><li><span class="name"><span class="innerContentContainer">fontScale：当前用户设置的字体的缩放比</span></span></li><li><span class="name"><span class="innerContentContainer">hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：HARDKEYBOARDHIDDEN_NO,HARDKEYBOARDHIDDEN_YES，分别是十六进制的0和1</span></span></li><li><span class="name"><span class="innerContentContainer">keyboard：获取当前关联额键盘类型：该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">KEYBOARD_12KEY（只有12个键的小键盘）</span></span></li><li><span class="name"><span class="innerContentContainer">KEYBOARD_NOKEYS (没有键盘)</span></span></li><li><span class="name"><span class="innerContentContainer">KEYBOARD_QWERTY（普通键盘）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。</span></span></li><li><span class="name"><span class="innerContentContainer">locale：获取用户当前的语言环境</span></span></li><li><span class="name"><span class="innerContentContainer">mcc：获取移动信号的国家码</span></span></li><li><span class="name"><span class="innerContentContainer">mnc：获取移动信号的网络码</span></span></li><li><span class="name"><span class="innerContentContainer">ps:国家代码和网络代码共同确定当前手机网络运营商</span></span></li><li><span class="name"><span class="innerContentContainer">navigation：判断系统中方向导航设备的类型 (都已经不支持了)。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">NAVIGATION_NONAV（无导航）</span></span></li><li><span class="name"><span class="innerContentContainer"> NAVIGATION_DPAD (DPAD导航）</span></span></li><li><span class="name"><span class="innerContentContainer">NAVIGATION_TRACKBALL（轨迹球导航）</span></span></li><li><span class="name"><span class="innerContentContainer">NAVIGATION_WHEEL（滚轮导航）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">orientation：获取系统屏幕的方向。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">ORIENTATION_LANDSCAPE（横向屏幕）</span></span></li><li><span class="name"><span class="innerContentContainer">ORIENTATION_PORTRAIT（竖向屏幕）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示</span></span></li><li><span class="name"><span class="innerContentContainer">touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_NOTOUCH（无触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_STYLUS（触摸笔式触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_FINGER（接收手指的触摸屏）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">// 在AndroidManifest.xml中申请权限权限</span></span></li><li><span class="name"><span class="innerContentContainer">&lt; uses-permission android:name="android.permission.CHANGE_CONFIGURATION" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 监听系统属性变化</span></span></li><li><span class="name"><span class="innerContentContainer">public void onConfigurationChanged(Configuration newConfig) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onConfigurationChanged(newConfig);</span></span></li><li><span class="name"><span class="innerContentContainer">String screen = {(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) ? "横屏" : "竖屏");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Gestures(手势)</span></span><ul><li><span class="name"><span class="innerContentContainer">在应用中通过手势来操作会大大提升用户体验.</span></span></li><li><span class="name"><span class="innerContentContainer">手势交互的执行顺序</span></span><ul><li><span class="name"><span class="innerContentContainer">1.手指触碰屏幕时，触发MotionEvent事件.</span></span></li><li><span class="name"><span class="innerContentContainer">2.该事件被OnTouchListener监听，可在它的onTouch()方法中获得该MotionEvent对象.</span></span></li><li><span class="name"><span class="innerContentContainer">3.通过GestureDetector转发MotionEvent对象给OnGestureListener.</span></span></li><li><span class="name"><span class="innerContentContainer">4.我们可以通过OnGestureListener获得该对象，然后获取相关信息，以及做相关处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GestureListener 提供了下述回调方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。</span></span></li><li><span class="name"><span class="innerContentContainer">抛掷（onFling）： 手指在触摸屏上迅速移动，并松开的动作。</span></span></li><li><span class="name"><span class="innerContentContainer">长按（onLongPress）： 手指按在持续一段时间，并且没有松开。</span></span></li><li><span class="name"><span class="innerContentContainer">滚动（onScroll）： 手指在触摸屏上滑动。</span></span></li><li><span class="name"><span class="innerContentContainer">按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。</span></span></li><li><span class="name"><span class="innerContentContainer">抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">知道了 GestureListener的相关方法后，实现手势检测也很简单，步骤如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">创建GestureDetector对象，创建时需实现GestureListener传入</span></span></li><li><span class="name"><span class="innerContentContainer">将Activity或者特定组件上的TouchEvent的事件交给GestureDetector处理.</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导航栏事件</span></span><ul><li><span class="name"><span class="innerContentContainer">点击home键后, 系统会发出一个 Intent_Action_Close_System_Dialogs 的广播.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Input问题分类</b></span></span><ul><li><span class="name"><span class="innerContentContainer">器件和驱动问题</span></span><ul><li><span class="name"><span class="innerContentContainer">最方便方法： 打开小圆点，录屏，没有小圆点，就证明底层没有上报事件。</span></span><ul><li><span class="name"><span class="innerContentContainer">打开小圆点的方法： 开发人员选项 - 显示触摸操作</span></span></li><li><span class="name"><span class="innerContentContainer">小圆点代码： </span></span><ul><li><span class="name"><span class="innerContentContainer">显示小圆点： 在 TouchInputMapper.cookAndDispatch() 中画。</span></span></li><li><span class="name"><span class="innerContentContainer">要不要显示，在设置一路传下来。参见 nativeSetShowTouches().</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">为了确认是底层问题，在确认没有小圆点的同时，还要确认用户的确按了。方法就是第三方视觉录屏。</span></span></li><li><span class="name"><span class="innerContentContainer">通过查看器件上报的数据确认</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell getevent -l</span></span></li><li><span class="name"><span class="innerContentContainer">前提：研发现场可复现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过adb模拟事件，如果模拟的事件没问题，则可反向确认是bsp异常。</span></span><ul><li><span class="name"><span class="innerContentContainer">前提：研发现场可复现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过查看 inputReader LOG打印确认上报的数据有没有问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Fwk policy错误</span></span><ul><li><span class="name"><span class="innerContentContainer">input policy主要是在pwm 中对一些按键和手势的拦截处理。涉及这方面要多考虑这块。</span></span></li><li><span class="name"><span class="innerContentContainer">主要逻辑在 interceptKeyBeforeQueueing() 和 interceptKeyBeforeDispatching()。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件分开过程中出现错误</span></span><ul><li><span class="name"><span class="innerContentContainer">事件有没有分发到inputdispatcher。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Input性能问题</span></span><ul><li><span class="name"><span class="innerContentContainer">一次事件上报过程分为4个环节： 硬件 - kernel - system server - app</span></span></li><li><span class="name"><span class="innerContentContainer">4个环节可划分5个时间点：</span></span><ul><li><span class="name"><span class="innerContentContainer">t1： 硬件中断时间。</span></span><ul><li><span class="name"><span class="innerContentContainer">这个可忽略不计。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t2： inputReader 从设备节点读出事件的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">事件时间戳在这里打上，所以看时间时间戳即可。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t3： inputDispatcher 向app进程发送时间的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">InputPublisher::publishMeyEvent(). 这里真正发消息了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t4： app开始事件处理的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">app通过 InputEventReceiver 接受事件，在 dispatchInputEvent()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t5： app完成事件处理的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">InputEventReceiver的 finishInputEvent()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">app处理耗时： t5 - t4</span></span></li><li><span class="name"><span class="innerContentContainer">system server耗时： t3 - t2</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">Sensor</span></span><ul><li><span class="name"><span class="innerContentContainer">Android平台支持三类传感器：</span></span><ul><li><span class="name"><span class="innerContentContainer">Motion sensors（运动传感器）：测量加速力，以及沿三个轴的旋转力。</span></span><ul><li><span class="name"><span class="innerContentContainer">运动传感器中有两个永远是基于硬件的，即加速度计和陀螺仪（accelerometer and gyroscope）。</span></span></li><li><span class="name"><span class="innerContentContainer">运动传感器中有三个是既可以基于硬件又可以基于软件的，即重力感应器、线性加速度计、旋转向量传感器。</span></span></li><li><span class="name"><span class="innerContentContainer">加速度传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 G-sensor，返回x、y、z三轴的加速度数值。</span></span></li><li><span class="name"><span class="innerContentContainer">该数值包含地心引力的影响，单位是m/s^2。</span></span></li><li><span class="name"><span class="innerContentContainer">值域是：</span></span><ul><li><span class="name"><span class="innerContentContainer">将手机平放在桌面上，x轴默认为0，y轴默认0，z轴默认9.81。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机朝下放在桌面上，z轴为-9.81。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机向左倾斜，x轴为正值。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机向右倾斜，x轴为负值。 </span></span></li><li><span class="name"><span class="innerContentContainer">将手机向上倾斜，y轴为负值。</span></span></li><li><span class="name"><span class="innerContentContainer">将手机向下倾斜，y轴为正值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动代码：kernel/drivers/input/accelerometer/gs_mma8452.c。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重力感应器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 Gyro-sensor，返回x、y、z三轴的角速度数据。</span></span></li><li><span class="name"><span class="innerContentContainer">角速度的单位是 radians/second。</span></span></li><li><span class="name"><span class="innerContentContainer">值域是：</span></span><ul><li><span class="name"><span class="innerContentContainer">水平逆时针旋转，Z轴为正。</span></span></li><li><span class="name"><span class="innerContentContainer">水平逆时针旋转，z轴为负。</span></span></li><li><span class="name"><span class="innerContentContainer">向左旋转，y轴为负。 </span></span></li><li><span class="name"><span class="innerContentContainer">向右旋转，y轴为正。 </span></span></li><li><span class="name"><span class="innerContentContainer">向上旋转，x轴为负。</span></span></li><li><span class="name"><span class="innerContentContainer"> 向下旋转，x轴为正。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">陀螺仪，gyroscope</span></span><ul><li><span class="name"><span class="innerContentContainer">陀螺仪测量的是设备绕三个轴向的旋转速度，单位是rad/s。</span></span></li><li><span class="name"><span class="innerContentContainer">所使用的坐标系统仍然和加速度计的一样。</span></span></li><li><span class="name"><span class="innerContentContainer">旋转的值在逆时针方向为正，即，如果一个观察者从某个轴的正向某点向原点看，如果观察到的旋转是逆时针的，则是一个正值的旋转。这是一个关于旋转方向的标准的数学定义，注意，这个和方向传感器所用的定义不同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Rotation Vector，旋转矢量传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 RV-sensor。</span></span></li><li><span class="name"><span class="innerContentContainer">旋转矢量代表设备的方向，是一个将坐标轴和角度混合计算得到的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">RV-sensor输出三个数据： xsin(theta/2) ysin(theta/2) z*sin(theta/2) sin(theta/2)是RV的数量级。</span></span></li><li><span class="name"><span class="innerContentContainer">RV的方向与轴旋转的方向相同。 RV的三个数值，与cos(theta/2)组成一个四元组。 RV的数据没有单位，使用的坐标系与加速度相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Gravity，重力传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 GV-sensor，输出重力数据。</span></span></li><li><span class="name"><span class="innerContentContainer">在地球上，重力数值为9.8，单位是m/s^2。 坐标系统与加速度传感器相同。 当设备复位时，重力传感器的输出与加速度传感器相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linear Acceleration，线性加速度传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 LA-sensor。</span></span></li><li><span class="name"><span class="innerContentContainer">线性加速度传感器是加速度传感器减去重力影响获取的数据。 单位是m/s^2，坐标系统与加速度传感器相同。</span></span></li><li><span class="name"><span class="innerContentContainer">加速度传感器、重力传感器和线性加速度传感器的计算公式如下： 加速度 = 重力 + 线性加速度。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Environmental sensors （环境传感器）：测量各种环境参数，例如环境空气温度和压力，照明和湿度。包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">Ambient Light Sensor，环境光传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">检测实时的光线强度，光强单位是lux(勒克司度)，其物理意义是照射到单位面积上的光通量。</span></span></li><li><span class="name"><span class="innerContentContainer">光线感应传感器主要用于LCD自动亮度功能，根据采样到的光强数值实时调整LCD的亮度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Proximity Sensor，接近光传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">接近传感器，检测物体与手机的距离，单位是cm(厘米)。</span></span></li><li><span class="name"><span class="innerContentContainer">一些接近传感器只能返回远和近两个状态， 因此，接近传感器将最大距离返回远状态，小于最大距离返回近状态。</span></span></li><li><span class="name"><span class="innerContentContainer">接近传感器可用于接听电话时自动关闭LCD屏幕以节省电量。</span></span></li><li><span class="name"><span class="innerContentContainer">一些芯片集成了接近传感器和环境光传感器两者功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Barometer Sensor，气压计</span></span><ul><li><span class="name"><span class="innerContentContainer">返回当前的压强，单位是百帕斯卡hectopascal（hPa）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Temperature Sensor，温度计</span></span><ul><li><span class="name"><span class="innerContentContainer">返回当前的温度。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Position sensors （位置传感器）：测量设备的物理位置。包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">方向传感器</span></span><ul><li><span class="name"><span class="innerContentContainer">简称 O-sensor，返回三轴的角度数据，方向数据的单位是角度。</span></span></li><li><span class="name"><span class="innerContentContainer">为了得到精确的角度数据，E-compass(电子罗盘传感器)需要获取G-sensor(加速度传感器)的数据， 经过计算生产O-sensor数据，否则只能获取水平方向的角度。</span></span></li><li><span class="name"><span class="innerContentContainer">方向传感器提供三个数据，分别为azimuth、pitch和roll。</span></span><ul><li><span class="name"><span class="innerContentContainer">azimuth：方位，返回水平时磁北极和Y轴的夹角，范围为0°至360°。 0°=北，90°=东，180°=南，270°=西。</span></span></li><li><span class="name"><span class="innerContentContainer">pitch：x轴和水平面的夹角，范围为-180°至180°。 当z轴向y轴转动时，角度为正值。</span></span></li><li><span class="name"><span class="innerContentContainer">roll：y轴和水平面的夹角，由于历史原因，范围为-90°至90°。 当x轴向z轴移动时，角度为正值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电子罗盘在获取正确的数据前需要进行校准，通常可用8字校准法。 </span></span><ul><li><span class="name"><span class="innerContentContainer">8字校准法要求用户使用需要校准的设备在空中做8字晃动， 原则上尽量多的让设备法线方向指向空间的所有8个象限。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">磁力计</span></span><ul><li><span class="name"><span class="innerContentContainer">简称为 M-sensor，返回x、y、z三轴的环境磁场数据。</span></span></li><li><span class="name"><span class="innerContentContainer">该数值的单位是微特斯拉（micro-Tesla），用uT表示。 单位也可以是高斯（Gauss），1Tesla=10000Gauss。 </span></span></li><li><span class="name"><span class="innerContentContainer">硬件上一般没有独立的磁力传感器，磁力数据由电子罗盘传感器提供（E-compass）。</span></span></li><li><span class="name"><span class="innerContentContainer">电子罗盘传感器同时提供下文的方向传感器数据。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SensorHub</span></span><ul><li><span class="name"><span class="innerContentContainer">Android手机通常用到的计步器、陀螺仪、磁力计等传感器，通常都需要低功耗运行，比如在手机灭屏的状态下，仍然能不休眠地继续工作，这得益于SensorHub.</span></span></li><li><span class="name"><span class="innerContentContainer">通过将传感器挂在主CPU外部的一个小低功耗CPU上，并在这个低功耗CPU上运行RTOS，可以实现待机状态下仍持续不停地获取传感器信息.</span></span></li><li><span class="name"><span class="innerContentContainer">Android有HAL层、设计上独立MCU做SensorHub是趋势，适合写Userspace Driver，甚至TP都可以接到Hub上，Hub和MPU串口连，用户层跑daemon与hub通讯，内核打开uio框架和uinput，背光、RTC、各种Sensor，都可搞定，比在内核里上窜下跳的改代码反复编译调试强。</span></span></li><li><span class="name"><span class="innerContentContainer">至少目前不是你说的那样，现在的SENSORHUB也是通过HAL接入的，而且基本上看到的sensor&nbsp;&nbsp;hub都比传统的结构更复杂，省电和功能强大是一方面，复杂是另外一面，另外SENSORHUB的软件供应商而且目前不开放源码，这个结果你是知道的。未来，中低端机SENSORHUB会好搞一些，因为基带都会集成，高端机在外面。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IMU：惯性测量单元</span></span><ul><li><span class="name"><span class="innerContentContainer">如何理解IMU以及其预积分 https://zhuanlan.zhihu.com/p/38009126</span></span></li><li><span class="name"><span class="innerContentContainer">测量物体三轴姿态角(或角速率)以及加速度的装置。</span></span></li><li><span class="name"><span class="innerContentContainer">一般情况，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪。</span></span></li><li><span class="name"><span class="innerContentContainer">加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层调用方法</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 获取SensorManager对象</span></span></li><li><span class="name"><span class="innerContentContainer">2. 获取Sensor对象</span></span></li><li><span class="name"><span class="innerContentContainer">3. 注册Sensor对象</span></span></li><li><span class="name"><span class="innerContentContainer">4. 重写onAccuracyChanged，onSensorChanged这两个方法</span></span></li><li><span class="name"><span class="innerContentContainer">5. 注销Sensor对象</span></span></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">public class SensorActivity extends Activity implements SensorEventListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">private SensorManager mSensorManager;</span></span></li><li><span class="name"><span class="innerContentContainer">private Sensor mSensor;</span></span></li><li><span class="name"><span class="innerContentContainer">public final void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.main);</span></span></li><li><span class="name"><span class="innerContentContainer">// 第一步：通过getSystemService获得SensorManager实例对象</span></span></li><li><span class="name"><span class="innerContentContainer"><b>mSensorManager </b>= (SensorManager) getSystemService(Context.SENSOR_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">// 第二步：通过SensorManager实例对象获得想要的传感器对象: 参数决定获取哪个传感器</span></span></li><li><span class="name"><span class="innerContentContainer">mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);</span></span></li><li><span class="name"><span class="innerContentContainer">if (mSensor  != null) { </span></span><ul><li><span class="name"><span class="innerContentContainer">// 系统支持该sensor，继续</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 系统不支持该sensor，或者处在不可用状态。进行错误处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 第四步：必须重写的两个方法：onAccuracyChanged，onSensorChanged</span></span></li><li><span class="name"><span class="innerContentContainer">/** 传感器精度发生改变的回调接口 */</span></span></li><li><span class="name"><span class="innerContentContainer">public final void onAccuracyChanged(Sensor sensor, int accuracy) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// TODO 在传感器精度发生改变时做些操作，accuracy为当前传感器精度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/** 传感器事件值改变时的回调接口：执行此方法的频率与注册传感器时的频率有关 */</span></span></li><li><span class="name"><span class="innerContentContainer">public final void onSensorChanged(SensorEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 大部分传感器会返回三个轴方向x,y,x的event值，值的意义因传感器而异</span></span></li><li><span class="name"><span class="innerContentContainer">float x = event.values[0];</span></span></li><li><span class="name"><span class="innerContentContainer">float y = event.values[1];</span></span></li><li><span class="name"><span class="innerContentContainer">float z = event.values[2];</span></span></li><li><span class="name"><span class="innerContentContainer">// TODO 利用获得的三个float传感器值做些操作</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/** 第三步：在获得焦点时注册传感器并让本类实现SensorEventListener接口 */</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onResume() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onResume();</span></span></li><li><span class="name"><span class="innerContentContainer">/**第一个参数：SensorEventListener接口的实例对象</span></span></li><li><span class="name"><span class="innerContentContainer">*第二个参数：需要注册的传感器实例</span></span></li><li><span class="name"><span class="innerContentContainer">*第三个参数：传感器获取传感器事件event值频率：</span></span><ul><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_FASTEST = 0：对应0微秒的更新间隔，最快，1微秒 = 1 % 1000000秒</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_GAME = 1：对应20000微秒的更新间隔，游戏中常用</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_UI = 2：对应60000微秒的更新间隔</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager.SENSOR_DELAY_NORMAL = 3：对应200000微秒的更新间隔</span></span></li><li><span class="name"><span class="innerContentContainer">键入自定义的int值x时：对应x微秒的更新间隔</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">*/ </span></span></li><li><span class="name"><span class="innerContentContainer">mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/** 第五步：在失去焦点时注销传感器 */</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onPause() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onPause();</span></span></li><li><span class="name"><span class="innerContentContainer">mSensorManager.unregisterListener(this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">通过 List&lt;Sensor&gt; deviceSensors = mSensorManager.getSensorList(Sensor.TYPE_ALL); 可列举系统支持的所有sensor。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FWK层</span></span><ul><li><span class="name"><span class="innerContentContainer">java-Client</span></span><ul><li><span class="name"><span class="innerContentContainer">即Android Sensor SDK。</span></span></li><li><span class="name"><span class="innerContentContainer">SensorManager：封装了 Sensor 相关的 API ，提供给 Application 使用。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/core/java/android/hardware/SensorManager.java</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">java-Server</span></span><ul><li><span class="name"><span class="innerContentContainer">SystemSensorManager：该类主要实现 SensorManager 控制和数据获取的逻辑。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/core/java/android/hardware/SystemSensorManager.java</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">jni</span></span><ul><li><span class="name"><span class="innerContentContainer">该文件负责 jave 层和 native 层通信的 JNI 实现，上层的 Java 代码通过 JNI 调用 Native 层提供的服务。</span></span></li><li><span class="name"><span class="innerContentContainer">android_hardware_SensorManager.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native-client</span></span><ul><li><span class="name"><span class="innerContentContainer">Sensor 在 Native 层的客户端，负责与服务端 SensorService.cpp 的通信。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/gui/SensorManager.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native-server</span></span><ul><li><span class="name"><span class="innerContentContainer">SensorService.cpp，是 Android Sensor Framework 最核心的模块，它实现了主要的 Sensor控制流和数据流逻辑，完成 Sensor 参数配置，数据分发，Client 请求处理等功能。 frameworks/native/services/sensorservice/SensorService.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BnSensorServer，提供类 Sensor 信息获取以及 SensorEventConnection 创建的功能。frameworks/native/include/gui/ISensorServer.h</span></span></li><li><span class="name"><span class="innerContentContainer">SensorEventConnection，是 Sensor 数据的传输通道，当 Client 开始监听某一个 Sensor 是，一个对应的 SensorEventConnection 将会被创建，Server 端在接收到 Sensor 数据后，通过写入到 SensorEventConnection 传递给 Client 端。 frameworks/native/libs/gui/ISensorEventConnection.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">SensorDevice，管理和维护系统中的所有 Sensor，封装了 Sensor 的使能、配置、数据读取等功能。 frameworks/native/services/sensorservice/SensorDevice.cpp</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">HAL层</span></span><ul><li><span class="name"><span class="innerContentContainer">SensorList，定义了 HAL 层提供的 Sensor，提供 Sensor 类型、供应商、功耗等信息。同时，HAL 层需要实现获取 SensorList 的回调接口。</span></span></li><li><span class="name"><span class="innerContentContainer">sensors_module_t，HAL 层需要定义一个 sensors_module_t，供系统在启动时加载 Sensor HAL 动态库。sensors_module_t 向上层注册获取 SensorList 和获取 Sensor 控制接口的相关回调函数。</span></span></li><li><span class="name"><span class="innerContentContainer">HAL 层还需要提供实际控制和获取 Sensor 数据的接口，SensorService 中对 Sensor 的控制和数据的获取最终会调用到这些接口。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>WMS</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">引入Window的目的是为了实现Activity和其上的视图View的解耦. 解耦之后, Activity只负责生命周期管理. </span></span></li><li><span class="name"><span class="innerContentContainer">WMS功能</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 窗口的添加和删除</span></span></li><li><span class="name"><span class="innerContentContainer">2. 窗口的显示和隐藏控制</span></span></li><li><span class="name"><span class="innerContentContainer">3. Z-order顺序管理</span></span></li><li><span class="name"><span class="innerContentContainer">4. 焦点窗口和焦点应用的管理</span></span></li><li><span class="name"><span class="innerContentContainer">5. 输入法窗口管理和墙纸窗口管理</span></span></li><li><span class="name"><span class="innerContentContainer">6. 窗口动画管理</span></span></li><li><span class="name"><span class="innerContentContainer">7. 系统消息收集和分发</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建窗口的过程  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">创建Activity的过程中, 会调用 <b>addWindow</b>() 来请求WMS添加窗口.</span></span></li><li><span class="name"><span class="innerContentContainer">Window的具体实现类是PhoneWindow. 在Activity初始化执行 attach 的时候，会创建一个PhoneWindow对象。然后给Window对象中的mWindowManager变量赋值。</span></span></li><li><span class="name"><span class="innerContentContainer">PhoneWindow作为装载根视图DecorView的容器，Activity通过setContentView实际上是调用PhoneWindow来创建DecorView。</span></span></li><li><span class="name"><span class="innerContentContainer">首先调用installDecor() 为Window类添加窗口装饰，其实就是标题栏.</span></span></li><li><span class="name"><span class="innerContentContainer">然后, 布局文件所定义的界面, 被包含在在窗口内容中。</span></span></li><li><span class="name"><span class="innerContentContainer">把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后AMS经过一系列调用到 Activity的makeVisible()，该方法将真正完成把窗口添加进Wms中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理窗口 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">处理系统按键和触摸消息</span></span></li><li><span class="name"><span class="innerContentContainer">管理窗口动画</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">屏幕坐标原点和坐标变换</span></span><ul><li><span class="name"><span class="innerContentContainer">Android 定义屏幕的左上角为坐标原点(0, 0), 向右为x轴, 向下为y轴, 向上为z轴. </span></span></li><li><span class="name"><span class="innerContentContainer">坐标值都是正数。</span></span></li><li><span class="name"><span class="innerContentContainer">横屏时（不论左旋还是右旋），坐标原点都是左上角。</span></span></li><li><span class="name"><span class="innerContentContainer">一般横屏指左旋。</span></span></li><li><span class="name"><span class="innerContentContainer">kernel报点不分横竖屏，坐标原点固定是竖屏的左上角。</span></span></li><li><span class="name"><span class="innerContentContainer">既然底层报点不分横竖屏，而应用层分，那么显而易见需要做坐标变换。</span></span></li><li><span class="name"><span class="innerContentContainer">坐标变换的方式是:</span></span><ul><li><span class="name"><span class="innerContentContainer">假定屏幕分辨率是(2340*1080)，左旋横屏相对于原点由(0, 0) 改为 (0, 1080)，</span></span></li><li><span class="name"><span class="innerContentContainer">则原坐标 (x, y) 改为 (y, 1080-x)。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">像素 相关概念</span></span><ul><li><span class="name"><span class="innerContentContainer">dp(dip):&nbsp;device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。</span></span></li><li><span class="name"><span class="innerContentContainer">px: pixels(像素). 不同设备显示效果相同.</span></span></li><li><span class="name"><span class="innerContentContainer">pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业.</span></span></li><li><span class="name"><span class="innerContentContainer">sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。size和dp相同.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分辨率及视频 相关概念</span></span><ul><li><span class="name"><span class="innerContentContainer">720P: 分辨率是 1280*720，长宽比是 16:9。即所谓高清，HD。</span></span><ul><li><span class="name"><span class="innerContentContainer">p是逐行扫描的意思</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">1080P: 分辨率是 1920*1080，长宽比是16:9。即所谓全高清，FHD.</span></span></li><li><span class="name"><span class="innerContentContainer">2K: 分辨率是 2048*1080</span></span><ul><li><span class="name"><span class="innerContentContainer">4k发展较快，一般认为大屏幕会绕过2k。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">全面屏手机，2k, FHD</span></span><ul><li><span class="name"><span class="innerContentContainer">2160*1080, 长宽比是  18:9</span></span></li><li><span class="name"><span class="innerContentContainer">2340*1080, 长宽比是 19.2:9。较常见。</span></span></li><li><span class="name"><span class="innerContentContainer">2376*1080，长宽比是 19.8:9。较常见。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">QHD, 3168*1440，长宽比是 19.8:9 ，即所谓的3k屏。</span></span></li><li><span class="name"><span class="innerContentContainer">4K: 分辨率是 3840*2160</span></span></li><li><span class="name"><span class="innerContentContainer">蓝光，即1080P</span></span><ul><li><span class="name"><span class="innerContentContainer">但是市面上很多1080p是从蓝光原碟有损压缩出来的，所以无形中需要要区分蓝光和1080p。</span></span></li><li><span class="name"><span class="innerContentContainer">蓝光电影一般在 35G左右，1080p则在10G左右，清晰度差距还是蛮大的。</span></span></li><li><span class="name"><span class="innerContentContainer">无损蓝光多为 . ts格式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">视频清晰度还取决于码率和编码格式。</span></span><ul><li><span class="name"><span class="innerContentContainer">1080P的视频码率不低于 5mbps。</span></span></li><li><span class="name"><span class="innerContentContainer">1080P的编码格式有mkv和rmvb。前者清晰度高一些。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">刷新率 相关概念</span></span><ul><li><span class="name"><span class="innerContentContainer">行扫描：屏幕画完一行的像素点叫行扫描。</span></span></li><li><span class="name"><span class="innerContentContainer">场扫描：屏幕画完一屏叫场扫描。</span></span></li><li><span class="name"><span class="innerContentContainer">hsync： 屏幕开始扫描一行的物理信号。</span></span></li><li><span class="name"><span class="innerContentContainer">vsync： 屏幕开始扫描一场的物理信号。</span></span></li><li><span class="name"><span class="innerContentContainer">场频： 屏幕每秒画完几场，就有几个vsync信号，这叫场频，也叫刷新率。</span></span></li><li><span class="name"><span class="innerContentContainer">FPS: 每秒刷新帧数, frames per second. 即屏幕刷新率，也叫帧率。</span></span><ul><li><span class="name"><span class="innerContentContainer">单位是Hz, 赫兹. </span></span></li><li><span class="name"><span class="innerContentContainer">通常, 要避免动作不流畅的最低FPS是 30. 最佳体验是 60或以上.</span></span></li><li><span class="name"><span class="innerContentContainer">人有视觉暂停的特性，对于连续远动的静态图片，当超过16帧/秒时，就感觉到运动是连贯的。</span></span></li><li><span class="name"><span class="innerContentContainer">这是视频、动画的原理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见帧率</span></span><ul><li><span class="name"><span class="innerContentContainer">电影 24Hz</span></span></li><li><span class="name"><span class="innerContentContainer">电视 25Hz</span></span></li><li><span class="name"><span class="innerContentContainer">电视(NTSL)  29.9Hz</span></span></li><li><span class="name"><span class="innerContentContainer">CRT显示  75Hz</span></span></li><li><span class="name"><span class="innerContentContainer">液晶显示  60Hz</span></span></li><li><span class="name"><span class="innerContentContainer">游戏中</span></span><ul><li><span class="name"><span class="innerContentContainer">超过75帧无感觉。</span></span></li><li><span class="name"><span class="innerContentContainer">帧率（FPS）&lt;30，游戏性就下降。</span></span></li><li><span class="name"><span class="innerContentContainer">30以上，则可以接受。</span></span></li><li><span class="name"><span class="innerContentContainer">如果升至60帧则交互性和逼真感大大加强.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>流量 = 分辨率 * 刷新率</b></span></span><ul><li><span class="name"><span class="innerContentContainer">比特率: 是指每秒传递的比特数(bit), 单位为 bps.</span></span></li><li><span class="name"><span class="innerContentContainer">码流: data rate, 指视频文件在单位时间内使用的数据流量, 也叫码率.  码流的单位 KB/s, 等于 比特率 / 8.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>图像处理能力 = 分辨率 * 刷新率</b></span></span></li><li><span class="name"><span class="innerContentContainer">Android颜色值</span></span><ul><li><span class="name"><span class="innerContentContainer">16位整数。</span></span></li><li><span class="name"><span class="innerContentContainer">一般写成16进制数形式。</span></span></li><li><span class="name"><span class="innerContentContainer">前2位为透明度(alpha)。00表示全透明(即隐藏了)，FF表示全不透明。7F表示半透。</span></span></li><li><span class="name"><span class="innerContentContainer">后6位为颜色值。000000表示白色，FFFFFF 表示黑色。</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer"><b>60帧, 丢帧, 跳帧   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">UI渲染是指从App生成帧并显示在屏幕上的行为。</span></span></li><li><span class="name"><span class="innerContentContainer">60 fps是手机app性能的衡量标准, 这个标准的来历是: 人眼与大脑之前的协作无法感知超过60 FPS的画面, 所以超过60 FPS 没有意义.</span></span></li><li><span class="name"><span class="innerContentContainer">对于60 fps, 1帧即 1000 / 60 = 16ms. </span></span></li><li><span class="name"><span class="innerContentContainer">Android系统每隔16ms, 会发一次 VSync 信息来通知重绘界面. </span></span></li><li><span class="name"><span class="innerContentContainer">当一个操作超过 16 ms, 系统在得到 VSync 信息时就无法进行绘制, 只能重新刷之前一帧. 这种情况叫丢帧.</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种情况叫跳帧. 即在一次VSync周期内, 应用产生了超过1帧的数据.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UI渲染的流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的 EventThread 唤醒了应用程序UI线程，表明现在是渲染新帧的时候了。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序使用CPU和GPU资源在UI线程，RenderThread 和 hwuiTasks 中渲染帧。这部分占UI的大部分。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序通过binder将绘制好的帧发送到SurfaceFlinger并进入睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的第二个EventThread 负责唤醒SurfaceFlinger来触发组合和显示输出。</span></span></li><li><span class="name"><span class="innerContentContainer">如果SurfaceFlinger确定没有任何工作要完成，它将返回睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过HWC / HWC2或GL处理组合。 HWC / HWC2组合更快，更低的功耗，但会受到SOC的限制。这一步通常需要4-6ms，但是可以与步骤2重叠，因为Android应用程序总是三重缓冲。 （虽然应用程序总是三重缓冲，但在SurfaceFlinger中只能有一个待处理帧，因此和双重缓存差不多。）</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过驱动程序调度最终输出，并返回睡眠状态，等待EventThread唤醒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">帧率和刷新频率不一致问题</span></span><ul><li><span class="name"><span class="innerContentContainer">Refresh Rate: 屏幕在1秒内刷新屏幕的次数, 这取决于硬件的固定参数, 比如 60Hz.</span></span></li><li><span class="name"><span class="innerContentContainer">Frame Rate: 代表GPU在1秒内绘制操作的帧数, 比如30 FPS.</span></span></li><li><span class="name"><span class="innerContentContainer">GPU 获取图形数据进行渲染, 然后硬件负责把渲染的内容呈现到屏幕上, 他们两者不停的进行协作.</span></span></li><li><span class="name"><span class="innerContentContainer">如果发生帧率和刷新频率不一致的情况, 就会出现Tearing 现象, 画面上下两部分显示内容断裂, 来自不同的两帧数据发生重叠. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">双缓冲机制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">多数系统都会使用双缓冲机制. 即一个buffer用于显示当前帧, 另一个buffer 用于缓存下一帧的数据. 其过程是:</span></span></li><li><span class="name"><span class="innerContentContainer">1. 屏幕显示缓冲A中的第0帧; </span></span></li><li><span class="name"><span class="innerContentContainer">2. CPU和GPU在缓冲B中构建第1帧; 构建好后, 并不会马上绘制, 而是必须等待系统的VSync信号.</span></span></li><li><span class="name"><span class="innerContentContainer">3. 系统发出VSync信号, 屏幕向缓冲B请求第1帧的数据, 如成功, 则绘制它;</span></span></li><li><span class="name"><span class="innerContentContainer">4. 此时, 缓冲A中的数据被清除, CPU和GPU开始构建第2帧.</span></span></li><li><span class="name"><span class="innerContentContainer">在第三步, 如果此时缓冲B的第1帧数据没有准备好, 屏幕只好继续显示缓冲A中的第0帧, 这种情况就叫丢帧, 也叫"Jank".</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">三缓冲机制 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">在缓冲A在显示中, 缓冲B数据已经准备好时, 此时时间会被浪费掉. </span></span></li><li><span class="name"><span class="innerContentContainer">可以再加一个缓冲C, 来准备下一帧数据. 这就是三缓冲机制.</span></span></li><li><span class="name"><span class="innerContentContainer">三缓冲不能根本上解决卡顿问题, 但是会缓解.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动画  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">逐帧动画</span></span><ul><li><span class="name"><span class="innerContentContainer">逐帧动画的原理就是让一系列的静态图片依次播放，利用人眼“视觉暂留”的原理，实现动画。</span></span></li><li><span class="name"><span class="innerContentContainer">逐帧动画通常是采用 XML 资源进行定义的，需要在 &lt;animation-list .../&gt; 标签下使用 &lt;item .../&gt; 子元素标签定义动画的全部帧，并指定各帧的持续时间。</span></span></li><li><span class="name"><span class="innerContentContainer">定义帧动画的方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">// res/drawable/frame_animation.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true|false"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;item android:drawable="@drawable/frame01" android:duration="100"/&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item android:drawable="@drawable/frame02" android:duration="100"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/animation-list&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">android:oneshot 控制该动画是否循环播放。如果为true，动画将不会循环播放， 否则该动画将会循环播放.</span></span></li><li><span class="name"><span class="innerContentContainer">android:drawable 为图片资源. 一般会有多张.</span></span></li><li><span class="name"><span class="innerContentContainer">android:duration 为持续时间, 单位为毫秒.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">使用该帧动画的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">在layout 中将 AnimationDrawable 对象直接作为背景.</span></span><ul><li><span class="name"><span class="innerContentContainer">// res/layout/activity_frame_animation.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;ImageView</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>android:background</b>="@drawable/frame_animation"</span></span></li><li><span class="name"><span class="innerContentContainer">/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity 中控制播放与停止</span></span><ul><li><span class="name"><span class="innerContentContainer">public class FrameAnimation extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView frame_image;</span></span></li><li><span class="name"><span class="innerContentContainer">AnimationDrawable animationDrawable;</span></span></li><li><span class="name"><span class="innerContentContainer">@ Override</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(@ Nullable Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_frame_animation);</span></span></li><li><span class="name"><span class="innerContentContainer">frame_image = findViewById(R.id.frame_image);</span></span></li><li><span class="name"><span class="innerContentContainer">// 获取 AnimationDrawable 对象</span></span><ul><li><span class="name"><span class="innerContentContainer">animationDrawable = (AnimationDrawable) frame_image.getBackground();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void start(View view){</span></span><ul><li><span class="name"><span class="innerContentContainer">// 开始播放</span></span></li><li><span class="name"><span class="innerContentContainer">animationDrawable.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void stop(View view){</span></span><ul><li><span class="name"><span class="innerContentContainer">//停止播放</span></span></li><li><span class="name"><span class="innerContentContainer">animationDrawable.stop();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">补间动画 (过场动画)</span></span><ul><li><span class="name"><span class="innerContentContainer">补间动画就是指开发者指定动画的开始、动画的结束的"关键帧"，而动画变化的"中间帧"由系统计算，并补齐。</span></span></li><li><span class="name"><span class="innerContentContainer">补间动画一般通过 xml 来实现，对于 xml 形式补间动画的定义，也是需要在 res/anim/ 文件夹下定义动画资源.</span></span></li><li><span class="name"><span class="innerContentContainer">补间动画有4种. 定义方法见内.</span></span><ul><li><span class="name"><span class="innerContentContainer">淡入淡出： alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">// alpha_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:duration="1000"</span></span></li><li><span class="name"><span class="innerContentContainer">android:fromAlpha="1.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:interpolator="@android:anim/accelerate_decelerate_interpolator"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toAlpha="0.0" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中: interpolator 代表插值器，主要作用是可以控制动画的变化速率，可以通过 @ android:anim 来选择不同的插值器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">位移：translate</span></span><ul><li><span class="name"><span class="innerContentContainer">// translate_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:fromDegree="0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toDegree="1800"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotX = "50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotY="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:duration = "3000" /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中: pivot 这个属性主要是在translate 和 scale 动画中，这两种动画都牵扯到view 的“物理位置“发生变化，所以需要一个参考点。而pivotX和pivotY就共同决定了这个点；它的值可以是float或者是百分比数值。</span></span></li><li><span class="name"><span class="innerContentContainer">以 pivotX 为例，说明其取不同的值的含义：</span></span></li><li><span class="name"><span class="innerContentContainer">10:距离动画所在view自身左边缘10像素</span></span></li><li><span class="name"><span class="innerContentContainer">10% :距离动画所在view自身左边缘 的距离是整个view宽度的10%</span></span></li><li><span class="name"><span class="innerContentContainer">10%p:距离动画所在view父控件左边缘的距离是整个view宽度的10%</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缩放：scale</span></span><ul><li><span class="name"><span class="innerContentContainer">// scale_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;scale xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:duration="1000"</span></span></li><li><span class="name"><span class="innerContentContainer">android:fromXScale="0.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:fromYScale="0.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotX="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotY="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toXScale="1.0"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toYScale="1.0"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">旋转： rotate</span></span><ul><li><span class="name"><span class="innerContentContainer">// rotate_anim.xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;rotate</span></span><ul><li><span class="name"><span class="innerContentContainer">android:fromDegrees="float"</span></span></li><li><span class="name"><span class="innerContentContainer">android:toDegrees="float"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotX="50%"</span></span></li><li><span class="name"><span class="innerContentContainer">android:pivotY="50%" /&gt;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">这4种动画形式可作用于同一个动画.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用该补间动画的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">利用 AnimationUtils 工具类来加载指定动画资源，加载成功后返回一个 Animation，该对象可以控制图片或者视图播放动画。</span></span></li><li><span class="name"><span class="innerContentContainer">public class tweenAnimation extends AppCompatActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">Button tween_start;</span></span></li><li><span class="name"><span class="innerContentContainer">@ Override</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(@ Nullable Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_tween_animation);</span></span></li><li><span class="name"><span class="innerContentContainer">final ImageView  tween_image = findViewById(R.id.tween_image);</span></span></li><li><span class="name"><span class="innerContentContainer">tween_start = findViewById(R.id.tween_start);</span></span></li><li><span class="name"><span class="innerContentContainer">// 加载动画资源</span></span></li><li><span class="name"><span class="innerContentContainer">final Animation anim = AnimationUtils.loadAnimation(this, R.anim.alpha_anim);</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置动画结束后保留结束状态</span></span></li><li><span class="name"><span class="innerContentContainer">anim.setFillAfter(true);</span></span></li><li><span class="name"><span class="innerContentContainer">tween_start.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View view) {</span></span><ul><li><span class="name"><span class="innerContentContainer">tween_image.startAnimation(anim);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动画监听</span></span><ul><li><span class="name"><span class="innerContentContainer">为了实现一些需求，如动画结束后开始另一个动画或者页面跳转，这时候就需要监听动画。</span></span></li><li><span class="name"><span class="innerContentContainer">Animation.addListener(new AnimatorListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onAnimationStart(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画开始时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onAnimationRepeat(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画重复时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">public void onAnimationCancel()(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画取消时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onAnimationEnd(Animation animation) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 动画结束时执行</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画</span></span><ul><li><span class="name"><span class="innerContentContainer">属性动画可以看作是补间动画的升级版，不同之处在：</span></span><ul><li><span class="name"><span class="innerContentContainer">补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</span></span></li><li><span class="name"><span class="innerContentContainer">补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">与补间动画类似的是，属性动画也需要定义几个方面的属性：</span></span><ul><li><span class="name"><span class="innerContentContainer">动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</span></span></li><li><span class="name"><span class="innerContentContainer">动画插值方式。通过 android:interploator 指定。</span></span></li><li><span class="name"><span class="innerContentContainer">动画重复次数。通过 android:repeatCount 指定。</span></span></li><li><span class="name"><span class="innerContentContainer">重复行为。通过 android:repeatMode 指定。</span></span></li><li><span class="name"><span class="innerContentContainer">动画集。在属性资源文件中通过 &lt;set .../&gt; 来组合。</span></span></li><li><span class="name"><span class="innerContentContainer">帧刷新率。指定多长时间播放一帧。默认为 10 ms。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画 API</span></span><ul><li><span class="name"><span class="innerContentContainer">Animator: 提供创建属性动画的基类，基本不会直接使用这个类。</span></span></li><li><span class="name"><span class="innerContentContainer">ValueAnimator:属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</span></span></li><li><span class="name"><span class="innerContentContainer">ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</span></span></li><li><span class="name"><span class="innerContentContainer">AnimatorSet：Animator 的子类，用于组合多个 Animator。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">除了这些 API,属性动画还提供了一个 Evaluator ，用来控制属性动画如何计算属性值。</span></span><ul><li><span class="name"><span class="innerContentContainer">IntEvaluator:计算 int 类型属性值的计算器。</span></span></li><li><span class="name"><span class="innerContentContainer">FloatEvaluator: 用于计算 float 类型属性值的计算器。</span></span></li><li><span class="name"><span class="innerContentContainer">ArgbEvaluator: 用于计算十六进制形式表示的颜色值的计算器。</span></span></li><li><span class="name"><span class="innerContentContainer">TypeEvaluator: 可以自定义计算器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用 ValueAnimator 创建动画的步骤：</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 ValueAnimator 的 ofInt()、ofFloat() 或者 ofObject() 静态方法创建 ValueAnimator 实例。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 ValueAnimator 的 setXxx() 等方法设置持续时间，插值方式、重复次数等。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 ValueAnimator 的 start() 方法启动动画。</span></span></li><li><span class="name"><span class="innerContentContainer">为 ValueAnimator 注册 AnimatorUpdateListener 监听器，在该监听器中可以监听 ValueAnimator 计算出来的值改变，并将这些值应用到指定对象上。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画的一般使用：</span></span></li><li><span class="name"><span class="innerContentContainer">定义属性动画和补间动画等类似，有两种方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。</span></span></li><li><span class="name"><span class="innerContentContainer">使用资源文件来定义动画。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">属性动画的使用：</span></span><ul><li><span class="name"><span class="innerContentContainer">创建 ValueAnimator 或 ObjectAnimator 对象 —— 即可以从 XML 资源文件加载该动画也可以直接调用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。</span></span></li><li><span class="name"><span class="innerContentContainer">根据需要为 Animator 对象设置属性。</span></span></li><li><span class="name"><span class="innerContentContainer">如果需要监听 Animator 的动画开始事件，动画结束事件、动画重复事件、动画值改变事件，并根据事件提供响应处理代码，需要为Animator 对象设置监听器。</span></span></li><li><span class="name"><span class="innerContentContainer">如果有多个动画需要同时播放，需要使用 AnimatorSet 组合这些动画。</span></span></li><li><span class="name"><span class="innerContentContainer">调用 Animator 对象的 start 启动动画。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">夜间模式方案</span></span><ul><li><span class="name"><span class="innerContentContainer">在夜间弱光环境下我们长时间注视屏幕，会引起视疲劳。</span></span></li><li><span class="name"><span class="innerContentContainer">为了解决这个问题，厂商推出了夜间模式，它可以降低屏幕亮度，缩小屏幕显示内容与环境光强度的差距，让你在夜间看屏幕时不会太刺眼。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AOD(息屏显示)方案</span></span><ul><li><span class="name"><span class="innerContentContainer">现在大多数旗舰手机使用的都是OLED屏幕.</span></span></li><li><span class="name"><span class="innerContentContainer">其自发光特性是LCD屏所不具备的，在显示黑色时，相应的像素点无需发光，可以减少电量消耗，提升手机续航.</span></span></li><li><span class="name"><span class="innerContentContainer">安卓厂商也基于此原理推出了息屏显示AOD (Always On Display)功能。</span></span></li><li><span class="name"><span class="innerContentContainer">AOD都是黑色的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LCD硬件和驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕物理结构（一般是三层）</span></span><ul><li><span class="name"><span class="innerContentContainer">最外面是玻璃</span></span><ul><li><span class="name"><span class="innerContentContainer">康宁Gorilla玻璃</span></span><ul><li><span class="name"><span class="innerContentContainer">俗称大猩猩，比塑料硬30倍，比塑料韧性好20倍，防刮耐磨。</span></span></li><li><span class="name"><span class="innerContentContainer">硬度在6.5-7之间。也就是说</span></span></li><li><span class="name"><span class="innerContentContainer">高端智能机基本都用了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">中间是TP</span></span><ul><li><span class="name"><span class="innerContentContainer">in-cell技术，即tp模组玻璃和前面板玻璃融为一体，也叫单玻璃（OGS）技术。</span></span><ul><li><span class="name"><span class="innerContentContainer">只有三家厂商有这个技术：LG Display、夏普以及Japan Display Inc。</span></span></li><li><span class="name"><span class="innerContentContainer">其产能基本被苹果垄断。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电阻屏</span></span><ul><li><span class="name"><span class="innerContentContainer">三层膜都是透明的。</span></span></li><li><span class="name"><span class="innerContentContainer">利用压力感应来控制。</span></span></li><li><span class="name"><span class="innerContentContainer">原理很简单，两层导电膜之间隔一层电阻膜，后者布满了小孔（孔径小于1/1000英寸）。</span></span></li><li><span class="name"><span class="innerContentContainer">如果手指按下，两层导电膜会导通，通电位置不同电阻不同，于是就可以算出坐标。</span></span></li><li><span class="name"><span class="innerContentContainer">常用的电阻屏是四线电阻屏，每层导电膜各有两个线，一个竖直方向，一个水平方向，加5v恒定电压。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电容屏</span></span><ul><li><span class="name"><span class="innerContentContainer">当手指触摸时，人体的静电流入产生微弱的电流，电流会引起电压的变化，根据电压变化可计算触点的位置。</span></span></li><li><span class="name"><span class="innerContentContainer">电容屏把人体作为一个电极使用。</span></span></li><li><span class="name"><span class="innerContentContainer">当人体没接触屏时，面板各处电压都相同，没有电流通过。</span></span></li><li><span class="name"><span class="innerContentContainer">电容屏的优势</span></span><ul><li><span class="name"><span class="innerContentContainer">电容屏中，压力值无效。</span></span></li><li><span class="name"><span class="innerContentContainer">方便，用手指即可；</span></span></li><li><span class="name"><span class="innerContentContainer">操作流畅；</span></span></li><li><span class="name"><span class="innerContentContainer">屏的透光性好。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">最里面是屏幕. 主要有LCD和 OLED 两种：</span></span></li><li><span class="name"><span class="innerContentContainer">LCD (Liquid Crystal Display)，即液晶显示器。包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">TFT</span></span><ul><li><span class="name"><span class="innerContentContainer">TFT(Thin Film Transistor) 即薄膜场效应晶体管，它可以“主动地”对屏幕上的各个独立的像素进行控制，这样可以大大提高反应时间。</span></span></li><li><span class="name"><span class="innerContentContainer">一般TFT的反应时间比较快，约80毫秒。</span></span></li><li><span class="name"><span class="innerContentContainer">而且可视角度大，一般可达到130度左右。</span></span></li><li><span class="name"><span class="innerContentContainer">成本低廉。</span></span></li><li><span class="name"><span class="innerContentContainer">基于TFT屏幕的改进面板技术包括：IPS、ASV、NOVA</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IPS</span></span><ul><li><span class="name"><span class="innerContentContainer">IPS是一种基于TFT屏幕的改进面板技术。</span></span></li><li><span class="name"><span class="innerContentContainer">这种LCD已经存在有一段时间了，但在苹果平板电脑之前一直没有大规模使用。</span></span></li><li><span class="name"><span class="innerContentContainer">IPS能提供更广阔的视角，更好的色彩还原。</span></span></li><li><span class="name"><span class="innerContentContainer">IPS仍然属于LCD范畴，最大生产商是LG。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SLCD</span></span><ul><li><span class="name"><span class="innerContentContainer">SLCD，全名Super clear LCD，是由三星研制。</span></span></li><li><span class="name"><span class="innerContentContainer">其拥有Super AMOLED的艳丽对比度，色彩更暖，更自然，适合人眼观看，屏幕清晰。</span></span></li><li><span class="name"><span class="innerContentContainer">SLCD是一种液晶屏幕，不是自发光的。可看成TFT的一个超级版。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">OLED (Organic Light-Emitting Diode)，即有机发光二极管。</span></span><ul><li><span class="name"><span class="innerContentContainer">三星引以为傲AMOLED系列屏幕属于OLED，被称誉为“梦幻显示器”。</span></span></li><li><span class="name"><span class="innerContentContainer">OLED显示技术与传统的LCD显示方式不同，无需背光灯。</span></span></li><li><span class="name"><span class="innerContentContainer">它采用非常薄的有机材料涂层和玻璃基板。当电流通过时，有机材料就会发光。</span></span></li><li><span class="name"><span class="innerContentContainer">在显示黑色时，相应的像素点无需发光，可以减少电量消耗，提升手机续航. </span></span></li><li><span class="name"><span class="innerContentContainer">而且OLED屏幕可以做得更轻更薄，可视角度更大，并能显著的节省耗电。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">摩氏矿物硬度表</span></span><ul><li><span class="name"><span class="innerContentContainer">硬度可以分为10个等级：</span></span><ul><li><span class="name"><span class="innerContentContainer">1 滑石</span></span></li><li><span class="name"><span class="innerContentContainer">2 石膏</span></span></li><li><span class="name"><span class="innerContentContainer">3 方解石</span></span></li><li><span class="name"><span class="innerContentContainer">4 萤石</span></span></li><li><span class="name"><span class="innerContentContainer">5 磷灰石</span></span></li><li><span class="name"><span class="innerContentContainer">6 正长石</span></span></li><li><span class="name"><span class="innerContentContainer">7 石英</span></span></li><li><span class="name"><span class="innerContentContainer">8 黄玉</span></span></li><li><span class="name"><span class="innerContentContainer">9 刚玉</span></span></li><li><span class="name"><span class="innerContentContainer">10 金刚石</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬度高的可以刮花硬度低的。</span></span></li><li><span class="name"><span class="innerContentContainer">普通玻璃的硬度是6-7左右，而钢的硬度仅为5，所以即使是普通的玻璃，用刀也是刮不花的。</span></span></li><li><span class="name"><span class="innerContentContainer">真正刮花手机屏幕的是沙子，沙子里包含了石英，摩氏硬度为7.5左右。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TP代码</span></span><ul><li><span class="name"><span class="innerContentContainer">核心态代码</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/input/eventdev.c: 事件处理</span></span></li><li><span class="name"><span class="innerContentContainer">atml_imc.c: 驱动代码</span></span></li><li><span class="name"><span class="innerContentContainer">input.c: input子系统，包括电阻屏、电容屏、键盘、鼠标、游戏杆等设备都算input设备</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用户态代码：hal层</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化过程</span></span><ul><li><span class="name"><span class="innerContentContainer">register</span></span></li><li><span class="name"><span class="innerContentContainer">Probe</span></span></li><li><span class="name"><span class="innerContentContainer"> I2C check -&gt; 取X轴、Y轴，Max_x,Max_y </span></span></li><li><span class="name"><span class="innerContentContainer">read_PDT(寄存器种event的buffer地址) </span></span></li><li><span class="name"><span class="innerContentContainer">固件更新，/sys</span></span></li><li><span class="name"><span class="innerContentContainer">proc，数据处理</span></span></li><li><span class="name"><span class="innerContentContainer">创建工作队列线程</span></span></li><li><span class="name"><span class="innerContentContainer">创建工作队列</span></span></li><li><span class="name"><span class="innerContentContainer">配置中断，低电平触发</span></span></li><li><span class="name"><span class="innerContentContainer">申请中断；如果非中断，则启动timer</span></span></li><li><span class="name"><span class="innerContentContainer">注册 early syspend / resume 函数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据处理</span></span><ul><li><span class="name"><span class="innerContentContainer">input子系统中，在中断或timer触发下，读取event_table[]，数组下标即设备号，获取当前evnet；</span></span></li><li><span class="name"><span class="innerContentContainer">通过主设备号，获取input-&gt;fops（event处理函数）处理该event。</span></span></li><li><span class="name"><span class="innerContentContainer">处理逻辑就是上报键值和坐标。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">键值上报</span></span><ul><li><span class="name"><span class="innerContentContainer">hal层device_poll()读取 /dev/input/event_x，x即设备号，然后上报给framework层。</span></span></li><li><span class="name"><span class="innerContentContainer">数据结构即 sensor_event_t，包括type、handle、value（union类似，可适配多种input设备）。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">LCD连接方式：RGB</span></span><ul><li><span class="name"><span class="innerContentContainer">数据位传输有6位，16位，18位，24位之分。</span></span></li><li><span class="name"><span class="innerContentContainer">连线有：</span></span><ul><li><span class="name"><span class="innerContentContainer">VSYNC</span></span></li><li><span class="name"><span class="innerContentContainer">HSYNC</span></span></li><li><span class="name"><span class="innerContentContainer">DOTCLK</span></span></li><li><span class="name"><span class="innerContentContainer">CS</span></span></li><li><span class="name"><span class="innerContentContainer">RESET，有的也需要RS</span></span></li><li><span class="name"><span class="innerContentContainer">剩下都是数据线</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">它的优缺点:</span></span><ul><li><span class="name"><span class="innerContentContainer">不耗费GRAM. 可以支持大屏.</span></span></li><li><span class="name"><span class="innerContentContainer">控制复杂.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">LCD常见问题  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">包括白屏、黑屏、花屏、冻屏。</span></span></li><li><span class="name"><span class="innerContentContainer">LCD初始化流程, 包括寄存器和sleep wakeup的配置，以及配置EBI2总线的LCD控制器，这个时序经常出问题。</span></span></li><li><span class="name"><span class="innerContentContainer">花屏的原因: </span></span></li><li><span class="name"><span class="innerContentContainer">MDP和ARM同时控制显示。ARM控制显示一般是为了调节亮度等的时候。此时就需要保护机制。</span></span></li><li><span class="name"><span class="innerContentContainer">MDP刷屏对时序要求很严格。发现花屏时，可通过LCD_CFG0寄存器来调节时序。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件通知机制</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/categories/Android/Event/">https://www.viseator.com/categories/Android/Event/</a>  --相当不错</span></span></li><li><span class="name"><span class="innerContentContainer">Android系统本质上是一个事件驱动的系统. 消息机制在android系统中占据核心位置.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">android消息机制分为java层，native层和kernel层。</span></span><ul><li><span class="name"><span class="innerContentContainer">java层消息通知方案，即looper类。</span></span></li><li><span class="name"><span class="innerContentContainer">looper是通过调用native层消息机制来完成功能的.</span></span></li><li><span class="name"><span class="innerContentContainer">连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理.</span></span></li><li><span class="name"><span class="innerContentContainer">native层消息机制中, 最关键的超时与唤醒机制, 是通过kernel层epoll机制实现.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Looper类</span></span></li><li><span class="name"><span class="innerContentContainer">native层方案</span></span><ul><li><span class="name"><span class="innerContentContainer">Native中的Looper是为了处理注册的自定义Fd引起的Request&nbsp;消息，这些消息一般来自于系统底层如触摸事件等.</span></span></li><li><span class="name"><span class="innerContentContainer">在获取下一条消息时，looper类会调用nativePollOnce()。</span></span></li><li><span class="name"><span class="innerContentContainer">nativePollOnce()是jni函数，实体是 android_os_messageQueue_nativePollOnce().</span></span></li><li><span class="name"><span class="innerContentContainer">后者最终调用的是 looper.cpp 的 pollOnce(), 实现主体是 pollInner().</span></span></li><li><span class="name"><span class="innerContentContainer">pollInner() 调用 系统调用 epoll_wait()，在指定的设备节点fd上等待事件发生。如果给出超时时间，则也会等待超时发生。</span></span><ul><li><span class="name"><span class="innerContentContainer">这是一个阻塞事件，执行完这一句，当前进程进入等待状态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当注册的fd上有消息，或者超时，</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>EPoll方案</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Epoll属于哪个领域的概念?</span></span><ul><li><span class="name"><span class="innerContentContainer">Epoll机制属于事件通知机制, 而事件通知机制看起来属于跨进程通讯的范畴, 但是它实际上属于设备管理的范畴.</span></span></li><li><span class="name"><span class="innerContentContainer">事件通知机制本质上要处理CPU和设备之间的不同步问题. 简言之, 就是CPU通知设备做点事, 设备不一定能马上处理完并返回的问题.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这里说的"事件"的含义是什么?</span></span><ul><li><span class="name"><span class="innerContentContainer">所谓"事件", 就其本质而言, 产生于设备的内核缓冲区, 当然最终是设备硬件中断产生的. </span></span></li><li><span class="name"><span class="innerContentContainer">事件和硬件中断不是一一对应的. 以网卡为例:</span></span><ul><li><span class="name"><span class="innerContentContainer">当数据量很少的时候，每来一个数据包网卡都回产生一个中断，os响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。</span></span></li><li><span class="name"><span class="innerContentContainer">当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。</span></span></li><li><span class="name"><span class="innerContentContainer">当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到<b>轮询</b>处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件包括4种:</span></span><ul><li><span class="name"><span class="innerContentContainer">内核读缓冲器非空.  (读方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 有人写入</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 事件未处理完.  (常用)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核读缓冲区空. (读方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚空. (常用)</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 空.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写缓冲区满.  (写方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚满</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 满</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写缓冲区非满. (写方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚非满</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 非满</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">这里说的消息机制, 分为3个层面:</span></span><ul><li><span class="name"><span class="innerContentContainer">IO设备管理方面, 通过native层消息机制完成数据传输的同步控制. 比如Input;</span></span></li><li><span class="name"><span class="innerContentContainer">消息队列, Looper, 通过java层消息机制完成跨线程通讯.</span></span></li><li><span class="name"><span class="innerContentContainer">Binder机制也是通过java层消息机制完成的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件通知机制有三种: 阻塞, 轮询, IO 多路复用.</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞指读取数据时, 数据没有准备好, 读进程会停止运行, 等数据准备好再被系统唤醒.&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞是一种同步机制.</span></span></li><li><span class="name"><span class="innerContentContainer">缺点是一个线程只能处理一路IO. 原因是如果同时处理两路, 一路阻塞了, 另外一路就得不到处理了. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">轮询指轮流查询各路IO的状态. </span></span><ul><li><span class="name"><span class="innerContentContainer">缺点是浪费CPU时间.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IO多路复用机制是, 数据没有准备好, 也会阻塞, 但是系统会设置一个IO<b>代理</b>, 当若干路IO就绪时, 由代理唤醒线程, 并告诉它是哪路IO就绪, 从而提升处理效率.</span></span><ul><li><span class="name"><span class="innerContentContainer">IO多路复用机制相当于阻塞机制的改进.</span></span></li><li><span class="name"><span class="innerContentContainer">epoll即 I/O多路复用机制的实现.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">epoll背景知识</span></span><ul><li><span class="name"><span class="innerContentContainer">epoll机制于Linux 2.5.44首度登场.</span></span></li><li><span class="name"><span class="innerContentContainer">设计目的旨在取代既有POSIX&nbsp;select(2)与poll(2)系统函数.</span></span></li><li><span class="name"><span class="innerContentContainer">优势是处理多路IO事件时, 性能提升非常多. 旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n). (很多材料说是 O(1), 这是错误的).</span></span></li><li><span class="name"><span class="innerContentContainer">性能提升的原因是它能够只关注有数据的FD(文件描述符), 而不是所有FD都轮询一遍.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">epoll&nbsp;通过使用红黑树(RB-tree)搜索被监视的文件描述符(file descriptor, FD)。</span></span></li><li><span class="name"><span class="innerContentContainer">在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</span></span></li><li><span class="name"><span class="innerContentContainer">程序接口</span></span><ul><li><span class="name"><span class="innerContentContainer">接口实现在 /bionic/libc/bionic/sys_epoll.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">int epoll_create(int size);  // 在内核中创建epoll实例并返回一个epoll文件描述符。</span></span></li><li><span class="name"><span class="innerContentContainer">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  // 添加、修改或删除对 fd 上事件 event 的监听。</span></span><ul><li><span class="name"><span class="innerContentContainer">op 可以为&nbsp;EPOLL_CTL_ADD,&nbsp;添加新的事件</span></span></li><li><span class="name"><span class="innerContentContainer">EPOLL_CTL_MOD,&nbsp;修改文件描述符上监听的事件类型. 类型包括沿触发和状态触发. </span></span></li><li><span class="name"><span class="innerContentContainer">EPOLL_CTL_DEL, 从实例上删除一个事件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">int <b>epoll_wait</b>(int epfd, struct epoll_event *events, int maxevents, int timeout);   // 监听并阻塞, 等待唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">当 timeout 为 0 时，epoll_wait 永远会立即返回。</span></span></li><li><span class="name"><span class="innerContentContainer">而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。</span></span></li><li><span class="name"><span class="innerContentContainer">当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">应用程序调用 <b>epoll_wait() 启动监听, 并阻塞自身后, 需要等待另一个进程唤醒.</b></span></span></li><li><span class="name"><span class="innerContentContainer">唤醒的机制是通过对event FD写入一个数据(一般是1, 显然在这个上下文下写入的内容无关紧要), epoll会监听这个FD, 发现有新数据了, 就把上面监听的进程逐一放入系统的就绪队列, 逐一处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">沿触发和状态触发</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发时，epoll_wait() 仅会在新的事件首次被加入epoll队列时返回.</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发时, epoll_wait在事件状态未变更前将不断被触发。</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发模式是默认的模式。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>同步, 异步, 阻塞, 非阻塞, 轮询, 事件之间的关系  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">这几个概念之所以很混乱, 是因为汉语中把同步调用和跨线程的同步控制, 这两个几乎无关系的概念, 都缩写成"同步"这个词. 这导致了广泛的概念混淆.</span></span></li><li><span class="name"><span class="innerContentContainer">这几个概念不是并列的. 其关系如下:</span></span></li><li><span class="name"><span class="innerContentContainer">同步调用</span></span><ul><li><span class="name"><span class="innerContentContainer">同步就是同一个线程一直在跑, 函数调用返回的时候, 就拿到了调用结果. </span></span></li><li><span class="name"><span class="innerContentContainer">但是, 如果调用涉及到IO操作, 即对硬件的处理. 由于一般情况下面 硬件的访问速度比CPU和内存慢若干个数量级, 所以就存在调用了不能马上得到调用结果的问题. </span></span><ul><li><span class="name"><span class="innerContentContainer">反推回去, 同步之所以行得通, 仅仅因为CPU和内存的速度处在同一个数量级上的(当然, 这个话也不准确, 为了解决这个问题, 有无数的解决方案, 这个领域属于芯片设计, 不提), 由于它们的速度处在同一个数量级, 所以当我们的代码仅仅是读一个数, 做个计算, 再写一个数的时候, 所有这些事情都可以同步完成. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">面对这种不同步, <b>轮询</b>是最直接的解决办法. 轮询算同步.</span></span><ul><li><span class="name"><span class="innerContentContainer">轮询指调用一个函数, 如果不能马上得到结果, 就反复调用它, 直到得到结果为止. </span></span><ul><li><span class="name"><span class="innerContentContainer">一般情况下, 轮询是消费CPU资源的, 而且会引起界面卡顿等问题. </span></span></li><li><span class="name"><span class="innerContentContainer">当然也有特殊情况, 此时轮询效率更高.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">异步</span></span><ul><li><span class="name"><span class="innerContentContainer">异步是轮询的一种改进, 改进的目的是节省CPU资源.</span></span></li><li><span class="name"><span class="innerContentContainer">异步的特点是, 调用结束时拿不到调用结果, 继续执行别的代码. 然后发生线程切换, 在另外一个线程中执行被调方代码并返回结果. 调用和拿到调用结果, 不是在同一个函数中, 一般也不在同一个线程中.</span></span></li><li><span class="name"><span class="innerContentContainer">异步的常见方式是: 调用的同时注册回调函数, 然后在没有执行结果的情况下直接返回, 接着往下执行. 回调函数则会在被调者执行完之后被调用.</span></span></li><li><span class="name"><span class="innerContentContainer">异步, 实际上是把调用逻辑分为4部分: 调用者前半部, 被调者前半部, 被调者后半部, 调用者后半部(也就是回调函数). </span></span></li><li><span class="name"><span class="innerContentContainer"><b>调用者前半部</b> 调用 <b>被调者前半部</b>, <b>被调者前半部</b> 想办法调用 <b>被调者后半部</b>(这里存在跨线程通讯), 这个过程发生在调用者线程中. 然后发生线程切换, 去执行 <b>被调者后半部</b>, 等它执行完了, 再调用 <b>调用者后半部</b>(再强调一遍, 也就是回调函数), 这个过程发生在被调者线程中. </span></span></li><li><span class="name"><span class="innerContentContainer">我之所以说异步是一种特殊的同步实现方法, 是因为调用者前半部 调用 被调者前半部, 是同步调用, 马上得到结果; 被调者后半部, 调用 调用者后半部, 也是同步调用, 马上得到结果. 至于被调者前半部 调用 被调者后半部的机制, 这往往是框架或平台在处理, 对使用者不可见. </span></span></li><li><span class="name"><span class="innerContentContainer">对初学者而言, 理解异步最困难的是理解回调函数. </span></span></li><li><span class="name"><span class="innerContentContainer">但是对于有经验的人来说, 回调函数仅仅是把处理的后半部分单独出来, 稍微有些绕而已, 并不难理解. 真正复杂的问题是, 被调者前半部, 怎么去调用 被调者后半部.</span></span></li><li><span class="name"><span class="innerContentContainer">首先要理解的是, 被调者前半部 和 被调者后半部 处在不同的线程中(调用者前半部, 和回调函数也在不同的线程中).  也就是说, 这是一个跨线程的调用. 因此请参见: "跨线程的同步机制".</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">阻塞</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞, 就是调用一个函数半途中发生线程切换, 等拿到调用结果时, 再把线程切换回来继续执行.</span></span></li><li><span class="name"><span class="innerContentContainer">其突出特点是虽然线程切换了, 但是函数没有换, 还是在原来函数中. </span></span></li><li><span class="name"><span class="innerContentContainer">从某种意义上讲, 阻塞是操作系统(或者虚拟机)帮忙, 以同步的形式, 完成异步的实质. 毕竟, 同步调用, 代码的执行顺序和编写顺序是一致的, 好理解多了.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">非阻塞, 就是异步. 不用阻塞, 又在IO操作中, 只能是异步. </span></span></li><li><span class="name"><span class="innerContentContainer">epoll: epoll是同步机制, 它支持阻塞, 也可以支持非阻塞. 区别在于入参. epoll_wait() 的</span></span></li><li><span class="name"><span class="innerContentContainer">跨线程的同步机制</span></span><ul><li><span class="name"><span class="innerContentContainer">异步和阻塞, 都涉及到同一个处理逻辑(从业务视角出发), 分解到不同的线程的问题. 因此, 这几个线程之间必须要有同步机制, 才能把业务逻辑处理好. </span></span></li><li><span class="name"><span class="innerContentContainer">同步机制是消息队列. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">还有一种分类方式, 就是把阻塞作为一种特殊的同步调用方式. 其理由是, 同步调用就是这个函数执行完了, 就拿到执行结果了. 阻塞没出函数拿到结果, 所以算同步机制. </span></span><ul><li><span class="name"><span class="innerContentContainer">这个仅仅是一个定义的问题. 这么算也可以. 但是阻塞出现了当前线程挂起, 失去CPU, 以及多个线程间的同步控制, 这种算同步就掩盖了很多技术细节.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同步阻塞的IO会使线程挂起，同步非阻塞(即轮询)的IO会消耗CPU资源在轮询上。</span></span></li><li><span class="name"><span class="innerContentContainer">IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）.</span></span></li><li><span class="name"><span class="innerContentContainer">直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">power 键的规格</span></span><ul><li><span class="name"><span class="innerContentContainer">0-500毫秒： 亮灭屏</span></span><ul><li><span class="name"><span class="innerContentContainer">亮屏时，抬起才灭屏。</span></span></li><li><span class="name"><span class="innerContentContainer">灭屏时，按下就亮屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">500-2500毫秒：语音助手</span></span></li><li><span class="name"><span class="innerContentContainer">2500毫秒以上： 关机</span></span></li><li><span class="name"><span class="innerContentContainer">灭屏时，按下即亮屏。 </span></span></li><li><span class="name"><span class="innerContentContainer">来电来闹钟，按power静音。</span></span></li><li><span class="name"><span class="innerContentContainer">连按power两次，进支付界面。（from iOS）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟导航键</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟导航键由SystemUI处理。</span></span></li><li><span class="name"><span class="innerContentContainer">应用不需要刻意处理导航键。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化过程</span></span><ul><li><span class="name"><span class="innerContentContainer">导航栏实质是 NavigationBarView, 继承自 ViewGroup.</span></span></li><li><span class="name"><span class="innerContentContainer">在 PhoneStatusBar.java 中的 makeStatusBarView () 中初始化。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 mWindowManagerService.hasNavigationBar() 判断是否要加载导航栏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">键值模拟过程</span></span><ul><li><span class="name"><span class="innerContentContainer">back和home的键值ID在layout文件的systemui.keycode 定义。</span></span></li><li><span class="name"><span class="innerContentContainer">然后构造KeyEvent对象后，调用InputManager的injectInputEvent() 注入事件。</span></span></li><li><span class="name"><span class="innerContentContainer">recent键的处理不太一样，它的键值是0，而且不走injectInputEvent()流程，而是直接打开 RecentApp的activity。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">back键按下后的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">系统调用当前activity栈的top activity的 Destroy()，然后底下的activity自然就显示出来。</span></span></li><li><span class="name"><span class="innerContentContainer">back键事件会送到应用。</span></span></li><li><span class="name"><span class="innerContentContainer">应用调用 onBackPress() 可拦截back键。</span></span></li><li><span class="name"><span class="innerContentContainer">framework处理back键在 interceptKeyBeforeQueueing().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">home键按下后的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">系统调用当前activity栈的top activity的 Stop(), 把整个应用都推到后台。</span></span></li><li><span class="name"><span class="innerContentContainer">home键事件不送给应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">recent键, 也叫 app_switch</span></span></li><li><span class="name"><span class="innerContentContainer">back键会送到应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">手势导航</span></span><ul><li><span class="name"><span class="innerContentContainer">Android Q 手势导航   <a class="contentLink" target="_blank" rel="noreferrer" href="https://juejin.im/post/6844903853486260232">https://juejin.im/post/6844903853486260232</a> --这个是google宣传材料</span></span></li></ul></li></ul>
  </body>
</html>