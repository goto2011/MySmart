<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">33-文件系统&amp;存储&amp;USB</span></span><ul><li><span class="name"><span class="innerContentContainer">MBR: 主引导记录（Master Boot Record）</span></span><ul><li><span class="name"><span class="innerContentContainer">可引导磁盘驱动器上的第一个物理扇区。</span></span></li><li><span class="name"><span class="innerContentContainer">计算机刚开始引导时，系统 BIOS 查看该扇区以确定当前哪个分区是活动的（可引导的），随后读取该分区的第一个（引导）扇区并从该分区引导。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RAID: 设备冗余阵列（Redundant Array of Independent/Inexpensive Disks/Devices）</span></span><ul><li><span class="name"><span class="innerContentContainer">一种提供数据冗余、改善性能和／或从磁盘崩溃中迅速恢复数据的方法，它是通过在多个磁盘驱动器上分布或复制数据来实现这一点的。</span></span></li><li><span class="name"><span class="innerContentContainer">常用的 RAID 类型包括 RAID 0（数据条带化），RAID 1（磁盘镜像）和 RAID 5（具有分布式奇偶校验的条带化）。</span></span></li><li><span class="name"><span class="innerContentContainer">RAID 配置通常需要 SCSI 磁盘驱动器（而不是 IDE/EIDE），可能要求磁盘相同（相同的容量、品牌等等）。</span></span></li><li><span class="name"><span class="innerContentContainer">操作系统将 RAID 阵列看作单个设备。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FAT32</span></span><ul><li><span class="name"><span class="innerContentContainer">FAT32 system图示  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SD卡驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">线序</span></span><ul><li><span class="name"><span class="innerContentContainer">共计10根线</span></span></li><li><span class="name"><span class="innerContentContainer">data 0-3（左右两边各2）</span></span><ul><li><span class="name"><span class="innerContentContainer">data3还可以做卡插入识别功能。</span></span></li><li><span class="name"><span class="innerContentContainer">一般卡座上会另外加一根中断线侦听sd卡插拔，所以不这么用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">clk（左4）</span></span></li><li><span class="name"><span class="innerContentContainer">GP1（左5）</span></span></li><li><span class="name"><span class="innerContentContainer">cmd（左6）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">理论速度： 4根data线，若clk配成50Mhz，则理论速率为25MB。</span></span></li><li><span class="name"><span class="innerContentContainer">命令字</span></span><ul><li><span class="name"><span class="innerContentContainer">识别高速卡： SD_ACMD 13 命令可获取sd_status，其中有speed class。</span></span></li><li><span class="name"><span class="innerContentContainer">识别spec版本： ACMD 51 命令，获取SCR寄存器，其中有版本号。</span></span></li><li><span class="name"><span class="innerContentContainer">获取制造商信息及串号： CMD2 获取，CID寄存器中有。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SD卡初始化命令序列</span></span><ul><li><span class="name"><span class="innerContentContainer">power</span></span></li><li><span class="name"><span class="innerContentContainer">clk</span></span></li><li><span class="name"><span class="innerContentContainer">CMD5: 寻找SD卡</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SDIO卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">config clk: 初始化阶段配置为400K</span></span></li><li><span class="name"><span class="innerContentContainer">CMD0: reset</span></span></li><li><span class="name"><span class="innerContentContainer">CMD8: 识别SDHC</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SDHC卡</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMD55: 是否支持ACMD</span></span></li><li><span class="name"><span class="innerContentContainer">ACMD41: 电压协商</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SD卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMD1: idle</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为 MMC卡.</span></span></li><li><span class="name"><span class="innerContentContainer">如果这个也不能回应，则为不可识别的卡。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SDIO控制器</span></span><ul><li><span class="name"><span class="innerContentContainer">sdio host控制器硬件在芯片中，共有4个控制器接口。其中:</span></span></li><li><span class="name"><span class="innerContentContainer">sdio1给sd卡用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio2给wifi用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio3给emmc用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio4 闲置.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动代码</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/mmc/. 下面有三个目录：</span></span><ul><li><span class="name"><span class="innerContentContainer">core</span></span><ul><li><span class="name"><span class="innerContentContainer">核心代码，与平台无关的通用代码放在这里。</span></span></li><li><span class="name"><span class="innerContentContainer">对 SDIO/SD/MMC的识别就在这个目录中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">host</span></span><ul><li><span class="name"><span class="innerContentContainer">对应的各硬件平台的sd host控制器与sd卡交互的代码，以及sd卡驱动参数配置。</span></span></li><li><span class="name"><span class="innerContentContainer">如 msm_sdcc.c就是负责把sd命令发给sd卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">card</span></span><ul><li><span class="name"><span class="innerContentContainer">block.c 即块设备驱动，负责把读写IO请求放入队列；</span></span></li><li><span class="name"><span class="innerContentContainer">queue.c 即队列管理，把读写IO请求翻译为sd host控制器可以识别的信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">平台设备部分</span></span><ul><li><span class="name"><span class="innerContentContainer">sdio模块的驱动在内核中注册的是platform驱动模型.</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO配置、SD VDD电源和时钟等，在/kernel/arch/arm/board_msm7***.c中配置。</span></span></li><li><span class="name"><span class="innerContentContainer">这部分每个产品都有区别，独立出来方便管理。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化步骤分为:</span></span><ul><li><span class="name"><span class="innerContentContainer">device 的注册</span></span><ul><li><span class="name"><span class="innerContentContainer">msm7x2x_init_mmc</span></span></li><li><span class="name"><span class="innerContentContainer">msm_add_sdcc(2, &amp;msm7x2x_sdc2_data)&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">platform_device_register&nbsp; //注册的设备名为msm_sdcc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">driver 的注册</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/mmc/msm_sdcc.c</span></span></li><li><span class="name"><span class="innerContentContainer">msmsdcc_init()</span></span></li><li><span class="name"><span class="innerContentContainer">platform_driver_register(&amp;msmsdcc_driver);</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc初始化的代码: board_msm7x27a.c，msm7x27a_init_mmc()</span></span></li><li><span class="name"><span class="innerContentContainer">配置sdcc gpio的代码</span></span><ul><li><span class="name"><span class="innerContentContainer">board_msm7x30.c</span></span></li><li><span class="name"><span class="innerContentContainer">msm_gpio sdc4_cfg_data[]</span></span></li><li><span class="name"><span class="innerContentContainer">{GPIO_CFG(58, 1, GPIO_CFG_OUTPUT, ..., GPIO_CFG_15MA (启动能力), "sdc4_clk"};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC特性</span></span><ul><li><span class="name"><span class="innerContentContainer">EMMC 就是sd卡，最小容量为2G，替代flash作为存储介质。</span></span></li><li><span class="name"><span class="innerContentContainer">emmc的一个主要特征是只允许一个执行单元访问.</span></span></li><li><span class="name"><span class="innerContentContainer">所以在app阶段，app负责访问emmc，而modem侧代码不能直接访问。</span></span><ul><li><span class="name"><span class="innerContentContainer">那么, modem侧文件系统怎么机制?</span></span><ul><li><span class="name"><span class="innerContentContainer">使用ram fs。</span></span></li><li><span class="name"><span class="innerContentContainer">modem 读写ram fs；</span></span></li><li><span class="name"><span class="innerContentContainer">其读写请求会被app侧获取，然后app访问真正的emmc，然后app把数据同步到ram fs；</span></span></li><li><span class="name"><span class="innerContentContainer">最后modem 从ram fs 中得到数据。</span></span></li><li><span class="name"><span class="innerContentContainer">也就是说，modem 必须异步的调用。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">分区表</span></span><ul><li><span class="name"><span class="innerContentContainer">生成方式变了，通过 xml+loadpt.cmm = bin文件；不需要编译。</span></span></li><li><span class="name"><span class="innerContentContainer">mbr 下有三个主分区 + 一个扩展分区（ebr）；</span></span></li><li><span class="name"><span class="innerContentContainer">ebr 下面之后可以容纳15 个逻辑分区。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何新建分区？</span></span><ul><li><span class="name"><span class="innerContentContainer">修改这个文件：AMSS\products\**\tools\jsdcc\partition_load_pt\partition.xml</span></span></li><li><span class="name"><span class="innerContentContainer">添加如下代码:&lt;extended order="1" type="59" label="OEMINFO" size="24576" readonly="false"&gt;&lt;file name="***.mbn" offset="0"/&gt;&lt;/extended&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">order: 分区的位置；</span></span></li><li><span class="name"><span class="innerContentContainer">type: 分区id, 自己定义；</span></span></li><li><span class="name"><span class="innerContentContainer">size: 大小, 定位为sector, 即 512Byte；</span></span></li><li><span class="name"><span class="innerContentContainer">file name: 有这个选项后, 会自动生成下载该分区的cmm脚本.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运行 loadpt.exe ，生成 partition.bin 及cmm脚本。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">emmc读写速率</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc是8根data线，时钟最大是50mhz，所以理论速率为50MBs.</span></span></li><li><span class="name"><span class="innerContentContainer">实测数据是10MBs。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC有两种方案</span></span><ul><li><span class="name"><span class="innerContentContainer">SLC</span></span><ul><li><span class="name"><span class="innerContentContainer">Single Layer Cell 单层单元。</span></span></li><li><span class="name"><span class="innerContentContainer">SLC的特点是成本高、容量小、速度快。</span></span></li><li><span class="name"><span class="innerContentContainer">SLC闪存的优点是复写次数高达100000次，比MLC闪存高10倍。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MLC</span></span><ul><li><span class="name"><span class="innerContentContainer">Multi-Level Cell 多层单元。</span></span></li><li><span class="name"><span class="innerContentContainer">MLC的特点是容量大，但速度慢。</span></span></li><li><span class="name"><span class="innerContentContainer">MLC的每个单元是2bit的，相对SLC来说整整大了一倍。</span></span></li><li><span class="name"><span class="innerContentContainer">由于结构复杂，出错的几率增加，需要做错误修正，导致其性能大幅落后于SLC闪存。&nbsp;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Vold</span></span><ul><li><span class="name"><span class="innerContentContainer">vold.conf: android\system\core\rootdir\etc\msm7630_surf\vold.qcom.conf</span></span></li><li><span class="name"><span class="innerContentContainer">mount service的代码: nativeDaemonConnector.java 之 doCommand()</span></span></li><li><span class="name"><span class="innerContentContainer">外置sd卡插拔的uevent发出: VolumeManager::handleBlockEvent()</span></span></li><li><span class="name"><span class="innerContentContainer">mount service下发mount命令的入口: VolumeManager::mountVolume()</span></span></li><li><span class="name"><span class="innerContentContainer">mount service下发umount命令的入口: Volume::unmountVol()</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡mount成功的log: Volume sdcard state Changing 3(checking) -&gt; 4(Mounted)</span></span></li><li><span class="name"><span class="innerContentContainer">fat check工具</span></span><ul><li><span class="name"><span class="innerContentContainer">/system/bin/fsck_msdos -p -f /mnt/sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">作为对比：windows上，chkdsk h:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">fat check的处理流程</span></span><ul><li><span class="name"><span class="innerContentContainer">在logswap()中，调用fork，创建一个子进程，然后调用child()加载 fsck_msdos工具进行检查。</span></span></li><li><span class="name"><span class="innerContentContainer">此时父进程通过 wait(&amp;status) 来等待子进程执行完毕。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP</span></span><ul><li><span class="name"><span class="innerContentContainer">PTP（Picture Transfer Protocol），MTP的前身，用在数码相机和MP3播放器上做文件传输。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP（Media Transfer Protocol，媒体传输协议），微软2006年提出。</span></span></li><li><span class="name"><span class="innerContentContainer">Android从3.0开始支持MTP。</span></span></li><li><span class="name"><span class="innerContentContainer">usb插入后，系统会弹出一个对话框，选择“Transfer files"即打开MTP。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP和UMS（即U盘）的对比</span></span><ul><li><span class="name"><span class="innerContentContainer">优势：</span></span><ul><li><span class="name"><span class="innerContentContainer">UMS挂载到PC后，存储器就被PC控制，手机侧不能再访问该存储器。这个不方便。</span></span></li><li><span class="name"><span class="innerContentContainer">在存储器重新挂载到手机后，需要重新扫描媒体文件。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP则没有这两个问题。当手机的sdcard以MTP模式挂载到PC机上，sdcard的控制权其实还是属于手机。只不过智能手机通过MTP协议向PC机构建了一个虚拟文件系统。PC机操作其中的文件时，都会通过标准MTP协议向智能手机发起请求。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP模式下，可判断PC机拷贝的媒体文件是否受目标手机支持，甚至会触发对应的转码程序将其转换成手机支持的格式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">劣势</span></span><ul><li><span class="name"><span class="innerContentContainer">速度较慢。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP不能直接修改文件本身。只能先拷贝到本地修改，完毕后再拷贝回去。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux和MacOS对MTP支持还不是很完善。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP协议有两个部分：Initiator（USB Host，例如PC机）和Responder（USB Client，例如手机或相机）。</span></span></li><li><span class="name"><span class="innerContentContainer">协议规定所有MTP操作只能由Initator发起。</span></span></li><li><span class="name"><span class="innerContentContainer">Responder 的作用就是处理Initator发起的请求。同时，它还会根据自身状态的变化发送Event以通知 Initiator。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP协议栈</span></span><ul><li><span class="name"><span class="innerContentContainer">物理层。用于传输数据。目前有三种物理层可供MTP使用。它们分别是：</span></span><ul><li><span class="name"><span class="innerContentContainer">USB：其主要特点是传输文件，同步媒体文件时速度快，而且可以边工作边充电，这是目前用的最多的一种方式；</span></span></li><li><span class="name"><span class="innerContentContainer">IP：基于IP的MTP（简称MTP/IP）将通过UPnP来匹配和发现设备。它是家庭网络中是最理想的传输方式；</span></span></li><li><span class="name"><span class="innerContentContainer">Bluetooth：MTP/BT是最省电，同时也是速度最慢的一种传输方式，用处较少。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输层：数据传输格式遵循PTP协议。</span></span></li><li><span class="name"><span class="innerContentContainer">命令层：实现MTP协议中的各种命令。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">以PC通过MTP打开一个文件为例，介绍其中涉及到几个主要MTP命令：</span></span><ul><li><span class="name"><span class="innerContentContainer">当设备第一次连接上PC后，Initiator（即PC）首先会发送一个名为 GetDeviceInfo 的请求以获取设备的信息，包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">设备所支持PTP版本的程度，以百分号表示（默认是100）</span></span></li><li><span class="name"><span class="innerContentContainer">所支持的MTP命令（Operation Supported）、</span></span></li><li><span class="name"><span class="innerContentContainer">所支持的Event类型等等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接着PC端会发送 OpenSession 命令以创建一个会话，该会话一直保持到设备从PC上断开为止。</span></span><ul><li><span class="name"><span class="innerContentContainer">此后所有命令（除GetDeviceInfo命令外）必须在此会话存活期间才能发送。</span></span></li><li><span class="name"><span class="innerContentContainer">会话由SessionID来标识，它是一个32位的无符号整型。</span></span></li><li><span class="name"><span class="innerContentContainer">SessionID由PC选择并传给手机。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PC端需要通过 GetStorageIDs 命令返回某个盘符对应的 StorageID。</span></span><ul><li><span class="name"><span class="innerContentContainer">PC端如果要进行文件操作的话，必须从根目录开始定位目标文件。在windows上，根目录即为盘符。</span></span></li><li><span class="name"><span class="innerContentContainer">StorageID是一个32位无符号整型，每一个StorageID代表了一个逻辑盘符。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，如果手机内部有两块存储卡的话（如内部存储卡和外部sd卡），Windows中会显示为两个盘符。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">根据上一步的StorageID号，利用 GetStorageInfo 操作去获取存储设备的信息，例如剩余存储空间、文件系统类型、访问权限等。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 GetObjectHandles 命令来获取此盘符下的文件和子目录的Object Handles。</span></span><ul><li><span class="name"><span class="innerContentContainer">一个Object Handle代表一个文件或目录。该值由Responder生成并保证唯一性。</span></span></li><li><span class="name"><span class="innerContentContainer">有了Object Handle，PC就可以操作这些文件或目录了，例如继续通过GetObjectHandles获取某个目录中子文件和子目录的信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果需要拷贝一个文件到手机上，那么PC会通过SendObjectInfo命令将文件信息（如文件名、文件大小）等传递给手机。而手机需要检查目标目录是否有足够的空间和对应权限。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一切正常，PC将通过SendObject把数据传递给手机。真正写文件到设备存储空间的则是手机中的Responder。Android实现的MTP还会在媒体文件传输完毕后，将信息更新到媒体数据库中。</span></span></li><li><span class="name"><span class="innerContentContainer">PC还可利用SetObjectPropValue 命令来设置文件的各种属性值，如Audio BitRate（比特率），Sample Rate（采样率），Number Of Channels（声道）等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UsbService</span></span><ul><li><span class="name"><span class="innerContentContainer">Android 的 UsbService 可同时管理USB Host/USB Device。其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">UsbDeviceManager管理Usb Device端的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">UsbHostManager管理Usb Host端的功能。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpServer</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Client</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>MtpReceiver</b>负责接收广播，接收到广播后会启动/关闭MtpService；例如，MtpReceiver收到"Android设备 和 PC连上"的消息时，会启动MtpService。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MtpService</b>的作用是提供管理MTP的服务，它会启动MtpServer，以及将本地存储内容和MTP的内容同步。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MediaProvider</b>负责本地存储内容查找和本地内容同步。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Server</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>MtpServer</b>相当于一个服务器，它通过和底层进行通信从而提供了MTP的相关服务。</span></span><ul><li><span class="name"><span class="innerContentContainer">MtpServer会不断地监听Kernel的消息"MTP请求"，并对相应的消息进行相关处理。</span></span></li><li><span class="name"><span class="innerContentContainer">同时，MTP的Event事件也是通过MtpServer发送给MTP驱动的。</span></span></li><li><span class="name"><span class="innerContentContainer">android_mtp_MtpServer 是一个JNI类，完成底层通讯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpDatabase</b>充当着数据库的功能，但它本身并没有数据库对数据进行保存，本质上是通过MediaProvider数据库获取所需要的数据。</span></span><ul><li><span class="name"><span class="innerContentContainer">android_mtp_MtpDatabase 是一个JNI类，完成对MediaProvider的操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpStorage</b>对应一个"存储单元"。例如，SD卡就对应一个MtpStorage。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MtpPacket </b>和 <b>MtpEventPacket</b>负责对MTP消息进行打包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化过程中，MtpServer.cpp中的MtpServer::run()会打开MTP文件节点"/dev/mtp_usb"。</span></span></li><li><span class="name"><span class="innerContentContainer">数据过程中，通过 read()，不断的从中读取"PC发来的消息"消息并进行处理。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP启动详细流程</span></span><ul><li><span class="name"><span class="innerContentContainer">开启MTP的核心代码如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">mUsbManager = context.getSystemService(UsbManager.class);</span></span></li><li><span class="name"><span class="innerContentContainer">mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_MTP, true);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UsbManager的服务端实现为UsbService，其功能是：</span></span><ul><li><span class="name"><span class="innerContentContainer">1.&nbsp; 设置sys.usb.config属性的值为 mtp,adb，底层响应属性改变，切换到MTP功能。文件在： system/core/rootdir/init.usb.configfs.rc</span></span></li><li><span class="name"><span class="innerContentContainer">2.&nbsp; 上层mUEventObserver监听到USB状态改变，在手机通过USB连接到电脑的情况下，会生成两个通知，以及发送一个USB状态改变的广播。frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java</span></span><ul><li><span class="name"><span class="innerContentContainer">ACTION_USB_STATE广播携带了很多extra（可以到Tethering.java中查看extra参数用途）。</span></span></li><li><span class="name"><span class="innerContentContainer">这个广播是<b>黏性广播</b>，这意味着你在注册broadcastReceiver后马上就能收到一次。所以即使我们插着usb线开机，没有插入usb线的操作去trigger，我们注册广播后依然可以把usb模式转换为mtp模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MtpReceiver.java属于packages/providers/MediaProvider模块。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java</span></span></li><li><span class="name"><span class="innerContentContainer">handleUsbState()方法如何处理USB状态改变的。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java</span></span><ul><li><span class="name"><span class="innerContentContainer">USB连接时，状态是从DISCONNECTED到CONNECTED，再到CONFIGURED。</span></span></li><li><span class="name"><span class="innerContentContainer">handleUsbState中启动MtpService。参数unlocked的值是true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MtpService 启动时候执行onStartCommand函数。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java</span></span></li><li><span class="name"><span class="innerContentContainer">StartServer函数启动MtpServer。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/media/java/android/mtp/MtpServer.java</span></span></li><li><span class="name"><span class="innerContentContainer">native_run函数最终调用JNI的函数android_mtp_MtpServer_run()。 frameworks/base/media/jni/android_mtp_MtpServer.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">android_mtp_MtpServer_run调用MtpServer.cpp的run方法。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/av/media/mtp/MtpServer.cpp。</span></span></li><li><span class="name"><span class="innerContentContainer">MtpServer.cpp不断从文件描述符读取请求，然后调用handleRequest进行处理。最后把处理结果返回给对端。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SD/EMMC问题定位经验  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">注意sd卡插拔诊断方式的处理代码，是否整个sd卡初始化流程根本没有启动。</span></span></li><li><span class="name"><span class="innerContentContainer">电源电压值是否ok，是否没有打开电源。出现的概率最高，也最好测出来。</span></span></li><li><span class="name"><span class="innerContentContainer">上电时序要符合协议要求；0到2.6V，要平滑上升。</span></span></li><li><span class="name"><span class="innerContentContainer">clk是否成功配下去，clk线的速率是否和配置值吻合;&nbsp; data 线是否有数据交互。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡的类型是否成功识别；</span></span></li><li><span class="name"><span class="innerContentContainer">是否底层已经初始化成功，但是没有正确的通知上层，导致ui无法访问卡内容；</span></span></li><li><span class="name"><span class="innerContentContainer">读卡过程中出现 crc fail错误，一般为频率太高。我们的硬件信号在50M高速传输下有问题，将其改为20M此错误会不出现。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡 第0个sector 读失败，导致FAT32 无法mount，很像兼容性问题。格式化能解决该问题（数据会丢失）。</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹混乱问题。使用 winhex.exe 定位。</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡初始化时间过长，导致时序相关问题。（升级时vvs不恢复）</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡访问速度太慢问题。排除卡自身的问题后，软件方面的原因较可能是时钟频率设得太低。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡错误处理中断注册的问题。高通代码中对sd卡的大部分中断都没有处理，导致一些问题。遇到了注册上即可。</span></span></li><li><span class="name"><span class="innerContentContainer">在上层调用底层接口往sd卡写数据之前，应该清一下cache；因为底层sd卡读写是采用DMA 方式。如果cache和内存有不同步的地方，则DMA会写入错误的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">由于高通默认配置中，蓝牙电源使用GP1配置，而我们的硬件上GP1电源给SD卡。但是相关代码没有按照这个修改来调整，导致蓝牙开关电源时实际上是在控制GP1电源，最终导致sd卡状态不正常。</span></span></li><li><span class="name"><span class="innerContentContainer">文件名超长问题。</span></span></li><li><span class="name"><span class="innerContentContainer">文件只读导致无法修改、删除、剪贴。</span></span></li><li><span class="name"><span class="innerContentContainer">seek超过文件大小的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">文件系统性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB autorun方案</span></span><ul><li><span class="name"><span class="innerContentContainer">方案的主要思想是自动安装驱动和后台软件.</span></span></li><li><span class="name"><span class="innerContentContainer">它要解决的核心问题是手机侧如何知道pc上是否安装了usb 驱动。</span></span></li><li><span class="name"><span class="innerContentContainer">有两种方案:</span></span><ul><li><span class="name"><span class="innerContentContainer">由手机来判断pc是否安装驱动.</span></span><ul><li><span class="name"><span class="innerContentContainer">优缺点: 便利. 但是受制于windows的实现.</span></span></li><li><span class="name"><span class="innerContentContainer">方案也有两种:</span></span><ul><li><span class="name"><span class="innerContentContainer">延迟判断法</span></span><ul><li><span class="name"><span class="innerContentContainer">usb驱动按照modem、diag口（串口）、光盘来设计，第一个口是modem。</span></span></li><li><span class="name"><span class="innerContentContainer">手机插入后，先报唯一一个光盘。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，如果pc安装过驱动，则pc会认为第一个端口为modem，它不会发命令查看光盘的内容。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有安装驱动，pc会加载标准光盘启动，并查看光盘内容。</span></span></li><li><span class="name"><span class="innerContentContainer">经验表明，这个时间大约是3秒。3秒内，pc没查询光盘内容，则表明它安装过驱动，此时手机自动切换为三端口。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">set feature判断法</span></span><ul><li><span class="name"><span class="innerContentContainer">这个方案的本质和延迟判断法基本一样，根据pc在两种情况下的行为不同来判断。</span></span></li><li><span class="name"><span class="innerContentContainer">但是判断的是set feature命令。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有安装驱动，pc会加载光盘驱动，不会发set feature命令；</span></span></li><li><span class="name"><span class="innerContentContainer">如果相反，则会发。</span></span></li><li><span class="name"><span class="innerContentContainer">所以当收到set feature时，就切换三端口。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">由手机光盘中的exe程序自动启动后从windows系统中判断是否安装驱动。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android手机上, 没有使用 autorun方案, 仅保留光盘.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">U盘的serial number问题</span></span><ul><li><span class="name"><span class="innerContentContainer">windows对U盘的识别策略是：</span></span><ul><li><span class="name"><span class="innerContentContainer">如果串号为空，则只识别第一个U盘；</span></span></li><li><span class="name"><span class="innerContentContainer">如果不为空，但相同，则多个U盘插入，windows会重启；</span></span></li><li><span class="name"><span class="innerContentContainer">如果不为空，且不同，则可分别识别。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对u盘sn号的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">google模式下用蓝牙地址；</span></span></li><li><span class="name"><span class="innerContentContainer">CTS模式下用字符串“hw_smart_phone”的asc码（因为CTS需要在linux下测试，需要串号）。</span></span></li><li><span class="name"><span class="innerContentContainer">normal等其它模式都没有sn号。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">各种版本的默认USB模式</span></span><ul><li><span class="name"><span class="innerContentContainer">国内升级：normal；</span></span></li><li><span class="name"><span class="innerContentContainer">海外升级：google；</span></span></li><li><span class="name"><span class="innerContentContainer">烧片：生产模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB spec</span></span><ul><li><span class="name"><span class="innerContentContainer">device</span></span><ul><li><span class="name"><span class="innerContentContainer">对应物理设备本身。</span></span></li><li><span class="name"><span class="innerContentContainer">device descriptor包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">USB版本号</span></span></li><li><span class="name"><span class="innerContentContainer">设备类型</span></span></li><li><span class="name"><span class="innerContentContainer">子类型</span></span></li><li><span class="name"><span class="innerContentContainer">协议类型（这三个字段在多设备中是空的）</span></span></li><li><span class="name"><span class="innerContentContainer">EP包大小</span></span></li><li><span class="name"><span class="innerContentContainer">vendor id及字符串</span></span></li><li><span class="name"><span class="innerContentContainer">产品id及字符串</span></span></li><li><span class="name"><span class="innerContentContainer">支持的配置数量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">configuration</span></span><ul><li><span class="name"><span class="innerContentContainer">一个device至少有个一个配置，一般就一个。</span></span></li><li><span class="name"><span class="innerContentContainer">config des包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">支持的interface数量</span></span></li><li><span class="name"><span class="innerContentContainer">是否直供电</span></span></li><li><span class="name"><span class="innerContentContainer">是否支持远程唤醒</span></span></li><li><span class="name"><span class="innerContentContainer">需要的最大总线电量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">interface</span></span><ul><li><span class="name"><span class="innerContentContainer">一个配置至少一个接口；</span></span></li><li><span class="name"><span class="innerContentContainer">多用途设备会有多个接口；接口数量和端口数量一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">interface des中包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">设备类型</span></span></li><li><span class="name"><span class="innerContentContainer">子类型</span></span></li><li><span class="name"><span class="innerContentContainer">协议类型</span></span></li><li><span class="name"><span class="innerContentContainer">支持的EP数量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EP</span></span><ul><li><span class="name"><span class="innerContentContainer">EP是位于usb设备或主机上的一个数据缓冲区。一个端口至少有一对端点。</span></span></li><li><span class="name"><span class="innerContentContainer">EP des包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">EP地址</span></span><ul><li><span class="name"><span class="innerContentContainer">EP地址包括ID和方向。每个EP是编号和方向唯一确定的.</span></span></li><li><span class="name"><span class="innerContentContainer">EP地址的结构是：0-3为EP id，即最多有16对。</span></span></li><li><span class="name"><span class="innerContentContainer">方向</span></span><ul><li><span class="name"><span class="innerContentContainer">IN（device-&gt;host）</span></span></li><li><span class="name"><span class="innerContentContainer">OUT（hos-&gt;device）。</span></span></li><li><span class="name"><span class="innerContentContainer">第7位为方向：out=0，in=1.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">传输类型</span></span><ul><li><span class="name"><span class="innerContentContainer">control: 用于控制，专指EP0</span></span><ul><li><span class="name"><span class="innerContentContainer">host发起的配置命令等，专用EP0通道。</span></span></li><li><span class="name"><span class="innerContentContainer">EP0为短向的，其它都是单向的。</span></span></li><li><span class="name"><span class="innerContentContainer">可分配10%带宽，如不用则分配给bulk传输。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bulk: 块传输. 比如U盘.</span></span><ul><li><span class="name"><span class="innerContentContainer">支持大量数据，但无时间要求。</span></span></li><li><span class="name"><span class="innerContentContainer">块传输没有保留带宽，但可使用当前总线所有空闲带宽，最高可达90%。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">interrupt: 中断传输. 比如键盘鼠标.</span></span><ul><li><span class="name"><span class="innerContentContainer">响应时间受限的少量数据，如事件通知、键盘、鼠标设备等。</span></span></li><li><span class="name"><span class="innerContentContainer">中断传输在初始化时就会申请足够的带宽，如果当前系统满足不了，则初始化失败。</span></span></li><li><span class="name"><span class="innerContentContainer">申请的带宽会一直保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同步传输: 比如USB语音.</span></span><ul><li><span class="name"><span class="innerContentContainer">响应时间受限的大量数据，如语音通话。同步传输可分配90%的带宽。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EP 0为控制通道，不需要EP des。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows系统usb识别的特殊问题</span></span><ul><li><span class="name"><span class="innerContentContainer">windows用vid、pid、interface id来区分一个usb设备</span></span><ul><li><span class="name"><span class="innerContentContainer">如果3者都一样，则被认为是同一个设备。</span></span></li><li><span class="name"><span class="innerContentContainer">windows会保存EP number到注册表中, 而不从驱动配置文件中获取.</span></span></li><li><span class="name"><span class="innerContentContainer">如果某个设备修改了EP，则需要更新这三个中的至少一个，否则会通讯失败。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows识别设多端口备的另一个要求</span></span><ul><li><span class="name"><span class="innerContentContainer">该设备各端口的interface id必须是从0开始，连续排列的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">如何区分usb host还是usb充电器？</span></span><ul><li><span class="name"><span class="innerContentContainer">当前高通方案是，有usb插入，先识别为usb，然后在usb中断中识别是不是充电器。</span></span></li><li><span class="name"><span class="innerContentContainer">方法是给D+、D-上电，usb host会给D+、D-加下拉电阻，外部上电，内部状态不变。</span></span></li><li><span class="name"><span class="innerContentContainer">而充电器是D+、D-短接的，外部上电，内部就上拉。如此就识别到了。</span></span></li><li><span class="name"><span class="innerContentContainer">非官方充电器，如果没做短接，有两个选择，1是分别上拉看情况；2是就认为是usb，反正后续usb协商无响应，对系统没影响。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输的发起者</span></span><ul><li><span class="name"><span class="innerContentContainer">除了中断传输，允许device发起外，其中传输都是host发起。</span></span></li><li><span class="name"><span class="innerContentContainer">正是这个原因，所以网卡、modem等都需要interrupt EP，因为它们需要device发起的传输。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输的物理单位</span></span><ul><li><span class="name"><span class="innerContentContainer">帧，时间概念。</span></span></li><li><span class="name"><span class="innerContentContainer">1毫秒为1帧，usb传输按帧来组织传输。</span></span></li><li><span class="name"><span class="innerContentContainer">对usb2.0，大约是12K大小。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输的逻辑单位</span></span><ul><li><span class="name"><span class="innerContentContainer">传输。一次请求的发起和结束。</span></span></li><li><span class="name"><span class="innerContentContainer">事务。一个传输包括一个或多个事务。</span></span><ul><li><span class="name"><span class="innerContentContainer">事务由3段组成：标记、数据和握手。</span></span></li><li><span class="name"><span class="innerContentContainer">每段由1-2个包组成，分别叫标记包、数据包和握手包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">包</span></span><ul><li><span class="name"><span class="innerContentContainer">只有数据包中有数据，最长不超过64B。</span></span></li><li><span class="name"><span class="innerContentContainer">包由PID、帧编号、地址、CRC和数据组成。</span></span></li><li><span class="name"><span class="innerContentContainer">特色包包括帧同步包，包含SOF记号标示帧起始；</span></span></li><li><span class="name"><span class="innerContentContainer">还有低速向导包。</span></span></li><li><span class="name"><span class="innerContentContainer">不同传输模式下，包结构不同。</span></span></li><li><span class="name"><span class="innerContentContainer">块传输的包大小</span></span><ul><li><span class="name"><span class="innerContentContainer">1.1协议是 64B;</span></span></li><li><span class="name"><span class="innerContentContainer">2.0协议是 512B。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">著名的零包问题</span></span><ul><li><span class="name"><span class="innerContentContainer">usb协议中规定，小于size的包表示transfer结束.</span></span></li><li><span class="name"><span class="innerContentContainer">所以如果数据大小正好整除，那么就需要传输一个零包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB远程唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">suspend的目的是为了节能。</span></span></li><li><span class="name"><span class="innerContentContainer">当device处在挂起状态时，它从总线上吸取的电流在500uA到2.5mA之间。</span></span></li><li><span class="name"><span class="innerContentContainer">当host检测总线没有活动一段时间后（大约3-5秒），就会把总线置为低电模式，并不再发帧开始包。</span></span></li><li><span class="name"><span class="innerContentContainer">当device 3ms没有收到帧开始包后，就应该进入挂起状态，10ms后必须进入此状态。</span></span></li><li><span class="name"><span class="innerContentContainer">此外，host端在必要的情况下，可随时通过set_prot_feather请求来挂起device。</span></span></li><li><span class="name"><span class="innerContentContainer">设备处在挂起状态时，两种情况可以使它resume:</span></span><ul><li><span class="name"><span class="innerContentContainer">一是总线上的任何活动都导致resume；</span></span></li><li><span class="name"><span class="innerContentContainer">二是如果device有远程唤醒机制，那么device可在任何情况下请求恢复。</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">双U盘方案</span></span><ul><li><span class="name"><span class="innerContentContainer">驱动: androdi_usb_pdata{} 之 nluns = 2，即可。</span></span></li><li><span class="name"><span class="innerContentContainer">挂载点: system/etc/vold.conf，volume_usb2 之 media_path = /devices/platform/msm_hsusb_host/usb2。</span></span></li><li><span class="name"><span class="innerContentContainer">FWK: vold模块的修改较多.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">USB线的物理结构</span></span><ul><li><span class="name"><span class="innerContentContainer">一条usb线分别有地线、电源线、D+、D- 4条线构成。</span></span></li><li><span class="name"><span class="innerContentContainer">其中D+、D-为差分输入线，使用3.3V电压。</span></span></li><li><span class="name"><span class="innerContentContainer">而电源线可向设备提供5V、最高500mA的电流。</span></span></li><li><span class="name"></span></li></ul></li></ul>
  </body>
</html>