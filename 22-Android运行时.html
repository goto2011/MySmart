<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">22-Android运行时</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟机</span></span><ul><li><span class="name"><span class="innerContentContainer">Java虚拟机</span></span><ul><li><span class="name"><span class="innerContentContainer">java虚拟机是执行字节码文件（.class）的进程。</span></span></li><li><span class="name"><span class="innerContentContainer">java代码执行流程如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">java源程序（.java）被编译器编译成字节码文件（.class）。</span></span></li><li><span class="name"><span class="innerContentContainer">然后字节码文件由java虚拟机，解释成机器码（不同平台的机器码不同）。</span></span></li><li><span class="name"><span class="innerContentContainer">最后利用机器码操作硬件和操作系统</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SUN提供的java虚拟机和Dalvik的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。</span></span></li><li><span class="name"><span class="innerContentContainer">dalvik虚拟机是基于寄存器的。</span></span></li><li><span class="name"><span class="innerContentContainer">ava虚拟机运行的是java字节码。</span></span></li><li><span class="name"><span class="innerContentContainer">Dalvik运行的是自定义的.dex字节码格式。java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">一个应用，一个虚拟机实例，一个linux线程。</span></span></li><li><span class="name"><span class="innerContentContainer">Android虚拟机的演进历史</span></span><ul><li><span class="name"><span class="innerContentContainer">2008, Android 1.0, <b>Dalvik</b>, 机制是app总是一边编译一边运行. </span></span></li><li><span class="name"><span class="innerContentContainer">2010, 2.2, <b>JIT</b>(Just in time). 即时编译. 将编译好的代码存储, 下次直接使用.</span></span></li><li><span class="name"><span class="innerContentContainer">2014-10, 5.0, <b>ART</b>(Android runtime), 将JIT编译器改为AOT(Ahead of time), 在apk安装时生成dex字节码, 运行时不编译.</span></span></li><li><span class="name"><span class="innerContentContainer">2016, 7.0, ART机制改为安装时不编译, 而是在安装后CPU空闲时编译. 在AOT编译器失效时, 改用JIT编译器. </span></span></li><li><span class="name"><span class="innerContentContainer">2019, 10.0, ART机制改为预先放置热点代码的标记, 在安装时先生成热点代码的字节码, 而剩下的代码则在CPU空闲时编译.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Dalvik</span></span><ul><li><span class="name"><span class="innerContentContainer">google开发的一种java虚拟机，是基于寄存器的。</span></span></li><li><span class="name"><span class="innerContentContainer">Dalvik有自己的bytecode, 并非使用 Java bytecode。所以不和sun java兼容。</span></span></li><li><span class="name"><span class="innerContentContainer">Dalvik为提升性能做的优化</span></span><ul><li><span class="name"><span class="innerContentContainer">多个 Class 文件融合进一个 Dex 文件中，以节省内存空间。</span></span></li><li><span class="name"><span class="innerContentContainer">Dex 文件可以在多个进程之间共享。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序运行之前完成字节码的检验操作，因为检验操作十分耗时。</span></span></li><li><span class="name"><span class="innerContentContainer">优化字节码。</span></span></li><li><span class="name"><span class="innerContentContainer">个进程共享的代码不能随意编辑，保证安全性。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ART</span></span><ul><li><span class="name"><span class="innerContentContainer">从 Android 4.4 开始，Art 开始和 Dalvik 共存。</span></span></li><li><span class="name"><span class="innerContentContainer">5.0 开始，Art 正式取代 Dalvik。</span></span></li><li><span class="name"><span class="innerContentContainer">Art 相比 Dalvik 在性能上有着显著的优势。</span></span><ul><li><span class="name"><span class="innerContentContainer">主要原因在于 Dalvik 虚拟机多数情况下还得通过解释器的方式来执行 Dex 数据；</span></span></li><li><span class="name"><span class="innerContentContainer">JIT 虽然能在一定程度上提高效率，但也仅仅是针对一小部分情况，作用有限；</span></span></li><li><span class="name"><span class="innerContentContainer">JIT 在程序运行过程中才会将部分热点代码编译成机器码，这在某种程度上也加重了 CPU 的负担。</span></span></li><li><span class="name"><span class="innerContentContainer">而 Art 则采用了 AOT(Ahead Of Time) 技术，从而大幅提高了性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AOT 提前将 Java 代码翻译成针对目标平台的机器码</span></span><ul><li><span class="name"><span class="innerContentContainer">虽然这也意味着编译时间有所增加。</span></span></li><li><span class="name"><span class="innerContentContainer">但 Android 系统的构建原本就慢，所以这点牺牲还是值得的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Art 虚拟机整体框架</span></span><ul><li><span class="name"><span class="innerContentContainer">无论是 Dalvik 还是 Art，它们提供的功能将全部封装在一个 so 库中，并且对外需要暴露：</span></span><ul><li><span class="name"><span class="innerContentContainer">JNI_GetDefaultVMInitArgs</span></span></li><li><span class="name"><span class="innerContentContainer">JNI_CreateVM</span></span></li><li><span class="name"><span class="innerContentContainer">JNI_GetCreatedJavaVMs 三个接口</span></span></li><li><span class="name"><span class="innerContentContainer">使用者（比如 Zygote）只需要按照统一的接口标准就可以控制和使用所有类型的虚拟机了。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">核心库 --代码中可以包含.</span></span><ul><li><span class="name"><span class="innerContentContainer">Java核心库</span></span></li><li><span class="name"><span class="innerContentContainer">Android核心库</span></span><ul><li><span class="name"><span class="innerContentContainer">android.os</span></span></li><li><span class="name"><span class="innerContentContainer">android.net</span></span></li><li><span class="name"><span class="innerContentContainer">android.media</span></span></li></ul></li></ul></li></ul>
  </body>
</html>