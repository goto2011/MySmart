<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">21-启动流程  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">开机</span></span><ul><li><span class="name"><span class="innerContentContainer">开机</span></span><ul><li><span class="name"><span class="innerContentContainer">长按power键</span></span><ul><li><span class="name"><span class="innerContentContainer">PS_HOLD是一个硬件管脚，功能是使能pmic芯片的。</span></span></li><li><span class="name"><span class="innerContentContainer">触发任何开机事件时，pmic都会自动给CPU上电。</span></span></li><li><span class="name"><span class="innerContentContainer">但如果在300ms内，软件没有将 ps_hold 拉高，则pmic会认为开机异常，而将CPU下电。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关机闹钟</span></span><ul><li><span class="name"><span class="innerContentContainer">设置关机闹钟时, 会给系统时钟源(RTC)设置一个定时器, 当定时器到时时会使能pmic芯片.</span></span></li><li><span class="name"><span class="innerContentContainer">系统开机过程中, 会检索所有的闹钟, 再重新将下一个闹钟设置到RTC上去. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电线插入</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重启</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog超时重启（不踢狗）, 是唯一软件能控制的重启，场景分为：</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog超时重启</span></span></li><li><span class="name"><span class="innerContentContainer">关机菜单</span></span></li><li><span class="name"><span class="innerContentContainer">升级</span></span></li><li><span class="name"><span class="innerContentContainer">恢复出厂设置</span></span></li><li><span class="name"><span class="innerContentContainer">死机</span></span><ul><li><span class="name"><span class="innerContentContainer">system_server重启</span></span></li><li><span class="name"><span class="innerContentContainer">kernel空指针或跑飞</span></span></li><li><span class="name"><span class="innerContentContainer">kernel&nbsp;watchdog超时，kernel异常导致。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ADB reboot命令</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">瞬间掉电重启</span></span></li><li><span class="name"><span class="innerContentContainer">Android重启</span></span><ul><li><span class="name"><span class="innerContentContainer">即SystemServer 重启. </span></span></li><li><span class="name"><span class="innerContentContainer">除init进程/Zygote<b>外, 其它用户态进程都死掉.</b></span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Loader</span></span><ul><li><span class="name"><span class="innerContentContainer">Boot Rom</span></span><ul><li><span class="name"><span class="innerContentContainer">当电源按下时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行.</span></span><ul><li><span class="name"><span class="innerContentContainer">ARM系统在上电或复位时通常都从地址 0x00000000 处开始执行.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Boot Rom负责加载引导程序Bootloader到RAM，然后执行。</span></span></li><li><span class="name"><span class="innerContentContainer">Boot Rom属于片内系统。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BootLoader</span></span><ul><li><span class="name"><span class="innerContentContainer">BootLoader负责加载Android系统。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在 bootable/bootloader/lk。</span></span></li><li><span class="name"><span class="innerContentContainer">代码入口: bootable/bootloader/lk/app/aboot/aboot.c，aboot_init()。</span></span></li><li><span class="name"><span class="innerContentContainer">lk意思是light kernel，为高通开发，因为组织良好，被很多平台采用。</span></span></li><li><span class="name"><span class="innerContentContainer">二进制包</span></span><ul><li><span class="name"><span class="innerContentContainer">nand版本叫 appsboot.mbn</span></span></li><li><span class="name"><span class="innerContentContainer">emmc版本叫 emmc_appsboot.mbn</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BootLoader的功能</span></span><ul><li><span class="name"><span class="innerContentContainer">进fastboot</span></span><ul><li><span class="name"><span class="innerContentContainer">停在aboot等待后台命令。比如，fastboot flash boot boot.image</span></span></li><li><span class="name"><span class="innerContentContainer">该模式中可以用的命令，可通过 fastboot_register()来添加。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 adb reboot bootloader命令，可以让手机重启并直接进入Fastboot 中去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进 recovery和FTM</span></span><ul><li><span class="name"><span class="innerContentContainer">代码在: bootable/recovery/recovery.c</span></span></li><li><span class="name"><span class="innerContentContainer">升级代码一般放在这里。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一般情况下直接&nbsp; &nbsp;&nbsp;启动kernel。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Boot Loader 严重地依赖于硬件而实现, 尤其是芯片. </span></span><ul><li><span class="name"><span class="innerContentContainer">Boot Loader通常分为两个部分:</span></span><ul><li><span class="name"><span class="innerContentContainer">stage1通常完成硬件设备的初始化，通常用汇编实现，以达到短小快速的目的。通常包括如下步骤：</span></span><ul><li><span class="name"><span class="innerContentContainer">最基本的硬件设备的初始化。包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">屏蔽所有的中断。为中断提供服务通常是 OS 设备驱动程序的责任，因此在 Boot Loader 的执行全过程中可以不必响应任何中断。中断屏蔽可以通过写 CPU 的中断屏蔽寄存器或状态寄存器（比如 ARM 的 CPSR 寄存器）来完成。</span></span></li><li><span class="name"><span class="innerContentContainer">设置 CPU 的速度和时钟频率。</span></span></li><li><span class="name"><span class="innerContentContainer">RAM 初始化。包括正确地设置系统的内存控制器的功能寄存器以及各内存库控制寄存器等。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化 LED。典型地，通过 GPIO 来驱动 LED，其目的是表明系统的状态是 OK 还是 Error。如果板子上没有 LED，那么也可以通过初始化 UART 向串口打印 Boot Loader 的 Logo 字符信息来完成这一点。</span></span></li><li><span class="name"><span class="innerContentContainer">关闭 CPU 内部指令／数据 cache。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">为加载 Boot Loader 的 stage2 准备 RAM 空间。</span></span><ul><li><span class="name"><span class="innerContentContainer">由于 stage2 通常是 C 语言执行代码，因此在考虑空间大小时，除了 stage2 可执行映象的大小外，还必须把堆栈空间也考虑进来。</span></span></li><li><span class="name"><span class="innerContentContainer">此外，空间大小最好是 memory page 大小(通常是 4KB)的倍数。</span></span></li><li><span class="name"><span class="innerContentContainer">一般而言，1M 的 RAM 空间已经足够了。</span></span></li><li><span class="name"><span class="innerContentContainer">具体的地址范围可以任意安排，比如 blob 就将它的 stage2 可执行映像安排到从系统 RAM 起始地址 0xc0200000 开始的 1M 空间内执行。</span></span></li><li><span class="name"><span class="innerContentContainer">将 stage2 安排到整个 RAM 空间的最顶 1MB(也即(RamEnd-1MB) - RamEnd), 也是一种值得推荐的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">还必须确保所安排的地址范围的的确确是可读写的 RAM 空间，因此，必须对你所安排的地址范围进行测试。blob 的方法是：以 memory page 为被测试单位，测试每个 memory page 开始的两个字是否是可读写的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拷贝 Boot Loader 的 stage2 到 RAM 空间中。</span></span><ul><li><span class="name"><span class="innerContentContainer">拷贝时要确定两点：</span></span></li><li><span class="name"><span class="innerContentContainer">stage2 的可执行映象在固态存储设备的存放起始地址和终止地址；</span></span></li><li><span class="name"><span class="innerContentContainer">RAM 空间的起始地址。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置好堆栈。</span></span><ul><li><span class="name"><span class="innerContentContainer">堆栈指针的设置是为了执行 C 语言代码作好准备。</span></span></li><li><span class="name"><span class="innerContentContainer">通常我们可以把 sp 的值设置为(stage2_end-4)，也即在 3.1.2 节所安排的那个 1MB 的 RAM 空间的最顶端(堆栈向下生长)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">跳转到 stage2 的 C 入口点。</span></span><ul><li><span class="name"><span class="innerContentContainer">在上述一切都就绪后，就可以跳转到 Boot Loader 的 stage2 去执行了。</span></span></li><li><span class="name"><span class="innerContentContainer">比如，在 ARM 系统中，这可以通过修改 PC 寄存器为合适的地址来实现。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">stage2 则通常用C语言来实现，这样可以实现给复杂的功能，而且代码会具有更好的可读性和可移植性。</span></span><ul><li><span class="name"><span class="innerContentContainer">提供main() 入口.</span></span><ul><li><span class="name"><span class="innerContentContainer">stage2 的代码通常用 C 语言来实现，但是与普通 C 语言应用程序不同的是，在编译和链接 boot loader 这样的程序时，我们不能使用 glibc 库中的任何支持函数。</span></span></li><li><span class="name"><span class="innerContentContainer">这就给我们带来一个问题，那就是从那里跳转进 main() 函数呢？直接把 main() 函数的起始地址作为整个 stage2 执行映像的入口点或许是最直接的想法。但是这样做有两个缺点：1)无法通过main() 函数传递函数参数；2)无法处理 main() 函数返回的情况。</span></span></li><li><span class="name"><span class="innerContentContainer">一种更为巧妙的方法是利用 trampoline(弹簧床)的概念。也即，用汇编语言写一段trampoline 小程序，并将这段 trampoline 小程序来作为 stage2 可执行映象的执行入口点。然后我们可以在 trampoline 汇编小程序中用 CPU 跳转指令跳入 main() 函数中去执行；而当 main() 函数返回时，CPU 执行路径显然再次回到我们的 trampoline 程序。简而言之，这种方法的思想就是：用这段 trampoline 小程序来作为 main() 函数的外部包裹(external wrapper)。</span></span></li><li><span class="name"><span class="innerContentContainer">下面给出一个简单的 trampoline 程序示例(来自blob)：</span></span></li><li><span class="name"><span class="innerContentContainer">.text</span></span></li><li><span class="name"><span class="innerContentContainer">.globl _trampoline</span></span></li><li><span class="name"><span class="innerContentContainer">_trampoline:</span></span><ul><li><span class="name"><span class="innerContentContainer">bl main</span></span></li><li><span class="name"><span class="innerContentContainer">/* if main ever returns we just call it again */</span></span></li><li><span class="name"><span class="innerContentContainer">b _trampoline</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可以看出，当 main() 函数返回后，我们又用一条跳转指令重新执行 trampoline 程序――当然也就重新执行 main() 函数，这也就是 trampoline(弹簧床)一词的意思所在。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">初始化本阶段要使用到的硬件设备。</span></span><ul><li><span class="name"><span class="innerContentContainer">比如, 初始化至少一个串口，以便和终端用户进行 I/O 输出信息；</span></span></li><li><span class="name"><span class="innerContentContainer">以及, 初始化计时器等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">检测系统内存映射(memory map)。</span></span><ul><li><span class="name"><span class="innerContentContainer">所谓内存映射就是指在整个 4GB 物理地址空间中有哪些地址范围被分配用来寻址系统的 RAM 单元。Boot Loader必须知道 CPU 预留的全部 RAM 地址空间中的哪些被真正映射到 RAM 地址单元，哪些是处于 "unused" 状态的。</span></span></li><li><span class="name"><span class="innerContentContainer">怎么做哩？一个标准的做法是：从基地址开始，以 memory page 为被测试单位，测试每个 memory page 开始的两个字是否是可读写的。</span></span></li><li><span class="name"><span class="innerContentContainer">每找到一块连续的内存区，则使用如下结构保存起来：</span></span></li><li><span class="name"><span class="innerContentContainer">typedef struct memory_area_struct {</span></span><ul><li><span class="name"><span class="innerContentContainer">u32 start; /* the base address of the memory region */</span></span></li><li><span class="name"><span class="innerContentContainer">u32 size; /* the byte number of the memory region */</span></span></li><li><span class="name"><span class="innerContentContainer">int used;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} memory_area_t;</span></span></li><li><span class="name"><span class="innerContentContainer">其中：(1)used=1，则说明这段连续的地址范围已被实现，也即真正地被映射到 RAM 单元上。(2)used=0，则说明这段连续的地址范围并未被系统所实现，而是处于未使用状态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将 kernel 映像和根文件系统映像从 flash 上读到 RAM 空间中。</span></span><ul><li><span class="name"><span class="innerContentContainer">对于内核映像，一般将其拷贝到从(MEM_START＋0x8000) 这个基地址开始的大约1MB大小的内存范围内(嵌入式 Linux 的内核一般都不操过 1MB)。为什么要把从 MEM_START 到 MEM_START＋0x8000 这段 32KB 大小的内存空出来呢？这是因为 Linux 内核要在这段内存中放置一些全局数据结构，如：启动参数和内核页表等信息。</span></span></li><li><span class="name"><span class="innerContentContainer">而对于根文件系统映像，则一般将其拷贝到 MEM_START+0x0010,0000 开始的地方。如果用 Ramdisk 作为根文件系统映像，则其解压后的大小一般是1MB。</span></span></li><li><span class="name"><span class="innerContentContainer">由于像 ARM 这样的嵌入式 CPU 通常都是在统一的内存地址空间中寻址 Flash 等固态存储设备的，因此从 Flash 上读取数据与从 RAM 单元中读取数据并没有什么不同。用一个简单的循环就可以完成从 Flash 设备上拷贝映像的工作：</span></span></li><li><span class="name"><span class="innerContentContainer">while(count) {</span></span><ul><li><span class="name"><span class="innerContentContainer">*dest++ = *src++; /* they are all aligned with word boundary */</span></span></li><li><span class="name"><span class="innerContentContainer">count -= 4; /* byte number */</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">为内核设置启动参数。</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux 2.4.x 以后的内核都期望以标记列表(tagged list)的形式来传递启动参数。启动参数标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。每个标记由标识被传递参数的 tag_header 结构以及随后的参数值数据结构来组成。数据结构 tag 和 tag_header 定义在 Linux 内核源码的include/asm/setup.h 头文件中。</span></span></li><li><span class="name"><span class="innerContentContainer">在嵌入式 Linux 系统中，通常需要由 Boot Loader 设置的常见启动参数有：ATAG_CORE、ATAG_MEM、ATAG_CMDLINE、ATAG_RAMDISK、ATAG_INITRD等。</span></span></li><li><span class="name"><span class="innerContentContainer">比如，设置 ATAG_CORE 的代码如下：</span></span></li><li><span class="name"><span class="innerContentContainer">params = (struct tag *)BOOT_PARAMS;</span></span><ul><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.tag = ATAG_CORE;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.size = tag_size(tag_core);</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.core.flags = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.core.pagesize = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.core.rootdev = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">params = tag_next(params);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中，BOOT_PARAMS 表示内核启动参数在内存中的起始基地址，指针 params 是一个 struct tag 类型的指针。宏 tag_next() 将以指向当前标记的指针为参数，计算紧临当前标记的下一个标记的起始地址。注意，内核的根文件系统所在的设备ID就是在这里设置的。</span></span></li><li><span class="name"><span class="innerContentContainer">下面是设置内存映射情况的示例代码：</span></span></li><li><span class="name"><span class="innerContentContainer">for(i = 0; i &lt;&nbsp;&nbsp;NUM_MEM_AREAS; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(memory_map[i].used) {</span></span><ul><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.tag = ATAG_MEM;</span></span><ul><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.size = tag_size(tag_mem32);</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.mem.start = memory_map[i].start;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.mem.size = memory_map[i].size;</span></span></li><li><span class="name"><span class="innerContentContainer">params = tag_next(params);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">可以看出，在 memory_map［］数组中，每一个有效的内存段都对应一个 ATAG_MEM 参数标记。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux 内核在启动时可以以命令行参数的形式来接收信息，利用这一点我们可以向内核提供那些内核不能自己检测的硬件参数信息，或者重载(override)内核自己检测到的信息。比如，我们用这样一个命令行参数字符串"console=ttyS0,115200n8"来通知内核以 ttyS0 作为控制台，且串口采用 "115200bps、无奇偶校验、8位数据位"这样的设置。下面是一段设置调用内核命令行参数字符串的示例代码：</span></span></li><li><span class="name"><span class="innerContentContainer">char *p;</span></span><ul><li><span class="name"><span class="innerContentContainer">/* eat leading white space */</span></span></li><li><span class="name"><span class="innerContentContainer">for(p = commandline; *p == ' '; p++) ;</span></span></li><li><span class="name"><span class="innerContentContainer">/* skip non-existent command lines so the kernel will still use its default command line. */</span></span></li><li><span class="name"><span class="innerContentContainer">if(*p == '\0')</span></span><ul><li><span class="name"><span class="innerContentContainer">return;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.tag = ATAG_CMDLINE;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.size = (sizeof(struct tag_header) + strlen(p) + 1 + 4) &gt;&gt;&nbsp;&nbsp;2;</span></span></li><li><span class="name"><span class="innerContentContainer">strcpy(params-&gt;u.cmdline.cmdline, p);</span></span></li><li><span class="name"><span class="innerContentContainer">params = tag_next(params);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">请注意在上述代码中，设置 tag_header 的大小时，必须包括字符串的终止符'\0'，此外还要将字节数向上圆整4个字节，因为 tag_header 结构中的size 成员表示的是字数。</span></span></li><li><span class="name"><span class="innerContentContainer">下面是设置 ATAG_INITRD 的示例代码，它告诉内核在 RAM 中的什么地方可以找到 initrd 映象(压缩格式)以及它的大小：</span></span><ul><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.tag = ATAG_INITRD2;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.size = tag_size(tag_initrd);</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.initrd.start = RAMDISK_RAM_BASE;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.initrd.size = INITRD_LEN;</span></span></li><li><span class="name"><span class="innerContentContainer">params = tag_next(params);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">下面是设置 ATAG_RAMDISK 的示例代码，它告诉内核解压后的 Ramdisk 有多大（单位是KB）：</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.tag = ATAG_RAMDISK;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.size = tag_size(tag_ramdisk);</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.ramdisk.start = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.ramdisk.size = RAMDISK_SIZE; /* 请注意，单位是KB */</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;u.ramdisk.flags = 1; /* automatically load ramdisk */</span></span></li><li><span class="name"><span class="innerContentContainer">params = tag_next(params);</span></span></li><li><span class="name"><span class="innerContentContainer">最后，设置 ATAG_NONE 标记，结束整个启动参数列表：</span></span></li><li><span class="name"><span class="innerContentContainer">static void setup_end_tag(void)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.tag = ATAG_NONE;</span></span></li><li><span class="name"><span class="innerContentContainer">params-&gt;hdr.size = 0;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用内核。</span></span><ul><li><span class="name"><span class="innerContentContainer">Boot Loader 调用 Linux 内核的方法是直接跳转到内核的第一条指令处，也即直接跳转到 MEM_START＋0x8000 地址处。在跳转时，下列条件要满足：</span></span></li><li><span class="name"><span class="innerContentContainer">1． CPU 寄存器的设置：</span></span></li><li><span class="name"><span class="innerContentContainer">R0＝0；</span></span></li><li><span class="name"><span class="innerContentContainer">R1＝机器类型 ID；关于 Machine Type Number，可以参见 linux/arch/arm/tools/mach-types。</span></span></li><li><span class="name"><span class="innerContentContainer">R2＝启动参数标记列表在 RAM 中起始基地址；</span></span></li><li><span class="name"><span class="innerContentContainer">2． CPU 模式：</span></span></li><li><span class="name"><span class="innerContentContainer">必须禁止中断（IRQs和FIQs）；</span></span></li><li><span class="name"><span class="innerContentContainer">CPU 必须 SVC 模式；</span></span></li><li><span class="name"><span class="innerContentContainer">3． Cache 和 MMU 的设置：</span></span></li><li><span class="name"><span class="innerContentContainer">MMU 必须关闭；</span></span></li><li><span class="name"><span class="innerContentContainer">指令 Cache 可以打开也可以关闭；</span></span></li><li><span class="name"><span class="innerContentContainer">数据 Cache 必须关闭；</span></span></li><li><span class="name"><span class="innerContentContainer">如果用 C 语言，可以像下列示例代码这样来调用内核：</span></span></li><li><span class="name"><span class="innerContentContainer">void (*theKernel)(int zero, int arch, u32 params_addr) = (void (*)(int, int, u32))KERNEL_RAM_BASE;</span></span></li><li><span class="name"><span class="innerContentContainer">theKernel(0, ARCH_NUMBER, (u32) kernel_params_start);</span></span></li><li><span class="name"><span class="innerContentContainer">注意，theKernel()函数调用应该永远不返回的。如果这个调用返回，则说明出错。</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel</span></span><ul><li><span class="name"><span class="innerContentContainer">swapper（pid=0）</span></span><ul><li><span class="name"><span class="innerContentContainer">内核启动时，先启动系统的第一个进程，swapper，完成内核的初始化。</span></span></li><li><span class="name"><span class="innerContentContainer">swapper对应于Windows系统的idle 进程。</span></span></li><li><span class="name"><span class="innerContentContainer">在多处理器系统中，每个CPU都有一个进程swapper进程。</span></span></li><li><span class="name"><span class="innerContentContainer">swapper初始化进程管理、内存管理。</span></span></li><li><span class="name"><span class="innerContentContainer">swapper加载驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">Camera driver</span></span></li><li><span class="name"><span class="innerContentContainer">Display driver</span></span></li><li><span class="name"><span class="innerContentContainer">Binder driver</span></span></li><li><span class="name"><span class="innerContentContainer">等等。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">init.rc</span></span><ul><li><span class="name"><span class="innerContentContainer">自举过程结束后，内核首先在 /system 分区中寻找 init.rc 文件；然后启动init进程.</span></span></li><li><span class="name"><span class="innerContentContainer">init进程是系统的第二个进程（pid=1）, 也是第一个用户态进程。</span></span></li><li><span class="name"><span class="innerContentContainer">init进程负责一行行执行 init.rc 文件;</span></span></li><li><span class="name"><span class="innerContentContainer">init进程是所有用户态进程的父父进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kthreadd (pid=2)</span></span><ul><li><span class="name"><span class="innerContentContainer">内核启动 kthreadd，它是所有内核进程的父进程，负责动态加载内核守护进程。</span></span></li><li><span class="name"><span class="innerContentContainer">所有内核进程都运行于内核态，用户都是root.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kthreadd 启动的内核守护进程（运行于内核态，顺序基本上是启动顺序）</span></span><ul><li><span class="name"><span class="innerContentContainer">ksoftirqd/0：负责监测CPU 0上的软中断</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/0:0：第0个CPU的第0个工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/0:1：第0个CPU的第1个工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/0:0H： 第0个cpu的第0H工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/u4:0：u代表的是unbound,即未与CPU绑定的进程</span></span></li><li><span class="name"><span class="innerContentContainer">migration/0：CPU 0上的用于在不同的CPU间迁移的进程</span></span></li><li><span class="name"><span class="innerContentContainer">rcu_preempt：读写更新，抢占器</span></span></li><li><span class="name"><span class="innerContentContainer">rcu_bh：</span></span></li><li><span class="name"><span class="innerContentContainer">rcu_sched：读写更新，调度</span></span></li><li><span class="name"><span class="innerContentContainer">ksoftirqd/1：负责监测CPU 1上的软中断</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/1:0H：第1个cpu的第0H工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/u4:1：u代表的是unbound,即未与CPU绑定的进程</span></span></li><li><span class="name"><span class="innerContentContainer">migration/1：CPU 1上的用于在不同的CPU间迁移的进程</span></span></li><li><span class="name"><span class="innerContentContainer">khelper： 用于调用内核模块的用户空间实现</span></span></li><li><span class="name"><span class="innerContentContainer">writeback：存储回写</span></span></li><li><span class="name"><span class="innerContentContainer">bioset：block i/o管理</span></span></li><li><span class="name"><span class="innerContentContainer">kblockd：用于卸载和影响ios延迟/吞吐率</span></span></li><li><span class="name"><span class="innerContentContainer">ata_sff：ata是 IDE硬盘接口。</span></span></li><li><span class="name"><span class="innerContentContainer">khubd：</span></span></li><li><span class="name"><span class="innerContentContainer">md：Multiple Devices driver for Linux</span></span></li><li><span class="name"><span class="innerContentContainer">cfg80211：配置802.11协议，即配置wifi的进程</span></span></li><li><span class="name"><span class="innerContentContainer">kswapd0：页交换</span></span></li><li><span class="name"><span class="innerContentContainer">fsnotify_mark：文件系统通知标记进程</span></span></li><li><span class="name"><span class="innerContentContainer">crypto：加密子进程</span></span></li><li><span class="name"><span class="innerContentContainer">scsi_eh_0：cpu 0上的scsi_eh进程(SCSI是一种存储硬件接口标准.),这进程在ubuntu上也存在</span></span></li><li><span class="name"><span class="innerContentContainer">scsi_eh_1：cpu 1上的scsi_eh进程</span></span></li><li><span class="name"><span class="innerContentContainer">uether：</span></span></li><li><span class="name"><span class="innerContentContainer">dm_bufio_cache：dm是指 RAID and LVM drivers 缓冲io</span></span></li><li><span class="name"><span class="innerContentContainer">binder：binder驱动</span></span></li><li><span class="name"><span class="innerContentContainer">deferwq：defer work queue 开启延迟设备检测</span></span></li><li><span class="name"><span class="innerContentContainer">jbd2/vda-8：journal block device2，vda-8是设备名称</span></span></li><li><span class="name"><span class="innerContentContainer">ext4-dio-unwrit：ext4文件系统相关进程</span></span></li><li><span class="name"><span class="innerContentContainer">therm_core：热管理</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog：看门狗</span></span></li><li><span class="name"><span class="innerContentContainer">perf</span></span></li><li><span class="name"><span class="innerContentContainer">netns</span></span></li><li><span class="name"><span class="innerContentContainer">rpm-smd</span></span></li><li><span class="name"><span class="innerContentContainer">mpm</span></span></li><li><span class="name"><span class="innerContentContainer">system</span></span></li><li><span class="name"><span class="innerContentContainer">mdss_dsi_event</span></span></li><li><span class="name"><span class="innerContentContainer">kgsl-events</span></span></li><li><span class="name"><span class="innerContentContainer">spi</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Native</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>init（pid=1）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">init是系统第二个进程，也是第一个用户态进程。</span></span></li><li><span class="name"><span class="innerContentContainer">init的代码：system/core/init/init.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">init.rc文件：system/core/rootdir/init.rc</span></span></li><li><span class="name"><span class="innerContentContainer">启动Zygote</span></span><ul><li><span class="name"><span class="innerContentContainer">在init执行过程中，在on boot阶段，会 trigger zygote-start，on zygote-start，根据当前的加密状态选择启动Zygote。</span></span></li><li><span class="name"><span class="innerContentContainer">Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。</span></span></li><li><span class="name"><span class="innerContentContainer">其中，zygote服务的启动脚本在 init.zygoteXX.rc中定义，比如 init.zygote64.rc。该文件位于 system/core/rootdir/。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动 MediaServer</span></span></li><li><span class="name"><span class="innerContentContainer">启动 <b>ServiceManager</b> (ContextManager)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>init fork的守护进程（运行于用户态，顺序基本上是启动顺序）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">sbin/<b>ueventd： 事件后台进程。最早启动。</b></span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/logd： log的守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>vold</b>： volume守护进程</span></span><ul><li><span class="name"><span class="innerContentContainer">system/bin/sdcard： 由vold进程创建，管理sdcard分区。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sbin/healthd：  电池的守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>lmkd</b>： LowmeMoryKiller守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/S<b>erviceManager： </b>binder服务的订阅查询服务进程。后面会详细描述。</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>surfaceflinger： </b>UI帧相关的进程</span></span></li><li><span class="name"><span class="innerContentContainer">kauditd：内核审核守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">sbin/<b>adbd</b>： adbd进程(Socket IPC)</span></span><ul><li><span class="name"><span class="innerContentContainer">system/bin/sh： ADB启动的 shell终端, 命令行控制台</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">system/bin/netd： 网络相关进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/debuggerd： 32位调试器</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/debuggerd64： 64位调试器</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>rild（</b>ril-daemon<b>）： </b>Radio Interface Layer（协议栈）的守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/drmserver： 数字版权管理进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/mediaserver： 媒体管理</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/installd： 负责安装应用程序的进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/keystore： 证书管理</span></span></li><li><span class="name"><span class="innerContentContainer"><b>zygote64</b>： 这是第一个客户进程，server_server进程和zygote64进程通信以创建其它的app进程。 后面会详述。</span></span></li><li><span class="name"><span class="innerContentContainer">zygote： 32位zygote</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>gatekeeperd</b>： 锁屏处理守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/xbin/perfprofd： perf profile collection daemon 性能搜集进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/fingerprintd: 指纹进程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Zygote</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Zygote是系统的第二个用户态进程，也是所有java进程的父进程。</span></span></li><li><span class="name"><span class="innerContentContainer">刚开始的名字为“app_process”，运行过程中，通过系统调用将自己名字改为Zygote。</span></span></li><li><span class="name"><span class="innerContentContainer">分Zygote和Zygote64。64位系统会同时启动这两个。</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote常驻后台，每当新的apk启动时，Zygote会派生一个linux进程来跑java虚拟机，然后apk会跑在该虚拟机上。</span></span></li><li><span class="name"><span class="innerContentContainer">进程文件：system/bin/app_process</span></span></li><li><span class="name"><span class="innerContentContainer">代码：frameworks/base/cmds/app_process/app_main.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote完成的初始化动作：</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化AppRuntime。AppRuntime继承于AndroidRuntime。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化Skia图形库。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化Dalvik虚拟机。</span></span></li><li><span class="name"><span class="innerContentContainer">注册jni函数。</span></span></li><li><span class="name"><span class="innerContentContainer">根据参数调用 ZygoteInit 的main方法，启动Zygote自身。关键。</span></span></li><li><span class="name"><span class="innerContentContainer">创建本地socket。</span></span></li><li><span class="name"><span class="innerContentContainer">预加载资源。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Zygote启动SystemServer （fwk的主体，详述见后）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Zygote的forkSystemServer方法主要是调用了native方法nativeForkSystemServer；</span></span></li><li><span class="name"><span class="innerContentContainer">在native层进行fork动作，并设置pid、gid、selinux安全上下文等，最后启动 com.android.server.SystemServer。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Zygote启动的 GC守护进程（用户态）</span></span><ul><li><span class="name"><span class="innerContentContainer">ReferenceQueueD：引用队列的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">FinalizerDaemon：析构的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">FinalizerWatchd：析构监控的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">HeapTrimmerDaem：堆整理的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">GCDaemon：执行GC的守护线程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Zygote启动的系统应用 (详述见后)</span></span></li><li><span class="name"><span class="innerContentContainer">MediaServer</span></span><ul><li><span class="name"><span class="innerContentContainer">管理本地系统service (C/C++)。包括:</span></span></li><li><span class="name"><span class="innerContentContainer">AudioFlinger</span></span></li><li><span class="name"><span class="innerContentContainer">MediaPlayerService</span></span></li><li><span class="name"><span class="innerContentContainer">Camera</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>ServiceManager</b> (ContextManager)</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/cmds/servicemanager/service_manager.c</span></span></li><li><span class="name"><span class="innerContentContainer">Binder架构的管理者，所有系统service都需要先向 servicemanager注册。</span></span></li><li><span class="name"><span class="innerContentContainer">framework和app在调用系统服务时，需要向servicemanager申请，然后通过 Binder调用该服务。</span></span></li><li><span class="name"><span class="innerContentContainer">文件：system/bin/servicemanager</span></span></li><li><span class="name"><span class="innerContentContainer">对外提供的接口有：</span></span><ul><li><span class="name"><span class="innerContentContainer">addService()</span></span></li><li><span class="name"><span class="innerContentContainer">getService()</span></span></li><li><span class="name"><span class="innerContentContainer">listServices()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">开机动画</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Framework</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>SystemServer</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>SystemServer</b>是zygote的首席大弟子，托起整个Java framework的所有service。</span></span></li><li><span class="name"><span class="innerContentContainer">启动后完成如下事务：</span></span><ul><li><span class="name"><span class="innerContentContainer">调整时间，如果系统时间比1970还要早，调整到1970年</span></span></li><li><span class="name"><span class="innerContentContainer">设置系统语言</span></span></li><li><span class="name"><span class="innerContentContainer">调整虚拟机堆内存大小和内存利用率</span></span></li><li><span class="name"><span class="innerContentContainer">初始化Looper为mainLooper</span></span></li><li><span class="name"><span class="innerContentContainer">装载库 libandroid_server.so</span></span></li><li><span class="name"><span class="innerContentContainer">初始化系统Context</span></span></li><li><span class="name"><span class="innerContentContainer">创建 SystemServiceManager负责系统Service启动</span></span></li><li><span class="name"><span class="innerContentContainer">创建和启动Java服务</span></span></li><li><span class="name"><span class="innerContentContainer">调用Looper.loop()，进入处理消息的循环</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SystemServer 启动的服务进程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService：AMS线程</span></span></li><li><span class="name"><span class="innerContentContainer">WindowManagerService：WMS线程</span></span></li><li><span class="name"><span class="innerContentContainer">PowerManagerSer：PMS线程</span></span></li><li><span class="name"><span class="innerContentContainer">PackageManager：PM线程</span></span></li><li><span class="name"><span class="innerContentContainer">Binder_：Binder IPC线程， 包含16个</span></span></li><li><span class="name"><span class="innerContentContainer">Thread_：普通线程，包含若干个</span></span></li><li><span class="name"><span class="innerContentContainer">Heap thread pool：异步的HeapWorker, 包含5个</span></span></li><li><span class="name"><span class="innerContentContainer">Signal Catcher：捕捉Kernel信号，比如SIGNAL_QUIT</span></span></li><li><span class="name"><span class="innerContentContainer">JDWP：虚拟机调试的线程</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask #: 异步任务，包含若干个</span></span></li><li><span class="name"><span class="innerContentContainer">RenderThread：渲染线程，可以包含若干个</span></span></li><li><span class="name"><span class="innerContentContainer">PerformanaceCont：性能统计</span></span></li><li><span class="name"><span class="innerContentContainer">FileObserver：system_server专有</span></span></li><li><span class="name"><span class="innerContentContainer">CpuTracker：CPU信息统计</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog：看门狗线程</span></span></li><li><span class="name"><span class="innerContentContainer">WifiMonitor：system_server专有</span></span></li><li><span class="name"><span class="innerContentContainer">UEventObserver：system_server专有其它的进程</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">APP</span></span><ul><li><span class="name"><span class="innerContentContainer">开机过程中, Zygote 会启动如下核心应用：</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.systemui： 系统状态栏进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.inputmethod.latin： 输入法进程</span></span></li><li><span class="name"><span class="innerContentContainer">android.process.media： 媒体进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.phone： telephony通话服务进程</span></span></li><li><span class="name"><span class="innerContentContainer">android.process.acore： 通讯录数据库进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.deskclock： 闹钟进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.quicksearchbox： 快速搜索框进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings： 设置进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.calendar： 日历进程，packages/apps/Calendar</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.providers.calendar： 日历提供器进程packages/providers/CalendarProvider</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.launcher3： 启动器进程，即桌面</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.email： 邮件服务进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.messaging： 短消息进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.smspush：短信发送</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.wifi：Wifi应用进程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开机后系统的大概状态</span></span><ul><li><span class="name"><span class="innerContentContainer">swapper： 2个子进程，分别为init， kthreadd</span></span></li><li><span class="name"><span class="innerContentContainer">init：55个子进程，用户进程</span></span></li><li><span class="name"><span class="innerContentContainer">kthreadd：303个子进程，内核进程</span></span></li><li><span class="name"><span class="innerContentContainer">zygote64：41个子进程，64位zygote</span></span></li><li><span class="name"><span class="innerContentContainer">zygote：3个子进程，32位zygote</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关机流程</span></span><ul><li><span class="name"><span class="innerContentContainer">关机流程从kernel log可看出，power down。</span></span></li><li><span class="name"><span class="innerContentContainer">SYSCALL_DEFINE4，这是kernel总的reboot和shut down的接口。</span></span></li><li><span class="name"><span class="innerContentContainer">kernel_power_off()，关机流程基本都在这个函数里面。</span></span></li><li><span class="name"><span class="innerContentContainer">kernel_shutdown_prepare()，关闭device。log：device_shutdown, dev name=platform。</span></span></li><li><span class="name"><span class="innerContentContainer">machine_power_off() -&gt; msm_pm_power_off()，进行下电操作。其中调用了 msm_rpcrollter_close()，关闭rpc。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>系统启动优化经验 <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">去掉打印频繁的log.</span></span></li><li><span class="name"><span class="innerContentContainer">根据器件情况做裁剪, 方法是修改配置文件, yes 改为 no.</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote预加载资源时, 采用单线程, 改为多线程(最多可节省15秒)</span></span></li><li><span class="name"><span class="innerContentContainer">所有apk在编译时生成odex. </span></span></li></ul></li></ul>
  </body>
</html>