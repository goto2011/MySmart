<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">11-Framework</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>framework服务层</b>, 都运行于 <b>SystemServer进程, 每个服务是一个独立的线程. 其功能通过 binder 对外暴露.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>PMS: 包管理</b></span></span><ul><li><span class="name"><span class="innerContentContainer">APK组成结构</span></span><ul><li><span class="name"><span class="innerContentContainer">APK: Android Package, 即安卓应用安装包. APK文件其实是zip格式，但后缀名被修改为apk，通过UnZip解压后，可以看到Dex文件.</span></span></li><li><span class="name"><span class="innerContentContainer">AAPT工具：(android asset packing tool)，安卓资源打包工具</span></span></li><li><span class="name"><span class="innerContentContainer">APK文件其实是zip格式, 解压缩后是如下目录: </span></span><ul><li><span class="name"><span class="innerContentContainer">META-INF\（Jar文件中常可以看到）</span></span></li><li><span class="name"><span class="innerContentContainer">res\（存放资源文件的目录）</span></span></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml（程序全局配置文件）</span></span><ul><li><span class="name"><span class="innerContentContainer">app包名 + 组件声明 + 程序兼容的最低版本 + 所需权限等程序的配置文件. </span></span></li><li><span class="name"><span class="innerContentContainer">一个apk一个.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">classes.dex（<b>dex文件，Dalvik字节码</b>）</span></span></li><li><span class="name"><span class="innerContentContainer">resources.arsc(编译后的二进制资源文件）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>其中最重要的是 dex文件，即Dalvik字节码</b></span></span><ul><li><span class="name"><span class="innerContentContainer">android java代码编译为dex格式（Dalvik execute）文件。</span></span></li><li><span class="name"><span class="innerContentContainer">dex格式是专为Dalvik设计的一种压缩格式。</span></span></li><li><span class="name"><span class="innerContentContainer">Dex: DalvikVM executes的简称，即Android Dalvik执行程序, Dalvik字节码. </span></span></li><li><span class="name"><span class="innerContentContainer">一个dex档通常会有多个.class。</span></span></li><li><span class="name"><span class="innerContentContainer">dx 是一套工具，可以将 Java .class 转换成 .dex 格式. </span></span></li><li><span class="name"><span class="innerContentContainer">对classes.dex文件进行Cache优化后, 文件大小会增加1-4倍，这种文件以ODEX结尾。</span></span><ul><li><span class="name"><span class="innerContentContainer">APK中原来的classes.dex文件会保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Dalvik第一次加载时，会对每个apk进行优化，这个过程叫odex。目的是加快apk启动速度。所以手机第一次开机时间较长。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml解析</span></span></li><li><span class="name"><span class="innerContentContainer">APK安装流程</span></span></li><li><span class="name"><span class="innerContentContainer">APK管理，权限和查询</span></span></li><li><span class="name"><span class="innerContentContainer">APK卸载流程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>关键服务</b></span></span><ul><li><span class="name"><span class="innerContentContainer">PowerManagerService: 功耗管理   --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">https://workflowy.com/#/a5573305b407</a></span></span></li><li><span class="name"><span class="innerContentContainer">BatteryService: 电池管理服务   --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">https://workflowy.com/#/a5573305b407</a></span></span></li><li><span class="name"><span class="innerContentContainer">NotificationManagerService: 通知栏管理服务   --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/2bfbaf316a49">https://workflowy.com/#/2bfbaf316a49</a></span></span></li><li><span class="name"><span class="innerContentContainer">StatusBarManagerService: 状态栏管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">视窗系统  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/56a8ba6ce429">https://workflowy.com/#/56a8ba6ce429</a></span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/e96b8978d6de">https://workflowy.com/#/e96b8978d6de</a></span></span></li><li><span class="name"><span class="innerContentContainer">Location  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/cb01714441aa">https://workflowy.com/#/cb01714441aa</a></span></span></li><li><span class="name"><span class="innerContentContainer">XMPP服务: 开源的即时通讯框架.</span></span></li><li><span class="name"><span class="innerContentContainer">Phone MS: 属于协议领域.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">非关键服务</span></span><ul><li><span class="name"><span class="innerContentContainer">EntropyService: 提供伪随机数</span></span></li><li><span class="name"><span class="innerContentContainer">AccountManagerService: 账户管理服务，android系统账户</span></span></li><li><span class="name"><span class="innerContentContainer">LightsService: 自然光强度感应传感器服务</span></span></li><li><span class="name"><span class="innerContentContainer">VibratorService: 震动器服务</span></span></li><li><span class="name"><span class="innerContentContainer">AlarmManagerService: 定时器管理服务，提供定时提醒服务</span></span></li><li><span class="name"><span class="innerContentContainer">BluetoothService: 蓝牙服务</span></span></li><li><span class="name"><span class="innerContentContainer">DevicePolicyManagerService: 系统级别的设置及属性管理</span></span></li><li><span class="name"><span class="innerContentContainer">ClipboardService: 系统剪切板服务</span></span></li><li><span class="name"><span class="innerContentContainer">InputMethodManagerService: 输入法管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">NetworkManagementService: 网络管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">NetStatService: 网络状态服务</span></span></li><li><span class="name"><span class="innerContentContainer">AccessibilityManagerService: 无障碍访问服务</span></span></li><li><span class="name"><span class="innerContentContainer">MountService: 挂载服务，可通过该服务调用Linux层面的mount程序</span></span></li><li><span class="name"><span class="innerContentContainer">SearchManagerService: 搜索管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">DropBoxManagerService: 通过该服务访问Linux层面的Dropbox程序</span></span></li><li><span class="name"><span class="innerContentContainer">WallpaperManagerService: 墙纸管理服务，墙纸不等同于桌面背景，在View系统内部，墙纸可以作为任何窗口的背景</span></span></li><li><span class="name"><span class="innerContentContainer">AudioService: 音频管理服务</span></span></li><li><span class="name"><span class="innerContentContainer">BackupManagerService: 系统备份服务</span></span></li><li><span class="name"><span class="innerContentContainer">AppWidgetService: Widget服务</span></span></li><li><span class="name"><span class="innerContentContainer">RecognitionManagerService: 身份识别服务</span></span></li><li><span class="name"><span class="innerContentContainer">DiskStatsService: 磁盘统计服务</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多用户</span></span><ul><li><span class="name"><span class="innerContentContainer">几个特殊的用户ID</span></span><ul><li><span class="name"><span class="innerContentContainer">0： 主用户</span></span></li><li><span class="name"><span class="innerContentContainer">-1： 所有用户的代号</span></span></li><li><span class="name"><span class="innerContentContainer">-2： 当前用户的代号</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">华为飞马架构</span></span><ul><li><span class="name"><span class="innerContentContainer">2019年发展到 5.0</span></span></li><li><span class="name"><span class="innerContentContainer">芯片组件</span></span></li><li><span class="name"><span class="innerContentContainer">系统组件</span></span></li><li><span class="name"><span class="innerContentContainer">版本组件</span></span></li><li><span class="name"><span class="innerContentContainer">定制组件</span></span><ul><li><span class="name"><span class="innerContentContainer">代码+配置仓</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">JNI: Java Native Interface. Java本地接口，用来实现Java代码与本地的C/C++代码进行互相调用.</span></span><ul><li><span class="name"><span class="innerContentContainer">JNI 是java语言固有的. 非Android特性.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Native &amp; NDK</span></span><ul><li><span class="name"><span class="innerContentContainer">Native即本地代码. 相对于托管代码而言.</span></span></li><li><span class="name"><span class="innerContentContainer">FWK及APP层的Java代码运行在虚拟机之上, 即托管代码. </span></span></li><li><span class="name"><span class="innerContentContainer">对应的, 所有的c代码, 以及部分不依赖虚拟机的java代码, 就是native代码.</span></span></li><li><span class="name"><span class="innerContentContainer">而NDK, 即native development kit. 也就是Google提供的开发native代码的工具包</span></span><ul><li><span class="name"><span class="innerContentContainer">在系统开发中, NDK 用于开发native层代码.</span></span></li><li><span class="name"><span class="innerContentContainer">在纯应用开发中, NDK用于支撑apk调用自己的c 的so库. 然后NDK能帮助程序员自动将so文件和java代码一起打包成apk。</span></span></li><li><span class="name"><span class="innerContentContainer">常见情况是: 出于跨平台考虑，核心算法用C实现。在android平台，用NDK生成c的so库，用java做上层产品实现。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">HAL: Hardware Abstraction Layer, 硬件抽象层</span></span><ul><li><span class="name"><span class="innerContentContainer">HAL为硬件供应商定义了一系列标准接口来实现, 以实现fwk代码和硬件的解耦.</span></span></li><li><span class="name"><span class="innerContentContainer">HAL 可算是Native的核心部分.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">它们之间的调用关系是:</span></span><ul><li><span class="name"><span class="innerContentContainer">应用层代码(java) 调用 java api;</span></span></li><li><span class="name"><span class="innerContentContainer">java api 调用 jni;</span></span></li><li><span class="name"><span class="innerContentContainer">jni 是一层皮, 调用 c 的 native 的 client 层;</span></span></li><li><span class="name"><span class="innerContentContainer">c 的native 包括 client 和 service, 两者用 binder 方式通讯;</span></span></li><li><span class="name"><span class="innerContentContainer">native service 调用 HAL.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI函数初始化过程</span></span><ul><li><span class="name"><span class="innerContentContainer">Zygote启动过程中会AndroidRuntime.cpp中的 startVm()创建虚拟机，VM创建完成后，紧接着调用 startReg()完成虚拟机中的JNI方法注册。</span></span></li><li><span class="name"><span class="innerContentContainer">register_jni_procs(gRegJNI, NELEM(gRegJNI), env) 的作用就是就是循环调用 gRegJNI数组成员所对应的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp. </span></span><ul><li><span class="name"><span class="innerContentContainer">其每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，在Zygote中介绍过，该宏的作用就是调用相应的方法。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI 就是一层皮, 找到规律后, 从 java 跳到 c 就非常容易理解了.</span></span><ul><li><span class="name"><span class="innerContentContainer">java文件中申明的native方法, 如何找对应的实现在哪个c++文件, 函数名是什么?</span></span><ul><li><span class="name"><span class="innerContentContainer">Android JNI在函数命名上是有规律的.</span></span></li><li><span class="name"><span class="innerContentContainer">比如 MessageQueue.java 中申明了private native void <b>nativePollOnce</b>(longptr,inttimeoutMillis); 怎么找? </span></span></li><li><span class="name"><span class="innerContentContainer">1. MessageQueue.java的全限定名为android.os.MessageQueue.java，方法名：android.os.MessageQueue.nativePollOnce()，而相对应的native层方法名只是将点号替换为下划线，可得android_os_MessageQueue_nativePollOnce()。</span></span><ul><li><span class="name"><span class="innerContentContainer">即: nativePollOnce ==&gt; android_os_MessageQueue_nativePollOnce()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 有了native方法名，那么接下来需要知道该native方法所在的文件名。规律一样, MessageQueue.java ==&gt; android_os_MessageQueue.cpp.</span></span><ul><li><span class="name"><span class="innerContentContainer">但是也有例外, 比如: Binder.java所对应的native文件：android_util_Binder.cpp.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 目录在哪里呢? jni文件一般在这3个目录中:</span></span><ul><li><span class="name"><span class="innerContentContainer">framework/base/core/jni/</span></span></li><li><span class="name"><span class="innerContentContainer">framework/base/services/core/jni/</span></span></li><li><span class="name"><span class="innerContentContainer">framework/base/media/jni/</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">程序自定义的jni函数, 如何找对应的实现呢?</span></span><ul><li><span class="name"><span class="innerContentContainer">以MediaPlayer.java为例，其包名为android.media.</span></span></li><li><span class="name"><span class="innerContentContainer">通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库。 接着通过关键字native加在native_init方法之前，便可以在java层直接使用native层方法。</span></span></li><li><span class="name"><span class="innerContentContainer">接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义LOCAL_MODULE:= libmedia_jni，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。</span></span></li><li><span class="name"><span class="innerContentContainer">搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/<a class="contentLink" target="_blank" rel="noreferrer" href="http://Android.mk">Android.mk</a>。</span></span></li><li><span class="name"><span class="innerContentContainer">文件名和函数名分别是: android_media_MediaPlayer.cpp 和 android_media_MediaPlayer_native_init()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Java代码如何调用C?</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种方式: 静态和动态</span></span></li><li><span class="name"><span class="innerContentContainer">静态注册: 根据函数名建立 Java 方法和 JNI 函数的一一对应关系。流程是：</span></span><ul><li><span class="name"><span class="innerContentContainer">先编写 Java 的 native 方法；</span></span></li><li><span class="name"><span class="innerContentContainer">然后用 javah 工具生成对应的头文件，执行命令 javah packagename.classname可以生成由包名加类名命名的 jni 层头文件，或执行命名 javah -o custom.h packagename.classname，其中 custom.h 为自定义的文件名；</span></span></li><li><span class="name"><span class="innerContentContainer">实现 JNI 里面的函数，再在Java中通过 <b>System.loadLibrary </b>加载 so 库即可.</span></span></li><li><span class="name"><span class="innerContentContainer">一个在java代码中叫 swap() 的native方法, 对应的C代码函数体是:</span></span><ul><li><span class="name"><span class="innerContentContainer">JNIEXPORT jint JNICALL <b>Java_Com_Oppo_Camera_Jni_swap__</b>(JNIEnv *, jclass);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">动态注册: 直接告诉 native 方法其在JNI 中对应函数的指针。通过使用 JNINativeMethod 结构来保存 Java native 方法和 JNI 函数关联关系，流程是：</span></span><ul><li><span class="name"><span class="innerContentContainer">先编写 Java 的 native 方法；</span></span></li><li><span class="name"><span class="innerContentContainer">编写 JNI 函数的实现（函数名可以随便命名）；</span></span></li><li><span class="name"><span class="innerContentContainer">利用结构体 JNINativeMethod 保存Java native方法和 JNI函数的对应关系；</span></span></li><li><span class="name"><span class="innerContentContainer">利用registerNatives(JNIEnv* env)注册类的所有本地方法；</span></span></li><li><span class="name"><span class="innerContentContainer">在 JNI_OnLoad 方法中调用注册方法；</span></span></li><li><span class="name"><span class="innerContentContainer">在Java中通过 System.loadLibrary 加载完JNI动态库之后，会调用 JNI_OnLoad 函数，完成动态注册.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码如何调用 Java?</span></span><ul><li><span class="name"><span class="innerContentContainer">当 Native 层需要调用 Java 的某个方法时，需要通过 JNI函数 GetMethodID()获取它的 ID，根据 ID 调用 JNI 函数获取该方法；变量的获取也是类似。</span></span></li><li><span class="name"><span class="innerContentContainer">jmethodID   (*<b>GetMethodID</b>)(JNIEnv*, jclass, const char*, const char*);    //C</span></span></li><li><span class="name"><span class="innerContentContainer">jmethodID <b>GetMethodID</b>(jclass clazz, const char* name, const char* sig)  //C++</span></span><ul><li><span class="name"><span class="innerContentContainer">{ return functions-&gt;GetMethodID(this, clazz, name, sig); </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">在实际编程中，如果使用 javah 工具来生成对应的 native 代码，就不需要手动编写对应的类型转换了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码方法的定义和 JNIEnv</span></span><ul><li><span class="name"><span class="innerContentContainer">JNIEnv 是指线程上下文环境，每个线程有且只有一个JNIEnv实例.</span></span></li><li><span class="name"><span class="innerContentContainer">所有本地函数都会接收 JNIEnv 作为第一个参数.</span></span></li><li><span class="name"><span class="innerContentContainer">JNIEnv 是一个指针，指向一组 JNI 函数，通过这些函数可以实现 Java 层和 JNI 层的交互，就是说通过 JNIEnv 调用 JNI 函数可以访问 Java 虚拟机，操作 Java 对象.</span></span></li><li><span class="name"><span class="innerContentContainer">用作线程局部存储，不能在线程间共享一个 JNIEnv 变量，也就是说&nbsp;JNIEnv 只在创建它的线程有效，不能跨线程传递；相同的 Java 线程调用本地方法，所使用的 JNIEnv 是相同的，一个 native 方法不能被不同的 Java 线程调用.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI数据类型映射表</span></span><ul><li><span class="name"><span class="innerContentContainer">定义参数和返回值时要用到数据类型, JNI一般使用:</span></span><ul><li><span class="name"><span class="innerContentContainer">String getString()  -&gt;  Ljava/lang/String;</span></span></li><li><span class="name"><span class="innerContentContainer">int sum(int a, int b)  -&gt;  (II)I</span></span></li><li><span class="name"><span class="innerContentContainer">void main(String[] args) -&gt; ([Ljava/lang/String;)V</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本数据类型: </span></span><ul><li><span class="name"><span class="innerContentContainer">字符 Java类型    C类型</span></span></li><li><span class="name"><span class="innerContentContainer">V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void</span></span></li><li><span class="name"><span class="innerContentContainer">Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jboolean&nbsp;&nbsp;&nbsp;&nbsp; boolean</span></span></li><li><span class="name"><span class="innerContentContainer">I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</span></span></li><li><span class="name"><span class="innerContentContainer">J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jlong&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long</span></span></li><li><span class="name"><span class="innerContentContainer">D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jdouble&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double</span></span></li><li><span class="name"><span class="innerContentContainer">F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jfloat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float</span></span></li><li><span class="name"><span class="innerContentContainer">B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jbyte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte</span></span></li><li><span class="name"><span class="innerContentContainer">C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jchar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char</span></span></li><li><span class="name"><span class="innerContentContainer">S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jshort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数组则以"["开始，用两个字符表示: </span></span><ul><li><span class="name"><span class="innerContentContainer">[I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jintArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[]</span></span></li><li><span class="name"><span class="innerContentContainer">[F&nbsp;&nbsp;&nbsp;&nbsp; jfloatArray&nbsp;&nbsp;&nbsp; float[]</span></span></li><li><span class="name"><span class="innerContentContainer">[B&nbsp;&nbsp;&nbsp;&nbsp; jbyteArray&nbsp;&nbsp;&nbsp; byte[]</span></span></li><li><span class="name"><span class="innerContentContainer">[C&nbsp;&nbsp;&nbsp; jcharArray&nbsp;&nbsp;&nbsp; char[]</span></span></li><li><span class="name"><span class="innerContentContainer">[S&nbsp;&nbsp;&nbsp; jshortArray&nbsp;&nbsp; short[]</span></span></li><li><span class="name"><span class="innerContentContainer">[D&nbsp;&nbsp;&nbsp; jdoubleArray double[]</span></span></li><li><span class="name"><span class="innerContentContainer">[J&nbsp;&nbsp;&nbsp;&nbsp; jlongArray&nbsp;&nbsp;&nbsp;&nbsp; long[]</span></span></li><li><span class="name"><span class="innerContentContainer">[Z&nbsp;&nbsp;&nbsp;  jbooleanArray boolean[]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">引用类型描述符:</span></span><ul><li><span class="name"><span class="innerContentContainer">引用类型不能直接在 Native 层使用. 需要用如下格式: </span></span></li><li><span class="name"><span class="innerContentContainer">L + 包名/类描述符 + ; ,  注意分号不要丢了.</span></span></li><li><span class="name"><span class="innerContentContainer">比如 CameraBuffer-&gt; Lcom/android/camera/CameraBuffer;   // 真是麻烦.</span></span></li><li><span class="name"><span class="innerContentContainer">一个例外是String类，其对应的类为jstring.</span></span></li><li><span class="name"><span class="innerContentContainer">同时其对应的C函数名的参数则为 <b>jobject</b>.</span></span></li><li><span class="name"><span class="innerContentContainer">如果JAVA函数位于一个嵌入类，则用$作为类名间的分隔符。如: "(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z"</span></span></li><li><span class="name"><span class="innerContentContainer">多维数组（含二维数组）都是引用类型，需要使用 jobjectArray 类型存取其值；</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>HAL层</b></span></span><ul><li><span class="name"><span class="innerContentContainer">HAL层是用户态进程访问硬件的标准接口，被编译成so文件，然后被framework代码动态加载。</span></span></li><li><span class="name"><span class="innerContentContainer">HAL层主要是为规避GPL而设计的</span></span><ul><li><span class="name"><span class="innerContentContainer">它将将硬件驱动分成内核空间和用户空间两部分，</span></span></li><li><span class="name"><span class="innerContentContainer">其中用户空间部分采用的是商业友好的Apache License。</span></span></li><li><span class="name"><span class="innerContentContainer">内核驱动层只提供简单的访问硬件逻辑，例如读写硬件寄存器的通道。</span></span></li><li><span class="name"><span class="innerContentContainer">至于从硬件中读到了什么值或者写了什么值到硬件中的逻辑，都放在HAL中去。</span></span></li><li><span class="name"><span class="innerContentContainer">这样就可以把商业秘密隐藏起来了。</span></span></li><li><span class="name"><span class="innerContentContainer">也正是由于这个原因，Android被踢出了Linux内核主线代码树中。Android放在内核空间的驱动程序对硬件的支持是不完整的，把Linux内核移植到别的机器上去时，由于缺乏硬件抽象层的支持，硬件就完全不能用了，这也是为什么说Android是开放系统而不是开源系统的原因。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同时是为了满足抽象的要求</span></span><ul><li><span class="name"><span class="innerContentContainer">比如framework需要用overlay，通过给 hw_get_module()传入字符串“overlay_module”，就可以取得该设备的标准模块的描述.</span></span></li><li><span class="name"><span class="innerContentContainer">有人实现了overlay，不管是软件加速，还是硬件加速，是基于v4l2，还是基于mmap接口，只要实现成 overlay_module 的样子就成，这样就“抽象”了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>HAL抽象接口</b></span></span><ul><li><span class="name"><span class="innerContentContainer">所有硬件hal层都具有 hardware/libhardware/include/hardware/hardware.h 中定义的属性。</span></span></li><li><span class="name"><span class="innerContentContainer">该抽象接口让系统可以以一致的方式来加载和管理各 hal模块的版本。</span></span></li><li><span class="name"><span class="innerContentContainer">hal抽象接口包括两个结构： 模块和设备</span></span></li><li><span class="name"><span class="innerContentContainer">模块</span></span><ul><li><span class="name"><span class="innerContentContainer">模块代表打包的 HAL 实现，这种实现存储为共享库 (.so file)。</span></span></li><li><span class="name"><span class="innerContentContainer">其结构是hw_module_t, 其中包含模块的版本、名称和作者等元数据。</span></span></li><li><span class="name"><span class="innerContentContainer">Android 会根据这些元数据来找到并正确加载 HAL 模块。</span></span></li><li><span class="name"><span class="innerContentContainer">hw_module_t&nbsp;结构体还包含指向另一个结构体&nbsp;hw_module_methods_t&nbsp;的指针，后面这个结构体包含指向相应模块的 open 函数的指针。</span></span></li><li><span class="name"><span class="innerContentContainer">此 open 函数用于与相关硬件（此 HAL 是其抽象形式）建立通信。</span></span></li><li><span class="name"><span class="innerContentContainer">每个硬件专用 HAL 通常都会使用该特定硬件的附加信息来扩展通用的&nbsp;hw_module_t&nbsp;结构体。比如相机 HAL 中，camera_module_t 就包括如下扩展接口:</span></span><ul><li><span class="name"><span class="innerContentContainer">typedef struct camera_module {</span></span><ul><li><span class="name"><span class="innerContentContainer">hw_module_t common;</span></span></li><li><span class="name"><span class="innerContentContainer">int (*get_number_of_cameras)(void);</span></span></li><li><span class="name"><span class="innerContentContainer">int (*get_camera_info)(int camera_id, struct camera_info *info);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} camera_module_t;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实现 HAL 并创建模块结构体时，您必须将其命名为&nbsp;HAL_MODULE_INFO_SYM。以下是 Nexus 9 音频 HAL 的示例：</span></span><ul><li><span class="name"><span class="innerContentContainer">struct audio_module HAL_MODULE_INFO_SYM = {</span></span><ul><li><span class="name"><span class="innerContentContainer">.common = {</span></span><ul><li><span class="name"><span class="innerContentContainer">.tag = HARDWARE_MODULE_TAG,</span></span></li><li><span class="name"><span class="innerContentContainer">.module_api_version = AUDIO_MODULE_API_VERSION_0_1,</span></span></li><li><span class="name"><span class="innerContentContainer">.hal_api_version = HARDWARE_HAL_API_VERSION,</span></span></li><li><span class="name"><span class="innerContentContainer">.id = AUDIO_HARDWARE_MODULE_ID,</span></span></li><li><span class="name"><span class="innerContentContainer">.name = "NVIDIA Tegra Audio HAL",</span></span></li><li><span class="name"><span class="innerContentContainer">.author = "The Android Open Source Project",</span></span></li><li><span class="name"><span class="innerContentContainer">.methods = &amp;hal_module_methods,</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">},</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">设备</span></span><ul><li><span class="name"><span class="innerContentContainer">设备是产品硬件的抽象表示。</span></span></li><li><span class="name"><span class="innerContentContainer">设备由&nbsp;hw_device_t&nbsp;结构体表示。与模块类似，每类设备都定义了一个通用&nbsp;hw_device_t&nbsp;的详细版本，其中包含指向特定硬件功能的函数指针。例如，audio_hw_device_t&nbsp;结构体类型会包含指向音频设备操作的函数指针：</span></span></li><li><span class="name"><span class="innerContentContainer">struct audio_hw_device {</span></span><ul><li><span class="name"><span class="innerContentContainer">struct hw_device_t common;</span></span><ul><li><span class="name"><span class="innerContentContainer">uint32_t (*get_supported_devices)(const struct audio_hw_device *dev);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">typedef struct audio_hw_device audio_hw_device_t;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">不是所有的设备驱动都用HAL</span></span><ul><li><span class="name"><span class="innerContentContainer">电池就不用，因为power是linux内核标准服务，JNI就直接访问内核服务了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">如何阅读native层代码?</span></span><ul><li><span class="name"><span class="innerContentContainer">java native方法申明: 在java代码中, 方法前面有 native 关键字的就是native方法.</span></span></li><li><span class="name"><span class="innerContentContainer">native方法的命名有规律, 一般是:</span></span><ul><li><span class="name"><span class="innerContentContainer">java库: Java_Lang_类名_方法名</span></span></li><li><span class="name"><span class="innerContentContainer">Android frameworkd : android_Hardware_Camera_CameraOpen()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native方法只是一个句柄, 真正的函数体是C代码的. 对应的代码在:</span></span><ul><li><span class="name"><span class="innerContentContainer">java库:  delvik/wm/native/</span></span></li><li><span class="name"><span class="innerContentContainer">Android framework : framework/base/core/jni/</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">编译so &amp; 加载so &amp; 调用so</span></span><ul><li><span class="name"><span class="innerContentContainer">编译so</span></span><ul><li><span class="name"><span class="innerContentContainer">Android系统支持7种CPU建构, 每一种对应一种ABI(应用程序二进制接口)</span></span><ul><li><span class="name"><span class="innerContentContainer">armV5 -- armeabi</span></span></li><li><span class="name"><span class="innerContentContainer">armV7(2010) -- armeabi-v7a</span></span></li><li><span class="name"><span class="innerContentContainer">x86(2011) -- x86</span></span></li><li><span class="name"><span class="innerContentContainer">mips(2012) -- mips</span></span></li><li><span class="name"><span class="innerContentContainer">armV8(2012) -- arm64-v8a</span></span></li><li><span class="name"><span class="innerContentContainer">mips64(2014) -- mips64</span></span></li><li><span class="name"><span class="innerContentContainer">x86-64(2014) -- x86-64</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果在项目中使用了NDK, 就会生成so文件.</span></span></li><li><span class="name"><span class="innerContentContainer">native libs monitor, 运行在手机上, 可列出各apk使用了哪些so文件, 以及so文件来源于哪些函数库或框架. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">加载so文件</span></span><ul><li><span class="name"><span class="innerContentContainer">hw_get_module()通过libdl动态加载库文件, 文件路径在 /system/lib/hw/[id].[arch].so</span></span></li><li><span class="name"><span class="innerContentContainer">其中id即设备id，是字符串. 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">overlay_module: 图层叠加</span></span></li><li><span class="name"><span class="innerContentContainer">gralloc_*: 图形buffer</span></span></li><li><span class="name"><span class="innerContentContainer">display_*: 显示控制</span></span></li><li><span class="name"><span class="innerContentContainer">nfc</span></span></li><li><span class="name"><span class="innerContentContainer">camera</span></span></li><li><span class="name"><span class="innerContentContainer">sensors_hardware_*: 传感器</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">arch 即芯片平台id。</span></span></li><li><span class="name"><span class="innerContentContainer">so文件名类似：camera.msm7630.surf.so 和 nfc.huawei.so。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用so接口</span></span><ul><li><span class="name"><span class="innerContentContainer">每个so库都要实现标准接口，这个标准即 HAL_MODULE_INFO_SYM，其中定义了一些属性，但要求必须实现的接口只有一个：open()。</span></span></li><li><span class="name"><span class="innerContentContainer">so文件找到后，调用 dlopen()打开，后者返回值为模块操作句柄。</span></span></li><li><span class="name"><span class="innerContentContainer">再调用dlsym(),  入参即模块操作句柄及符号名，返回符号对应的地址。不仅可以返回函数指针，也可以获得全局变量的地址.</span></span></li><li><span class="name"><span class="innerContentContainer">其它接口包括:</span></span></li><li><span class="name"><span class="innerContentContainer">dlclose():关闭库文件。 </span></span></li><li><span class="name"><span class="innerContentContainer">dlerror()当操作函数执行失败时，可通过此接口返回出错信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">NDK开发常见问题  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">忘记delete local reference。带New到方法(如：NewByteArray)这样到方法比较好辨认，需要手动调用DeleteLocalRef()来释放(返回值除外)。比较特殊的一个方法是：GetByteArrayELement必须要调用ReleaseByteArrayElements进行释放。当然如果你只是取bytearray中到byte，那么完全可以用GetByteArrayRegion实现。</span></span></li><li><span class="name"><span class="innerContentContainer">没有NewGlobalRef。 在不同线程调用java方法，需要保存jobject对象，这时需要对jobject对象做全局引用，否则会失效。</span></span></li><li><span class="name"><span class="innerContentContainer">jbytearray的length。在JNI layer获取到jbytearray到长度是不对到，应该由java获取byte[]的length再传给C layer。否则C layer有可能获得到是乱码。</span></span></li><li><span class="name"><span class="innerContentContainer">线程问题。 不同线程使用JNIEnv*对象，需要AttachCurrentThread将env挂到当前线程，否则无法使用env。</span></span></li><li><span class="name"><span class="innerContentContainer">&nbsp;javap 命令是对java的class文件操作；而javah命令需要在包名到上一层路径运行才行，否则无法生成.h文件。</span></span></li><li><span class="name"><span class="innerContentContainer">尽量避免频繁调用JNI或者是使用JNI传输大量到数据。</span></span></li><li><span class="name"><span class="innerContentContainer">Reference Table overflow (max=1024) 或者是&nbsp;Reference Table overflow (max=512)一定是因为忘记释放global reference或者local reference，请仔细检查代码。</span></span></li><li><span class="name"><span class="innerContentContainer">不要在windows下使用cygwin编译NDK code，那样会遇到arguments too long问题，因为windows路径长度有限制导致。虽然可以使用subst将路径映射为短路径，但是在编译时间和调试上，windows到孩子都是伤不起。同样到build，在windows下要15分钟左右，而在mac下只要5分多，相差3倍。调试JNI 代码到速度更是不用提了，差太多。</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer"><b>Treble架构</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android 8.0 推出. Android 9.0 强制使用.</span></span></li><li><span class="name"><span class="innerContentContainer">旨在实现HAL和框架层的解耦, 做到不重新编译而升级框架的目的。</span></span></li><li><span class="name"><span class="innerContentContainer">供应商接口主要在vendor目录中定义.</span></span></li><li><span class="name"><span class="innerContentContainer">原理</span></span><ul><li><span class="name"><span class="innerContentContainer">老架构下，HAL是一个个的.so库，通过dlopen来加载，hal和framework或应用进程在同一个进程中跑。</span></span></li><li><span class="name"><span class="innerContentContainer">这种架构显然鲁棒性差。hal的异常会直接导致框架或应用进程异常。</span></span></li><li><span class="name"><span class="innerContentContainer">新架构下，framework和hal运行于不同的进程，所有的HAL调用使用HIDL技术跨进程完成。</span></span></li><li><span class="name"><span class="innerContentContainer">跨进程通信通过HIDL接口和 dev/hwbinder 的IPC域来完成。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">HIDL有两种实现模式：Passthrough和Binderized</span></span><ul><li><span class="name"><span class="innerContentContainer">Passthrough模式，也叫same-process HAL, SP-HAL。可以方便的使用存量代码，不需要重新编写相关的HAL。</span></span></li><li><span class="name"><span class="innerContentContainer">Binderized是纯Treble架构, Google 推荐, 适合新代码.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">hal模块使用办法</span></span><ul><li><span class="name"><span class="innerContentContainer">以 hardware/interfaces/power/1.0 作为例子。当编译 hardware/interfaces/power/1.0 的时候，会生成：</span></span><ul><li><span class="name"><span class="innerContentContainer">中间文件PowerAll.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">/vendor/bin/hw/android.hardware.power@1.0-service 的二进制文件，即库。</span></span></li><li><span class="name"><span class="innerContentContainer">/vendor/lib/hw/<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:android.hardware.power@1.0-impl.so">android.hardware.power@1.0-impl.so</a>的库文件</span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="mailto:android.hardware.power@1.0-service.rc">android.hardware.power@1.0-service.rc</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">rc文件会被拷贝到vendor.img 里面的vendor/etc/init 目录。rc文件的内容如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">service power-hal-1-0 /vendor/bin/hw/android.hardware.power@1.0-service</span></span><ul><li><span class="name"><span class="innerContentContainer">class hal</span></span></li><li><span class="name"><span class="innerContentContainer">user system</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统启动时, 会启动hal服务，执行/vendor/bin/hw/android.hardware.power@1.0-service，从而调用hardware/interfaces/power/1.0/default/service.cpp的main方法。代码如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">int main() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return defaultPassthroughServiceImplementation&lt;IPower&gt;();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接下来会调用 PowerAll.cpp 的 IPower::getService(), 获取service对象. 这是关键. 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">defaultPassthroughServiceImplementation(); <span class="contentTag" title="Filter @hardware">@<span class="contentTagText">hardware</span><span class="contentTagNub"></span></span>/interfaces/power/1.0/default/service.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">IPower::getService @ PowerAll.cpp 从HwServiceManager里面获取注册的服务。默认情况下是没有注册这个服务的。</span></span></li><li><span class="name"><span class="innerContentContainer">defaultServiceManager <span class="contentTag" title="Filter @system">@<span class="contentTagText">system</span><span class="contentTagNub"></span></span>/libhidl/transport/ServiceManagement.cpp 打开/dev/hwbinder，通过binder通信，获取HwServiceManager服务端。</span></span></li><li><span class="name"><span class="innerContentContainer">sm-&gt;getTransport 基本就是按照Binder通信的机制来实现相关的流程。通过HwBinder调用服务端的getTransPort方法。接下来的调用链是:</span></span><ul><li><span class="name"><span class="innerContentContainer">BpHwServiceManager::getTransport() @ ServiceManagerAll.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BpHwBinder::transact</span></span></li><li><span class="name"><span class="innerContentContainer">IPCThreadState::self()-&gt;transact</span></span></li><li><span class="name"><span class="innerContentContainer">IPCThreadState::transact writeTransactionData waitForResponse</span></span></li><li><span class="name"><span class="innerContentContainer">IPCThreadState::executeCommand</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ServiceManager::getTransport() @ system/hwservicemanager/ServiceManager.cpp</span></span><ul><li><span class="name"><span class="innerContentContainer">getTransport @ system/hwservicemanager/Vintf.cpp 根据framework hal和device hal配置的manifest.xml里面的定义，来判断当前的传输类型是HwBinder还是Passthrough模式。</span></span></li><li><span class="name"><span class="innerContentContainer">在vendor/manifest.xml里面，power配置的是hwbinder,所以最终就是hwBinder模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">由于我们采取的是defaultPassthroughServiceImplementation&lt;IPower&gt;();进行注册，所以getStub=true.所以会走到const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager();</span></span><ul><li><span class="name"><span class="innerContentContainer">getPassthroughServiceManager @ PowerAll.cpp 获取passthrough服务管理。</span></span></li><li><span class="name"><span class="innerContentContainer">调用PassthroughServiceManager的get(const hidl_string&amp; fqName, const hidl_string&amp; name)函数 @ ServiceManagement.cpp, </span></span></li><li><span class="name"><span class="innerContentContainer">根据传入的fqName=(android.hardware.power@1.0::IPower"),获取当前的接口名IPower，拼接出后面需要载入的函数名HIDL_FETCH_IPower和库名字android.hardware.power@1.0-impl，</span></span></li><li><span class="name"><span class="innerContentContainer">接着通过dlopen载入/vendor/lib/hw/<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:android.hardware.power@1.0-impl.so">android.hardware.power@1.0-impl.so</a>，然后通过dlsym载入HIDL_FETCH_IPower函数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过 hw_get_module 就和 Android O 以前的Hal模式一致，这正是Passthrough复用原有hal的原理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">HIDL语法</span></span><ul><li><span class="name"><span class="innerContentContainer">使用Binderized模式时, 对HAL的访问需要跨进程, 即 client-server 模式. </span></span></li><li><span class="name"><span class="innerContentContainer">types.hal 放在软件包根目录，不定义接口，而是用于定义本软件包各hal可用的数据结构。</span></span></li><li><span class="name"><span class="innerContentContainer">用户可以使用HIDL语法编写.hal 文件, 然后使用 hidl-gen 自动生成 client 端和 server 端的代码, 很方便 (和AIDL 一回事).</span></span></li><li><span class="name"><span class="innerContentContainer">比如: hardware/interfaces/power/1.0/IPower.hal，会通过hidl-gen转换成 out/soong/.intermediates/hardware/interfaces/power/1.0/android.hardware.power@1.0_genc++/gen/android/hardware/power/1.0/PowerAll.cpp文件</span></span></li><li><span class="name"><span class="innerContentContainer">hidl-gen源码路径：system/tools/hidl</span></span></li><li><span class="name"><span class="innerContentContainer">使用方法：hidl-gen -o output-path -L language (-r interface-root) fqname</span></span></li><li><span class="name"><span class="innerContentContainer">在hardware/interfaces的子目录里面，存在.hal文件的目录，会产生Android.bp和Android.mk文件。</span></span></li><li><span class="name"><span class="innerContentContainer">Android.bp 大概是如下内容:</span></span><ul><li><span class="name"><span class="innerContentContainer">// This is an autogenerated file, do not edit.</span></span></li><li><span class="name"><span class="innerContentContainer">subdirs = [</span></span><ul><li><span class="name"><span class="innerContentContainer">"1.0",</span></span></li><li><span class="name"><span class="innerContentContainer">"1.0/default",</span></span></li><li><span class="name"><span class="innerContentContainer">"1.0/vts/functional",</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">]</span></span></li><li><span class="name"><span class="innerContentContainer">意思是, 编译时需要编译 hardware/interfaces/power目录下的这3个子目录。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">.hal文件转换成对应的代码后，就具备了Binder通信的能力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">版本管理</span></span><ul><li><span class="name"><span class="innerContentContainer">这里的版本是指service的版本. </span></span></li><li><span class="name"><span class="innerContentContainer">client 在初始化时可以探测当前系统中的service的版本. </span></span></li><li><span class="name"><span class="innerContentContainer">系统中可能有多个不同版本的 service的so文件. </span></span></li><li><span class="name"><span class="innerContentContainer">Google 约定, 1.0 升级到 1.1 , 要保证接口的兼容性, 也就是说只能新增接口, 不能修改删除接口. 1.1 升级到 2.0, 就不保证接口的兼容性, 也就是可以改接口.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">死亡通知</span></span><ul><li><span class="name"><span class="innerContentContainer">客户端注册了死亡通知后, 当服务死亡时会收到由Treble框架提供的死亡通知。</span></span></li><li><span class="name"><span class="innerContentContainer">为了完成注册，客户端需要满足以下条件：</span></span><ul><li><span class="name"><span class="innerContentContainer">HIDL 类 / 接口&nbsp;hidl_death_recipient&nbsp;的子类。（在 C++ 代码中，而非 HIDL）</span></span></li><li><span class="name"><span class="innerContentContainer">重写它的&nbsp;serviceDied()&nbsp;方法。</span></span></li><li><span class="name"><span class="innerContentContainer">实例化一个&nbsp;hidl_death_recipient&nbsp;子类对象。</span></span></li><li><span class="name"><span class="innerContentContainer">调用服务的方法&nbsp;<b>linkToDeath</b>()&nbsp;给监视器，传入&nbsp;IDeathRecipient&nbsp;的接口对象。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">class IMyDeathReceiver : hidl_death_recipient {</span></span><ul><li><span class="name"><span class="innerContentContainer">virtual void serviceDied(uint64_t cookie,</span></span><ul><li><span class="name"><span class="innerContentContainer">wp&lt;IBase&gt;&amp; service) override {</span></span></li><li><span class="name"><span class="innerContentContainer">log("RIP service %d!", cookie);  // Cookie should be 42</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">IMyDeathReceiver deathReceiver = new IMyDeathReceiver();</span></span></li><li><span class="name"><span class="innerContentContainer">m_importantService-&gt;<b>linkToDeath</b>(deathReceiver, 42);</span></span></li></ul></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">系统库 - 即Android中间件, 通用解决方案</span></span><ul><li><span class="name"><span class="innerContentContainer">SurfaceManager/Surfaceflinger (图层服务)</span></span></li><li><span class="name"><span class="innerContentContainer">OpenGLE （3D图形引擎）</span></span><ul><li><span class="name"><span class="innerContentContainer">SurfaceView/TextureView 用 OpenGL, 用硬件加速.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Skia（2D图形引擎, 又叫 SGL）</span></span><ul><li><span class="name"><span class="innerContentContainer">普通view渲染时不用 OpenGL, 用 skia, 不用硬件加速, 依赖CPU性能.</span></span></li><li><span class="name"><span class="innerContentContainer">Canvas 底层用 skia库实现. </span></span></li><li><span class="name"><span class="innerContentContainer">Android系统用 skia 来画普通的图形元素，包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">image</span></span></li><li><span class="name"><span class="innerContentContainer">shap</span></span></li><li><span class="name"><span class="innerContentContainer">color</span></span></li><li><span class="name"><span class="innerContentContainer">pre-defined 动画.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">FreeType</span></span></li><li><span class="name"><span class="innerContentContainer">媒体库</span></span></li><li><span class="name"><span class="innerContentContainer">SQLite --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/e96b8978d6de">https://workflowy.com/#/e96b8978d6de</a></span></span></li><li><span class="name"><span class="innerContentContainer">Webkit (web套件)</span></span></li><li><span class="name"><span class="innerContentContainer">SSL (安全套接字)</span></span></li><li><span class="name"><span class="innerContentContainer">LibC (C/C++库)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android运行时 -- java虚拟机和java语言库</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟机</span></span><ul><li><span class="name"><span class="innerContentContainer">Java虚拟机</span></span><ul><li><span class="name"><span class="innerContentContainer">java虚拟机是执行字节码文件（.class）的进程。</span></span></li><li><span class="name"><span class="innerContentContainer">java代码执行流程如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">java源程序（.java）被编译器编译成字节码文件（.class）。</span></span></li><li><span class="name"><span class="innerContentContainer">然后字节码文件由java虚拟机，解释成机器码（不同平台的机器码不同）。</span></span></li><li><span class="name"><span class="innerContentContainer">最后利用机器码操作硬件和操作系统</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SUN提供的java虚拟机和Dalvik的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。</span></span></li><li><span class="name"><span class="innerContentContainer">dalvik虚拟机是基于寄存器的。</span></span></li><li><span class="name"><span class="innerContentContainer">ava虚拟机运行的是java字节码。</span></span></li><li><span class="name"><span class="innerContentContainer">Dalvik运行的是自定义的.dex字节码格式。java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">一个应用，一个虚拟机实例，一个linux线程。</span></span></li><li><span class="name"><span class="innerContentContainer">Android虚拟机的演进历史</span></span><ul><li><span class="name"><span class="innerContentContainer">2008, Android 1.0, <b>Dalvik</b>, 机制是app总是一边编译一边运行. </span></span></li><li><span class="name"><span class="innerContentContainer">2010, 2.2, <b>JIT</b>(Just in time). 即时编译. 将编译好的代码存储, 下次直接使用.</span></span></li><li><span class="name"><span class="innerContentContainer">2014-10, 5.0, <b>ART</b>(Android runtime), 将JIT编译器改为AOT(Ahead of time), 在apk安装时生成dex字节码, 运行时不编译.</span></span></li><li><span class="name"><span class="innerContentContainer">2016, 7.0, ART机制改为安装时不编译, 而是在安装后CPU空闲时编译. 在AOT编译器失效时, 改用JIT编译器. </span></span></li><li><span class="name"><span class="innerContentContainer">2019, 10.0, ART机制改为预先放置热点代码的标记, 在安装时先生成热点代码的字节码, 而剩下的代码则在CPU空闲时编译.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Dalvik</span></span><ul><li><span class="name"><span class="innerContentContainer">google开发的一种java虚拟机，是基于寄存器的。</span></span></li><li><span class="name"><span class="innerContentContainer">Dalvik有自己的bytecode, 并非使用 Java bytecode。所以不和sun java兼容。</span></span></li><li><span class="name"><span class="innerContentContainer">Dalvik为提升性能做的优化</span></span><ul><li><span class="name"><span class="innerContentContainer">多个 Class 文件融合进一个 Dex 文件中，以节省内存空间。</span></span></li><li><span class="name"><span class="innerContentContainer">Dex 文件可以在多个进程之间共享。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序运行之前完成字节码的检验操作，因为检验操作十分耗时。</span></span></li><li><span class="name"><span class="innerContentContainer">优化字节码。</span></span></li><li><span class="name"><span class="innerContentContainer">个进程共享的代码不能随意编辑，保证安全性。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ART</span></span><ul><li><span class="name"><span class="innerContentContainer">从 Android 4.4 开始，Art 开始和 Dalvik 共存。</span></span></li><li><span class="name"><span class="innerContentContainer">5.0 开始，Art 正式取代 Dalvik。</span></span></li><li><span class="name"><span class="innerContentContainer">Art 相比 Dalvik 在性能上有着显著的优势。</span></span><ul><li><span class="name"><span class="innerContentContainer">主要原因在于 Dalvik 虚拟机多数情况下还得通过解释器的方式来执行 Dex 数据；</span></span></li><li><span class="name"><span class="innerContentContainer">JIT 虽然能在一定程度上提高效率，但也仅仅是针对一小部分情况，作用有限；</span></span></li><li><span class="name"><span class="innerContentContainer">JIT 在程序运行过程中才会将部分热点代码编译成机器码，这在某种程度上也加重了 CPU 的负担。</span></span></li><li><span class="name"><span class="innerContentContainer">而 Art 则采用了 AOT(Ahead Of Time) 技术，从而大幅提高了性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AOT 提前将 Java 代码翻译成针对目标平台的机器码</span></span><ul><li><span class="name"><span class="innerContentContainer">虽然这也意味着编译时间有所增加。</span></span></li><li><span class="name"><span class="innerContentContainer">但 Android 系统的构建原本就慢，所以这点牺牲还是值得的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Art 虚拟机整体框架</span></span><ul><li><span class="name"><span class="innerContentContainer">无论是 Dalvik 还是 Art，它们提供的功能将全部封装在一个 so 库中，并且对外需要暴露：</span></span><ul><li><span class="name"><span class="innerContentContainer">JNI_GetDefaultVMInitArgs</span></span></li><li><span class="name"><span class="innerContentContainer">JNI_CreateVM</span></span></li><li><span class="name"><span class="innerContentContainer">JNI_GetCreatedJavaVMs 三个接口</span></span></li><li><span class="name"><span class="innerContentContainer">使用者（比如 Zygote）只需要按照统一的接口标准就可以控制和使用所有类型的虚拟机了。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">核心库 --代码中可以包含.</span></span><ul><li><span class="name"><span class="innerContentContainer">Java核心库</span></span></li><li><span class="name"><span class="innerContentContainer">Android核心库</span></span><ul><li><span class="name"><span class="innerContentContainer">android.os</span></span></li><li><span class="name"><span class="innerContentContainer">android.net</span></span></li><li><span class="name"><span class="innerContentContainer">android.media</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内核库  -- C/C++ 语言库</span></span><ul><li><span class="name"><span class="innerContentContainer">Bionic: google开发的c语言库，采用BSD许可形式开源，目的是替代以GPL开源的 glibc.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>google做这个的目的是为了避免开源感染扩散到HAL层。</b></span></span></li><li><span class="name"><span class="innerContentContainer">特点是:</span></span><ul><li><span class="name"><span class="innerContentContainer">大小仅200KB，是glibc的一半，且比glibc快。</span></span></li><li><span class="name"><span class="innerContentContainer">实现了一个更小、更快的pthread；</span></span></li><li><span class="name"><span class="innerContentContainer">提供了一些android需要的函数，如getprop、LOGI；</span></span></li><li><span class="name"><span class="innerContentContainer">不完全支持POSIX标准，如C++ exceptions、wide chars等；</span></span></li><li><span class="name"><span class="innerContentContainer">不提供libthread_db和libm的实现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">新增的特性:</span></span><ul><li><span class="name"><span class="innerContentContainer">wp、sp是智能指针；</span></span></li><li><span class="name"><span class="innerContentContainer">string8.h 是定义单字节字符串的类；并提供从 string16 转换的接口。</span></span></li><li><span class="name"><span class="innerContentContainer">keyedvector.h，定义hash向量表模板，用key（字符串）随机访问数据。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>