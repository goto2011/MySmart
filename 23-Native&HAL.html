<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">23-Native&amp;HAL</span></span><ul><li><span class="name"><span class="innerContentContainer">JNI: Java Native Interface.  一套编程接口，用来实现Java代码与本地的C/C++代码进行互相调用.</span></span></li><li><span class="name"><span class="innerContentContainer">Native: 本地代码. 相对于托管代码而言.</span></span><ul><li><span class="name"><span class="innerContentContainer">FWK及APP层的Java代码运行在虚拟机之上, 即托管代码. </span></span></li><li><span class="name"><span class="innerContentContainer">相对应, 所有的c代码, 以及部分不依赖虚拟机的java代码, 就是native代码.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">NDK: native development kit. 开发native代码的工具包</span></span><ul><li><span class="name"><span class="innerContentContainer">在系统开发中, NDK 用于开发native层代码.</span></span></li><li><span class="name"><span class="innerContentContainer">在纯应用开发中, NDK用于支撑apk调用自己的c 的so库. 然后NDK能帮助程序员自动将so文件和java代码一起打包成apk。</span></span><ul><li><span class="name"><span class="innerContentContainer">常见情况是: 出于跨平台考虑，核心算法用C实现。在android平台，用NDK生成c的so库，用java做上层产品实现。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">HAL: 即Hardware Abstraction Layer. 为硬件供应商定义了一系列标准接口来实现, 以实现fwk代码和硬件的解耦.</span></span></li><li><span class="name"><span class="innerContentContainer">这几组概念的调用关系是:</span></span><ul><li><span class="name"><span class="innerContentContainer">java 调用 java api; (即java的native函数)</span></span></li><li><span class="name"><span class="innerContentContainer">java api 调用 jni;</span></span></li><li><span class="name"><span class="innerContentContainer">jni 是一层皮, 调用 c 的 native 的 client 层;</span></span></li><li><span class="name"><span class="innerContentContainer">c 的native 包括 client 和 service, 两者用 binder 方式通讯;</span></span></li><li><span class="name"><span class="innerContentContainer">native service 调用 HAL.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI 就是一层皮, 找到规律后, 从 java 跳到 c 就非常容易理解了.</span></span><ul><li><span class="name"><span class="innerContentContainer">Java代码如何调用C?</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种方式: 静态和动态</span></span></li><li><span class="name"><span class="innerContentContainer">静态注册: 根据函数名建立 Java 方法和 JNI 函数的一一对应关系。流程是：</span></span><ul><li><span class="name"><span class="innerContentContainer">先编写 Java 的 native 方法；</span></span></li><li><span class="name"><span class="innerContentContainer">然后用 javah 工具生成对应的头文件，执行命令 javah packagename.classname可以生成由包名加类名命名的 jni 层头文件，或执行命名 javah -o custom.h packagename.classname，其中 custom.h 为自定义的文件名；</span></span></li><li><span class="name"><span class="innerContentContainer">实现 JNI 里面的函数，再在Java中通过 <b>System.loadLibrary </b>加载 so 库即可.</span></span></li><li><span class="name"><span class="innerContentContainer">一个在java代码中叫 swap() 的native方法, 对应的C代码函数体是:</span></span><ul><li><span class="name"><span class="innerContentContainer">JNIEXPORT jint JNICALL <b>Java_Com_Oppo_Camera_Jni_swap__</b>(JNIEnv *, jclass);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">动态注册: 直接告诉 native 方法其在JNI 中对应函数的指针。通过使用 JNINativeMethod 结构来保存 Java native 方法和 JNI 函数关联关系，流程是：</span></span><ul><li><span class="name"><span class="innerContentContainer">先编写 Java 的 native 方法；</span></span></li><li><span class="name"><span class="innerContentContainer">编写 JNI 函数的实现（函数名可以随便命名）；</span></span></li><li><span class="name"><span class="innerContentContainer">利用结构体 JNINativeMethod 保存Java native方法和 JNI函数的对应关系；</span></span></li><li><span class="name"><span class="innerContentContainer">利用registerNatives(JNIEnv* env)注册类的所有本地方法；</span></span></li><li><span class="name"><span class="innerContentContainer">在 JNI_OnLoad 方法中调用注册方法；</span></span></li><li><span class="name"><span class="innerContentContainer">在Java中通过 System.loadLibrary 加载完JNI动态库之后，会调用 JNI_OnLoad 函数，完成动态注册.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码如何调用 Java?</span></span><ul><li><span class="name"><span class="innerContentContainer">当 Native 层需要调用 Java 的某个方法时，需要通过 JNI函数 GetMethodID()获取它的 ID，根据 ID 调用 JNI 函数获取该方法；变量的获取也是类似。</span></span></li><li><span class="name"><span class="innerContentContainer">jmethodID   (*<b>GetMethodID</b>)(JNIEnv*, jclass, const char*, const char*);    //C</span></span></li><li><span class="name"><span class="innerContentContainer">jmethodID <b>GetMethodID</b>(jclass clazz, const char* name, const char* sig)  //C++</span></span><ul><li><span class="name"><span class="innerContentContainer">{ return functions-&gt;GetMethodID(this, clazz, name, sig); </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">在实际编程中，如果使用 javah 工具来生成对应的 native 代码，就不需要手动编写对应的类型转换了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码方法的定义和 JNIEnv</span></span><ul><li><span class="name"><span class="innerContentContainer">所有本地函数都会接收 JNIEnv 作为第一个参数.</span></span></li><li><span class="name"><span class="innerContentContainer">JNIEnv 是一个指针，指向一组 JNI 函数，通过这些函数可以实现 Java 层和 JNI 层的交互，就是说通过 JNIEnv 调用 JNI 函数可以访问 Java 虚拟机，操作 Java 对象.</span></span></li><li><span class="name"><span class="innerContentContainer">用作线程局部存储，不能在线程间共享一个 JNIEnv 变量，也就是说&nbsp;JNIEnv 只在创建它的线程有效，不能跨线程传递；相同的 Java 线程调用本地方法，所使用的 JNIEnv 是相同的，一个 native 方法不能被不同的 Java 线程调用.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI数据类型映射表</span></span><ul><li><span class="name"><span class="innerContentContainer">定义参数和返回值时要用到数据类型, JNI一般使用:</span></span><ul><li><span class="name"><span class="innerContentContainer">String getString()  -&gt;  Ljava/lang/String;</span></span></li><li><span class="name"><span class="innerContentContainer">int sum(int a, int b)  -&gt;  (II)I</span></span></li><li><span class="name"><span class="innerContentContainer">void main(String[] args) -&gt; ([Ljava/lang/String;)V</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本数据类型: </span></span><ul><li><span class="name"><span class="innerContentContainer">字符 Java类型    C类型</span></span></li><li><span class="name"><span class="innerContentContainer">V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void</span></span></li><li><span class="name"><span class="innerContentContainer">Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jboolean&nbsp;&nbsp;&nbsp;&nbsp; boolean</span></span></li><li><span class="name"><span class="innerContentContainer">I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</span></span></li><li><span class="name"><span class="innerContentContainer">J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jlong&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long</span></span></li><li><span class="name"><span class="innerContentContainer">D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jdouble&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double</span></span></li><li><span class="name"><span class="innerContentContainer">F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jfloat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float</span></span></li><li><span class="name"><span class="innerContentContainer">B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jbyte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte</span></span></li><li><span class="name"><span class="innerContentContainer">C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jchar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char</span></span></li><li><span class="name"><span class="innerContentContainer">S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jshort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数组则以"["开始，用两个字符表示: </span></span><ul><li><span class="name"><span class="innerContentContainer">[I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jintArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[]</span></span></li><li><span class="name"><span class="innerContentContainer">[F&nbsp;&nbsp;&nbsp;&nbsp; jfloatArray&nbsp;&nbsp;&nbsp; float[]</span></span></li><li><span class="name"><span class="innerContentContainer">[B&nbsp;&nbsp;&nbsp;&nbsp; jbyteArray&nbsp;&nbsp;&nbsp; byte[]</span></span></li><li><span class="name"><span class="innerContentContainer">[C&nbsp;&nbsp;&nbsp; jcharArray&nbsp;&nbsp;&nbsp; char[]</span></span></li><li><span class="name"><span class="innerContentContainer">[S&nbsp;&nbsp;&nbsp; jshortArray&nbsp;&nbsp; short[]</span></span></li><li><span class="name"><span class="innerContentContainer">[D&nbsp;&nbsp;&nbsp; jdoubleArray double[]</span></span></li><li><span class="name"><span class="innerContentContainer">[J&nbsp;&nbsp;&nbsp;&nbsp; jlongArray&nbsp;&nbsp;&nbsp;&nbsp; long[]</span></span></li><li><span class="name"><span class="innerContentContainer">[Z&nbsp;&nbsp;&nbsp;  jbooleanArray boolean[]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">引用类型描述符:</span></span><ul><li><span class="name"><span class="innerContentContainer">引用类型不能直接在 Native 层使用. 需要用如下格式: </span></span></li><li><span class="name"><span class="innerContentContainer">L + 包名/类描述符 + ; ,  注意分号不要丢了.</span></span></li><li><span class="name"><span class="innerContentContainer">比如 CameraBuffer-&gt; Lcom/android/camera/CameraBuffer;   // 真是麻烦.</span></span></li><li><span class="name"><span class="innerContentContainer">一个例外是String类，其对应的类为jstring.</span></span></li><li><span class="name"><span class="innerContentContainer">同时其对应的C函数名的参数则为 <b>jobject</b>.</span></span></li><li><span class="name"><span class="innerContentContainer">如果JAVA函数位于一个嵌入类，则用$作为类名间的分隔符。如: "(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z"</span></span></li><li><span class="name"><span class="innerContentContainer">多维数组（含二维数组）都是引用类型，需要使用 jobjectArray 类型存取其值；</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">HAL层是用户态进程访问硬件的标准接口，被编译成so文件，然后被framework代码动态加载。</span></span></li><li><span class="name"><span class="innerContentContainer">HAL层的必要性</span></span><ul><li><span class="name"><span class="innerContentContainer">HAL层主要是为规避GPL而设计的</span></span><ul><li><span class="name"><span class="innerContentContainer">它将将硬件驱动分成内核空间和用户空间两部分，</span></span></li><li><span class="name"><span class="innerContentContainer">其中用户空间部分采用的是商业友好的Apache License。</span></span></li><li><span class="name"><span class="innerContentContainer">内核驱动层只提供简单的访问硬件逻辑，例如读写硬件寄存器的通道。</span></span></li><li><span class="name"><span class="innerContentContainer">至于从硬件中读到了什么值或者写了什么值到硬件中的逻辑，都放在HAL中去。</span></span></li><li><span class="name"><span class="innerContentContainer">这样就可以把商业秘密隐藏起来了。</span></span></li><li><span class="name"><span class="innerContentContainer">也正是由于这个原因，Android被踢出了Linux内核主线代码树中。Android放在内核空间的驱动程序对硬件的支持是不完整的，把Linux内核移植到别的机器上去时，由于缺乏硬件抽象层的支持，硬件就完全不能用了，这也是为什么说Android是开放系统而不是开源系统的原因。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同时是为了满足抽象的要求</span></span><ul><li><span class="name"><span class="innerContentContainer">比如framework需要用overlay，通过给 hw_get_module()传入字符串“overlay_module”，就可以取得该设备的标准模块的描述.</span></span></li><li><span class="name"><span class="innerContentContainer">有人实现了overlay，不管是软件加速，还是硬件加速，是基于v4l2，还是基于mmap接口，只要实现成 overlay_module 的样子就成，这样就“抽象”了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">如何看native代码?</span></span><ul><li><span class="name"><span class="innerContentContainer">java native方法申明: 在java代码中, 方法前面有 native 关键字的就是native方法.</span></span></li><li><span class="name"><span class="innerContentContainer">native方法的命名有规律, 一般是:</span></span><ul><li><span class="name"><span class="innerContentContainer">java库: Java_Lang_类名_方法名</span></span></li><li><span class="name"><span class="innerContentContainer">Android frameworkd : android_Hardware_Camera_CameraOpen()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native方法只是一个句柄, 真正的函数体是C代码的. 对应的代码在:</span></span><ul><li><span class="name"><span class="innerContentContainer">java库:  delvik/wm/native/</span></span></li><li><span class="name"><span class="innerContentContainer">Android framework : framework/base/core/jni/</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">编译so文件</span></span><ul><li><span class="name"><span class="innerContentContainer">Android系统支持7种CPU建构, 每一种对应一种ABI(应用程序二进制接口)</span></span><ul><li><span class="name"><span class="innerContentContainer">armV5 -- armeabi</span></span></li><li><span class="name"><span class="innerContentContainer">armV7(2010) -- armeabi-v7a</span></span></li><li><span class="name"><span class="innerContentContainer">x86(2011) -- x86</span></span></li><li><span class="name"><span class="innerContentContainer">mips(2012) -- mips</span></span></li><li><span class="name"><span class="innerContentContainer">armV8(2012) -- arm64-v8a</span></span></li><li><span class="name"><span class="innerContentContainer">mips64(2014) -- mips64</span></span></li><li><span class="name"><span class="innerContentContainer">x86-64(2014) -- x86-64</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果在项目中使用了NDK, 就会生成so文件.</span></span></li><li><span class="name"><span class="innerContentContainer">native libs monitor, 运行在手机上, 可列出各apk使用了哪些so文件, 以及so文件来源于哪些函数库或框架. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">寻址so文件</span></span><ul><li><span class="name"><span class="innerContentContainer">hw_get_module()通过libdl动态加载库文件, 文件路径在 /system/lib/hw/[id].[arch].so</span></span></li><li><span class="name"><span class="innerContentContainer">其中id即设备id，是字符串. 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">overlay_module: 图层叠加</span></span></li><li><span class="name"><span class="innerContentContainer">gralloc_*: 图形buffer</span></span></li><li><span class="name"><span class="innerContentContainer">display_*: 显示控制</span></span></li><li><span class="name"><span class="innerContentContainer">nfc</span></span></li><li><span class="name"><span class="innerContentContainer">camera</span></span></li><li><span class="name"><span class="innerContentContainer">sensors_hardware_*: 传感器</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">arch 即芯片平台id。</span></span></li><li><span class="name"><span class="innerContentContainer">so文件名类似：camera.msm7630.surf.so 和 nfc.huawei.so。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用so文件</span></span><ul><li><span class="name"><span class="innerContentContainer">每个so库都要实现标准接口，这个标准即 HAL_MODULE_INFO_SYM，其中定义了一些属性，但要求必须实现的接口只有一个：open()。</span></span></li><li><span class="name"><span class="innerContentContainer">so文件找到后，调用 dlopen()打开，后者返回值为模块操作句柄。</span></span></li><li><span class="name"><span class="innerContentContainer">再调用dlsym(),  入参即模块操作句柄及符号名，返回符号对应的地址。不仅可以返回函数指针，也可以获得全局变量的地址.</span></span></li><li><span class="name"><span class="innerContentContainer">其它接口包括:</span></span></li><li><span class="name"><span class="innerContentContainer">dlclose():关闭库文件。 </span></span></li><li><span class="name"><span class="innerContentContainer">dlerror()当操作函数执行失败时，可通过此接口返回出错信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不是所有的设备驱动都用HAL</span></span><ul><li><span class="name"><span class="innerContentContainer">电池就不用，因为power是linux内核标准服务，JNI就直接访问内核服务了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">NDK开发常见问题</span></span><ul><li><span class="name"><span class="innerContentContainer">忘记delete local reference。带New到方法(如：NewByteArray)这样到方法比较好辨认，需要手动调用DeleteLocalRef()来释放(返回值除外)。比较特殊的一个方法是：GetByteArrayELement必须要调用ReleaseByteArrayElements进行释放。当然如果你只是取bytearray中到byte，那么完全可以用GetByteArrayRegion实现。</span></span></li><li><span class="name"><span class="innerContentContainer">没有NewGlobalRef。 在不同线程调用java方法，需要保存jobject对象，这时需要对jobject对象做全局引用，否则会失效。</span></span></li><li><span class="name"><span class="innerContentContainer">jbytearray的length。在JNI layer获取到jbytearray到长度是不对到，应该由java获取byte[]的length再传给C layer。否则C layer有可能获得到是乱码。</span></span></li><li><span class="name"><span class="innerContentContainer">线程问题。 不同线程使用JNIEnv*对象，需要AttachCurrentThread将env挂到当前线程，否则无法使用env。</span></span></li><li><span class="name"><span class="innerContentContainer">&nbsp;javap 命令是对java的class文件操作；而javah命令需要在包名到上一层路径运行才行，否则无法生成.h文件。</span></span></li><li><span class="name"><span class="innerContentContainer">尽量避免频繁调用JNI或者是使用JNI传输大量到数据。</span></span></li><li><span class="name"><span class="innerContentContainer">Reference Table overflow (max=1024) 或者是&nbsp;Reference Table overflow (max=512)一定是因为忘记释放global reference或者local reference，请仔细检查代码。</span></span></li><li><span class="name"><span class="innerContentContainer">不要在windows下使用cygwin编译NDK code，那样会遇到arguments too long问题，因为windows路径长度有限制导致。虽然可以使用subst将路径映射为短路径，但是在编译时间和调试上，windows到孩子都是伤不起。同样到build，在windows下要15分钟左右，而在mac下只要5分多，相差3倍。调试JNI 代码到速度更是不用提了，差太多。</span></span></li></ul></li></ul>
  </body>
</html>