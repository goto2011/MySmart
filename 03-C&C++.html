<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">C&amp;C++</span><ul><li><span class="name">代码组织方式</span><ul><li><span class="name">C语言：头文件 .h 和 .c文件</span></li><li><span class="name">C++：</span></li><li><span class="name">冒号（:）的用法</span><ul><li><span class="name">类名后面的冒号是用于定义类的继承关系；</span></li><li><span class="name">构造函数后面的冒号用于成员变量的赋值，常见于const常量。如：</span><ul><li><span class="name">struct MyStruct{</span><ul><li><span class="name">MyStruct(): Param(initValue) {…}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">双冒号(::)的用法</span><ul><li><span class="name">表示“域操作符”。申明一个类及其成员函数 void func()，则在类外定义 func时，要写成void MyClass::func()</span></li><li><span class="name">用于函数前，表示是全局函数。例如 ::flock()</span></li><li><span class="name">表示应用成员函数或变量，等价于.号。如：System::Math::Sqrt(), 等价于 System.Math.Sqrt()</span></li></ul></li></ul></li><li><span class="name">类（结构 for C）</span><ul><li><span class="name">在C++中，对于类的定义和实现是否要分别在h文件和cpp文件中并没有做严格要求。但一般是要分开的。&nbsp;</span></li><li><span class="name">.h文件：</span></li><li><span class="name">class MyClass : public SuperClass</span></li><li><span class="name">{</span><ul><li><span class="name">public: &nbsp;// 方法常公有</span><ul><li><span class="name">MyClass(); &nbsp; // 构造函数1，无参数。构造函数没有返回值。</span></li><li><span class="name">MyClass(int param); &nbsp; // 构造函数2，有参数。</span></li><li><span class="name">~MyClass(); &nbsp; // 析构函数。析构函数没有参数，也没有返回值。</span></li><li><span class="name">int myFunc1(); &nbsp;// 其它对外接口。</span></li></ul></li><li><span class="name">private: // 属性常私有</span><ul><li><span class="name">static int staticParam = 0; &nbsp; // 静态成员属性。后文可看到，这是个访问计数。</span></li><li><span class="name">int myParam1;</span></li></ul></li></ul></li><li><span class="name">};</span></li><li><span class="name">.cpp文件：</span></li><li><span class="name"># include &lt;MyClass.h&gt;</span></li><li><span class="name">int&nbsp;MyClass::myParam1; &nbsp; &nbsp;// 属性要重新引用。这个略奇葩。</span></li><li><span class="name">MyClass::MyClass(): SuperClass() { &nbsp;// 显示调用父类的构造函数</span><ul><li><span class="name">myParam1 = 0;</span></li><li><span class="name">staticParam++;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">MyClass::MyClass(int param): SuperClass() { &nbsp;// 显示调用父类的构造函数</span><ul><li><span class="name">myParam1 =&nbsp;param;</span></li><li><span class="name">staticParam++;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">MyClass::~MyClass() {</span><ul><li><span class="name">staticParam—;</span></li><li><span class="name">if (staticParam &lt; 0) {</span><ul><li><span class="name">LogE(“MyClass free erro.");</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">int myFunc1() {</span><ul><li><span class="name">myParam1 *= 2.5;</span></li><li><span class="name">return myParam1;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">要点：（1）子类不能访问基类中的私有对象；</span></li><li><span class="name">（2）最好不要用友元；</span></li><li><span class="name">（3）不要new基类，要new子类。new基类，就和子类无关了。</span></li></ul></li><li><span class="name">Hello world</span><ul><li><span class="name"># include &lt;stdio.h&gt;</span></li><li><span class="name">main() {</span><ul><li><span class="name">printf(“Hello world!\n");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">编译：cc hello.cpp</span></li></ul></li><li><span class="name">注释</span><ul><li><span class="name">// 单行注释</span></li><li><span class="name">/* 多行</span></li><li><span class="name">注释 */</span></li></ul></li><li><span class="name">Log打印</span><ul><li><span class="name">打印到文件</span><ul><li><span class="name">fprintf(fp, “%s %s\t %s\t%s\t%s\n”, __DATA__, __TIME, __FILE__, __LINE__, argv[0]);&nbsp;</span></li></ul></li><li><span class="name">打印堆栈. 这个代码在android上不可用, 但android有其它解决办法。</span><ul><li><span class="name"># include &lt;execinfo.h&gt;</span></li><li><span class="name"># define MAX_STACK_COUNT 16</span></li><li><span class="name">void * array[MAX_STACK_COUNT];</span></li><li><span class="name">int stack_num = backtrace(array, MAX_STACK_COUNT);</span></li><li><span class="name">char ** stacktrace = backtrace_symbols(array, stack_num);</span></li><li><span class="name">ALOGE(“stack begin:")</span></li><li><span class="name">for (int ii=0; ii&lt;stack_num; ++ii) {</span><ul><li><span class="name">ALOGE(“ &nbsp;%s”, stacktrace[ii]);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">free(stacktrace);</span></li></ul></li></ul></li><li><span class="name">函数（传值、传址、传引用）</span><ul><li><span class="name">一般函数: int myFunc(int ii, char * string) {…}&nbsp;</span></li><li><span class="name">变参函数</span><ul><li><span class="name">void simple_va_fun(int start, …) {</span><ul><li><span class="name">va_list arg_prt;</span></li><li><span class="name">int nArgValue = start; &nbsp; // 第一个参数</span></li><li><span class="name">int nArgCount = 0;</span></li><li><span class="name">va_start(arg_ptr, start);</span></li><li><span class="name">do {   // 遍历各个参数</span><ul><li><span class="name">++nArgCount;</span></li><li><span class="name">printf(“the %d argument is %d”,&nbsp;nArgCount,&nbsp;nArgValue);</span></li></ul></li><li><span class="name">} while (nArgValue != -1);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">宏定义中使用可变参数</span><ul><li><span class="name">c99支持 ## _VA_ARGS_ 宏。</span></li><li><span class="name"># define debug(… ) printf (_VA_ARGS_)</span></li><li><span class="name">使用时：debug(“y=%d\n”, y);</span></li><li><span class="name">gcc还支持一种格式，就是：# define dbprint(format, args…) frpintf(stderr, format, ##args)&nbsp;</span></li></ul></li><li><span class="name">参数参数传递分为传值、传址、传引用。</span><ul><li><span class="name">基本数据类型、结构体默认是传值. </span></li><li><span class="name">数组、字符串、指针、对象默认是传址。</span></li></ul></li><li><span class="name">除语义差异外，传值涉及值拷贝，可能有性能问题。</span></li><li><span class="name">c++中提供传引用的方法，推荐使用。</span><ul><li><span class="name">void myFunc(int &amp;param) {…}</span></li><li><span class="name">函数体中直接使用变量名 param，不需要加什么符号。</span></li><li><span class="name">传参时也直接传，myFunc(myParam) ，不需要加什么符号，所以相对简单。</span></li><li><span class="name">传引用的参数，在退出函数后还可以保持，这个和指针类似。但是和指针不同的是，引用不能做指针运算。</span></li></ul></li></ul></li><li><span class="name">整数&amp;布尔量</span><ul><li><span class="name">整数如下: </span></li><li><span class="name">int ii; &nbsp; // 32位，正负20亿。</span></li><li><span class="name">long ii; &nbsp;// 32位</span></li><li><span class="name">long long ii; &nbsp;// 64位</span></li><li><span class="name">char jj; &nbsp;// 8位，正负128</span></li><li><span class="name">负数在有符号数中用补码表示。补码是绝对值按位取反+1。</span></li><li><span class="name">int和uint运算时，int会先转为uint。</span></li><li><span class="name">布尔量</span><ul><li><span class="name">c用 char 表示布尔变量。0表示false，非0表示true。</span></li><li><span class="name">c++有bool类型，有true和false两个值。但在逻辑运算中，默认非零为true。</span></li></ul></li></ul></li><li><span class="name">浮点数</span><ul><li><span class="name">浮点数在内存中按科学计数法来存储。其整数部分始终是一个个位数。</span></li><li><span class="name">float number; &nbsp;// 32位。小数部分占23位，相当于十进制的6-7位，所以其精度是支持6-7位小数。</span></li><li><span class="name">double complex; &nbsp;// 128位。小数部分占52位，精度为15-16位小数。</span></li></ul></li><li><span class="name">常量、全局变量、静态变量、枚举量</span><ul><li><span class="name">常量：const int ii = 32;</span></li><li><span class="name">全局变量：在函数外部定义的都是全局可见。</span></li><li><span class="name">静态变量：static变量，全局可见。包括在函数内部定义的。</span></li><li><span class="name">枚举量：</span><ul><li><span class="name">enum enumType {</span><ul><li><span class="name">Monday = 0,</span></li><li><span class="name">TuesDay = 1,</span></li><li><span class="name">…</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">enumType WeekDay;</span></li></ul></li></ul></li><li><span class="name">运算符表</span><ul><li><span class="name">() [] -&gt; . &nbsp; 括号（函数等），数组，两种结构成员访问. 由左向右</span></li><li><span class="name">! ~ ++ -- + - * &amp; (类型) sizeof &nbsp;否定，按位否定，增量，减量，正负号，间接，取地址，类型转换，求大小. 由右向左</span></li><li><span class="name">/ % &nbsp;乘，除，取模. 由左向右</span></li><li><span class="name">+ - &nbsp;加，减. 由左向右</span></li><li><span class="name">&lt;&lt; &gt;&gt; &nbsp;左移，右移. 由左向右</span></li><li><span class="name">&lt; &lt;= &gt;= &gt; &nbsp;小于，小于等于，大于等于，大于. 由左向右</span></li><li><span class="name">== != &nbsp;等于，不等于. 由左向右</span></li><li><span class="name">&amp; &nbsp;按位与. 由左向右</span></li><li><span class="name">^ &nbsp;按位异或. 由左向右</span></li><li><span class="name">| &nbsp;按位或. 由左向右</span></li><li><span class="name">&amp;&amp; &nbsp;逻辑与. 由左向右</span></li><li><span class="name">|| &nbsp;逻辑或. 由左向右</span></li><li><span class="name">? : &nbsp;条件. 由右向左</span></li><li><span class="name">= += -= *= /= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &nbsp;各种赋值. 由右向左</span></li><li><span class="name">, &nbsp;逗号（顺序） &nbsp;由左向右</span></li></ul></li><li><span class="name">数据的拆箱和装箱</span></li><li><span class="name">指针&amp;引用</span><ul><li><span class="name">指针: int * myPtr = &amp;myInt;</span></li><li><span class="name">引用（c++）</span><ul><li><span class="name">int m;</span></li><li><span class="name">int &amp;n = m; &nbsp;// n相当于m的别名，对n的任何操作就是对m的操作。</span></li><li><span class="name">引用的规则是：引用必须在定义的同时被初始化，而且只能初始化为合法的存储单元；一旦初始化后，就不能再更改引用关系。</span></li></ul></li><li><span class="name">android 智能指针(sp/wp)</span><ul><li><span class="name">android定义了两类智能指针, 强指针sp(strong pointer)/弱指针(weak pointer), 相关代码在:</span></li><li><span class="name">/system/core/include/utils/strongpointer.h</span></li><li><span class="name">/system/core/include/utils/RefBase.h</span></li><li><span class="name">/system/core/libutils/RefBase.cpp</span></li><li><span class="name">sp与一般意义上的智能指针概念相同, 通过引用计数来记录有多少个使用者在使用一个对象, 如果所有使用者都放弃了对该对象的引用, 则对象自动销毁.</span></li><li><span class="name">wp也指向一个对象, 但wp仅记录对象地址, 不管理对象的生命周期, 所以不能通过该指针访问该对象.</span></li><li><span class="name">要用sp/wp来个对象, 那么它需要满足两个条件:</span><ul><li><span class="name">要是RefBase的子类;</span></li><li><span class="name">要定义虚拟的析构函数, 即 virtual ~myClass();</span></li></ul></li></ul></li><li><span class="name">sp的使用</span><ul><li><span class="name">初始化:sp&lt;myClass&gt;sp = new myClass();</span></li><li><span class="name">调用接口: sp-&gt;myFunction();</span></li><li><span class="name">获取原来的对象: sp.get();</span></li><li><span class="name">指针重新赋值: sp重载了operate=, 重新赋值会自动将原来的引用减一, 新的引用加一.</span></li><li><span class="name">手动清理: sp.clear();</span></li><li><span class="name">不用时, 将sp指针改为null;</span></li></ul></li><li><span class="name">wp的使用</span><ul><li><span class="name">wp不能直接使用, 用之前要先升级为sp, 即sp = wp.promote();</span></li><li><span class="name">promote()失败表示对象已经销毁. 所以需要检查得到的sp指针是否为空. </span></li></ul></li><li><span class="name">c++指针强转 :const_cast</span><ul><li><span class="name">c++中对指针强转做了一些保护. const_cast的功能是去掉类型的const或者volatile属性. 如:</span><ul><li><span class="name">const Sa ra;</span></li><li><span class="name">Sa &amp;rb =&nbsp;const_cast&lt;Sa &amp;&gt;(ra);</span></li></ul></li></ul></li><li><span class="name">static_cast: 静态类型转换. 用于基类和子类间的转换, 不支持非继承关系的类型之间的转换. 如:</span><ul><li><span class="name">int n = 8;</span></li><li><span class="name">double d = static_cast&lt;double&gt;(n);</span></li></ul></li><li><span class="name">dynamic_cast: 动态类型转换. 也是用于基类和子类间的转换, 而且会做转换类型检查, 不完全的会返回null. 所谓安全, 就是指只能从子类转化为基类.</span></li><li><span class="name">reinterpret_cast: 无条件强制, 仅重新解释类型, 不做任何二进制的转换. 和C的强制类似, 没有安全保障.</span></li><li><span class="name">C++智能指针: std::unique_ptr</span><ul><li><span class="name">c++标准库提供的智能指针解决方案. 用法是: </span><ul><li><span class="name">std::unique_ptr&lt;MyClass&gt; myPtr = new MyClass;</span></li></ul></li></ul></li></ul></li><li><span class="name">对象判空</span><ul><li><span class="name">if (myObj &lt;&gt; NULL) {...}</span></li></ul></li><li><span class="name">对象的元属性</span><ul><li><span class="name">sizeof()</span></li><li><span class="name">typeof()</span><ul><li><span class="name">typeof 支持的情况不太统一.&nbsp;它的作用是自动推导表达式的数据类型，以解决泛型编程中有些类型由模板参数决定而难以表示的问题。</span></li></ul></li><li><span class="name">c++中新增 typeid 关键字, 更强大.</span><ul><li><span class="name"># include &lt;typeinfo&gt;</span></li><li><span class="name">MyClass myObj;</span></li><li><span class="name">const type_info &amp;myInfo = typeid(myObj);</span></li><li><span class="name">cout &lt;&lt;<a class="contentLink" target="_blank" rel="noreferrer" href="http://myInfo.name">myInfo.name</a>() &lt;&lt; “|” &lt;&lt; myInfo.raw_name() &lt;&lt; “|” &lt;&lt; myInfo.hash_code() &lt;&lt; endl;</span></li><li><span class="name">输出: class MyClass | .?MyClass@@ | 1035034553</span></li></ul></li></ul></li><li><span class="name">for &amp; while</span><ul><li><span class="name"><b>for</b> (int ii = 1; ii &lt; limit; ii++) {...}</span></li><li><span class="name"><b>while</b> (myInt &lt;= 100) {…}</span></li><li><span class="name"><b>do</b> {…} <b>while</b> (myInt &lt;= 100)</span></li></ul></li><li><span class="name">if &amp; swith</span><ul><li><span class="name">if (myInt &gt; 0) {...}</span></li><li><span class="name">switch(myInt) {</span><ul><li><span class="name">case 1:</span><ul><li><span class="name">…</span></li><li><span class="name">break;</span></li></ul></li><li><span class="name">case 2:</span><ul><li><span class="name">…</span></li><li><span class="name">break;</span></li></ul></li><li><span class="name">default:</span><ul><li><span class="name">…</span></li><li><span class="name">break;</span></li></ul></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">字符串的使用</span><ul><li><span class="name">转义符</span><ul><li><span class="name">\n: 换行</span></li><li><span class="name">\r: 回车</span></li><li><span class="name">\t: Tab符</span></li><li><span class="name">\f: 清屏并换页</span></li><li><span class="name">\\: \本身</span></li><li><span class="name">%%: %本身</span></li></ul></li><li><span class="name">字符串定义</span><ul><li><span class="name">c语言的字符串是一个以’\0’结尾的字符数组. 有两种方式定义:</span></li><li><span class="name"># include &lt;string.h&gt;</span></li><li><span class="name">char myString[] = “Hello world!”;</span></li><li><span class="name">char *myString =&nbsp;“Hello world!”; &nbsp; &nbsp;// 此时myString指向常量区. 做指针运算的时候要格外小心.</span></li></ul></li><li><span class="name">unicode字符串</span><ul><li><span class="name">andorid 中, string8.h 是系统提供的utf8字符串类. 还有&nbsp;string16.h 类.</span></li><li><span class="name">代码在: frameworks/native/include/utils/String8.h.   其用法是:</span></li><li><span class="name">String8 myStr1(“Hello android");</span></li><li><span class="name">String8 myStr2(“ is good! ^_^");</span></li><li><span class="name">String8 add8 = str1 + str2; &nbsp; // 用比较自然的方法连接字符串</span></li><li><span class="name">cout&lt;&lt;"name:"&lt;&lt;add8.string()&lt;&lt;endl; &nbsp;// 通过string()得到它的字符串.</span></li><li><span class="name">add8.setTo(“Hello world”); &nbsp;// 字符串重新定义</span></li><li><span class="name">add8.append(" is good!”); &nbsp; // 另外一种连接字符串的方式</span></li><li><span class="name">cout&lt;&lt;String8::format("hello %c","world").string()&lt;&lt;endl; &nbsp;// 还可以这样.</span></li></ul></li><li><span class="name">字符串取长</span><ul><li><span class="name">uint strlen(const char *);   长度不包括结束符”\0”.</span></li></ul></li><li><span class="name">字符串去两边的空格</span><ul><li><span class="name">int stringTrim(char * p, char * buf){</span><ul><li><span class="name">int ret = 0, ncount = 0, begin = 0;</span></li><li><span class="name">int end =&nbsp;strlen(p) - 1;</span></li><li><span class="name">if (p == NULL || buf == NULL) {</span><ul><li><span class="name">return -1; &nbsp; &nbsp;// fail</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">while (isspace(p[begin]) &amp;&amp; p[begin] != '\0'){</span><ul><li><span class="name">begin++;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">while (isspace(p[end]) &amp;&amp; end&gt;0){</span><ul><li><span class="name">end--;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">ncount = end&nbsp;- begin&nbsp;+ 1;</span></li><li><span class="name">strncpy_s(buf, ncount + 1, p + i, ncount);</span></li><li><span class="name">buf[ncount] = '\0';</span></li><li><span class="name">return ret;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">字符串拼接</span><ul><li><span class="name">char *strcat(char *dest, const char *src); &nbsp; // 返回指向 dest 的指针.&nbsp;</span></li></ul></li><li><span class="name">字符串截取</span><ul><li><span class="name">char *strncpy(char *dest, char *src, int n); &nbsp; // 返回指向 dest 的指针. &nbsp;</span></li><li><span class="name">注意第三个参数 n 不包括结束符, 所以dest的size一定要不小于n+1.</span></li><li><span class="name">如果要实现截取从m开始到n的,可以这样做:</span></li><li><span class="name">strncpy(dest ,str + n , m-n);</span></li></ul></li><li><span class="name">字符串比较</span><ul><li><span class="name">int strcmp(const char *s1, const char *s2);</span></li><li><span class="name">返回值为0表示相等, 大于零表示 str1 比较大, 反之 str2 比较大.</span></li><li><span class="name">还有一种, strncmp(str1, str2, int n);   // 只比较前n个字符.</span></li></ul></li><li><span class="name">字符串查找</span><ul><li><span class="name">在字符串str1中定位字符串str2首次出现的位置</span><ul><li><span class="name">const char * strstr ( const char * str1, cosnt char *str2);   // 没有找到返回 NULL.</span></li></ul></li><li><span class="name">返回在字符串str1里找到字符串str2里的任意一个字符之前已查找的字符数量</span><ul><li><span class="name">size_t strcspn ( const char * str1, const char * str2);   // 不是太好理解,  例如:</span></li><li><span class="name">char *str = "Linux was first developed for 386/486-based pcs. “;</span></li><li><span class="name">printf("%d\n", strcspn(str, "1234567890"));</span></li><li><span class="name">返回值是:计算到出现数字字符为止, 所以返回"3"出现前的长度(有点像正则表达式)</span></li></ul></li><li><span class="name">在字符串str1里定位字符串str2里任意一个首次出现的字符: const char * strpbrk (const char * str1, const char * str2);</span></li><li><span class="name">返回字符串str1从开始字符到第一个不在str2中的字符个数: size_t strspn ( const char * str1, const char * str2);</span></li><li><span class="name">在指定内存里查找给定字符: void * memchr ( const void * str, int character, size_t num); // character为要找的字</span></li><li><span class="name">在指定字符串里定位给定字符: char * strchr ( const char * str, int character);</span></li><li><span class="name">在字符串里定位给定字符最后一次出现的位置: const char * strrchr ( const char * str, int character);</span></li></ul></li><li><span class="name">字符串替换</span><ul><li><span class="name">char *replacestr(char *strbuf, char *sstr, char *dstr){</span><ul><li><span class="name">char *p,*p1;</span></li><li><span class="name">int len;</span></li><li><span class="name">if ((strbuf == NULL)||(sstr == NULL)||(dstr == NULL)) return NULL;</span></li><li><span class="name">p = strstr(strbuf, sstr);</span></li><li><span class="name">if (p == NULL) return NULL;&nbsp;&nbsp;// 不包含子串则直接退出</span></li><li><span class="name">len = strlen(strbuf) + strlen(dstr) - strlen(sstr);</span></li><li><span class="name">p1 = malloc(len);</span></li><li><span class="name">bzero(p1, len);</span></li><li><span class="name">strncpy(p1, strbuf, p - strbuf);</span></li><li><span class="name">strcat(p1, dstr);</span></li><li><span class="name">p += strlen(sstr);</span></li><li><span class="name">strcat(p1, p);</span></li><li><span class="name">return p1;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">字符串切分</span><ul><li><span class="name">char *strtok(char *str, const char *delim); str为要切分的字符串，delim为分隔符字符串。</span></li><li><span class="name">返回值：从str开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。</span></li><li><span class="name">另外:&nbsp;strtok函数线程不安全，可以使用strtok_r替代。</span></li><li><span class="name">例子:</span></li><li><span class="name">char s[] = "Golden Global&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View,disk * desk";</span></li><li><span class="name">const char *d = " ,*";</span></li><li><span class="name">char *p;</span></li><li><span class="name">p = strtok(s,d);</span></li><li><span class="name">while(p)</span></li><li><span class="name">{</span><ul><li><span class="name">printf("%s\n",p);</span></li><li><span class="name">p=strtok(NULL,d);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">字符串的格式化输出</span><ul><li><span class="name">格式化输出:  int snprintf(char *str, size_t n, char * format [, argument, ...]); &nbsp;//&nbsp;将格式化的数据写入字符串.</span></li><li><span class="name">其中: str 为要写入的字符串；</span></li><li><span class="name">n 是要写入的数量;</span></li><li><span class="name">format 为格式化字符串，与printf()函数相同；</span><ul><li><span class="name">%d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十进制有符号整数</span></li><li><span class="name">%3d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;输出3位整型数, 不够3位右对齐.</span></li><li><span class="name">%04d&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位。</span></li><li><span class="name">%ld&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  &nbsp;输出长整型, 即long整数.</span></li><li><span class="name">%lld&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  &nbsp;输出long long整数.</span></li><li><span class="name">%-7d &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 输出7位整数,左对齐.</span></li><li><span class="name">%u &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十进制无符号整数</span></li><li><span class="name">%xhh, %XHH &nbsp; &nbsp; &nbsp;无符号以十六进制表示的整数.</span></li><li><span class="name">%0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  无符号以八进制表示的整数</span></li><li><span class="name">%f &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 浮点数</span></li><li><span class="name">%9.2f&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;输出场宽为9的浮点数, 其中小数位为2, 整数位为6, 小数点占一位, 不够9位右对齐。</span></li><li><span class="name">%lf &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 输出double浮点数</span></li><li><span class="name">%e &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指数形式的浮点数</span></li><li><span class="name">%s &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串</span></li><li><span class="name">%8s&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 输出8个字符的字符串, 不够8个字符右对齐。</span></li><li><span class="name">%6.9s &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出一个长度不小于6且不大于9的字符串。若大于9, 则多余内容将被删除。</span></li><li><span class="name">%-10s &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出10个字符, 左对齐.</span></li><li><span class="name">%c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单个字符</span></li><li><span class="name">%p &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针的值</span></li><li><span class="name">%g &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动选择合适的表示法</span></li></ul></li><li><span class="name">argument 为变量。</span></li><li><span class="name">类似函数还有:&nbsp;printf(), sprintf().&nbsp;</span></li></ul></li><li><span class="name">格式化输入</span><ul><li><span class="name">int sscanf( string str, string format, mixed var1, mixed var2 ... ); &nbsp; // 从字符串输入格式化字符串. 例如:</span><ul><li><span class="name">int a, b, c;</span></li><li><span class="name">sscanf("2006:03:18", "%d:%d:%d", a, b, c);</span></li></ul></li><li><span class="name">int scanf( const char *format [,argument]... ); &nbsp;  // 从屏幕输入格式化字符串.</span></li><li><span class="name">上面这两个函数的关键是参数format具有和正则表达式类似的功能. 其语法结构是:</span></li><li><span class="name">{%[*] [width] [{h | l | I64 | L}]type | ' ' | '\t' | '\n' | 非%符号}</span></li><li><span class="name">亦可用于格式中, (即 %*d 和 %*s) 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)</span></li><li><span class="name">{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。</span></li><li><span class="name">width表示读取宽度。</span></li><li><span class="name">{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。</span></li><li><span class="name">type :这就很多了，就是%s,%d之类。</span></li><li><span class="name">特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值</span></li><li><span class="name">支持集合操作：</span></li><li><span class="name">%[a-z] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)</span></li><li><span class="name">%[aB'] 匹配a、B、'中一员，贪婪性</span></li><li><span class="name">%[^a] 匹配非a的任意字符，贪婪性</span></li><li><span class="name">例1:</span></li><li><span class="name">取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span></li><li><span class="name">sscanf("123456abcdedfBCDEF", "%[^A-Z]", buf);</span></li><li><span class="name">printf("%s\n", buf);</span></li><li><span class="name">结果为：123456abcdedf</span></li><li><span class="name">例2:</span></li><li><span class="name">给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 "iios/"过滤掉，再将非'@'的一串内容送到buf中</span></li><li><span class="name">sscanf("iios/12DDWDFF@122", "%*[^/]/%[^@]", buf);</span></li><li><span class="name">printf("%s\n", buf);</span></li><li><span class="name">结果为：12DDWDFF</span></li></ul></li></ul></li><li><span class="name">对时间的处理</span><ul><li><span class="name">在c/c++中, 最小的计时单位是1毫秒.</span></li><li><span class="name"># include &lt;sys/time.h&gt;&nbsp;</span></li><li><span class="name">获取系统时间</span><ul><li><span class="name">long long getCurrentTime() {  // 返回微秒数(百万分之秒)</span><ul><li><span class="name">struct timeval tv;</span></li><li><span class="name">gettimeofday(&amp;tv, NULL); &nbsp; //&nbsp;gettimeofday()返回1970年1月1日到现在的时间.</span></li><li><span class="name">return <a class="contentLink" target="_blank" rel="noreferrer" href="http://tv.tv">tv.tv</a>_sec * 1000,000 + <a class="contentLink" target="_blank" rel="noreferrer" href="http://tv.tv">tv.tv</a>_usec;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">日历时间的两种格式</span><ul><li><span class="name">通过tm结构来获得日期和时间，tm结构在time.h中的定义如下：</span></li><li><span class="name">struct tm {</span><ul><li><span class="name">int tm_sec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 秒 – 取值区间为[0,59] */</span></li><li><span class="name">int tm_min;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 分 - 取值区间为[0,59] */</span></li><li><span class="name">int tm_hour;&nbsp;&nbsp;&nbsp;&nbsp;/* 时 - 取值区间为[0,23] */</span></li><li><span class="name">int tm_mday;&nbsp;&nbsp;&nbsp;&nbsp;/* 一个月中的日期 - 取值区间为[1,31] */</span></li><li><span class="name">int tm_mon;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</span></li><li><span class="name">int tm_year;&nbsp;&nbsp;&nbsp;&nbsp;/* 年份，其值等于实际年份减去1900 */</span></li><li><span class="name">int tm_wday;&nbsp;&nbsp;&nbsp;&nbsp;/* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></li><li><span class="name">int tm_yday;&nbsp;&nbsp;&nbsp;&nbsp;/* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */</span></li><li><span class="name">int tm_isdst;&nbsp;&nbsp;&nbsp;/* 夏令时标识符，实行夏令时的时候，tm_isdst为正不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负*/</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">这种时间表示叫分解时间(broken-down time).</span></li><li><span class="name">还有一种日历时间（Calendar Time）, 是通过time_t数据类型来表示的，用time_t表示的时间是从一个时间点（1970年1月1日0时0分0秒）到此时的秒数.</span></li><li><span class="name">typedef long time_t;  // 对time_t数据类型的值来说，它所表示的时间不能晚于2038年1月18日19时14分07秒.</span></li></ul></li><li><span class="name">时间格式间的转化</span><ul><li><span class="name">time_t mktime(struct tm * timeptr); &nbsp; // 将tm时间转化为time_t时间</span></li><li><span class="name">time_t time(time_t * timer); &nbsp; // 获取从指定的timer时间到现在的秒数</span></li><li><span class="name">char * asctime(const struct tm * timeptr); &nbsp;// 将tm时间转为字符串.</span></li><li><span class="name">char * ctime(const time_t *timer); &nbsp; &nbsp;// 将time_t时间转为字符串, 并遵循系统时间格式.</span></li></ul></li><li><span class="name">获取两个时间间的间隔:  double difftime(time_t time1, time_t time0); &nbsp; // 单位为秒.</span></li><li><span class="name">时区处理</span><ul><li><span class="name">struct tm * localtime(const time_t * timer); &nbsp; // 将time_t时间转化为当前系统时区下的tm时间</span></li><li><span class="name">struct tm * gmtime(const time_t *timer); &nbsp; // 将time_t时间转化为世界标准时间下的tm时间</span></li></ul></li><li><span class="name">自定义时间格式</span><ul><li><span class="name">使用 strftime（）函数将时间格式化为我们想要的格式. 它的原型如下：</span></li><li><span class="name">size_t strftime(char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);</span></li><li><span class="name">其中 format 支持的格式有好几十种. 此处不再累述.</span></li></ul></li></ul></li><li><span class="name">数组</span><ul><li><span class="name">数组的定义和遍历</span></li><li><span class="name">数组的size</span></li><li><span class="name">数组元素的访问</span></li><li><span class="name">数组元素的新增、删除</span></li><li><span class="name">排序</span></li><li><span class="name">不可变数组 Tuple</span></li></ul></li><li><span class="name">内存管理</span><ul><li><span class="name">内存模型</span><ul><li><span class="name">字节序</span><ul><li><span class="name">x86芯片字节序为低字节在低地址, 高字节在高地址. 即小头.</span></li><li><span class="name">arm芯片字节序为高字节在低地址, 低字节在高地址. 即大头.</span></li></ul></li><li><span class="name">读写寄存器</span><ul><li><span class="name">写一个Long: void WRITE_REGISTER_ULONG(PULONG Register, ULONG Value);</span></li><li><span class="name">其实现是: # define&nbsp;WRITE_REGISTER_ULONG(addr, val) (*(volatile UNIT32)*)(addr)=(val))</span></li><li><span class="name">addr是统一编址的内存地址, 寄存器资源在内存地址的具体映射由硬件定义.</span></li><li><span class="name">volatile为关键字, 表示本code不可因为寄存器的优化而忽略, 且要求每次都字节读取. 与硬件和中断打交道的代码, 千万不要忘记&nbsp;volatile.</span></li></ul></li><li><span class="name">android区分32位/64位的宏: # if defined(__LP64__)&nbsp;</span></li></ul></li><li><span class="name">内存申请</span></li><li><span class="name">内存释放</span></li><li><span class="name">内存拷贝</span></li><li><span class="name">内存清零</span></li><li><span class="name">内存比较</span></li></ul></li><li><span class="name">文件系统</span><ul><li><span class="name">获取系统目录/当前目录/跳转</span></li><li><span class="name">文件夹和文件的的存在性</span></li><li><span class="name">文件夹的新建/删除</span></li><li><span class="name">文件夹的遍历</span></li><li><span class="name">文件的新建/删除</span></li><li><span class="name">文件的读/写</span></li><li><span class="name">获取文件长度</span></li><li><span class="name">文件的改名/修改属性</span></li><li><span class="name">行读</span></li><li><span class="name">行写</span></li></ul></li><li><span class="name">类的进一步讨论</span><ul><li><span class="name">虚函数和纯虚函数</span><ul><li><span class="name">凡在子类中要重写的函数, 其类定义要加 virtual 关键字. 虚函数可以有实现, 如果子类没有覆盖, 则用父类的. 重写了, 则用子类的.</span></li><li><span class="name">没有加&nbsp;virtual 的, 子类不可覆盖.</span></li><li><span class="name">对于要求每个子类都实现的函数, 父类定义时应定义为纯虚函数. 形式是: virtual myFunc() = 0;</span></li><li><span class="name">如果 new 一个父类, 则纯虚函数就不存在. 所以永远不要 new 一个父类.</span></li></ul></li><li><span class="name">父类如何调用子类的函数?</span><ul><li><span class="name">不推荐这样做. 实在不行可通过new一个子类来访问.&nbsp;</span></li></ul></li><li><span class="name">子类不能调用父类的私有函数, 但可调用 protected 函数.</span></li><li><span class="name">友元函数和友元类</span><ul><li><span class="name">通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</span></li><li><span class="name">友元函数:友元函数是可以直接访问类的私有成员和受保护成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明. 声明格式是:</span><ul><li><span class="name">friend 类型 函数名(形式参数);</span></li></ul></li><li><span class="name">友元函数的声明可以放在类的任何位置, 没有区别. 数量也没有限制.</span></li><li><span class="name">友元类 ：友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类的私有成员和受保护成员。</span></li><li><span class="name">申明友元类的语句格式如下：</span><ul><li><span class="name">friend class 类名;</span></li></ul></li><li><span class="name">注意:&nbsp;友元关系不能被继承。父类的友元, 不是子类的友元.</span></li></ul></li></ul></li><li><span class="name">hash表</span><ul><li><span class="name">定义</span><ul><li><span class="name">android中, KeyedVector.h：定义使用关键字的向量模板KeyedVector. 用字符串key来随机访问数据.&nbsp;</span></li></ul></li><li><span class="name">size</span></li><li><span class="name">遍历</span></li><li><span class="name">元素的新增/修改/删除</span></li><li><span class="name">排序</span></li></ul></li><li><span class="name">字典</span></li><li><span class="name">链表</span></li><li><span class="name">高级数据结构: 二叉树/红黑树</span></li><li><span class="name">异常处理</span><ul><li><span class="name">为什么使用空指针会造成data abort？地址0难道不是一个合法的地址吗？</span><ul><li><span class="name">为了捕捉空指针错误，编译器故意将地址空间的最低部分设为不可使用的，因此任何时候使用地址0（以及极小的地址，比如地址13），都会产生错误。这个故意留的“空洞”一般为几K。</span></li></ul></li></ul></li><li><span class="name">UT</span></li><li><span class="name">平台兼容性</span></li><li><span class="name">泛型</span><ul><li><span class="name">C++模板分为函数模板和类模板.&nbsp;</span></li><li><span class="name">函数模板:  template &lt;class 形参1, class 形参2, …&gt; 返回值类型 函数名(参数列表) {…};  例如:</span><ul><li><span class="name">template &lt;class T&gt; void swap(T&amp; a, T&amp;b){</span><ul><li><span class="name">T c;</span></li><li><span class="name">c = a;</span></li><li><span class="name">a = b;</span></li><li><span class="name">b = c;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">使用时:</span><ul><li><span class="name">int a = 0, b = 1;</span></li><li><span class="name">swap(a, b);</span></li><li><span class="name">float c = 0.1, d = 0.2;</span></li><li><span class="name">swap(c, d);</span></li></ul></li><li><span class="name">类模板: template &lt;class 形参1, class 形参2, …&gt; class 类名 {…}; 例如:</span></li><li><span class="name">template &lt;class T&gt; class A {</span><ul><li><span class="name">public:</span></li><li><span class="name">A();</span></li><li><span class="name">T add(T a, T b);</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">template &lt;class T&gt; class A::add(T a, T b) {</span><ul><li><span class="name">return a+b;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">使用时:</span></li><li><span class="name">A&lt;int&gt; a;</span></li><li><span class="name">count &lt;&lt; a.add(2, 3)&lt;&lt;endl;</span></li></ul></li><li><span class="name">多线程</span><ul><li><span class="name">启动子线程</span><ul><li><span class="name"># include &lt;thread&gt;</span></li><li><span class="name">std::thread Reader(ReaderBlockedThread, mSynchronized, &amp;mFw);</span></li><li><span class="name">其中: Reader 为进程名</span></li><li><span class="name">ReaderBlockedThread 为全局函数</span></li><li><span class="name">mFw 为函数参数表</span></li><li><span class="name">Reader.<b>join</b>();  &nbsp;// join() 会阻塞当前线程, 知道Reader线程执行完毕后join()才会返回.</span></li></ul></li><li><span class="name">互斥锁</span><ul><li><span class="name">互斥类: Mutex; 例如:</span></li><li><span class="name">Mutex mLock;</span></li><li><span class="name">使用时:</span></li><li><span class="name">mLock.lock();</span></li><li><span class="name">mLock.unlock();</span></li><li><span class="name">还有一种利用对象的自动析构机制而实现的锁自动释放的形式:</span></li><li><span class="name">{ &nbsp; // 大括号不能少</span><ul><li><span class="name">AutoMutex _L(mLock);</span></li></ul></li><li><span class="name">} &nbsp; // 出大括号时锁自动失败.</span></li></ul></li></ul></li><li><span class="name">其它有意思的话题</span><ul><li><span class="name">这个宏定义为什么要写成do~while结构？有什么好处？</span><ul><li><span class="name"># define ErrChk(iserr)\</span></li><li><span class="name">do {\</span><ul><li><span class="name">if ((iserr) != 0) {\</span><ul><li><span class="name">ChkErrorFail(__FILE__,__LINE__, # iserr);\</span></li></ul></li><li><span class="name">}\</span></li></ul></li><li><span class="name">}while(0)</span></li></ul></li><li><span class="name">A1：假如不用do-while(0)：</span></li><li><span class="name"># define SOME_MACRO \</span><ul><li><span class="name">dosomething1(); \</span></li><li><span class="name">dosomething2();</span></li></ul></li><li><span class="name">if (i&gt;0)</span><ul><li><span class="name">SOME_MACRO</span></li></ul></li><li><span class="name">else</span><ul><li><span class="name">dosomething3();</span></li></ul></li><li><span class="name">试试看，编译能不能通过？</span></li><li><span class="name">你可能认为可以这样：</span></li><li><span class="name">if (i&gt;0) {</span><ul><li><span class="name">SOME_MACRO</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">else</span><ul><li><span class="name">dosomething3();</span></li></ul></li><li><span class="name">没错，但如果宏是你定义的，但由别人使用，能保证别人一定会怎么用吗？</span></li><li><span class="name">Q2：可以这样啊</span></li><li><span class="name"># define SOME_MACRO {\</span><ul><li><span class="name">dosomething1(); \</span></li><li><span class="name">dosomething2();\</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">A2：你这种写法在例子中是没错。但是，假设某个旧版本中：</span></li><li><span class="name"># define SOME_MACROdosomething()</span></li><li><span class="name">已经有很多应用了，此时你为了增强其功能而升级：</span></li><li><span class="name"># define SOME_MACRO \</span></li><li><span class="name">do { \</span><ul><li><span class="name">dosomething1(); \</span></li><li><span class="name">dosomething2(); \</span></li></ul></li><li><span class="name">} while(0)</span></li><li><span class="name">这样的兼容性就很好，但如果采用</span></li><li><span class="name"># define SOME_MACRO \</span></li><li><span class="name">{ \</span><ul><li><span class="name">dosomething1(); \</span></li><li><span class="name">dosomething2(); \</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">就不能保证其它的程序能正确编译，如</span></li><li><span class="name">if (i&gt;0)</span><ul><li><span class="name">SOME_MACRO; &nbsp;&nbsp;&nbsp;&nbsp;// 注意有分号</span></li></ul></li><li><span class="name">elses</span><ul><li><span class="name">dosomething3();</span></li></ul></li><li><span class="name">说白了，以前的宏定义是单语句，这样的宏定义一般习惯都不会带上分号，当你把宏升级成多语句时，最后也不能带上分号，但{...}表面上没有分号，实际上数据块等同于已经有了分号，所以编译时可能出错。</span></li></ul></li></ul>
  </body>
</html>