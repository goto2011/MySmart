<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>08-Log关键字</b></span></span><ul><li><span class="name"><span class="innerContentContainer">官方的Log注释</span></span><ul><li><span class="name"><span class="innerContentContainer">原生代码中其实有大量的关键log的文档. 这类文档叫 event.logtags.</span></span></li><li><span class="name"><span class="innerContentContainer">其数据格式是: event|1|5</span></span></li><li><span class="name"><span class="innerContentContainer">event表示含义;</span></span></li><li><span class="name"><span class="innerContentContainer">第一个数字表示数据类型, 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">1: int</span></span></li><li><span class="name"><span class="innerContentContainer">2: long</span></span></li><li><span class="name"><span class="innerContentContainer">3: string</span></span></li><li><span class="name"><span class="innerContentContainer">4: list</span></span></li><li><span class="name"><span class="innerContentContainer">5: float</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二个数字表示数据属性, 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">1: Number of objects</span></span></li><li><span class="name"><span class="innerContentContainer">2: Number of bytes</span></span></li><li><span class="name"><span class="innerContentContainer">3: Number of milliseconds</span></span></li><li><span class="name"><span class="innerContentContainer">4: Number of allocations</span></span></li><li><span class="name"><span class="innerContentContainer">5: Id</span></span></li><li><span class="name"><span class="innerContentContainer">6: Percent</span></span></li><li><span class="name"><span class="innerContentContainer">s: Number of seconds (monotonic time)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>结构化分析log的能力</b></span></span><ul><li><span class="name"><span class="innerContentContainer">1. 寻找指定应用PID, 过滤其Log --用于复现问题抓log，快速定位</span></span><ul><li><span class="name"><span class="innerContentContainer">寻找指定应用PID的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep 'Start proc' "   // 用于启动应用的场景</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell "top | grep 'com.android.settings' "   // 用于应用已经启动起来的场景.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抓指定PID的log</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat -c"   // 清旧Log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep &lt;PID&gt; " &gt; 1.log</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 确定应用线程和包名</span></span><ul><li><span class="name"><span class="innerContentContainer">Start proc</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager: Start proc \d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 如果上面这个不行，原因是进程启动发生在log窗口之前，那么使用页面切换log.</span></span><ul><li><span class="name"><span class="innerContentContainer">START u0</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager: START u0&nbsp;{\w+ com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. 跟踪页面切换流。这个对跟踪用户操作流，进而理解问题本质价值很大</span></span><ul><li><span class="name"><span class="innerContentContainer">Relayout Window</span></span></li><li><span class="name"><span class="innerContentContainer">WindowManager: Relayout Window{\w+ &nbsp;u0 com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 针对稳定性问题，跟踪AMS杀进程的流程   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Killing|am_kill</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager:&nbsp;Killing&nbsp;\d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 时刻关注丢帧, GC, Log溢出的情况, 因为系统资源衰竭的时候, 各种奇怪的事都会发生</span></span><ul><li><span class="name"><span class="innerContentContainer">垃圾回收： Starting a blocking GC Alloc|GC freed|am_low_memory</span></span></li><li><span class="name"><span class="innerContentContainer">丢帧： Choreographer: Skipped</span></span><ul><li><span class="name"><span class="innerContentContainer">当掉帧数超过SKIPPED_FRAME_WARNING_LIMIT（默认30帧）时会打印.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log溢出： identical</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 警惕binder异常  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,<a class="contentLink" target="_blank" rel="noreferrer" href="http://com.starbucks.cn">com.starbucks.cn</a>,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span></li><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer"><b>940: delay的时长(单位: 毫秒)   --这个非常关键.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://com.starbucks.cn">com.starbucks.cn</a>: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比.</span></span></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Input  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://blog.csdn.net/DroidPhone/article/details/8432055">https://blog.csdn.net/DroidPhone/article/details/8432055</a></span></span></li><li><span class="name"><span class="innerContentContainer">常规： Inputreader|inputdispatcher|eventhub|inputmanager_dispatch|InputTransport|PhoneWindowManager|processMotionEvent</span></span></li><li><span class="name"><span class="innerContentContainer">View 处理触摸事件： processMotionEvent </span></span><ul><li><span class="name"><span class="innerContentContainer">Input log开关不打开时，这个打印也有，所以方便。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>input rawdata： Input event</b></span></span><ul><li><span class="name"><span class="innerContentContainer">其中，device 即设备ID</span></span></li><li><span class="name"><span class="innerContentContainer">Type, 事件类型.</span></span><ul><li><span class="name"><span class="innerContentContainer">0, EV_SYN，同步事件。因为一个事件要保上报多次，所以需要同步事件来确认整个事件上报完毕。</span></span></li><li><span class="name"><span class="innerContentContainer">1, EV_KEY，描述键盘，按键或者类似键盘设备的状态变化。</span></span></li><li><span class="name"><span class="innerContentContainer">2, EV_REL，用来描述相对坐标轴上数值的变化，例如：鼠标向左方移动了5个单位。</span></span></li><li><span class="name"><span class="innerContentContainer">3, EV_ABS, 用来描述坐标轴上数值的变化，例如：描述触摸屏上坐标的值。</span></span></li><li><span class="name"><span class="innerContentContainer">4, EV_MSC, 当不能匹配现有的类型时，使用该类型。</span></span></li><li><span class="name"><span class="innerContentContainer">5, EV_SW, 描述具备两种状态的输入开关。</span></span></li><li><span class="name"><span class="innerContentContainer">17, EV_LED, 控制设备上的LED灯的开和关。</span></span></li><li><span class="name"><span class="innerContentContainer">18, EV_SND, 用来给设备输出提示声音。</span></span></li><li><span class="name"><span class="innerContentContainer">20, EV_REP, 用于可以自动重复的设备（autorepeating）。</span></span></li><li><span class="name"><span class="innerContentContainer">21, EV_FF, 用来给输入设备发送强制回馈命令。</span></span></li><li><span class="name"><span class="innerContentContainer">22, EV_PWR, 用于电源开关的输入。</span></span></li><li><span class="name"><span class="innerContentContainer">23, EV_FF_STATUS, 用于接收设备的强制反馈状态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">code，指键值，即键的ID. 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">code值依赖 type字段, 相当于type的进一步说明.</span></span></li><li><span class="name"><span class="innerContentContainer">EV_KEY</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式，比如，KEY_A代表键盘上的A键.</span></span></li><li><span class="name"><span class="innerContentContainer">当一个按键被按下时，一个带有按键编码和value为1的事件被发出。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个按键被释放时，一个value为0的事件被发出。</span></span></li><li><span class="name"><span class="innerContentContainer">有些硬件当按键重复时会发出事件，这些事件的value值为2。</span></span></li><li><span class="name"><span class="innerContentContainer">通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。</span></span></li><li><span class="name"><span class="innerContentContainer">几个特殊的codes:</span></span></li><li><span class="name"><span class="innerContentContainer">116, 0x74, power键</span></span></li><li><span class="name"><span class="innerContentContainer">115, 0x73, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">114, 0x72, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_&lt;name&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">BTN_TOOL_PEN, 0x140</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_RUBBER, 0x141</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_BRUSH, 0x142</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_PENCIL, 0x143</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_AIRBRUSH, 0x144</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_FINGER, 0x145</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_MOUSE, 0x146</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_LENS, 0x147</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_QUINTTAP, 0x148</span></span></li><li><span class="name"><span class="innerContentContainer">这些codes用于配合触控板，平板和触摸屏这些设备的输入，这些设备可以使用手指，笔或者其它工具。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个事件发生并且检测到某种工具在使用时，相应的BTN_TOOL_&lt;name&gt; code事件应该把value设为1，</span></span></li><li><span class="name"><span class="innerContentContainer">当该工具不再和输入设备进行交互时，value应该复位为0。</span></span></li><li><span class="name"><span class="innerContentContainer">所有的触控板，当事件发生时，平板和触摸屏映泰至少使用一种BTN_TOOL_&lt;name&gt; code。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">0x14a, BTN_TOUCH, 触摸屏</span></span><ul><li><span class="name"><span class="innerContentContainer">用于触摸事件。当一个输入工具被判定为有意义的物理接触时，这一特性的value值应该设为1。</span></span></li><li><span class="name"><span class="innerContentContainer">所谓有意义的物理接触可以是任何的接触，又或者是满足某种定义条件的接触。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，触摸板可以当触摸的压力达到某一个值以上时才把value设为1，一个用笔的平板当笔划过但没有接触到平板的表面时，把BTN_TOOL_PEN的value设为1，而把BTN_TOUCH的value设为0.</span></span></li><li><span class="name"><span class="innerContentContainer">出于历史的原因，用户空间会把带有BTN_TOOL_FINGER和 BTN_TOUCH的触摸设备解释为触摸板，而类似的不带BTN_TOOL_FINGER的触摸设备则被解释为触摸屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">0x14b，BTN_STYLUS, 手写笔</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP,BTN_TOOL_TRIPLETAP, BTN_TOOL_QUADTAP</span></span><ul><li><span class="name"><span class="innerContentContainer">这些codes表明一个，两个，三个和四个手指参与触摸板和触摸屏的操作。</span></span></li><li><span class="name"><span class="innerContentContainer">如果用户使用两只手指在触摸板上试图滚动屏幕上的内容，在运动期间，应该发送value为1的BTN_TOOL_DOUBLETAP。</span></span></li><li><span class="name"><span class="innerContentContainer">在多手指触摸驱动中，应该使用input_mt_report_finger_count()函数来发出以上这些codes，详情请参看内核文档：multi-touch-protocol.txt。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EV_REL</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_REL事件描述了某种特性的相对变化量。例如，鼠标向左方移动了几个单位距离，但是他的绝对位置是未知的。</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们可以知道绝对位置，那我们应该使用EV_ABS而不是EV_REL。</span></span></li><li><span class="name"><span class="innerContentContainer">下面这些属于EV_REL的codes有特别的意义：</span></span></li><li><span class="name"><span class="innerContentContainer">REL_WHEEL, REL_HWHEEL:</span></span><ul><li><span class="name"><span class="innerContentContainer">用于对应的垂直方向和水平方向的滚轮。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EV_ABS</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_ABS事件描述了某一特性的绝对变化值，例如，触摸板会用它发出当前位置的绝对坐标值。</span></span></li><li><span class="name"><span class="innerContentContainer">以下这些属于EV_ABS的 codes有特殊的意义：</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_DISTANCE:</span></span></li><li><span class="name"><span class="innerContentContainer">用来描述触摸工具离触摸表面的距离。这一事件应该只有当触摸工具在表面悬空滑过时发出，也就是说，在靠经触摸表面，但是BTN_TOUCH的value是0的时候。如果输入设备可以工作在3维坐标时，应该考虑使用ABS_Z会更好。</span></span><ul><li><span class="name"><span class="innerContentContainer">ABS_MT_&lt;name&gt;:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用于描述多手指触摸输入设备。详情请参考内核文档：multi-touch-protocol.txt。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">value，指具体值</span></span><ul><li><span class="name"><span class="innerContentContainer">1 表示按下</span></span></li><li><span class="name"><span class="innerContentContainer">0 表示抬起</span></span></li><li><span class="name"><span class="innerContentContainer">触摸事件时，value表示坐标。x, y轴是分开上报的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件上报： notifyMotion|notifyKey|dispatchMotion|dispatchKey</b></span></span><ul><li><span class="name"><span class="innerContentContainer">分为两组，前者在入队列前打印，后两者在分发前打印。两组内容基本一样，仅policyFlags可能会发生变化。</span></span></li><li><span class="name"><span class="innerContentContainer">各枚举字段的含义在 input.h 中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">eventTime, 事件上报时间</span></span></li><li><span class="name"><span class="innerContentContainer">downTime, down事件时间。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，所有非down的事件，它的downTime不等于自己的eventTime，而是等于上一次的eventTime。</span></span></li><li><span class="name"><span class="innerContentContainer">凡是不满足这个条件的，都是非法事件，会被过滤掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">deviceId： 设备id。即hal层input设备id。</span></span><ul><li><span class="name"><span class="innerContentContainer">R版本上，注入的事件统一设置为-1。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">source，设备类型</span></span><ul><li><span class="name"><span class="innerContentContainer">触屏： 0x1002</span></span></li><li><span class="name"><span class="innerContentContainer">键盘： 0x101</span></span></li><li><span class="name"><span class="innerContentContainer">鼠标： 0x2002</span></span></li><li><span class="name"><span class="innerContentContainer">手写笔： 0x4002</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">policyFlags： 即wms窗口策略。 重要</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 保持系统唤醒</span></span></li><li><span class="name"><span class="innerContentContainer">2, 是虚拟导航按键</span></span></li><li><span class="name"><span class="innerContentContainer">4, 是特殊功能修饰健（Ctrl、shift 之类）</span></span></li><li><span class="name"><span class="innerContentContainer">8, </span></span></li><li><span class="name"><span class="innerContentContainer">0x100 0000，注入的事件</span></span></li><li><span class="name"><span class="innerContentContainer">0x200 0000，可信的</span></span></li><li><span class="name"><span class="innerContentContainer">0x400 0000， 过滤的</span></span></li><li><span class="name"><span class="innerContentContainer">0x800 0000， 禁用自动重复事件。</span></span></li><li><span class="name"><span class="innerContentContainer">0x2000 0000，交互的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">0x4000 0000，事件要传递到应用层，即 PASS_TO_USER.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">action: 事件类型。重要。</span></span><ul><li><span class="name"><span class="innerContentContainer">0： down</span></span></li><li><span class="name"><span class="innerContentContainer">1： up</span></span></li><li><span class="name"><span class="innerContentContainer">2： move</span></span></li><li><span class="name"><span class="innerContentContainer">3： cancel</span></span></li><li><span class="name"><span class="innerContentContainer">4： outside</span></span></li><li><span class="name"><span class="innerContentContainer">7： hover move</span></span></li><li><span class="name"><span class="innerContentContainer">9： hover enter</span></span></li><li><span class="name"><span class="innerContentContainer">10： hover exit</span></span></li><li><span class="name"><span class="innerContentContainer">11： button press</span></span></li><li><span class="name"><span class="innerContentContainer">12： button release</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">actionButton： 按键类型，比如左键、中键、右键之类。</span></span></li><li><span class="name"><span class="innerContentContainer">flags： </span></span><ul><li><span class="name"><span class="innerContentContainer">对于触摸事件，用于标记点位发生在屏幕边界，分上下左右。--不常用。</span></span></li><li><span class="name"><span class="innerContentContainer">对于按键事件，这个字段重要多了。</span></span><ul><li><span class="name"><span class="innerContentContainer">2，软键盘产生的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">8, 事件来自系统，不可被应用屏蔽。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Precision: 分x、y轴, 屏幕密度，一般是1。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>keyCode: 按键键值(逻辑)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">在 Keycodes.h 和 KeyEvent.java 中定义，两者保持一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">在 InputEventLabels.h 中引用。如果要修改，这三处要保持一致。</span></span></li><li><span class="name"><span class="innerContentContainer">fwk和应用使用keyCode。</span></span></li><li><span class="name"><span class="innerContentContainer">3, KeyCode_HOME</span></span></li><li><span class="name"><span class="innerContentContainer">4, KeyCode_BACK</span></span></li><li><span class="name"><span class="innerContentContainer">187，0xbb, KeyCode_APP_SWITCH</span></span></li><li><span class="name"><span class="innerContentContainer">24, 0x18, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">25, 0x19, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">26, 0x1a, power键</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>scanCode: 按键键值(硬件)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">输入设备上报的值。在 framework/base/data/keyboards 目录下的各 *.kl 文件中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">116, 0x74, power键</span></span></li><li><span class="name"><span class="innerContentContainer">115, 0x73, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">114, 0x72, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">158, 0x9e, back键</span></span></li><li><span class="name"><span class="innerContentContainer">102, 0x66, home键</span></span></li><li><span class="name"><span class="innerContentContainer">580, 0x244, app switch键</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">metaState: 键盘，标识 Ctrl、ALT等按键的状态。 参见 ameta_none</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>触摸屏报点： Pointer</b></span></span><ul><li><span class="name"><span class="innerContentContainer">id：点的序号，从0开始，一些input事件有多个点。</span></span></li><li><span class="name"><span class="innerContentContainer">toolType： 触摸工具类型。</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 手指</span></span></li><li><span class="name"><span class="innerContentContainer">2, 手写笔</span></span></li><li><span class="name"><span class="innerContentContainer">3, 鼠标</span></span></li><li><span class="name"><span class="innerContentContainer">4, 橡皮擦 ？</span></span></li><li><span class="name"><span class="innerContentContainer">5, 手掌 ？</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">x, y： 点坐标</span></span></li><li><span class="name"><span class="innerContentContainer">pressure: 按下压力值。用于按压屏或者手写笔。</span></span></li><li><span class="name"><span class="innerContentContainer">size： 触摸区域的大小（近似值）。0到1之间。</span></span></li><li><span class="name"><span class="innerContentContainer">touchMajor, tohchMinor, 触摸区域的长轴和短轴（单位为像素）</span></span></li><li><span class="name"><span class="innerContentContainer">toolMajor, toolMinor, 触摸根工具的长轴和短轴 （单位为像素）</span></span></li><li><span class="name"><span class="innerContentContainer">这4个值一般一样。</span></span></li><li><span class="name"><span class="innerContentContainer">orientation: 屏幕方向，0表示竖屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">channel 发送事件的流程</span></span><ul><li><span class="name"><span class="innerContentContainer">enqueueDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">prepareDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">startDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">publishMotionEvent</span></span></li><li><span class="name"><span class="innerContentContainer">finishDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">sendFinishedSignal</span></span></li><li><span class="name"><span class="innerContentContainer">receiveFinishedSignal </span></span><ul><li><span class="name"><span class="innerContentContainer">注意，errno=11 并不是什么错误。意思是当前处理过程被其它进程打断，后续调度回来会继续处理，不会影响业务。这种错误id很常见。</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">取得焦点窗口： Focus entered window</span></span></li><li><span class="name"><span class="innerContentContainer"><b>事件注入： injectInputEvent|should inject</b></span></span><ul><li><span class="name"><span class="innerContentContainer">injectorPid: 注入线程id</span></span></li><li><span class="name"><span class="innerContentContainer">injectorUid: 注入线程uid</span></span></li><li><span class="name"><span class="innerContentContainer">Finished with result to 0: 注入成功。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件拦截： interceptKeyBeforeQueueing|interceptKeyBeforeDispatching</span></span></li><li><span class="name"><span class="innerContentContainer">事件cancel： InputDispatcher: cancel</span></span><ul><li><span class="name"><span class="innerContentContainer">各字段含义和 notify Motion相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件cancel的原因：cancellation events</span></span><ul><li><span class="name"><span class="innerContentContainer">其中，channel, cancel</span></span></li><li><span class="name"><span class="innerContentContainer">synthesized，被cancel的事件的数量</span></span></li><li><span class="name"><span class="innerContentContainer">mode，cancel模式</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 点事件</span></span></li><li><span class="name"><span class="innerContentContainer">2, 非点事件</span></span></li><li><span class="name"><span class="innerContentContainer">3, callback事件</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件被跳过： skipping inconsistent motion event</span></span></li><li><span class="name"><span class="innerContentContainer">事件删除： Dropping</span></span><ul><li><span class="name"><span class="innerContentContainer">第二个关键字是删除原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件过滤： filter|shouldInterceptEventLocked </span></span></li><li><span class="name"><span class="innerContentContainer">事件冲突： Conflicting pointer actions</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">设备识别： Device added|New device|Input event</span></span><ul><li><span class="name"><span class="innerContentContainer">其中，id 后面用得比较多。</span></span></li><li><span class="name"><span class="innerContentContainer">classes 为设备类型，为掩码量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">光标显示： unfade|fade|cursor</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏切换： Device reconfigured</span></span><ul><li><span class="name"><span class="innerContentContainer">其中，size： 屏幕坐标</span></span></li><li><span class="name"><span class="innerContentContainer">orientation： 0表示竖屏, 1表示横屏。</span></span></li><li><span class="name"><span class="innerContentContainer">mode： 设备模式，参见 DeviceMode.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>稳定性  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">crash开始： beginning of crash</span></span></li><li><span class="name"><span class="innerContentContainer"><b>AMS杀进程: Killing|am_kill</b></span></span><ul><li><span class="name"><span class="innerContentContainer">am_kill 是event log，数据是：</span></span><ul><li><span class="name"><span class="innerContentContainer"> (User|1|5), (PID|1|5), (Process Name|3), (OomAdj|1|5), (<b>Reason</b>|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Killing 是logcat。</span></span></li><li><span class="name"><span class="innerContentContainer">这两个log是一一对应的。</span></span></li><li><span class="name"><span class="innerContentContainer">最有价值的字段是reason。常见的有几种：</span></span><ul><li><span class="name"><span class="innerContentContainer">user request after error： 进程遇到错误自杀.</span></span></li><li><span class="name"><span class="innerContentContainer">empty: 空进程</span></span></li><li><span class="name"><span class="innerContentContainer">remove task: </span></span></li><li><span class="name"><span class="innerContentContainer">stop: 被强制杀死。比如通过 adb shell kill 这种。</span></span></li><li><span class="name"><span class="innerContentContainer">anr： 应用失去响应</span></span></li><li><span class="name"><span class="innerContentContainer">scheduleCrash for: 进程之前已经死掉</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中间的数字是adj。999就是空进程。</span></span></li><li><span class="name"><span class="innerContentContainer">如果杀进程的log太多，可只看指定进程的：</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager:&nbsp;Killing&nbsp;\d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用crash: am_crash</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Exception|3), (Message|3), (File|3), (Line|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ANR： ANR in|Input event dispatching timed out</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟机重启（进程会退出）： shutting down vm</span></span></li><li><span class="name"><span class="innerContentContainer">一级crash： crash|fatal|backtrace|died|goodbye|Androidruntime|am_crash|service crashed|java.lang.runtimeexception|exit zygote|Death received|am_proc_died|Sending signal</span></span></li><li><span class="name"><span class="innerContentContainer">二级crash：Err|fail|unexpected|system.err|java.lang|Systrace</span></span></li><li><span class="name"><span class="innerContentContainer">卡死冻屏: held by|blocked|caused by|locked|waiting on|locked</span></span></li><li><span class="name"><span class="innerContentContainer">activity ANR: am_anr</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (pid|1|5), (Package Name|3), (Flags|1|5), (reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_wtf: </span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Tag|3), (Message|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程短时间crash多次： am_process_crashed_too_much</span></span></li><li><span class="name"><span class="innerContentContainer">Watchdog</span></span><ul><li><span class="name"><span class="innerContentContainer">进程踢狗: tickle (authority|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog (Service|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_proc_pss (Process|3),(Pid|1|5),(Pss|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_soft_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2),(Skip|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_hard_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_pss_stats (EmptyPss|1|2),(EmptyCount|1|1),(BackgroundPss|1|2),(BackgroundCount|1|1),(ServicePss|1|2),(ServiceCount|1|1),(VisiblePss|1|2),(VisibleCount|1|1),(ForegroundPss|1|2),(ForegroundCount|1|1),(NoPssCount|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_proc_stats (DeathsInOne|1|1),(DeathsInTwo|1|1),(DeathsInThree|1|1),(DeathsInFour|1|1),(DeathsInFive|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_scheduled_reboot (Now|2|1),(Interval|1|3),(StartTime|1|3),(Window|1|3),(Skip|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_meminfo (MemFree|1|2),(Buffers|1|2),(Cached|1|2),(Active|1|2),(Inactive|1|2),(AnonPages|1|2),(Mapped|1|2),(Slab|1|2),(SReclaimable|1|2),(SUnreclaim|1|2),(PageTables|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_vmstat (runtime|2|3),(pgfree|1|1),(pgactivate|1|1),(pgdeactivate|1|1),(pgfault|1|1),(pgmajfault|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_requested_reboot (NoWait|1|1),(ScheduleInterval|1|3),(RecheckInterval|1|3),(StartTime|1|3),(Window|1|3),(MinScreenOff|1|3),(MinNextAlarm|1|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低内存杀进程: killinfo</span></span><ul><li><span class="name"><span class="innerContentContainer">(Pid|1|5), (Uid|1|5), (OomAdj|1), (MinOomAdj|1), (TaskSize|1), (enum kill_reasons|1|5), (MemFree|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(Cached|1), (SwapCached|1), (Buffers|1), (Shmem|1), (Unevictable|1), (SwapTotal|1), (SwapFree|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(ActiveAnon|1), (InactiveAnon|1), (ActiveFile|1), (InactiveFile|1), (SReclaimable|1), (SUnreclaim|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(KernelStack|1), (PageTables|1), (IonHeap|1), (IonHeapPool|1), (CmaFree|1), (MsSinceEvent|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(MsSincePrevWakeup|1), (WakeupsSinceEvent|1), (SkippedWakeups|1)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>性能  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">丢帧： Choreographer: Skipped</span></span><ul><li><span class="name"><span class="innerContentContainer">当掉帧数超过SKIPPED_FRAME_WARNING_LIMIT（默认30帧）时会打印.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log溢出： identical</span></span></li><li><span class="name"><span class="innerContentContainer">CPU占用率: cpu</span></span><ul><li><span class="name"><span class="innerContentContainer">(total|1|6),(user|1|6),(system|1|6),(iowait|1|6),(irq|1|6),(softirq|1|6)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU占用率： CPU usage</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存  <span class="contentTag" title="Filter #问题内存">#<span class="contentTagText">问题内存</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">内存信息： am_meminfo</span></span><ul><li><span class="name"><span class="innerContentContainer">数据：(Cached|2|2), (Free|2|2), (Zram|2|2), (Kernel|2|2), (Native|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">pss信息： am_pss</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： (Pid|1|5), (UID|1|5), (Process Name|3), (Pss|2|2), (Uss|2|2), (SwapPss|2|2), (Rss|2|2), (StatType|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(ProcState|1|5), </span></span><ul><li><span class="name"><span class="innerContentContainer">进程状态，参见 ActivityManager.h. 其中2表示前台进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">(TimeToCollect|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">垃圾回收： Starting a blocking GC Alloc|GC freed|am_low_memory</span></span></li><li><span class="name"><span class="innerContentContainer">强制垃圾回收: force_gc (reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Sensor<b>  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">hal层上报数据：sensors-hal|ap_sensors</span></span></li><li><span class="name"><span class="innerContentContainer">服务： SensorManager|SensorService</span></span></li><li><span class="name"><span class="innerContentContainer">接近光： proximity</span></span></li><li><span class="name"><span class="innerContentContainer">加速度： accelerometer</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>应用进程  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">应用启动： Start proc|New app record|am_proc_start|am_pre_boot</span></span></li><li><span class="name"><span class="innerContentContainer">进程处理事件： handleMessage, what   --有的有, 有的没有.</span></span></li><li><span class="name"><span class="innerContentContainer">Usb对话框： showMtpDialog : mode</span></span></li><li><span class="name"><span class="innerContentContainer">应用清理（会造成应用退出）： Clearing app   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">attach进程失败(找不到pid)： am_drop_process  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Task 被压缩: am_compact</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (Pid|1|5),(Process Name|3),(Action|3),(BeforeRssTotal|2|2),(BeforeRssFile|2|2),(BeforeRssAnon|2|2),(BeforeRssSwap|2|2),(DeltaRssTotal|2|2),(DeltaRssFile|2|2),(DeltaRssAnon|2|2),(DeltaRssSwap|2|2),(Time|2|3),(LastAction|1|2),(LastActionTimestamp|2|3),(setAdj|1|2),(procState|1|2),(BeforeZRAMFree|2|2),(DeltaZRAMFree|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">any processes of a uid have started running:  am_uid_running</span></span></li><li><span class="name"><span class="innerContentContainer">all processes of a uid have stopped:  am_uid_stopped</span></span></li><li><span class="name"><span class="innerContentContainer">the state of a uid has become active:  am_uid_active</span></span></li><li><span class="name"><span class="innerContentContainer">the state of a uid has become idle (background check enforced):  am_uid_idle</span></span></li><li><span class="name"><span class="innerContentContainer">a service is being forcibly stopped because its app went idle:  am_stop_idle_service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Activity <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">新建activity： Relayout Window|DecorView setVisibility</span></span></li><li><span class="name"><span class="innerContentContainer">activity启动： start U0|am_create_task|am_create_activity|am_restart_activity|am_on_create_called|am_on_start_called|am_on_restart_called|am_relaunch_resume_activity|am_relaunch_activity</span></span></li><li><span class="name"><span class="innerContentContainer">Activity 显示到界面上：am_task_to_front|am_resume_activity|am_on_resume_called|Displayed</span></span></li><li><span class="name"><span class="innerContentContainer">启动activity耗时: am _activity_launch_time  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">activity绘制时间： am_activity_fully_drawn_time|am_activity_launch_time  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">am_activity_launch_time:[0,225986022, com.android.camera/.Camera, 19823]</span></span></li><li><span class="name"><span class="innerContentContainer">其中 19823 是绘制的毫秒数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">已经存在的activity接受新的intent: am_new_intent</span></span><ul><li><span class="name"><span class="innerContentContainer">数据结构: (User|1|5),(Token|1|5),(Task ID|1|5),(Component Name|3),(Action|3),(MIME Type|3),(URI|3),(Flags|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity结束： am_finish_activity|am_destroy_activity|am_stop_activity|am_on_stop_called|am_on_destroy_called</span></span><ul><li><span class="name"><span class="innerContentContainer">am_destroy_activity 有reasen字段.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity从栈中被移除： am_remove_task</span></span><ul><li><span class="name"><span class="innerContentContainer">数据是两个整数，前者是task id，后者是stack id。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Application 线程绑定到工作队列: am_proc_bound</span></span></li><li><span class="name"><span class="innerContentContainer">Stack focus: am_focused_stack</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (Display Id|1|5), (Focused Stack Id|1|5), (Last Focused Stack Id|1|5), (Reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">The activity's onTopResumedActivityChanged(true) has been called: am_on_top_resumed_gained_called</span></span></li><li><span class="name"><span class="innerContentContainer">The activity's onTopResumedActivityChanged(false) has been called:  am_on_top_resumed_lost_called</span></span></li><li><span class="name"><span class="innerContentContainer">An activity been add into stopping list: am_add_to_stopping</span></span></li><li><span class="name"><span class="innerContentContainer">回调onActivityResult: am_on_activity_result_called</span></span></li><li><span class="name"><span class="innerContentContainer">暂停activity: am_pause_activity|am_on_paused_called|am_set_resumed_activity</span></span></li><li><span class="name"><span class="innerContentContainer">activity启动异常: am_proc_bad|am_process_start_timeout|am_failed_to_pause</span></span></li><li><span class="name"><span class="innerContentContainer">activity恢复正常: am_proc_good</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Window / View  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>焦点窗口切换</b>： Set focused app to|Changing focus from</span></span></li><li><span class="name"><span class="innerContentContainer">创建task stack： wm_stack_created</span></span><ul><li><span class="name"><span class="innerContentContainer">StackId: 指activity task ID</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将window移动到top 或 bottom： wm_task_moved</span></span><ul><li><span class="name"><span class="innerContentContainer">(TaskId|1|5), (ToTop|1), (Index|1)</span></span></li><li><span class="name"><span class="innerContentContainer">Totop: 1表示top，0表示bottom</span></span></li><li><span class="name"><span class="innerContentContainer">index： target position的值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">横竖屏切换： orientation </span></span><ul><li><span class="name"><span class="innerContentContainer">0, 竖屏； 1, 横屏</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">移除task： wm_task_removed</span></span><ul><li><span class="name"><span class="innerContentContainer">(TaskId|1|5),  (Reason|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Reason: 移除原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">窗口大小： Rect</span></span></li><li><span class="name"><span class="innerContentContainer">surfaces内存溢出: wm_no_surface_memory (Window|3),(PID|1|5),(Operation|3)  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">bootanim finished: wm_boot_animation_done (time|2|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏 / 唤醒睡眠 / 屏幕亮度<b>  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">亮灭屏原因： power_screen_state</span></span><ul><li><span class="name"><span class="innerContentContainer">1. offOrOn: 0, 灭；1，亮</span></span></li><li><span class="name"><span class="innerContentContainer">2. because: 亮灭屏原因</span></span><ul><li><span class="name"><span class="innerContentContainer">参见 PowerManager.java， 300行。</span></span></li><li><span class="name"><span class="innerContentContainer">亮屏</span></span><ul><li><span class="name"><span class="innerContentContainer">0, 其它原因</span></span></li><li><span class="name"><span class="innerContentContainer">1, 按键</span></span></li><li><span class="name"><span class="innerContentContainer">2, 应用</span></span></li><li><span class="name"><span class="innerContentContainer">3, 设备插入</span></span></li><li><span class="name"><span class="innerContentContainer">4, 手势</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灭屏</span></span><ul><li><span class="name"><span class="innerContentContainer">0, 应用请求</span></span></li><li><span class="name"><span class="innerContentContainer">2, 屏幕超时</span></span></li><li><span class="name"><span class="innerContentContainer">4, power键</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏： onScreenChanged|PowerManagetService</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕亮灭: <b>screen_toggled</b> (screen_state|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">0 : screen off</span></span></li><li><span class="name"><span class="innerContentContainer">1 : screen on</span></span></li><li><span class="name"><span class="innerContentContainer">2 : 已锁屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏广播： power_screen_broadcast_send|power_screen_broadcast_done</span></span><ul><li><span class="name"><span class="innerContentContainer">wakelockCount: 发送广播的数量</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕亮度变化： Brightness</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕亮度变化： auto_brightness_adj</span></span><ul><li><span class="name"><span class="innerContentContainer">其中, old_lux: 旧的环境光度</span></span></li><li><span class="name"><span class="innerContentContainer">old_brightness： 旧的屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer">new_lux：新的环境光度</span></span></li><li><span class="name"><span class="innerContentContainer">new_brightness： 新的屏幕亮度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ams点亮屏幕（开机过程）： boot_progress_enable_screen (数字是毫秒数)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService calls enableScreenAfterBoot().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灭屏时被清空的应用持有唤醒数量： power_sleep_requested</span></span></li><li><span class="name"><span class="innerContentContainer">锁屏类型: lock_screen_type (type|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统</span></span><ul><li><span class="name"><span class="innerContentContainer">音量调节： volume_changed| VOLUME_CHANGED_ACTION</span></span></li><li><span class="name"><span class="innerContentContainer">开机动画播放完成： wm_boot_animation_done  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">允许安装未知来源的应用： unknown_sources_enabled</span></span><ul><li><span class="name"><span class="innerContentContainer">1为允许</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">恢复出厂设置</span></span><ul><li><span class="name"><span class="innerContentContainer">重置统计： rescue_note</span></span></li><li><span class="name"><span class="innerContentContainer">重置等级： rescue_level</span></span></li><li><span class="name"><span class="innerContentContainer">重置成功： rescue_success</span></span></li><li><span class="name"><span class="innerContentContainer">重置失败： rescue_failure</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">存储分区统计： storage_state</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： uuid, old state, new state, 可用空间，总空间</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统重启： beginning of main|beginning of system </span></span></li><li><span class="name"><span class="innerContentContainer">底层模块启动: boot_progress_start (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">ZygoteInit 启动各模块: boot_progress_preload_start (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">ZygoteInit 启动结束: boot_progress_preload_end (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">启动Dalvik: dvm_lock_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式:  (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动ART: art_hidden_api_access</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (access_method|1),(flags|1),(class|3),(member|3),(type_signature|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ams就绪： boot_progress_ams_ready (数字是毫秒数)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService.systemReady() starts</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SystemServer 启动: boot_progress_system_run</span></span></li><li><span class="name"><span class="innerContentContainer">SystemServer 启动: system_server_start</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (start_count|1), (uptime|2|3), (elapse_time|2|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统进入桌面： system now ready  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">写系统文件: commit_sys_config_file (name|3),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">配置改变: configuration_changed</span></span></li><li><span class="name"><span class="innerContentContainer">切换用户： am_switch_user|am_user_state_changed</span></span></li><li><span class="name"><span class="innerContentContainer">账户: sync</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (id|3), (event|1|5), (source|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(account|1|5), account是账号名的hash值.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">功耗 / 充电 / 电池</span></span><ul><li><span class="name"><span class="innerContentContainer">功耗service： PowerManagetService</span></span></li><li><span class="name"><span class="innerContentContainer">过滤power: intercept_power (action|3),(mPowerKeyHandled|1),(mPowerKeyPressCounter|1)</span></span></li><li><span class="name"><span class="innerContentContainer">电池电量： battery_level</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式： 电量，电压，温度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电状态： battery_status</span></span><ul><li><span class="name"><span class="innerContentContainer">第一个参数： 2，充电；3，放电；4，未充电；5，充满电。</span></span></li><li><span class="name"><span class="innerContentContainer">第二个参数：2，电池正常；3，过热；4，电池损坏；5，电压过高；6，未知故障；7，电池过冷。</span></span></li><li><span class="name"><span class="innerContentContainer">第三个参数：1，放电；0，充电</span></span></li><li><span class="name"><span class="innerContentContainer">第四个参数：1，AC直充；2，USB充电；4，无线充电</span></span></li><li><span class="name"><span class="innerContentContainer">第五个参数：电池类型，li-ion，锂电池。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">放电状态： battery_discharge</span></span><ul><li><span class="name"><span class="innerContentContainer">放电时长，最低电流，最高电量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">Selinux 权限检验失败  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">denied {execute/read/write} for </span></span></li><li><span class="name"><span class="innerContentContainer">其中校验目标即 comm字段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">security_adb_shell_interactive</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_shell_command&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(command|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_sync_recv&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_sync_send&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_app_process_start&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(process|3),(start_time|2|3),(uid|1),(pid|1),(seinfo|3),(sha256|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_dismissed</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_dismiss_auth_attempt&nbsp; &nbsp;(success|1),(method_strength|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_secured</span></span></li><li><span class="name"><span class="innerContentContainer">security_os_startup&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (boot_state|3),(verity_mode|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_os_shutdown</span></span></li><li><span class="name"><span class="innerContentContainer">security_logging_started</span></span></li><li><span class="name"><span class="innerContentContainer">security_logging_stopped</span></span></li><li><span class="name"><span class="innerContentContainer">security_media_mounted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3),(label|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_media_unmounted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3),(label|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_log_buffer_size_critical</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_expiration_set&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(timeout|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_complexity_set&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(length|1),(quality|1),(num_letters|1),(num_non_letters|1),(num_numeric|1),(num_uppercase|1),(num_lowercase|1),(num_symbols|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_history_length_set&nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(length|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_max_screen_lock_timeout_set&nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(timeout|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_max_password_attempts_set&nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(num_failures|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_disabled_features_set&nbsp; (package|3),(admin_user|1),(target_user|1),(features|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_remote_lock&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_wipe_failed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_generated&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_imported&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_destroyed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_user_restriction_added&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (package|3),(admin_user|1),(restriction|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_user_restriction_removed&nbsp; &nbsp; &nbsp; &nbsp; (package|3),(admin_user|1),(restriction|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_authority_installed&nbsp; &nbsp; &nbsp; &nbsp; (success|1),(subject|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_authority_removed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (success|1),(subject|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_crypto_self_test_completed&nbsp; &nbsp; &nbsp; (success|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_integrity_violation&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_validation_failure&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Service</span></span><ul><li><span class="name"><span class="innerContentContainer">创建： am_create_service</span></span></li><li><span class="name"><span class="innerContentContainer">销毁： am_destroy_service</span></span></li><li><span class="name"><span class="innerContentContainer">启动： startService</span></span></li><li><span class="name"><span class="innerContentContainer">Service多次crash： am_service_crashed_too_much</span></span><ul><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">绑定, 解绑：  bindService|unbindService</span></span></li><li><span class="name"><span class="innerContentContainer">统计绑定了多少个客户端： total connections for service</span></span></li><li><span class="name"><span class="innerContentContainer">重启： am_schedule_service_restart</span></span></li><li><span class="name"><span class="innerContentContainer">访问统计: service_manager_stats (call_count|1), (total_time|1|3), (duration|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">响应迟缓: service_manager_slow (time|1|3), (service|3)</span></span></li><li><span class="name"><span class="innerContentContainer">服务空闲而关闭： am_stop_idle_service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder / 广播 / 通知</span></span><ul><li><span class="name"><span class="innerContentContainer">通知被取消： notification_cancel</span></span></li><li><span class="name"><span class="innerContentContainer">通知被点击： notification_action_clicked</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏被点击： notification_clicked</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏扩展或收缩： notification_expansion</span></span></li><li><span class="name"><span class="innerContentContainer">新通知显示状态改变： notification_visibility_changed</span></span><ul><li><span class="name"><span class="innerContentContainer">新的显示状态，旧的显示状态</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">显示信息栏： notification_panel_revealed</span></span></li><li><span class="name"><span class="innerContentContainer">隐藏信息栏： notification_panel_hidden</span></span></li><li><span class="name"><span class="innerContentContainer">模块全部通知取消： notification_cancel_all</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： cancel原因，监听者</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通知取消： notification_cancel</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： cancel原因，监听者</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通知： notification_enqueue</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： uid, pid, 包名，id, tag, userid, notificatin, status(0=post, 1=update, 2=ignored)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder溢出： binder_alloc_buf, no vma  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">binder超时: audioserver_binder_timeout (command|3)  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">接收广播： received broadcast|onReceive， 太多，请直接搜广播名</span></span></li><li><span class="name"><span class="innerContentContainer">忽略特定广播： am_broadcast_discard_filter|am_broadcast_discard_app</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： (User|1|5),(Broadcast|1|5),(Action|3),(Receiver Number|1|1),(BroadcastFilter|1|5) / (App|3)</span></span></li><li><span class="name"><span class="innerContentContainer">原因可能是: timeout/ANR/crash.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Provider / SQL</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库更新： onSharedPreferenceChanged</span></span></li><li><span class="name"><span class="innerContentContainer">provider没有准备好： am_provider_lost_process</span></span></li><li><span class="name"><span class="innerContentContainer">数据库操作: db_sample  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (db|3),(sql|3),(time|1|3),(blocking_package|3),(sample_percent|1|6)</span></span></li><li><span class="name"><span class="innerContentContainer">db：数据库的文件名</span></span></li><li><span class="name"><span class="innerContentContainer">sql：已执行的查询（无查询参数）</span></span></li><li><span class="name"><span class="innerContentContainer">time：cpu时间毫秒（不是墙上时间），包括锁定获取  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">blocking_package：如果在主线程上，则为程序包名称，否则为“”</span></span></li><li><span class="name"><span class="innerContentContainer">sample_percent：记录此查询的可能性百分比</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库更新: ***_upgrade_receiver (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_current (current|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_max (max|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_alloc_attempt (attempts|1|4)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_released (Memory released|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_db_corrupt (Database file corrupt|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PackageManagerService</span></span><ul><li><span class="name"><span class="innerContentContainer">Package Manager starts: boot_progress_pms_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan starts: boot_progress_pms_system_scan_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan starts: boot_progress_pms_data_scan_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan ends: boot_progress_pms_scan_end (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager ready: boot_progress_pms_ready (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">check activity_launch_time for Home app: Value of "unknown sources" setting at app install time:  unknown_sources_enabled (value|1)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager critical info: pm_critical_info (msg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Disk usage stats for verifying quota correctness: pm_package_stats </span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (manual_time|2|3),(quota_time|2|3),(manual_data|2|2),(quota_data|2|2),(manual_cache|2|2),(quota_cache|2|2)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">WiFi / 网络</span></span><ul><li><span class="name"><span class="innerContentContainer">网络流量统计： netstats_mobile_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">字段太多，网上补充</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Wifi 流量统计： netstats_wifi_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">字段太多，网上补充</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">wifi状态改变: wifi_state_changed (wifi_state|3)</span></span></li><li><span class="name"><span class="innerContentContainer">事件分发: wifi_event_handled (wifi_event|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">[15 - 0] HSM event (as defined in WifiStateTracker.java)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Supplicant状态改变: wifi_supplicant_state_changed (supplicant_state|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">[8 - 0] Supplicant state (as defined in SupplicantState.java)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Location</span></span><ul><li><span class="name"><span class="innerContentContainer">定位成功, 上报位置数据: location_controller</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用</span></span><ul><li><span class="name"><span class="innerContentContainer">GMS拒绝注册: gms_unknown</span></span></li><li><span class="name"><span class="innerContentContainer">联系人数量和查询时间: contacts_aggregation (aggregation time|2|3), (count|1|1)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">查询阶段 count为负，合并阶段 count为正.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单项被选中: menu_item_selected</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (Menu type where 0 is options and 1 is context|1|5), (Menu item title|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单打开: menu_opened</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (Menu type where 0 is options and 1 is context|1|5)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Web / HTTP / WebView</span></span><ul><li><span class="name"><span class="innerContentContainer">NTP成功: ntp_success (server|3),(rtt|2),(offset|2)</span></span></li><li><span class="name"><span class="innerContentContainer">NTP失败: ntp_failure (server|3),(msg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">http_stats (useragent|3),(response|2|3),(processing|2|3),(tx|1|2),(rx|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">viewroot_layout (Layout time|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">view_build_drawing_cache (View created drawing cache|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">view_use_drawing_cache (View drawn using bitmap cache|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_zoom_level_change (start level|1|5),(end level|1|5),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">viewroot_draw (Draw time|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_double_tap_duration (duration|1|3),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_snap_center</span></span></li><li><span class="name"><span class="innerContentContainer">exp_det_attempt_to_call_object_getclass (app_signature|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LibC异常</span></span><ul><li><span class="name"><span class="innerContentContainer">bionic_event_memcpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcat_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_memmov_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncat_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_memset_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcat_integer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncat_integer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_old_response (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_wrong_server (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_wrong_query (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">exp_det_cert_pin_failure (certs|4)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systemui</span></span><ul><li><span class="name"><span class="innerContentContainer">sysui_view_visibility (category|1|5),(visible|1|6)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_action (category|1|5),(pkg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_multi_action (content|4)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_count (name|3),(increment|1)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_histogram (name|3),(bucket|1)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时区</span></span><ul><li><span class="name"><span class="innerContentContainer">时区： timezone</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_trigger_received (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_read_from_data_app (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_uninstall (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_install (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_nothing (token_bytes|3), (success|1)</span></span></li></ul></li></ul>
  </body>
</html>