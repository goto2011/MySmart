<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">31-启动流程  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">开机</span></span><ul><li><span class="name"><span class="innerContentContainer">开机</span></span><ul><li><span class="name"><span class="innerContentContainer">长按power键</span></span><ul><li><span class="name"><span class="innerContentContainer">PS_HOLD是一个硬件管脚，功能是使能pmic芯片的。</span></span></li><li><span class="name"><span class="innerContentContainer">触发任何开机事件时，pmic都会自动给CPU上电。</span></span></li><li><span class="name"><span class="innerContentContainer">但如果在300ms内，软件没有将 ps_hold 拉高，则pmic会认为开机异常，而将CPU下电。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关机闹钟</span></span><ul><li><span class="name"><span class="innerContentContainer">设置关机闹钟时, 会给系统时钟源(RTC)设置一个定时器, 当定时器到时时会使能pmic芯片.</span></span></li><li><span class="name"><span class="innerContentContainer">系统开机过程中, 会检索所有的闹钟, 再重新将下一个闹钟设置到RTC上去. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电线插入</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重启</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog超时重启（不踢狗）, 是唯一软件能控制的重启，场景分为：</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog超时重启</span></span></li><li><span class="name"><span class="innerContentContainer">关机菜单</span></span></li><li><span class="name"><span class="innerContentContainer">升级</span></span></li><li><span class="name"><span class="innerContentContainer">恢复出厂设置</span></span></li><li><span class="name"><span class="innerContentContainer">死机</span></span><ul><li><span class="name"><span class="innerContentContainer">system_server重启</span></span></li><li><span class="name"><span class="innerContentContainer">kernel空指针或跑飞</span></span></li><li><span class="name"><span class="innerContentContainer">kernel&nbsp;watchdog超时，kernel异常导致。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ADB reboot命令</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">瞬间掉电重启</span></span></li><li><span class="name"><span class="innerContentContainer">Android重启</span></span><ul><li><span class="name"><span class="innerContentContainer">即SystemServer 重启. </span></span></li><li><span class="name"><span class="innerContentContainer">除init进程/Zygote<b>外, 其它用户态进程都死掉.</b></span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Loader</span></span><ul><li><span class="name"><span class="innerContentContainer">Boot Rom</span></span><ul><li><span class="name"><span class="innerContentContainer">当电源按下时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行.</span></span></li><li><span class="name"><span class="innerContentContainer">加载引导程序Bootloader到RAM，然后执行。</span></span></li><li><span class="name"><span class="innerContentContainer">Boot Rom属于片内系统。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BootLoader</span></span><ul><li><span class="name"><span class="innerContentContainer">BootLoader负责加载Android系统。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在 bootable/bootloader/lk。</span></span></li><li><span class="name"><span class="innerContentContainer">代码入口: bootable/bootloader/lk/app/aboot/aboot.c，aboot_init()。</span></span></li><li><span class="name"><span class="innerContentContainer">lk意思是light kernel，为高通开发，因为组织良好，被很多平台采用。</span></span></li><li><span class="name"><span class="innerContentContainer">二进制包</span></span><ul><li><span class="name"><span class="innerContentContainer">nand版本叫 appsboot.mbn</span></span></li><li><span class="name"><span class="innerContentContainer">emmc版本叫 emmc_appsboot.mbn</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BootLoader的功能</span></span><ul><li><span class="name"><span class="innerContentContainer">进fastboot</span></span><ul><li><span class="name"><span class="innerContentContainer">停在aboot等待后台命令。比如，fastboot flash boot boot.image</span></span></li><li><span class="name"><span class="innerContentContainer">该模式中可以用的命令，可通过 fastboot_register()来添加。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 adb reboot bootloader命令，可以让手机重启并直接进入Fastboot 中去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进 recovery和FTM</span></span><ul><li><span class="name"><span class="innerContentContainer">代码在: bootable/recovery/recovery.c</span></span></li><li><span class="name"><span class="innerContentContainer">升级代码一般放在这里。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一般情况下直接&nbsp; &nbsp;&nbsp;启动kernel。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel</span></span><ul><li><span class="name"><span class="innerContentContainer">swapper（pid=0）</span></span><ul><li><span class="name"><span class="innerContentContainer">内核启动时，先启动系统的第一个进程，swapper，完成内核的初始化。</span></span></li><li><span class="name"><span class="innerContentContainer">swapper对应于Windows系统的idle 进程。</span></span></li><li><span class="name"><span class="innerContentContainer">在多处理器系统中，每个CPU都有一个进程swapper进程。</span></span></li><li><span class="name"><span class="innerContentContainer">swapper初始化进程管理、内存管理。</span></span></li><li><span class="name"><span class="innerContentContainer">swapper加载驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">Camera driver</span></span></li><li><span class="name"><span class="innerContentContainer">Display driver</span></span></li><li><span class="name"><span class="innerContentContainer">Binder driver</span></span></li><li><span class="name"><span class="innerContentContainer">等等。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">init.rc</span></span><ul><li><span class="name"><span class="innerContentContainer">自举过程结束后，内核首先在 /system 分区中寻找 init.rc 文件；然后启动init进程.</span></span></li><li><span class="name"><span class="innerContentContainer">init进程是系统的第二个进程（pid=1）, 也是第一个用户态进程。</span></span></li><li><span class="name"><span class="innerContentContainer">init进程负责一行行执行 init.rc 文件;</span></span></li><li><span class="name"><span class="innerContentContainer">init进程是所有用户态进程的父父进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kthreadd (pid=2)</span></span><ul><li><span class="name"><span class="innerContentContainer">内核启动 kthreadd，它是所有内核进程的父进程，负责动态加载内核守护进程。</span></span></li><li><span class="name"><span class="innerContentContainer">所有内核进程都运行于内核态，用户都是root.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kthreadd 启动的内核守护进程（运行于内核态，顺序基本上是启动顺序）</span></span><ul><li><span class="name"><span class="innerContentContainer">ksoftirqd/0：负责监测CPU 0上的软中断</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/0:0：第0个CPU的第0个工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/0:1：第0个CPU的第1个工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/0:0H： 第0个cpu的第0H工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/u4:0：u代表的是unbound,即未与CPU绑定的进程</span></span></li><li><span class="name"><span class="innerContentContainer">migration/0：CPU 0上的用于在不同的CPU间迁移的进程</span></span></li><li><span class="name"><span class="innerContentContainer">rcu_preempt：读写更新，抢占器</span></span></li><li><span class="name"><span class="innerContentContainer">rcu_bh：</span></span></li><li><span class="name"><span class="innerContentContainer">rcu_sched：读写更新，调度</span></span></li><li><span class="name"><span class="innerContentContainer">ksoftirqd/1：负责监测CPU 1上的软中断</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/1:0H：第1个cpu的第0H工作进程</span></span></li><li><span class="name"><span class="innerContentContainer">kworker/u4:1：u代表的是unbound,即未与CPU绑定的进程</span></span></li><li><span class="name"><span class="innerContentContainer">migration/1：CPU 1上的用于在不同的CPU间迁移的进程</span></span></li><li><span class="name"><span class="innerContentContainer">khelper： 用于调用内核模块的用户空间实现</span></span></li><li><span class="name"><span class="innerContentContainer">writeback：存储回写</span></span></li><li><span class="name"><span class="innerContentContainer">bioset：block i/o管理</span></span></li><li><span class="name"><span class="innerContentContainer">kblockd：用于卸载和影响ios延迟/吞吐率</span></span></li><li><span class="name"><span class="innerContentContainer">ata_sff：ata是 IDE硬盘接口。</span></span></li><li><span class="name"><span class="innerContentContainer">khubd：</span></span></li><li><span class="name"><span class="innerContentContainer">md：Multiple Devices driver for Linux</span></span></li><li><span class="name"><span class="innerContentContainer">cfg80211：配置802.11协议，即配置wifi的进程</span></span></li><li><span class="name"><span class="innerContentContainer">kswapd0：页交换</span></span></li><li><span class="name"><span class="innerContentContainer">fsnotify_mark：文件系统通知标记进程</span></span></li><li><span class="name"><span class="innerContentContainer">crypto：加密子进程</span></span></li><li><span class="name"><span class="innerContentContainer">scsi_eh_0：cpu 0上的scsi_eh进程(SCSI是一种存储硬件接口标准.),这进程在ubuntu上也存在</span></span></li><li><span class="name"><span class="innerContentContainer">scsi_eh_1：cpu 1上的scsi_eh进程</span></span></li><li><span class="name"><span class="innerContentContainer">uether：</span></span></li><li><span class="name"><span class="innerContentContainer">dm_bufio_cache：dm是指 RAID and LVM drivers 缓冲io</span></span></li><li><span class="name"><span class="innerContentContainer">binder：binder驱动</span></span></li><li><span class="name"><span class="innerContentContainer">deferwq：defer work queue 开启延迟设备检测</span></span></li><li><span class="name"><span class="innerContentContainer">jbd2/vda-8：journal block device2，vda-8是设备名称</span></span></li><li><span class="name"><span class="innerContentContainer">ext4-dio-unwrit：ext4文件系统相关进程</span></span></li><li><span class="name"><span class="innerContentContainer">therm_core：热管理</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog：看门狗</span></span></li><li><span class="name"><span class="innerContentContainer">perf</span></span></li><li><span class="name"><span class="innerContentContainer">netns</span></span></li><li><span class="name"><span class="innerContentContainer">rpm-smd</span></span></li><li><span class="name"><span class="innerContentContainer">mpm</span></span></li><li><span class="name"><span class="innerContentContainer">system</span></span></li><li><span class="name"><span class="innerContentContainer">mdss_dsi_event</span></span></li><li><span class="name"><span class="innerContentContainer">kgsl-events</span></span></li><li><span class="name"><span class="innerContentContainer">spi</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Native</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>init（pid=1）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">init是系统第二个进程，也是第一个用户态进程。</span></span></li><li><span class="name"><span class="innerContentContainer">init的代码：system/core/init/init.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">init.rc文件：system/core/rootdir/init.rc</span></span></li><li><span class="name"><span class="innerContentContainer">启动Zygote</span></span><ul><li><span class="name"><span class="innerContentContainer">在init执行过程中，在on boot阶段，会 trigger zygote-start，on zygote-start，根据当前的加密状态选择启动Zygote。</span></span></li><li><span class="name"><span class="innerContentContainer">Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。</span></span></li><li><span class="name"><span class="innerContentContainer">其中，zygote服务的启动脚本在 init.zygoteXX.rc中定义，比如 init.zygote64.rc。该文件位于 system/core/rootdir/。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动 MediaServer</span></span></li><li><span class="name"><span class="innerContentContainer">启动 <b>ServiceManager</b> (ContextManager)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>init fork的守护进程（运行于用户态，顺序基本上是启动顺序）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">sbin/<b>ueventd： 事件后台进程。最早启动。</b></span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/logd： log的守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>vold</b>： volume守护进程</span></span><ul><li><span class="name"><span class="innerContentContainer">system/bin/sdcard： 由vold进程创建，管理sdcard分区。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sbin/healthd：  电池的守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>lmkd</b>： LowmeMoryKiller守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/S<b>erviceManager： </b>binder服务的订阅查询服务进程。后面会详细描述。</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>surfaceflinger： </b>UI帧相关的进程</span></span></li><li><span class="name"><span class="innerContentContainer">kauditd：内核审核守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">sbin/<b>adbd</b>： adbd进程(Socket IPC)</span></span><ul><li><span class="name"><span class="innerContentContainer">system/bin/sh： ADB启动的 shell终端, 命令行控制台</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">system/bin/netd： 网络相关进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/debuggerd： 32位调试器</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/debuggerd64： 64位调试器</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>rild（</b>ril-daemon<b>）： </b>Radio Interface Layer（协议栈）的守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/drmserver： 数字版权管理进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/mediaserver： 媒体管理</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/installd： 负责安装应用程序的进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/keystore： 证书管理</span></span></li><li><span class="name"><span class="innerContentContainer"><b>zygote64</b>： 这是第一个客户进程，server_server进程和zygote64进程通信以创建其它的app进程。 后面会详述。</span></span></li><li><span class="name"><span class="innerContentContainer">zygote： 32位zygote</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/<b>gatekeeperd</b>： 锁屏处理守护进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/xbin/perfprofd： perf profile collection daemon 性能搜集进程</span></span></li><li><span class="name"><span class="innerContentContainer">system/bin/fingerprintd: 指纹进程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Zygote</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Zygote是系统的第二个用户态进程，也是所有java进程的父进程。</span></span></li><li><span class="name"><span class="innerContentContainer">刚开始的名字为“app_process”，运行过程中，通过系统调用将自己名字改为Zygote。</span></span></li><li><span class="name"><span class="innerContentContainer">分Zygote和Zygote64。64位系统会同时启动这两个。</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote常驻后台，每当新的apk启动时，Zygote会派生一个linux进程来跑java虚拟机，然后apk会跑在该虚拟机上。</span></span></li><li><span class="name"><span class="innerContentContainer">进程文件：system/bin/app_process</span></span></li><li><span class="name"><span class="innerContentContainer">代码：frameworks/base/cmds/app_process/app_main.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote完成的初始化动作：</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化AppRuntime。AppRuntime继承于AndroidRuntime。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化Skia图形库。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化Dalvik虚拟机。</span></span></li><li><span class="name"><span class="innerContentContainer">注册jni函数。</span></span></li><li><span class="name"><span class="innerContentContainer">根据参数调用 ZygoteInit 的main方法，启动Zygote自身。关键。</span></span></li><li><span class="name"><span class="innerContentContainer">创建本地socket。</span></span></li><li><span class="name"><span class="innerContentContainer">预加载资源。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Zygote启动SystemServer （fwk的主体，详述见后）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Zygote的forkSystemServer方法主要是调用了native方法nativeForkSystemServer；</span></span></li><li><span class="name"><span class="innerContentContainer">在native层进行fork动作，并设置pid、gid、selinux安全上下文等，最后启动 com.android.server.SystemServer。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Zygote启动的 GC守护进程（用户态）</span></span><ul><li><span class="name"><span class="innerContentContainer">ReferenceQueueD：引用队列的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">FinalizerDaemon：析构的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">FinalizerWatchd：析构监控的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">HeapTrimmerDaem：堆整理的守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">GCDaemon：执行GC的守护线程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Zygote启动的系统应用 (详述见后)</span></span></li><li><span class="name"><span class="innerContentContainer">MediaServer</span></span><ul><li><span class="name"><span class="innerContentContainer">管理本地系统service (C/C++)。包括:</span></span></li><li><span class="name"><span class="innerContentContainer">AudioFlinger</span></span></li><li><span class="name"><span class="innerContentContainer">MediaPlayerService</span></span></li><li><span class="name"><span class="innerContentContainer">Camera</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>ServiceManager</b> (ContextManager)</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/cmds/servicemanager/service_manager.c</span></span></li><li><span class="name"><span class="innerContentContainer">Binder架构的管理者，所有系统service都需要先向 servicemanager注册。</span></span></li><li><span class="name"><span class="innerContentContainer">framework和app在调用系统服务时，需要向servicemanager申请，然后通过 Binder调用该服务。</span></span></li><li><span class="name"><span class="innerContentContainer">文件：system/bin/servicemanager</span></span></li><li><span class="name"><span class="innerContentContainer">对外提供的接口有：</span></span><ul><li><span class="name"><span class="innerContentContainer">addService()</span></span></li><li><span class="name"><span class="innerContentContainer">getService()</span></span></li><li><span class="name"><span class="innerContentContainer">listServices()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">开机动画</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Framework</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>SystemServer</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>SystemServer</b>是zygote的首席大弟子，托起整个Java framework的所有service。</span></span></li><li><span class="name"><span class="innerContentContainer">启动后完成如下事务：</span></span><ul><li><span class="name"><span class="innerContentContainer">调整时间，如果系统时间比1970还要早，调整到1970年</span></span></li><li><span class="name"><span class="innerContentContainer">设置系统语言</span></span></li><li><span class="name"><span class="innerContentContainer">调整虚拟机堆内存大小和内存利用率</span></span></li><li><span class="name"><span class="innerContentContainer">初始化Looper为mainLooper</span></span></li><li><span class="name"><span class="innerContentContainer">装载库 libandroid_server.so</span></span></li><li><span class="name"><span class="innerContentContainer">初始化系统Context</span></span></li><li><span class="name"><span class="innerContentContainer">创建 SystemServiceManager负责系统Service启动</span></span></li><li><span class="name"><span class="innerContentContainer">创建和启动Java服务</span></span></li><li><span class="name"><span class="innerContentContainer">调用Looper.loop()，进入处理消息的循环</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SystemServer 启动的服务进程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService：AMS线程</span></span></li><li><span class="name"><span class="innerContentContainer">WindowManagerService：WMS线程</span></span></li><li><span class="name"><span class="innerContentContainer">PowerManagerSer：PMS线程</span></span></li><li><span class="name"><span class="innerContentContainer">PackageManager：PM线程</span></span></li><li><span class="name"><span class="innerContentContainer">Binder_：Binder IPC线程， 包含16个</span></span></li><li><span class="name"><span class="innerContentContainer">Thread_：普通线程，包含若干个</span></span></li><li><span class="name"><span class="innerContentContainer">Heap thread pool：异步的HeapWorker, 包含5个</span></span></li><li><span class="name"><span class="innerContentContainer">Signal Catcher：捕捉Kernel信号，比如SIGNAL_QUIT</span></span></li><li><span class="name"><span class="innerContentContainer">JDWP：虚拟机调试的线程</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask #: 异步任务，包含若干个</span></span></li><li><span class="name"><span class="innerContentContainer">RenderThread：渲染线程，可以包含若干个</span></span></li><li><span class="name"><span class="innerContentContainer">PerformanaceCont：性能统计</span></span></li><li><span class="name"><span class="innerContentContainer">FileObserver：system_server专有</span></span></li><li><span class="name"><span class="innerContentContainer">CpuTracker：CPU信息统计</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog：看门狗线程</span></span></li><li><span class="name"><span class="innerContentContainer">WifiMonitor：system_server专有</span></span></li><li><span class="name"><span class="innerContentContainer">UEventObserver：system_server专有其它的进程</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">APP</span></span><ul><li><span class="name"><span class="innerContentContainer">开机过程中, Zygote 会启动如下核心应用：</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.systemui： 系统状态栏进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.inputmethod.latin： 输入法进程</span></span></li><li><span class="name"><span class="innerContentContainer">android.process.media： 媒体进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.phone： telephony通话服务进程</span></span></li><li><span class="name"><span class="innerContentContainer">android.process.acore： 通讯录数据库进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.deskclock： 闹钟进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.quicksearchbox： 快速搜索框进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings： 设置进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.calendar： 日历进程，packages/apps/Calendar</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.providers.calendar： 日历提供器进程packages/providers/CalendarProvider</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.launcher3： 启动器进程，即桌面</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.email： 邮件服务进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.messaging： 短消息进程</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.smspush：短信发送</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.wifi：Wifi应用进程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开机后系统的大概状态</span></span><ul><li><span class="name"><span class="innerContentContainer">swapper： 2个子进程，分别为init， kthreadd</span></span></li><li><span class="name"><span class="innerContentContainer">init：55个子进程，用户进程</span></span></li><li><span class="name"><span class="innerContentContainer">kthreadd：303个子进程，内核进程</span></span></li><li><span class="name"><span class="innerContentContainer">zygote64：41个子进程，64位zygote</span></span></li><li><span class="name"><span class="innerContentContainer">zygote：3个子进程，32位zygote</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关机流程</span></span><ul><li><span class="name"><span class="innerContentContainer">关机流程从kernel log可看出，power down。</span></span></li><li><span class="name"><span class="innerContentContainer">SYSCALL_DEFINE4，这是kernel总的reboot和shut down的接口。</span></span></li><li><span class="name"><span class="innerContentContainer">kernel_power_off()，关机流程基本都在这个函数里面。</span></span></li><li><span class="name"><span class="innerContentContainer">kernel_shutdown_prepare()，关闭device。log：device_shutdown, dev name=platform。</span></span></li><li><span class="name"><span class="innerContentContainer">machine_power_off() -&gt; msm_pm_power_off()，进行下电操作。其中调用了 msm_rpcrollter_close()，关闭rpc。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>系统启动优化经验 <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">去掉打印频繁的log.</span></span></li><li><span class="name"><span class="innerContentContainer">根据器件情况做裁剪, 方法是修改配置文件, yes 改为 no.</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote预加载资源时, 采用单线程, 改为多线程(最多可节省15秒)</span></span></li><li><span class="name"><span class="innerContentContainer">所有apk在编译时生成odex. </span></span></li></ul></li></ul>
  </body>
</html>