<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">15-Native</span><ul><li><span class="name">JNI: Java Native Interface.  一套编程接口，用来实现Java代码与本地的C/C++代码进行互相调用.</span></li><li><span class="name">NDK: native development kit. 开发JNI的工具包，帮助开发者快速开发 C/C++ 的动态库，并能自动将so和java应用一起打包成apk。</span></li><li><span class="name">如何看native代码?</span><ul><li><span class="name">native方法申明: 在java代码中, 方法前面有 native 关键字的就是native方法.</span></li><li><span class="name">native方法的命名有规律, 一般:</span><ul><li><span class="name">java库: Java_Lang_类名_方法名</span></li><li><span class="name">Android frameworkd : android_Hardware_Camera_CameraOpen()</span></li></ul></li><li><span class="name">对应的C代码位置:</span><ul><li><span class="name">java库:  delvik/wm/native/</span></li><li><span class="name">Android framework : framework/base/core/jni/</span></li></ul></li></ul></li><li><span class="name">JNI数据类型映射表</span><ul><li><span class="name">定义参数和返回值时要用到数据类型, JNI一般使用:</span><ul><li><span class="name">String getString()  -&gt;  Ljava/lang/String;</span></li><li><span class="name">int sum(int a, int b)  -&gt;  (II)I</span></li><li><span class="name">void main(String[] args) -&gt; ([Ljava/lang/String;)V</span></li></ul></li><li><span class="name">基本数据类型: </span><ul><li><span class="name">字符 Java类型    C类型</span></li><li><span class="name">V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void</span></li><li><span class="name">Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jboolean&nbsp;&nbsp;&nbsp;&nbsp; boolean</span></li><li><span class="name">I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</span></li><li><span class="name">J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jlong&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long</span></li><li><span class="name">D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jdouble&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double</span></li><li><span class="name">F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jfloat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float</span></li><li><span class="name">B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jbyte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte</span></li><li><span class="name">C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jchar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char</span></li><li><span class="name">S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jshort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short</span></li></ul></li><li><span class="name">数组则以"["开始，用两个字符表示: </span><ul><li><span class="name">[I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jintArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[]</span></li><li><span class="name">[F&nbsp;&nbsp;&nbsp;&nbsp; jfloatArray&nbsp;&nbsp;&nbsp; float[]</span></li><li><span class="name">[B&nbsp;&nbsp;&nbsp;&nbsp; jbyteArray&nbsp;&nbsp;&nbsp; byte[]</span></li><li><span class="name">[C&nbsp;&nbsp;&nbsp; jcharArray&nbsp;&nbsp;&nbsp; char[]</span></li><li><span class="name">[S&nbsp;&nbsp;&nbsp; jshortArray&nbsp;&nbsp; short[]</span></li><li><span class="name">[D&nbsp;&nbsp;&nbsp; jdoubleArray double[]</span></li><li><span class="name">[J&nbsp;&nbsp;&nbsp;&nbsp; jlongArray&nbsp;&nbsp;&nbsp;&nbsp; long[]</span></li><li><span class="name">[Z&nbsp;&nbsp;&nbsp;  jbooleanArray boolean[]</span></li></ul></li><li><span class="name">引用类型描述符:</span><ul><li><span class="name">引用类型不能直接在 Native 层使用. 需要用如下格式: </span></li><li><span class="name">L + 包名/类描述符 + ; ,  注意分号不要丢了.</span></li><li><span class="name">比如 CameraBuffer-&gt; Lcom/android/camera/CameraBuffer;   // 真是麻烦.</span></li><li><span class="name">一个例外是String类，其对应的类为jstring.</span></li><li><span class="name">同时其对应的C函数名的参数则为 <b>jobject</b>.</span></li><li><span class="name">如果JAVA函数位于一个嵌入类，则用$作为类名间的分隔符。如: "(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z"</span></li><li><span class="name">多维数组（含二维数组）都是引用类型，需要使用 jobjectArray 类型存取其值；</span></li></ul></li></ul></li><li><span class="name">C代码如何调用 Java?</span><ul><li><span class="name">当 Native 层需要调用 Java 的某个方法时，需要通过 JNI函数 GetMethodID()获取它的 ID，根据 ID 调用 JNI 函数获取该方法；变量的获取也是类似。</span></li><li><span class="name">jmethodID   (*<b>GetMethodID</b>)(JNIEnv*, jclass, const char*, const char*);    //C</span></li><li><span class="name">jmethodID <b>GetMethodID</b>(jclass clazz, const char* name, const char* sig)  //C++</span><ul><li><span class="name">{ return functions-&gt;GetMethodID(this, clazz, name, sig); }</span></li></ul></li><li><span class="name">在实际编程中，如果使用 javah 工具来生成对应的 native 代码，就不需要手动编写对应的类型转换了。</span></li></ul></li><li><span class="name">C代码方法的定义和 JNIEnv</span><ul><li><span class="name">所有本地函数都会接收 JNIEnv 作为第一个参数.</span></li><li><span class="name">JNIEnv 是一个指针，指向一组 JNI 函数，通过这些函数可以实现 Java 层和 JNI 层的交互，就是说通过 JNIEnv 调用 JNI 函数可以访问 Java 虚拟机，操作 Java 对象.</span></li><li><span class="name">用作线程局部存储，不能在线程间共享一个 JNIEnv 变量，也就是说&nbsp;JNIEnv 只在创建它的线程有效，不能跨线程传递；相同的 Java 线程调用本地方法，所使用的 JNIEnv 是相同的，一个 native 方法不能被不同的 Java 线程调用.</span></li></ul></li><li><span class="name">Java 的 native 方法是如何链接 C/C++中的函数？</span><ul><li><span class="name">可以通过静态和动态的方式注册JNI。</span></li><li><span class="name">静态注册: 根据函数名建立 Java 方法和 JNI 函数的一一对应关系。流程如下：</span><ul><li><span class="name">先编写 Java 的 native 方法；</span></li><li><span class="name">然后用 javah 工具生成对应的头文件，执行命令 javah packagename.classname可以生成由包名加类名命名的 jni 层头文件，或执行命名 javah -o custom.h packagename.classname，其中 custom.h 为自定义的文件名；</span></li><li><span class="name">实现 JNI 里面的函数，再在Java中通过 <b>System.loadLibrary </b>加载 so 库即可.</span></li><li><span class="name">一个在java代码中叫 swap() 的native方法, 对应的C代码函数体是:</span><ul><li><span class="name">JNIEXPORT jint JNICALL <b>Java_Com_Oppo_Camera_Jni_swap__</b>(JNIEnv *, jclass);</span></li></ul></li></ul></li><li><span class="name">动态注册: 直接告诉 native 方法其在JNI 中对应函数的指针。通过使用 JNINativeMethod 结构来保存 Java native 方法和 JNI 函数关联关系，步骤：</span><ul><li><span class="name">先编写 Java 的 native 方法；</span></li><li><span class="name">编写 JNI 函数的实现（函数名可以随便命名）；</span></li><li><span class="name">利用结构体 JNINativeMethod 保存Java native方法和 JNI函数的对应关系；</span></li><li><span class="name">利用registerNatives(JNIEnv* env)注册类的所有本地方法；</span></li><li><span class="name">在 JNI_OnLoad 方法中调用注册方法；</span></li><li><span class="name">在Java中通过 System.loadLibrary 加载完JNI动态库之后，会调用 JNI_OnLoad 函数，完成动态注册.</span></li></ul></li></ul></li><li><span class="name">so文件编译</span><ul><li><span class="name">Android系统支持7种CPU建构, 每一种对应一种ABI(应用程序二进制接口)</span><ul><li><span class="name">armV5 -- armeabi</span></li><li><span class="name">armV7(2010) -- armeabi-v7a</span></li><li><span class="name">x86(2011) -- x86</span></li><li><span class="name">mips(2012) -- mips</span></li><li><span class="name">armV8(2012) -- arm64-v8a</span></li><li><span class="name">mips64(2014) -- mips64</span></li><li><span class="name">x86-64(2014) -- x86-64</span></li></ul></li><li><span class="name">如果在项目中使用了NDK, 就会生成so文件.</span></li><li><span class="name">一个app, native libs monitor, 可列出各apk使用了哪些so文件, 以及so文件来源于哪些函数库或框架. </span></li></ul></li><li><span class="name">NDK开发常见问题</span><ul><li><span class="name">忘记delete local reference。带New到方法(如：NewByteArray)这样到方法比较好辨认，需要手动调用DeleteLocalRef()来释放(返回值除外)。比较特殊的一个方法是：GetByteArrayELement必须要调用ReleaseByteArrayElements进行释放。当然如果你只是取bytearray中到byte，那么完全可以用GetByteArrayRegion实现。</span></li><li><span class="name">没有NewGlobalRef。 在不同线程调用java方法，需要保存jobject对象，这时需要对jobject对象做全局引用，否则会失效。</span></li><li><span class="name">jbytearray的length。在JNI layer获取到jbytearray到长度是不对到，应该由java获取byte[]的length再传给C layer。否则C layer有可能获得到是乱码。</span></li><li><span class="name">线程问题。 不同线程使用JNIEnv*对象，需要AttachCurrentThread将env挂到当前线程，否则无法使用env。</span></li><li><span class="name">&nbsp;javap 命令是对java的class文件操作；而javah命令需要在包名到上一层路径运行才行，否则无法生成.h文件。</span></li><li><span class="name">尽量避免频繁调用JNI或者是使用JNI传输大量到数据。</span></li><li><span class="name">Reference Table overflow (max=1024) 或者是&nbsp;Reference Table overflow (max=512)一定是因为忘记释放global reference或者local reference，请仔细检查代码。</span></li><li><span class="name">不要在windows下使用cygwin编译NDK code，那样会遇到arguments too long问题，因为windows路径长度有限制导致。虽然可以使用subst将路径映射为短路径，但是在编译时间和调试上，windows到孩子都是伤不起。同样到build，在windows下要15分钟左右，而在mac下只要5分多，相差3倍。调试JNI 代码到速度更是不用提了，差太多。</span></li></ul></li></ul>
  </body>
</html>