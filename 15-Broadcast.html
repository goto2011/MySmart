<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">15-<b>Broadcast</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android的广播机制是一种 Publish/subscribepattern. </span></span><ul><li><span class="name"><span class="innerContentContainer">Publish(发布者)只会将不同类型的讯息传送出去, 并不会在意subscribe(订阅者);</span></span></li><li><span class="name"><span class="innerContentContainer">而 subscribe(订阅者)只在意想接收的讯息, 并不会在意谁是Publish(发布者).</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静态注册</span></span><ul><li><span class="name"><span class="innerContentContainer">静态注册是在AndroidManifest.xml上加一个receiver tag来指定. 在编译android app就指定好了</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态注册</span></span><ul><li><span class="name"><span class="innerContentContainer">在代码中, 调用 Context.registerReceiver() 来注册. </span></span></li><li><span class="name"><span class="innerContentContainer">registerReceiver() 的实现在 ContextImpl.java.</span></span><ul><li><span class="name"><span class="innerContentContainer">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return registerReceiver(receiver, filter, null, null);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public Intent <b>registerReceiver</b>(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// registerReceiverInternal() 做了两件事, 先将传入reciever包装产生一个IIntentReceiver, 然后再将IIntentReceiver传送给 AMS 去注册.</span></span></li><li><span class="name"><span class="innerContentContainer">private Intent <b>registerReceiverInternal</b>(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) {</span></span><ul><li><span class="name"><span class="innerContentContainer">IIntentReceiver rd = null;</span></span></li><li><span class="name"><span class="innerContentContainer">if (receiver != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">// mPackageInfo是一个LoadedApk的对象.</span></span></li><li><span class="name"><span class="innerContentContainer">rd = mPackageInfo.<b>getReceiverDispatcher</b>(receiver, context, scheduler, mMainThread.getInstrumentation(), true);</span></span></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">rd = new LoadedApk.ReceiverDispatcher(receiver, context, scheduler, null, true).getIIntentReceiver();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">final Intent intent = ActivityManagerNative.getDefault().<b>registerReceiver</b>(mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId);</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">return intent;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (RemoteException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">throw e.rethrowFromSystemServer();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">继续看下 LoadedApk.getReceiverDispatcher()</span></span><ul><li><span class="name"><span class="innerContentContainer">先产生一个receiver的ReceiverDispatcher然后再产生一个ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;来做管理.最后会执行ReceiverDispatcher的getIIntentReceiver方法.</span></span></li><li><span class="name"><span class="innerContentContainer">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler,Instrumentation instrumentation, boolean registered) {</span></span><ul><li><span class="name"><span class="innerContentContainer">synchronized (mReceivers) {</span></span><ul><li><span class="name"><span class="innerContentContainer">LoadedApk.ReceiverDispatcher rd = null;</span></span><ul><li><span class="name"><span class="innerContentContainer">ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">if (rd == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered);</span></span></li><li><span class="name"><span class="innerContentContainer">if (registered) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (map == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">mReceivers.put(context, map);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">map.put(r, rd);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">rd.validate(context, handler);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">// getIIntentReceiver()回传的 IItentReciever是一道Receiver Binder interface.</span></span></li><li><span class="name"><span class="innerContentContainer">return rd.getIIntentReceiver();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">至此, InnerReceiver(IBinder) 创建出来, 下面看 AMS.registerReceiver()</span></span><ul><li><span class="name"><span class="innerContentContainer">// 启动一个binder调用. request id 是 REGISTER_RECEIVER_TRANSACTION.</span></span></li><li><span class="name"><span class="innerContentContainer">public Intent registerReceiver(IApplicationThread caller, String packageName, IIntentReceiver receiver, IntentFilter filter, String perm, int userId) throws RemoteException {</span></span><ul><li><span class="name"><span class="innerContentContainer">Parcel data = Parcel.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">Parcel reply = Parcel.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">mRemote.<b>transact</b>(REGISTER_RECEIVER_TRANSACTION, data, reply, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">最终调用到 ActivityManagerService.java 的 registerReceiver().</span></span></li><li><span class="name"><span class="innerContentContainer">// 使用 mRegisteredReceivers 将IIntentReceiver放进Receiver list.最后在执行 mReceiverResolver的addFilter新增一个BroadcastFilter. 之后在发送讯息阶段时,就会利用 mReceiverResolver来做传送媒介.</span></span></li><li><span class="name"><span class="innerContentContainer">public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">mRegisteredReceivers.put(receiver.asBinder(), rl);</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);</span></span></li><li><span class="name"><span class="innerContentContainer">rl.add(bf);&nbsp; // rl 是一个ReceiverList data.</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">mReceiverResolver.addFilter(bf); // mReceiverResolver是一个IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; data</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">发送广播</span></span></li></ul>
  </body>
</html>