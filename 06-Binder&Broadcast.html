<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">06-Binder&amp;Broadcast</span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.cnblogs.com/samchen2009/p/3316001.html">https://www.cnblogs.com/samchen2009/p/3316001.html</a>  图解Android - Binder 和 Service</span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://www.mysixue.com/?p=137">http://www.mysixue.com/?p=137</a>  Binder详解  <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Binder是Android系统中的进程间通讯方式之一. </span></span></li><li><span class="name"><span class="innerContentContainer">Binder和传统IPC方式的优劣对比  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">传统IPC有如下方式：</span></span></li><li><span class="name"><span class="innerContentContainer">socket: 通用接口, 传输效率低, 多用于跨网络或本机的低速通讯。</span></span></li><li><span class="name"><span class="innerContentContainer">消息队列 / 管道, 采取存储-转发方式, 至少需要两次拷贝，效率低。</span></span><ul><li><span class="name"><span class="innerContentContainer">此方式需要共享内存地址, 所以只能用于同进程的两个线程间通信。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">共享内存无需拷贝, 但是控制复杂, 难以使用和扩展.</span></span></li><li><span class="name"><span class="innerContentContainer">上述方式的共同缺点是没有安全机制, 无法获得访问线程的可靠的UID/PID, 无法鉴别访问者身份. 而且传统IPC访问接入点是开放的, 无法建立私有通道.</span></span></li><li><span class="name"><span class="innerContentContainer">Binder的优势有:</span></span><ul><li><span class="name"><span class="innerContentContainer">性能高：数据只拷贝1次, 消息队列和管道至少两次。</span></span></li><li><span class="name"><span class="innerContentContainer">安全：通过UID/PID可校验访问者身份, 并支持匿名Binder。</span></span></li><li><span class="name"><span class="innerContentContainer">和共享内存比, 读写两方各自管理自己的数据, 控制较简单. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder的缺点: 只能单向由Client发起请求，而Service无法主动传输数据. 这个限制了它的使用场景.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder 5元素</span></span><ul><li><span class="name"><span class="innerContentContainer">server负责提供业务能力， 同时提供访问接入点, 类似于: ip地址+端口号</span></span></li><li><span class="name"><span class="innerContentContainer">client负责使用业务能力，它需要具有探测访问接入点的能力;</span></span></li><li><span class="name"><span class="innerContentContainer">通讯协议. IBinder的扩展类. 分别为 server 和 client 继承。</span></span><ul><li><span class="name"><span class="innerContentContainer">其中client继承类即 BinderProxy。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ServiceManager (SMgr)，native层。</span></span><ul><li><span class="name"><span class="innerContentContainer">它的功能类似于互联网的域名服务器DNS, 作用是将字符串格式的Binder名字转化为Client中对Binder server的应用, 以完成寻址.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder驱动: 位于内核，进程运行于核心态。</span></span><ul><li><span class="name"><span class="innerContentContainer">设备节点是 /dev/binder, 主要通过 ioctl() 接口对上提供能力.  </span></span></li><li><span class="name"><span class="innerContentContainer">代码在 drivers/misc/binder.c.</span></span></li><li><span class="name"><span class="innerContentContainer">跨进程能力就是由 Binder驱动提供.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder限制</span></span><ul><li><span class="name"><span class="innerContentContainer">binder最大支持传1m的数据。因为binder驱动仅预留1m大小的虚拟内存。</span></span></li><li><span class="name"><span class="innerContentContainer">binder线程池默认是16个。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Binder通讯过程 (核心)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">数据结构: server/client/Binder驱动, 三方都使用 binder_tansaction_data 结构来封装信息. 字段如下: </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>code</b>, 整数, Binder方法的句柄.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>data_buffer</b>, 存放参数.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>traget, 关键。是一个联合体, 在server侧, 它是 ptr, 指向被调用的Binder对象的地址. 在client端, 它是handle, 指向BinderProxy对象的句柄.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">server侧注册过程</span></span><ul><li><span class="name"><span class="innerContentContainer">Service 可以运行在native 层(C/C++)，也可以运行在Java 层。</span></span></li><li><span class="name"><span class="innerContentContainer">先定义一个抽象接口类封装 server 的所有功能, 其中包含一系列纯虚函数, 待server和client分别实现.</span></span></li><li><span class="name"><span class="innerContentContainer">使用AIDL, client可自动生成(因为client只是一个影子类, 目的是编译通过), server则必须得自己实现.</span></span></li><li><span class="name"><span class="innerContentContainer">server 创建Binder实体, 命名, 并实现其业务能力; </span></span></li><li><span class="name"><span class="innerContentContainer">然后server需要写一个实现 IBinder接口的 Remote class，来处理client的Binder请求, 其中最重要的是函数是 <b>onTransact</b>(). 它负责按请求来调用server端的实体函数. </span></span></li><li><span class="name"><span class="innerContentContainer">最后，调用 ServiceManager.<b>AddService</b>() 把自己注册到 ServiceManager。</span></span><ul><li><span class="name"><span class="innerContentContainer">ServiceManager.AddService(string Name, IBinder Service);</span></span></li><li><span class="name"><span class="innerContentContainer">可将一个IBinder与name字符串绑定。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ServiceManager 向 Binder驱动注册该server.</span></span></li><li><span class="name"><span class="innerContentContainer">Binder驱动为这个 Binder创建位于内核的实体节点, 以及 ServiceManager对实体节点的引用. 并把这些信息返回给ServiceManager.</span></span><ul><li><span class="name"><span class="innerContentContainer">对驱动而言, 引用就是0,1,2,...这样的整数, 相当于是函数的序号. </span></span></li><li><span class="name"><span class="innerContentContainer">所以server和client要事先约定好函数顺序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ServiceManager 收到信息后, 把名称和引用填入查找表. </span></span></li><li><span class="name"><span class="innerContentContainer">至此，server初始化工作完成了。系统的server，比如ams，wms也是这样一个流程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">client侧发送请求</span></span><ul><li><span class="name"><span class="innerContentContainer">由于client 持有 IBinder 的影子类, 所以尽管自身代码中有调用service接口的代码, 并无实现, 也可以编译通过. 影子类的目的就是实现独立编译。</span></span></li><li><span class="name"><span class="innerContentContainer">在Client 进程中, 先调用 ServiceManager.GetService(string Name) 获取系统service对象, 参数为字符串, </span></span></li><li><span class="name"><span class="innerContentContainer">然后获取指定Name（各name由系统硬编译）对应的Server线程的编号(handle)。</span></span><ul><li><span class="name"><span class="innerContentContainer">后者是个32位的正整数，值随机。</span></span></li><li><span class="name"><span class="innerContentContainer">0专用于和servicemanager通讯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IBinder对象的最重要的一个函数是 IBinder.<b>TransAct</b>(int code, Parcel data, Parcel reply, int flag);  其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">code 是要调用的函数;</span></span></li><li><span class="name"><span class="innerContentContainer">data 是函数参数打包到Parcel 中去. binder引用地址写入 traget.handle. </span></span></li><li><span class="name"><span class="innerContentContainer">reply 是返回值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">然后调用remote()-&gt;transact(xxx);</span></span></li><li><span class="name"><span class="innerContentContainer">remote()是在BpXXXService的父类BpRefBase中实现的，返回的就是一个BpBinder.实际上调用的就是BpBinder的 transact();</span></span></li><li><span class="name"><span class="innerContentContainer">BpBinder的transact() 实现，就是直接调用 IPCThreadState::self()-&gt;transact() 发送数据。</span></span></li><li><span class="name"><span class="innerContentContainer">通过共享内存的方式，使用内核方法 copy_from_user() 将参数拷贝到内核空间。</span></span></li><li><span class="name"><span class="innerContentContainer">客户端进入等待状态。</span></span></li><li><span class="name"><span class="innerContentContainer">binder驱动向服务端的todo队列插入一条事务。</span></span></li><li><span class="name"><span class="innerContentContainer">事务执行完后，将执行结果通过 copy_to_user() 将内核结果copy到用户空间（不拷贝数据）。</span></span></li><li><span class="name"><span class="innerContentContainer">唤醒客户端并响应结果。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">server侧响应调用过程</span></span><ul><li><span class="name"><span class="innerContentContainer">该命令首先发给 <b>Binder驱动</b>, 驱动会根据 traget.handle 往 traget<b>.</b>ptr 字段中填写Binder对象的地址. 并把它转给server. </span></span></li><li><span class="name"><span class="innerContentContainer">server端通过 IPCThreadState 接收到 client的请求后，首先会调用 BBinder的 transact()。</span></span></li><li><span class="name"><span class="innerContentContainer">BBinder的 transact() 负责取出traget.ptr指针, reinterpret_cast 强转为Binder抽象类, 然后调用它的 onTransact() 方法. 这个方法是在 BnXXXService 中实现的。</span></span></li><li><span class="name"><span class="innerContentContainer">onTransact() 负责取出根据命令字id调用具体的方法.</span></span></li><li><span class="name"><span class="innerContentContainer">执行结果会通过binder驱动返回给 client.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">具体代码是:</span></span><ul><li><span class="name"><span class="innerContentContainer">server端代码</span></span><ul><li><span class="name"><span class="innerContentContainer">Class myService extends Binder {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected boolean OnTransact (int code, Parcel data, Parcel reply, int flags) throws RemoteException {...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关键是实现OnTransact(), 根据code实现逻辑分发.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Client端代码</span></span><ul><li><span class="name"><span class="innerContentContainer">IBinder myBinder = getService(Context.ACCESSIBILITY_SERVICE);   // 参数是字符串</span></span></li><li><span class="name"><span class="innerContentContainer">myBinder.transact(code, data, reply, 0);    // 执行完这一步, 线程会挂起</span></span></li><li><span class="name"><span class="innerContentContainer">reply.readException();</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Native层的binder (核心)</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>ProcessState: 管理设备节点 </b>/dev/binder</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/binder/<b>ProcessState</b>.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">每个binder通讯进程都持有唯一的ProcessState对象。</span></span></li><li><span class="name"><span class="innerContentContainer">ProcessState 主要接口有：</span></span></li><li><span class="name"><span class="innerContentContainer">ProcessState::self()&nbsp;:&nbsp;功能是 open(/dev/binder), Server/Client都会用到,&nbsp;因为它们都得打开内核设备节点.</span></span></li><li><span class="name"><span class="innerContentContainer">ProcessState::startThreadPool()&nbsp;: Server进程会用到,&nbsp;主要目的是创建一个线程,&nbsp;在线程里面while循环,&nbsp;监听是否有数据写入设备节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>IPCThreadState: </b>通过ioctl 读写 /dev/binder,完成用户空间与内核空间的数据交互.</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/binder/<b>IPCThreadState</b>.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">binder通讯进程可以有多个线程，每个线程都唯一持有一个 IPCThreadState 对象。</span></span></li><li><span class="name"><span class="innerContentContainer">在驱动层面有 Binder_thread 对象于与之一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">主要接口是:</span></span></li><li><span class="name"><span class="innerContentContainer">&nbsp;IPCThreadState::transact()&nbsp;: Client进程会用到,&nbsp;目的是往设备节点写入数据.</span></span><ul><li><span class="name"><span class="innerContentContainer">transact里面会分 waitForResponse(reply) 和 waitForResponse(NULL) 这两种情况,&nbsp;前者的意思是Client发送一个数据（请求/命令…）给Server后,&nbsp;需要等待Server的执行结果,&nbsp;结果存储在reply中;&nbsp;后者的意思是Client只是发送个请求,&nbsp;不需要等待对应的执行结果.</span></span></li><li><span class="name"><span class="innerContentContainer">两个 waitForResponse() 都会调用talkWithDriver,&nbsp;后者会调用 ioctl与 /dev/binder 交互.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IPCThreadState::joinThreadPool&nbsp;: Server进程会用到,&nbsp;ProcessState::startThreadPool()最终就是调用的IPCThreadState::joinThreadPool,&nbsp;目的就是监听设备节点.&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">joinThreadPool会调用getAndExecuteCommand(),&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">后者会调用talkWithDriver()监听设备节点,&nbsp;当收到一个数据后,&nbsp;就解析并执行相应的操作(ExecuteCommand).</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">上面这两个类主要用于通讯, 下面几个类主要用于binder数据封装.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>IBinder:  </b>是 BBinder 和 BpBinder 的基类.</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/<b>IBinder</b>.h</span></span></li><li><span class="name"><span class="innerContentContainer">它里面定义的一个重要接口是 transact().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IInterface: BnInterface 和 BpInterface 的基类</span></span><ul><li><span class="name"><span class="innerContentContainer">IInterface 定义了两个非常关键的接口:</span></span></li><li><span class="name"><span class="innerContentContainer">interface_cast(): 功能是统一管理binder对象(不分客户端和服务器端). 代码如下:</span></span><ul><li><span class="name"><span class="innerContentContainer">template&lt;typename INTERFACE&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return INTERFACE::<b>asInterface</b>(obj);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">这是一个模板函数. 每个binder对象都会按自己的类型来展开. 下面以 ICameraClient为例展开.</span></span></li><li><span class="name"><span class="innerContentContainer">inline sp&lt;ICameraClient &gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return ICameraClient ::asInterface(obj);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">ICameraClient ::asInterface() 在哪里定义的?</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/av/include/camera/android/hardware/ICameraClient.h 的内容是:</span></span></li><li><span class="name"><span class="innerContentContainer">DECLARE_META_INTERFACE(CameraClient);</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/av/camera/ICameraClient.cpp 的内容是:</span></span></li><li><span class="name"><span class="innerContentContainer">IMPLEMENT_META_INTERFACE(CameraClient, "android.hardware.ICameraClient");</span></span></li><li><span class="name"><span class="innerContentContainer">即通过宏 DECLARE_META_INTERFACE 和 IMPLEMENT_META_INTERFACE 来展开.</span></span></li><li><span class="name"><span class="innerContentContainer">其中, ICameraClient::asInterface() 的展开代码如下:</span></span></li><li><span class="name"><span class="innerContentContainer">android::sp&lt;ICameraClient&gt; ICameraClient::asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj) {</span></span><ul><li><span class="name"><span class="innerContentContainer">android::sp&lt;ICameraClient&gt; intr;</span></span></li><li><span class="name"><span class="innerContentContainer">if (obj != NULL) {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>// queryLocalInterface()是在IBinder中定义的，默认返回NULL. 但在BBinder的子类BnInterface中，重载了该方法，返回this，而BpBinder没有重载，使用IBinder的默认实现，返回NULL  --关键</b></span></span></li><li><span class="name"><span class="innerContentContainer">intr = static_cast&lt;ICameraClient*&gt;(obj-&gt;<b>queryLocalInterface</b>(ICameraClient::descriptor).get());</span></span></li><li><span class="name"><span class="innerContentContainer">if (intr == NULL) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 构建INTERFACE的Bp端代理对象</span></span></li><li><span class="name"><span class="innerContentContainer">intr = new BpCameraClient(obj);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return intr;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">asBinder():</span></span><ul><li><span class="name"><span class="innerContentContainer">asBinder() 会直接调用 onAsBinder(). 而后者在子类中定义, 其中:</span></span></li><li><span class="name"><span class="innerContentContainer">BnInterface的onAsBinder()， 直接返回自身;</span></span><ul><li><span class="name"><span class="innerContentContainer">template&lt;typename INTERFACE&gt; IBinder* BnInterface&lt;INTERFACE&gt;::onAsBinder() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return this;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BpInterface的onAsBinder()，调用remote()方法并返回.</span></span><ul><li><span class="name"><span class="innerContentContainer">template&lt;typename INTERFACE&gt; inline IBinder* BpInterface&lt;INTERFACE&gt;::onAsBinder() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return remote();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">remote() 在其父类 BpRefBase 中实现，就是返回 mRemote 变量.</span></span></li><li><span class="name"><span class="innerContentContainer">而mRemote变量是在创建BpInterface对象时，将remote变量传给了其父类BpRefBase.</span></span><ul><li><span class="name"><span class="innerContentContainer">template inline BpInterface::BpInterface(const sp&amp; remote) : BpRefBase(remote) {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>BpRefBase</b>: 客户端类</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/Binder.h, frameworks/native/libs/binder/Binder.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BpRefBase里面定义了一个变量&nbsp;:&nbsp;IBinder* const&nbsp;mRemote;&nbsp;这个mRemote实际上指的就是BpBinder.</span></span></li><li><span class="name"><span class="innerContentContainer">BpRefBase用于Client端, Client端的代码会继承BpRefBase,&nbsp;当Client端想往Server发送数据时,&nbsp;会使用mRemote-&gt;transact()的形式.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>BBinder: 服务器端</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/Binder.h, frameworks/native/libs/binder/Binder.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BBinder继承了IBinder,&nbsp;也实现了IBinder中定义的transact函数.前文我们说过Server端会开启一个线程,&nbsp;监听/dev/binder节点.&nbsp;当收到数据时, Server端的这个线程会调用BBinder::transact.</span></span></li><li><span class="name"><span class="innerContentContainer">BBinder用于Server端, BBinder除了继承了IBinder中的transact接口,&nbsp;它自己也定义了一个onTransact接口, Server端的代码一般会实现onTransact接口. </span></span></li><li><span class="name"><span class="innerContentContainer">BBinder::transact里面会调用onTransact函数,&nbsp;继而把Client端通过内核传递过来的数据交给Server端的代码进行处理,&nbsp;从而完成一次进程间通信.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>BpBinder: 客户端数据封装类, </b>继承了IBinder. 它存在于 BpRefBase中的 mRemote的成员变量中。</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/include/binder/BpBinder.h, frameworks/native/libs/binder/BpBinder.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">BpBinder并不在继承关系当中，它只是一个打包数据，该数据通过IPCThreadState::self()-&gt;transact()方法发送出去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>BnInterface</b>: 模板类, 所有服务器端类都是它的子类. 主要方法是: onAsBinder().</span></span></li><li><span class="name"><span class="innerContentContainer"><b>BpInterface</b>: 模板类, 所有客户端类都是它的子类. 主要方法是: onAsBinder().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">binder驱动在以misc设备进行注册，作为虚拟字符设备，但是这个设备没有操作硬件，只是对内存的处理。</span></span></li><li><span class="name"><span class="innerContentContainer">操作一个Binder，相当于打开 “/dev/binder”，然后通过该节点的 ioctl 接口传入命令。</span></span></li><li><span class="name"><span class="innerContentContainer">对 /dev/binder 的访问, 即是进行系统调用(syscall), 此时代码会陷入内核态. 陷入流程是:</span></span><ul><li><span class="name"><span class="innerContentContainer">比如, 打开Binder驱动方法的调用链为： open-&gt; __open() -&gt; binder_open()。</span></span></li><li><span class="name"><span class="innerContentContainer">其中, open()为用户空间的方法;</span></span></li><li><span class="name"><span class="innerContentContainer">__open()便是系统调用中相应的处理方法;</span></span></li><li><span class="name"><span class="innerContentContainer">对应调用到内核binder驱动的binder_open()方法.</span></span></li><li><span class="name"><span class="innerContentContainer">其它接口也是大同小异.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>接口:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">代码在：binder_module.h。</span></span></li><li><span class="name"><span class="innerContentContainer">open/close</span></span></li><li><span class="name"><span class="innerContentContainer">ioctl: 这是主要的接口.</span></span><ul><li><span class="name"><span class="innerContentContainer">参数包括三个：</span></span><ul><li><span class="name"><span class="innerContentContainer">fd，文件句柄；</span></span></li><li><span class="name"><span class="innerContentContainer">cmd，命令字；</span></span><ul><li><span class="name"><span class="innerContentContainer">BINDER_WRITE_READ，Binder读写（主要命令）；</span></span><ul><li><span class="name"><span class="innerContentContainer">由于有返回值，所以一旦write之后，必须有read操作，所以这两个动作放在一个命令中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER_SET_IDLE_TIMEOUT，设置请求超时；</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER_SET_REPALY_TIMEOUT，设置reply超时；</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER_SET_MAX_THREADS，设置线程池容量。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在：binder.h。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">args，参数和返回值。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel space中，/dev/binder 有如下接口：</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_open: 进行初始化</span></span></li><li><span class="name"><span class="innerContentContainer">binder_ioctl: 对命令字进行解析和分发</span></span></li><li><span class="name"><span class="innerContentContainer">binder_mmap: 内存映射，将Binder对象从内核空间映射到用户空间</span></span></li><li><span class="name"><span class="innerContentContainer">binder_flush: 将处在等待中的进程唤醒并返回</span></span></li><li><span class="name"><span class="innerContentContainer">代码在：binder.c。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>binder_ioctl() 处理流程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">如果传入的cmd是 BINDER_WRITE_READ, 则调用 binder_thread_write().</span></span></li><li><span class="name"><span class="innerContentContainer">后者对命令进一步解析，发现cmd为 bcTransaction，即发起IPC transaction，则将参数 binder_transaction_data 复制到内核空间。</span></span></li><li><span class="name"><span class="innerContentContainer">binder_transaction() 根据 binder_transaction_data 中的target字段可寻出被调者的进程，从该进程的缓冲区中<b>选择一个处在wait for ioctl的线程，将 binder_transaction_data 复制给它，并唤醒它。</b></span></span></li><li><span class="name"><span class="innerContentContainer">被调者用户线程执行相应指令。然后将执行结果写入新的 binder_transaction_data 中，通过ioctl发给内核，即发起一个新的transaction。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>内核将结果写入调用者线程的buffer中，并唤醒该线程。调用者得到结果。</b></span></span></li><li><span class="name"><span class="innerContentContainer">Binder可以传递对象引用。传递过程中，内核负责将其添加到对象映射表中。</span></span></li><li><span class="name"><span class="innerContentContainer">server进程收到rpc调用，则从线程池中选择一个线程处理rpc请求，包括cmd和reply两个过程。内核收到reply后，将其传给client。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder内存映射机制</span></span><ul><li><span class="name"><span class="innerContentContainer">由binder_mmap() 完成. 主要功能是:</span></span></li><li><span class="name"><span class="innerContentContainer">首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；</span></span></li><li><span class="name"><span class="innerContentContainer">然后再申请1个page大小的物理内存，</span></span></li><li><span class="name"><span class="innerContentContainer">再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder线程池</span></span><ul><li><span class="name"><span class="innerContentContainer">每个server进程在启动时创建一个binder线程池。线程数默认是16个。server进程探测到没有空闲线程时可增加线程，binder驱动也可以。</span></span></li><li><span class="name"><span class="innerContentContainer">其中0号线程默认用于server和servicemanager通讯用。线程池开辟完后就会被使用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">和第三方service的通讯过程</span></span><ul><li><span class="name"><span class="innerContentContainer">第三方service和系统service大同小异, 就是要定义唯一的字符串来作为service的名称, server和client要一致.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AIDL</span></span><ul><li><span class="name"><span class="innerContentContainer">AIDL相当于Binder脚本. 目的是</span></span></li><li><span class="name"><span class="innerContentContainer">RPC系统一般都会定义自己的接口定义语言（IDL），android上的叫aidl.</span></span></li><li><span class="name"><span class="innerContentContainer">aidl语法和java类似。例如:</span></span><ul><li><span class="name"><span class="innerContentContainer">interface IMyInterface {</span></span><ul><li><span class="name"><span class="innerContentContainer">int getData(int a);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AIDL文件如何编译？</span></span><ul><li><span class="name"><span class="innerContentContainer">用tools 目录下的aidl.exe编译.</span></span></li><li><span class="name"><span class="innerContentContainer">编译结果是 IMyInterface，以及内镶类 proxy和stub。</span></span></li><li><span class="name"><span class="innerContentContainer">IMyInterface 拷贝到 client 工程中使用.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">server 和 client 如何和 ServiceManager 通讯呢? </span></span><ul><li><span class="name"><span class="innerContentContainer">这种情况下, SMgr是server, 而各server 和 client 都是client. </span></span></li><li><span class="name"><span class="innerContentContainer">它们之前的Binder的引用固定为0, 不需要寻址. </span></span></li><li><span class="name"><span class="innerContentContainer">当一个进程建立Binder时, 使用 BINDER_SET_CONTEXT_MGR 来发起和SMgr的通讯, 完成注册自己. </span></span></li><li><span class="name"><span class="innerContentContainer">既然servicemanager作为所有Server进程/Client进程的服务端,&nbsp;那是不是应该提供相应的客户端的封装,&nbsp;以便客户端能方便与servicemanager通信呢? Android系统确实提供了这样的封装,&nbsp;它就是 frameworks/native/libs/binder/IServiceManager.cpp.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">匿名Binder</span></span><ul><li><span class="name"><span class="innerContentContainer">不向ServiceManager注册名字的Binder即位匿名Binder.</span></span></li><li><span class="name"><span class="innerContentContainer">其通讯方式是：通过已经建立的Binder连接将新的Binder实体传递给client. </span></span></li><li><span class="name"><span class="innerContentContainer">也就是说，它要求server和client之间至少已经存在了一个实名Binder.</span></span></li><li><span class="name"><span class="innerContentContainer">匿名Binder无法被第三方破解, 比较安全.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder与intent</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">Android的广播机制是一种 Publish/subscribepattern. </span></span><ul><li><span class="name"><span class="innerContentContainer">Publish(发布者)只会将不同类型的讯息传送出去, 并不会在意subscribe(订阅者);</span></span></li><li><span class="name"><span class="innerContentContainer">而 subscribe(订阅者)只在意想接收的讯息, 并不会在意谁是Publish(发布者).</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静态注册广播</span></span><ul><li><span class="name"><span class="innerContentContainer">静态注册是在AndroidManifest.xml上加一个receiver tag来指定. 在编译android app就指定好了</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态注册广播</span></span><ul><li><span class="name"><span class="innerContentContainer">在代码中, 调用 Context.registerReceiver() 来注册. </span></span></li><li><span class="name"><span class="innerContentContainer">registerReceiver() 的实现在 ContextImpl.java.</span></span><ul><li><span class="name"><span class="innerContentContainer">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return registerReceiver(receiver, filter, null, null);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public Intent <b>registerReceiver</b>(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// registerReceiverInternal() 做了两件事, 先将传入reciever包装产生一个IIntentReceiver, 然后再将IIntentReceiver传送给 AMS 去注册.</span></span></li><li><span class="name"><span class="innerContentContainer">private Intent <b>registerReceiverInternal</b>(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) {</span></span><ul><li><span class="name"><span class="innerContentContainer">IIntentReceiver rd = null;</span></span></li><li><span class="name"><span class="innerContentContainer">if (receiver != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">// mPackageInfo是一个LoadedApk的对象.</span></span></li><li><span class="name"><span class="innerContentContainer">rd = mPackageInfo.<b>getReceiverDispatcher</b>(receiver, context, scheduler, mMainThread.getInstrumentation(), true);</span></span></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">rd = new LoadedApk.ReceiverDispatcher(receiver, context, scheduler, null, true).getIIntentReceiver();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">final Intent intent = ActivityManagerNative.getDefault().<b>registerReceiver</b>(mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId);</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">return intent;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (RemoteException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">throw e.rethrowFromSystemServer();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">继续看下 LoadedApk.getReceiverDispatcher()</span></span><ul><li><span class="name"><span class="innerContentContainer">先产生一个receiver的ReceiverDispatcher然后再产生一个ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;来做管理.最后会执行ReceiverDispatcher的getIIntentReceiver方法.</span></span></li><li><span class="name"><span class="innerContentContainer">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler,Instrumentation instrumentation, boolean registered) {</span></span><ul><li><span class="name"><span class="innerContentContainer">synchronized (mReceivers) {</span></span><ul><li><span class="name"><span class="innerContentContainer">LoadedApk.ReceiverDispatcher rd = null;</span></span><ul><li><span class="name"><span class="innerContentContainer">ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">if (rd == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered);</span></span></li><li><span class="name"><span class="innerContentContainer">if (registered) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (map == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">mReceivers.put(context, map);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">map.put(r, rd);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">rd.validate(context, handler);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">// getIIntentReceiver()回传的 IItentReciever是一道Receiver Binder interface.</span></span></li><li><span class="name"><span class="innerContentContainer">return rd.getIIntentReceiver();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">至此, InnerReceiver(IBinder) 创建出来, 下面看 AMS.registerReceiver()</span></span><ul><li><span class="name"><span class="innerContentContainer">// 启动一个binder调用. request id 是 REGISTER_RECEIVER_TRANSACTION.</span></span></li><li><span class="name"><span class="innerContentContainer">public Intent registerReceiver(IApplicationThread caller, String packageName, IIntentReceiver receiver, IntentFilter filter, String perm, int userId) throws RemoteException {</span></span><ul><li><span class="name"><span class="innerContentContainer">Parcel data = Parcel.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">Parcel reply = Parcel.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">mRemote.<b>transact</b>(REGISTER_RECEIVER_TRANSACTION, data, reply, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">最终调用到 ActivityManagerService.java 的 registerReceiver().</span></span></li><li><span class="name"><span class="innerContentContainer">// 使用 mRegisteredReceivers 将IIntentReceiver放进Receiver list.最后在执行 mReceiverResolver的addFilter新增一个BroadcastFilter. 之后在发送讯息阶段时,就会利用 mReceiverResolver来做传送媒介.</span></span></li><li><span class="name"><span class="innerContentContainer">public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">mRegisteredReceivers.put(receiver.asBinder(), rl);</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);</span></span></li><li><span class="name"><span class="innerContentContainer">rl.add(bf);&nbsp; // rl 是一个ReceiverList data.</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li><li><span class="name"><span class="innerContentContainer">mReceiverResolver.addFilter(bf); // mReceiverResolver是一个IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; data</span></span></li><li><span class="name"><span class="innerContentContainer">[…]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">发送广播</span></span></li><li><span class="name"><span class="innerContentContainer">接受广播</span></span></li></ul>
  </body>
</html>