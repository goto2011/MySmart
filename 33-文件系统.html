<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">33-文件系统</span></span><ul><li><span class="name"><span class="innerContentContainer">FAT32 system图示  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">SD卡驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">线序</span></span><ul><li><span class="name"><span class="innerContentContainer">共计10根线</span></span></li><li><span class="name"><span class="innerContentContainer">data 0-3（左右两边各2）</span></span><ul><li><span class="name"><span class="innerContentContainer">data3还可以做卡插入识别功能。</span></span></li><li><span class="name"><span class="innerContentContainer">一般卡座上会另外加一根中断线侦听sd卡插拔，所以不这么用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">clk（左4）</span></span></li><li><span class="name"><span class="innerContentContainer">GP1（左5）</span></span></li><li><span class="name"><span class="innerContentContainer">cmd（左6）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">理论速度： 4根data线，若clk配成50Mhz，则理论速率为25MB。</span></span></li><li><span class="name"><span class="innerContentContainer">命令字</span></span><ul><li><span class="name"><span class="innerContentContainer">识别高速卡： SD_ACMD 13 命令可获取sd_status，其中有speed class。</span></span></li><li><span class="name"><span class="innerContentContainer">识别spec版本： ACMD 51 命令，获取SCR寄存器，其中有版本号。</span></span></li><li><span class="name"><span class="innerContentContainer">获取制造商信息及串号： CMD2 获取，CID寄存器中有。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SD卡初始化命令序列</span></span><ul><li><span class="name"><span class="innerContentContainer">power</span></span></li><li><span class="name"><span class="innerContentContainer">clk</span></span></li><li><span class="name"><span class="innerContentContainer">CMD5: 寻找SD卡</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SDIO卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">config clk: 初始化阶段配置为400K</span></span></li><li><span class="name"><span class="innerContentContainer">CMD0: reset</span></span></li><li><span class="name"><span class="innerContentContainer">CMD8: 识别SDHC</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SDHC卡</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMD55: 是否支持ACMD</span></span></li><li><span class="name"><span class="innerContentContainer">ACMD41: 电压协商</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SD卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMD1: idle</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为 MMC卡.</span></span></li><li><span class="name"><span class="innerContentContainer">如果这个也不能回应，则为不可识别的卡。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SDIO控制器</span></span><ul><li><span class="name"><span class="innerContentContainer">sdio host控制器硬件在芯片中，共有4个控制器接口。其中:</span></span></li><li><span class="name"><span class="innerContentContainer">sdio1给sd卡用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio2给wifi用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio3给emmc用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio4 闲置.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动代码</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/mmc/. 下面有三个目录：</span></span><ul><li><span class="name"><span class="innerContentContainer">core</span></span><ul><li><span class="name"><span class="innerContentContainer">核心代码，与平台无关的通用代码放在这里。</span></span></li><li><span class="name"><span class="innerContentContainer">对 SDIO/SD/MMC的识别就在这个目录中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">host</span></span><ul><li><span class="name"><span class="innerContentContainer">对应的各硬件平台的sd host控制器与sd卡交互的代码，以及sd卡驱动参数配置。</span></span></li><li><span class="name"><span class="innerContentContainer">如 msm_sdcc.c就是负责把sd命令发给sd卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">card</span></span><ul><li><span class="name"><span class="innerContentContainer">block.c 即块设备驱动，负责把读写IO请求放入队列；</span></span></li><li><span class="name"><span class="innerContentContainer">queue.c 即队列管理，把读写IO请求翻译为sd host控制器可以识别的信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">平台设备部分</span></span><ul><li><span class="name"><span class="innerContentContainer">sdio模块的驱动在内核中注册的是platform驱动模型.</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO配置、SD VDD电源和时钟等，在/kernel/arch/arm/board_msm7***.c中配置。</span></span></li><li><span class="name"><span class="innerContentContainer">这部分每个产品都有区别，独立出来方便管理。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化步骤分为:</span></span><ul><li><span class="name"><span class="innerContentContainer">device 的注册</span></span><ul><li><span class="name"><span class="innerContentContainer">msm7x2x_init_mmc</span></span></li><li><span class="name"><span class="innerContentContainer">msm_add_sdcc(2, &amp;msm7x2x_sdc2_data)&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">platform_device_register&nbsp; //注册的设备名为msm_sdcc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">driver 的注册</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/mmc/msm_sdcc.c</span></span></li><li><span class="name"><span class="innerContentContainer">msmsdcc_init()</span></span></li><li><span class="name"><span class="innerContentContainer">platform_driver_register(&amp;msmsdcc_driver);</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc初始化的代码: board_msm7x27a.c，msm7x27a_init_mmc()</span></span></li><li><span class="name"><span class="innerContentContainer">配置sdcc gpio的代码</span></span><ul><li><span class="name"><span class="innerContentContainer">board_msm7x30.c</span></span></li><li><span class="name"><span class="innerContentContainer">msm_gpio sdc4_cfg_data[]</span></span></li><li><span class="name"><span class="innerContentContainer">{GPIO_CFG(58, 1, GPIO_CFG_OUTPUT, ..., GPIO_CFG_15MA (启动能力), "sdc4_clk"};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC特性</span></span><ul><li><span class="name"><span class="innerContentContainer">EMMC 就是sd卡，最小容量为2G，替代flash作为存储介质。</span></span></li><li><span class="name"><span class="innerContentContainer">emmc的一个主要特征是只允许一个执行单元访问.</span></span></li><li><span class="name"><span class="innerContentContainer">所以在app阶段，app负责访问emmc，而modem侧代码不能直接访问。</span></span><ul><li><span class="name"><span class="innerContentContainer">那么, modem侧文件系统怎么机制?</span></span><ul><li><span class="name"><span class="innerContentContainer">使用ram fs。</span></span></li><li><span class="name"><span class="innerContentContainer">modem 读写ram fs；</span></span></li><li><span class="name"><span class="innerContentContainer">其读写请求会被app侧获取，然后app访问真正的emmc，然后app把数据同步到ram fs；</span></span></li><li><span class="name"><span class="innerContentContainer">最后modem 从ram fs 中得到数据。</span></span></li><li><span class="name"><span class="innerContentContainer">也就是说，modem 必须异步的调用。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">分区表</span></span><ul><li><span class="name"><span class="innerContentContainer">生成方式变了，通过 xml+loadpt.cmm = bin文件；不需要编译。</span></span></li><li><span class="name"><span class="innerContentContainer">mbr 下有三个主分区 + 一个扩展分区（ebr）；</span></span></li><li><span class="name"><span class="innerContentContainer">ebr 下面之后可以容纳15 个逻辑分区。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何新建分区？</span></span><ul><li><span class="name"><span class="innerContentContainer">修改这个文件：AMSS\products\**\tools\jsdcc\partition_load_pt\partition.xml</span></span></li><li><span class="name"><span class="innerContentContainer">添加如下代码:&lt;extended order="1" type="59" label="OEMINFO" size="24576" readonly="false"&gt;&lt;file name="***.mbn" offset="0"/&gt;&lt;/extended&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">order: 分区的位置；</span></span></li><li><span class="name"><span class="innerContentContainer">type: 分区id, 自己定义；</span></span></li><li><span class="name"><span class="innerContentContainer">size: 大小, 定位为sector, 即 512Byte；</span></span></li><li><span class="name"><span class="innerContentContainer">file name: 有这个选项后, 会自动生成下载该分区的cmm脚本.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运行 loadpt.exe ，生成 partition.bin 及cmm脚本。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">emmc读写速率</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc是8根data线，时钟最大是50mhz，所以理论速率为50MBs.</span></span></li><li><span class="name"><span class="innerContentContainer">实测数据是10MBs。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC有两种方案</span></span><ul><li><span class="name"><span class="innerContentContainer">SLC</span></span><ul><li><span class="name"><span class="innerContentContainer">Single Layer Cell 单层单元。</span></span></li><li><span class="name"><span class="innerContentContainer">SLC的特点是成本高、容量小、速度快。</span></span></li><li><span class="name"><span class="innerContentContainer">SLC闪存的优点是复写次数高达100000次，比MLC闪存高10倍。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MLC</span></span><ul><li><span class="name"><span class="innerContentContainer">Multi-Level Cell 多层单元。</span></span></li><li><span class="name"><span class="innerContentContainer">MLC的特点是容量大，但速度慢。</span></span></li><li><span class="name"><span class="innerContentContainer">MLC的每个单元是2bit的，相对SLC来说整整大了一倍。</span></span></li><li><span class="name"><span class="innerContentContainer">由于结构复杂，出错的几率增加，需要做错误修正，导致其性能大幅落后于SLC闪存。&nbsp;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Vold</span></span><ul><li><span class="name"><span class="innerContentContainer">vold.conf: android\system\core\rootdir\etc\msm7630_surf\vold.qcom.conf</span></span></li><li><span class="name"><span class="innerContentContainer">mount service的代码: nativeDaemonConnector.java 之 doCommand()</span></span></li><li><span class="name"><span class="innerContentContainer">外置sd卡插拔的uevent发出: VolumeManager::handleBlockEvent()</span></span></li><li><span class="name"><span class="innerContentContainer">mount service下发mount命令的入口: VolumeManager::mountVolume()</span></span></li><li><span class="name"><span class="innerContentContainer">mount service下发umount命令的入口: Volume::unmountVol()</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡mount成功的log: Volume sdcard state Changing 3(checking) -&gt; 4(Mounted)</span></span></li><li><span class="name"><span class="innerContentContainer">fat check工具</span></span><ul><li><span class="name"><span class="innerContentContainer">/system/bin/fsck_msdos -p -f /mnt/sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">作为对比：windows上，chkdsk h:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">fat check的处理流程</span></span><ul><li><span class="name"><span class="innerContentContainer">在logswap()中，调用fork，创建一个子进程，然后调用child()加载 fsck_msdos工具进行检查。</span></span></li><li><span class="name"><span class="innerContentContainer">此时父进程通过 wait(&amp;status) 来等待子进程执行完毕。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP</span></span><ul><li><span class="name"><span class="innerContentContainer">PTP（Picture Transfer Protocol），MTP的前身，用在数码相机和MP3播放器上做文件传输。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP（Media Transfer Protocol，媒体传输协议），微软2006年提出。</span></span></li><li><span class="name"><span class="innerContentContainer">Android从3.0开始支持MTP。</span></span></li><li><span class="name"><span class="innerContentContainer">usb插入后，系统会弹出一个对话框，选择“Transfer files"即打开MTP。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP和UMS（即U盘）的对比</span></span><ul><li><span class="name"><span class="innerContentContainer">优势：</span></span><ul><li><span class="name"><span class="innerContentContainer">UMS挂载到PC后，存储器就被PC控制，手机侧不能再访问该存储器。这个不方便。</span></span></li><li><span class="name"><span class="innerContentContainer">在存储器重新挂载到手机后，需要重新扫描媒体文件。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP则没有这两个问题。当手机的sdcard以MTP模式挂载到PC机上，sdcard的控制权其实还是属于手机。只不过智能手机通过MTP协议向PC机构建了一个虚拟文件系统。PC机操作其中的文件时，都会通过标准MTP协议向智能手机发起请求。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP模式下，可判断PC机拷贝的媒体文件是否受目标手机支持，甚至会触发对应的转码程序将其转换成手机支持的格式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">劣势</span></span><ul><li><span class="name"><span class="innerContentContainer">速度较慢。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP不能直接修改文件本身。只能先拷贝到本地修改，完毕后再拷贝回去。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux和MacOS对MTP支持还不是很完善。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP协议有两个部分：Initiator（USB Host，例如PC机）和Responder（USB Client，例如手机或相机）。</span></span></li><li><span class="name"><span class="innerContentContainer">协议规定所有MTP操作只能由Initator发起。</span></span></li><li><span class="name"><span class="innerContentContainer">Responder 的作用就是处理Initator发起的请求。同时，它还会根据自身状态的变化发送Event以通知 Initiator。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP协议栈</span></span><ul><li><span class="name"><span class="innerContentContainer">物理层。用于传输数据。目前有三种物理层可供MTP使用。它们分别是：</span></span><ul><li><span class="name"><span class="innerContentContainer">USB：其主要特点是传输文件，同步媒体文件时速度快，而且可以边工作边充电，这是目前用的最多的一种方式；</span></span></li><li><span class="name"><span class="innerContentContainer">IP：基于IP的MTP（简称MTP/IP）将通过UPnP来匹配和发现设备。它是家庭网络中是最理想的传输方式；</span></span></li><li><span class="name"><span class="innerContentContainer">Bluetooth：MTP/BT是最省电，同时也是速度最慢的一种传输方式，用处较少。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输层：数据传输格式遵循PTP协议。</span></span></li><li><span class="name"><span class="innerContentContainer">命令层：实现MTP协议中的各种命令。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">以PC通过MTP打开一个文件为例，介绍其中涉及到几个主要MTP命令：</span></span><ul><li><span class="name"><span class="innerContentContainer">当设备第一次连接上PC后，Initiator（即PC）首先会发送一个名为 GetDeviceInfo 的请求以获取设备的信息，包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">设备所支持PTP版本的程度，以百分号表示（默认是100）</span></span></li><li><span class="name"><span class="innerContentContainer">所支持的MTP命令（Operation Supported）、</span></span></li><li><span class="name"><span class="innerContentContainer">所支持的Event类型等等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接着PC端会发送 OpenSession 命令以创建一个会话，该会话一直保持到设备从PC上断开为止。</span></span><ul><li><span class="name"><span class="innerContentContainer">此后所有命令（除GetDeviceInfo命令外）必须在此会话存活期间才能发送。</span></span></li><li><span class="name"><span class="innerContentContainer">会话由SessionID来标识，它是一个32位的无符号整型。</span></span></li><li><span class="name"><span class="innerContentContainer">SessionID由PC选择并传给手机。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PC端需要通过 GetStorageIDs 命令返回某个盘符对应的 StorageID。</span></span><ul><li><span class="name"><span class="innerContentContainer">PC端如果要进行文件操作的话，必须从根目录开始定位目标文件。在windows上，根目录即为盘符。</span></span></li><li><span class="name"><span class="innerContentContainer">StorageID是一个32位无符号整型，每一个StorageID代表了一个逻辑盘符。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，如果手机内部有两块存储卡的话（如内部存储卡和外部sd卡），Windows中会显示为两个盘符。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">根据上一步的StorageID号，利用 GetStorageInfo 操作去获取存储设备的信息，例如剩余存储空间、文件系统类型、访问权限等。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 GetObjectHandles 命令来获取此盘符下的文件和子目录的Object Handles。</span></span><ul><li><span class="name"><span class="innerContentContainer">一个Object Handle代表一个文件或目录。该值由Responder生成并保证唯一性。</span></span></li><li><span class="name"><span class="innerContentContainer">有了Object Handle，PC就可以操作这些文件或目录了，例如继续通过GetObjectHandles获取某个目录中子文件和子目录的信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果需要拷贝一个文件到手机上，那么PC会通过SendObjectInfo命令将文件信息（如文件名、文件大小）等传递给手机。而手机需要检查目标目录是否有足够的空间和对应权限。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一切正常，PC将通过SendObject把数据传递给手机。真正写文件到设备存储空间的则是手机中的Responder。Android实现的MTP还会在媒体文件传输完毕后，将信息更新到媒体数据库中。</span></span></li><li><span class="name"><span class="innerContentContainer">PC还可利用SetObjectPropValue 命令来设置文件的各种属性值，如Audio BitRate（比特率），Sample Rate（采样率），Number Of Channels（声道）等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UsbService</span></span><ul><li><span class="name"><span class="innerContentContainer">Android 的 UsbService 可同时管理USB Host/USB Device。其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">UsbDeviceManager管理Usb Device端的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">UsbHostManager管理Usb Host端的功能。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpServer</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Client</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>MtpReceiver</b>负责接收广播，接收到广播后会启动/关闭MtpService；例如，MtpReceiver收到"Android设备 和 PC连上"的消息时，会启动MtpService。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MtpService</b>的作用是提供管理MTP的服务，它会启动MtpServer，以及将本地存储内容和MTP的内容同步。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MediaProvider</b>负责本地存储内容查找和本地内容同步。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Server</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>MtpServer</b>相当于一个服务器，它通过和底层进行通信从而提供了MTP的相关服务。</span></span><ul><li><span class="name"><span class="innerContentContainer">MtpServer会不断地监听Kernel的消息"MTP请求"，并对相应的消息进行相关处理。</span></span></li><li><span class="name"><span class="innerContentContainer">同时，MTP的Event事件也是通过MtpServer发送给MTP驱动的。</span></span></li><li><span class="name"><span class="innerContentContainer">android_mtp_MtpServer 是一个JNI类，完成底层通讯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpDatabase</b>充当着数据库的功能，但它本身并没有数据库对数据进行保存，本质上是通过MediaProvider数据库获取所需要的数据。</span></span><ul><li><span class="name"><span class="innerContentContainer">android_mtp_MtpDatabase 是一个JNI类，完成对MediaProvider的操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpStorage</b>对应一个"存储单元"。例如，SD卡就对应一个MtpStorage。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MtpPacket </b>和 <b>MtpEventPacket</b>负责对MTP消息进行打包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化过程中，MtpServer.cpp中的MtpServer::run()会打开MTP文件节点"/dev/mtp_usb"。</span></span></li><li><span class="name"><span class="innerContentContainer">数据过程中，通过 read()，不断的从中读取"PC发来的消息"消息并进行处理。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP启动详细流程</span></span><ul><li><span class="name"><span class="innerContentContainer">开启MTP的核心代码如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">mUsbManager = context.getSystemService(UsbManager.class);</span></span></li><li><span class="name"><span class="innerContentContainer">mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_MTP, true);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UsbManager的服务端实现为UsbService，其功能是：</span></span><ul><li><span class="name"><span class="innerContentContainer">1.&nbsp; 设置sys.usb.config属性的值为 mtp,adb，底层响应属性改变，切换到MTP功能。文件在： system/core/rootdir/init.usb.configfs.rc</span></span></li><li><span class="name"><span class="innerContentContainer">2.&nbsp; 上层mUEventObserver监听到USB状态改变，在手机通过USB连接到电脑的情况下，会生成两个通知，以及发送一个USB状态改变的广播。frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java</span></span><ul><li><span class="name"><span class="innerContentContainer">ACTION_USB_STATE广播携带了很多extra（可以到Tethering.java中查看extra参数用途）。</span></span></li><li><span class="name"><span class="innerContentContainer">这个广播是<b>黏性广播</b>，这意味着你在注册broadcastReceiver后马上就能收到一次。所以即使我们插着usb线开机，没有插入usb线的操作去trigger，我们注册广播后依然可以把usb模式转换为mtp模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MtpReceiver.java属于packages/providers/MediaProvider模块。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java</span></span></li><li><span class="name"><span class="innerContentContainer">handleUsbState()方法如何处理USB状态改变的。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java</span></span><ul><li><span class="name"><span class="innerContentContainer">USB连接时，状态是从DISCONNECTED到CONNECTED，再到CONFIGURED。</span></span></li><li><span class="name"><span class="innerContentContainer">handleUsbState中启动MtpService。参数unlocked的值是true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MtpService 启动时候执行onStartCommand函数。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java</span></span></li><li><span class="name"><span class="innerContentContainer">StartServer函数启动MtpServer。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/media/java/android/mtp/MtpServer.java</span></span></li><li><span class="name"><span class="innerContentContainer">native_run函数最终调用JNI的函数android_mtp_MtpServer_run()。 frameworks/base/media/jni/android_mtp_MtpServer.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">android_mtp_MtpServer_run调用MtpServer.cpp的run方法。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/av/media/mtp/MtpServer.cpp。</span></span></li><li><span class="name"><span class="innerContentContainer">MtpServer.cpp不断从文件描述符读取请求，然后调用handleRequest进行处理。最后把处理结果返回给对端。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SD/EMMC问题定位经验  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">注意sd卡插拔诊断方式的处理代码，是否整个sd卡初始化流程根本没有启动。</span></span></li><li><span class="name"><span class="innerContentContainer">电源电压值是否ok，是否没有打开电源。出现的概率最高，也最好测出来。</span></span></li><li><span class="name"><span class="innerContentContainer">上电时序要符合协议要求；0到2.6V，要平滑上升。</span></span></li><li><span class="name"><span class="innerContentContainer">clk是否成功配下去，clk线的速率是否和配置值吻合;&nbsp; data 线是否有数据交互。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡的类型是否成功识别；</span></span></li><li><span class="name"><span class="innerContentContainer">是否底层已经初始化成功，但是没有正确的通知上层，导致ui无法访问卡内容；</span></span></li><li><span class="name"><span class="innerContentContainer">读卡过程中出现 crc fail错误，一般为频率太高。我们的硬件信号在50M高速传输下有问题，将其改为20M此错误会不出现。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡 第0个sector 读失败，导致FAT32 无法mount，很像兼容性问题。格式化能解决该问题（数据会丢失）。</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹混乱问题。使用 winhex.exe 定位。</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡初始化时间过长，导致时序相关问题。（升级时vvs不恢复）</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡访问速度太慢问题。排除卡自身的问题后，软件方面的原因较可能是时钟频率设得太低。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡错误处理中断注册的问题。高通代码中对sd卡的大部分中断都没有处理，导致一些问题。遇到了注册上即可。</span></span></li><li><span class="name"><span class="innerContentContainer">在上层调用底层接口往sd卡写数据之前，应该清一下cache；因为底层sd卡读写是采用DMA 方式。如果cache和内存有不同步的地方，则DMA会写入错误的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">由于高通默认配置中，蓝牙电源使用GP1配置，而我们的硬件上GP1电源给SD卡。但是相关代码没有按照这个修改来调整，导致蓝牙开关电源时实际上是在控制GP1电源，最终导致sd卡状态不正常。</span></span></li><li><span class="name"><span class="innerContentContainer">文件名超长问题。</span></span></li><li><span class="name"><span class="innerContentContainer">文件只读导致无法修改、删除、剪贴。</span></span></li><li><span class="name"><span class="innerContentContainer">seek超过文件大小的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">文件系统性能。</span></span></li></ul></li></ul>
  </body>
</html>