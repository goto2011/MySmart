<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">32-Memory</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">kmalloc() 和 kfree()</span></span></li><li><span class="name"><span class="innerContentContainer">内核和用户空间之间交换数据</span></span><ul><li><span class="name"><span class="innerContentContainer">copy_to_user()</span></span></li><li><span class="name"><span class="innerContentContainer">copy_from_user()</span></span></li><li><span class="name"><span class="innerContentContainer">使用它们要特别小心，因为用户空间的内存地址可能已经被交换到外设，此时当前进行会sleep，直至该页交换回内存再唤醒。这就要求调用这些函数的内核代码可以睡眠，并允许重入。</span></span></li><li><span class="name"><span class="innerContentContainer">这个函数需要检查返回值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">linux 用户态进程如何使用内核设备节点的？</span></span><ul><li><span class="name"><span class="innerContentContainer">wait_event_interruptible&nbsp; 阻塞</span></span></li><li><span class="name"><span class="innerContentContainer">wake_up 唤醒</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux / Android / windows的内存管理的理念差异</span></span><ul><li><span class="name"><span class="innerContentContainer">在Linux中经常发现空闲内存很少，似乎所有的内存都被系统占用了，表面感觉是内存不够用了，其实不然。这是Linux内存管理的一个优秀特性.</span></span></li><li><span class="name"><span class="innerContentContainer">Windows是只在需要内存时，才为应用程序分配内存，不使用的情况下大量的内存空间被闲置。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux的想法不同, 在内存空间够用的情况下, 会将一些程序调用过的硬盘数据读入内存，利用内存读写的高速特性来提高系统性能。每增加一些物理内存，Linux都能利用起来，充分发挥了硬件投资带来的好处.</span></span></li><li><span class="name"><span class="innerContentContainer">Android的理念较之Linux更进一步，便是应用程序退出, 系统也会尽可能多保留该进程的内存资源, 以便在用户再次启动时提高响应时间.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android的内存机制</span></span><ul><li><span class="name"><span class="innerContentContainer">我们在用安卓手机的时候不需要太在意剩余内存. </span></span></li><li><span class="name"><span class="innerContentContainer">Bundle传递数据的限制: 不能超过0.5MB, 超过会报 TransactionTooLargeException 异常.</span></span></li><li><span class="name"><span class="innerContentContainer">android上, 每开一个应用就会打开一个独立的虚拟机。其实和java的垃圾回收机制类似，系统有一个规则来回收内存。</span></span></li><li><span class="name"><span class="innerContentContainer">进行内存调度有个阀值，只有低于这个值系统才会按一个列表来关闭用户不需要的东西。</span></span></li><li><span class="name"><span class="innerContentContainer">当然这个值默认设置得很小，所以你会看到内存老在很少的数值徘徊。但事实上他并不影响速度。相反加快了下次启动应用的速度。这本来就是&nbsp;android标榜的优势之一，如果人为去关闭进程，没有太大必要。</span></span></li><li><span class="name"><span class="innerContentContainer">为什么内存少的时候运行大型程序会慢? 原因是：在内存剩余不多时打开大型程序时会触发系统自身的调进程调度策略，甚至会反复触发, 这是十分消耗系统资源的操作, 对性能压力很大.</span></span></li><li><span class="name"><span class="innerContentContainer">如果不关程序是不是会耗电? android的应用在被切换到后台时，它其实已经被暂停了,并不会消耗cpu资源只保留了运行状态。所以为什么有的程序切出去重进会到主界面。</span></span></li><li><span class="name"><span class="innerContentContainer">一个程序如果想要在后台处理些东西，如音乐播放，它就会开启一个服务。服务可在后台持续运行，<b>所以在后台耗电的只有带服务的应用了。</b></span></span></li><li><span class="name"><span class="innerContentContainer">malloc 分配的内存需要高地址释放完后再释放低地址空间, 释放是串行的, 会导致虚拟地址占用很高. 相机连拍时易发生. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android应用内存被分为2部分：native和dalvik.</span></span><ul><li><span class="name"><span class="innerContentContainer">native即C/C++代码堆栈. </span></span></li><li><span class="name"><span class="innerContentContainer">dalvik即java堆，我们创建的对象是在这里面分配的.</span></span></li><li><span class="name"><span class="innerContentContainer">而bitmap是直接在native上分配的.</span></span></li><li><span class="name"><span class="innerContentContainer">对于内存的限制是 native+dalvik 不能超过最大限制, android应用一般限制在16M，也有24M的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Swap分区管理</b></span></span><ul><li><span class="name"><span class="innerContentContainer">为了缓解物理内存不足的问题, 在磁盘上开辟一块空间虚拟为一块内存区, 这个叫swap分区. Windows和 Linux上都用. </span></span></li><li><span class="name"><span class="innerContentContainer">当物理内存不足时, 内核会将暂时不用的内存块写到swap分区, 然后释放该内存块. 当需要使用之前的内存块时, 这些信息会被重新交换到物理内存中.</span></span></li><li><span class="name"><span class="innerContentContainer">内核根据"最近最常使用"的调度算法, 仅将最久不使用的页交换到swap空间.</span></span></li><li><span class="name"><span class="innerContentContainer">Linux系统会不时进行页交换, 即使物理内存够用, 目的是提高内存页交换性能. 经常出现的一种现象是, 物理内存还有很多, 但是交换空间也用了很多, 这是正常的. </span></span></li><li><span class="name"><span class="innerContentContainer">Android系统上, 由于外存使用的FLASH/EMMC, 其读写寿命远小于PC上用的磁盘, 所以不能把外存做swap空间. </span></span></li><li><span class="name"><span class="innerContentContainer">Android系统的办法是把一部分内存作为swap分区. 页交换是在两个内存区之间发生. </span></span></li><li><span class="name"><span class="innerContentContainer">对于存放在swap中的内存页, 会先压缩再交换(否则没有意义). 回写时要解压缩再交换到物理内存. 交换区叫 zram.</span></span></li><li><span class="name"><span class="innerContentContainer">查询 swap 的命令</span></span><ul><li><span class="name"><span class="innerContentContainer">cat /proc/sys/vm/swappiness, 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">0: 最大限度使用物理内存;</span></span></li><li><span class="name"><span class="innerContentContainer">60: Linux默认值</span></span></li><li><span class="name"><span class="innerContentContainer">100: 积极使用swap分区.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">cat /proc/sys/wm/drop_caches, 是否自动释放swap. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">0: 不释放</span></span></li><li><span class="name"><span class="innerContentContainer">1: 释放页缓存</span></span></li><li><span class="name"><span class="innerContentContainer">2: 释放dentries 和 inodes</span></span></li><li><span class="name"><span class="innerContentContainer">3: 释放所有缓存</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">关闭 swap</span></span><ul><li><span class="name"><span class="innerContentContainer">echo 0 &gt; /proc/sys/vm/swappiness</span></span></li><li><span class="name"><span class="innerContentContainer">echo 0 &gt; /proc/sys/vm/direct_swappiness</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种方法:</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell sysctl -w vm.swappiness=0</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">标准Linux的OOM Killer机制</span></span><ul><li><span class="name"><span class="innerContentContainer">在 mm/oom_kill.c中实现，且会被 __alloc_pages_may_oom调用(在分配内存时，即mm/page_alloc.c中)。</span></span></li><li><span class="name"><span class="innerContentContainer">核心函数是 out_of_memory，它选择一个bad进程Kill，Kill的方法是通过发送SIGKILL信号。</span></span></li><li><span class="name"><span class="innerContentContainer">在 out_of_memory中通过调用 select_bad_process() 来选择一个进程Kill，选择的依据在 badness() 中实现，基于多个标准来给每个进程评分，评分最高的被选中并Kill。</span></span></li><li><span class="name"><span class="innerContentContainer">一般而言，占用内存越多，oom_adj 就越大，也就越有可能被选中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Android LMK (Low Memory Killer)  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">执行条件: 剩余内存小于应用定义的 APP_MEM 值，开始比较进程的adj值，从高往底杀进程。</span></span></li><li><span class="name"><span class="innerContentContainer">杀进程的方式是: 发送SIGKILL信息，让该进程自杀(换句话说, 被杀的有机会留下临终遗言)。</span></span></li><li><span class="name"><span class="innerContentContainer">机制的源代码在 kernel/drivers/staging/android/lowmemorykiller.c</span></span></li><li><span class="name"><span class="innerContentContainer">adj值越高, 优先级越低.  adj的含义及赋值参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/59c892e36383">https://workflowy.com/#/59c892e36383</a></span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer"><b>内存泄漏的种类 <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">内存泄漏的根源在于长周期对象, 持有了短周期对象.</span></span></li><li><span class="name"><span class="innerContentContainer">持有Activity context异常</span></span><ul><li><span class="name"><span class="innerContentContainer">查看 <b>meminfo</b> 输出中的Activities. 如果有异常, 比如camera应用是单activity应用, 如果这个值大于2, 一般就是activity泄露. </span></span></li><li><span class="name"><span class="innerContentContainer">activity泄露的原因是有长周期的对象持有了短周期对象 Activity的 context. </span></span></li><li><span class="name"><span class="innerContentContainer">修改方案是不要通过Activity来获取 context, 而是通过 Application 获取 context. 因为一个虚拟机线程中只会有一个Application对象, 该对象的生命周期和线程一样长.</span></span></li><li><span class="name"><span class="innerContentContainer">代码如下: getApplicationContext().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">handle 持有activity导致内存泄漏</span></span><ul><li><span class="name"><span class="innerContentContainer">因为 java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用.</span></span></li><li><span class="name"><span class="innerContentContainer">由于Handler是非静态内部类, 所以其持有当前Activity的隐式引用. 如果Handler没有被释放，其所持有的Activity也不可能被释放. 这就导致内存泄漏.</span></span></li><li><span class="name"><span class="innerContentContainer">修改方案是使用静态内部类并继承Handler. 因为静态的内部类不会持有外部类的引用. </span></span></li><li><span class="name"><span class="innerContentContainer">在这种情况下, 如果Handler内部又要是用外部类, 也就是 Activity, 怎么办?</span></span></li><li><span class="name"><span class="innerContentContainer">使用弱引用.</span></span></li><li><span class="name"><span class="innerContentContainer">综合以上, 代码如下:</span></span></li><li><span class="name"><span class="innerContentContainer">private static class MyHandler extends Handler{</span></span><ul><li><span class="name"><span class="innerContentContainer">// 持有弱引用HandlerActivity, GC回收时会被回收掉.</span></span></li><li><span class="name"><span class="innerContentContainer">private final WeakReference&lt;HandlerActivity&gt; mActivty;</span></span></li><li><span class="name"><span class="innerContentContainer">public <b>MyHandler</b>(HandlerActivity activity){</span></span><ul><li><span class="name"><span class="innerContentContainer">mActivty =new WeakReference&lt;HandlerActivity&gt;(activity);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>handleMessage</b>(Message msg) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.handleMessage(msg);</span></span></li><li><span class="name"><span class="innerContentContainer">HandlerActivity activity=mActivty.get();</span></span></li><li><span class="name"><span class="innerContentContainer">if(activity != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 执行业务逻辑</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AsycTask 持有activity导致内存泄漏</span></span><ul><li><span class="name"><span class="innerContentContainer">和handle 持有activity导致内存泄漏完全一样, 解决方案也一样, 使用静态内部类.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">位图资源释放异常</span></span></li><li><span class="name"><span class="innerContentContainer">动画时序差异, 导致资源未释放</span></span><ul><li><span class="name"><span class="innerContentContainer">比如说在动画结束回调中释放资源. 一般情况下, 动画结束时业务逻辑已经执行完了. 但是在低概率情况没执行完. 此时会资源释放失败. 等业务逻辑执行完后, 由于动画早已结束, 导致资源没有释放.</span></span></li><li><span class="name"><span class="innerContentContainer">修改方案: 在业务执行完后, 检查动画状态, 如果动画已经执行完了, 就自行释放资源.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">openGL渲染错误导致内存泄露</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>内存消耗优化  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">清理冗余资源: 图片, 字符串, 冗余类.</span></span></li><li><span class="name"><span class="innerContentContainer">图片压缩</span></span></li><li><span class="name"><span class="innerContentContainer">bitmap加载优化</span></span><ul><li><span class="name"><span class="innerContentContainer">decode bitmap 的时候，尽量配置下Options，例如：inSameSize</span></span></li><li><span class="name"><span class="innerContentContainer">Bitmap使用完以后，调用 bitmap.recycle()来释放内存</span></span></li><li><span class="name"><span class="innerContentContainer">如果应用是基于图片的应用，尽量采用LazyLoad和DymanicRecycle</span></span></li><li><span class="name"><span class="innerContentContainer">decode bitmap 的时候，将decode代码 try catch 出来，catch oom error，避免程序crash，可以在catch里面做一些释放内存操作</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用bitmap池</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Hprof 使用方法</b></span></span><ul><li><span class="name"><span class="innerContentContainer">用<b>Hprof </b>分析工具可检测出泄漏的对象、activities、以及冗余重复的字符串。</span></span></li><li><span class="name"><span class="innerContentContainer">Hprof最初是由J2SE支持的一种二进制堆对象转储格式。但Android的Hprof文件与标准的java Hprof文件格式不一样。</span></span></li><li><span class="name"><span class="innerContentContainer">抓取方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">抓 hprof 文件: 手机要 remount. 然后使用:adb shell am dumpheap com.oppo.camera /data/1.hprof</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用eclipse MAT 分析 hprof文件</span></span><ul><li><span class="name"><span class="innerContentContainer">先把文件转换，进入进入&nbsp;android-sdk-windows\tools目录,  hprof_conv 1.hprof 1-1.hprof。</span></span></li><li><span class="name"><span class="innerContentContainer">eclipse上安装MAT: help - install new software - Search "MAT"。</span></span></li><li><span class="name"><span class="innerContentContainer">打开MAT：在Eclipse中点击 Windows-&gt;Open Perspective-&gt;Other-&gt;Memory Analysis</span></span></li><li><span class="name"><span class="innerContentContainer">导入.hprof文件: 在MAT中点击&nbsp;File-&gt;Open File打开刚刚转换而得到的yyyyy.hprof文件，并Cancel掉自动生成报告,点击Dominator Tree，并按Package分组，选择自己所定义的Package类点右键，在弹出菜单中选择List objects-&gt;With incoming references。</span></span></li><li><span class="name"><span class="innerContentContainer">分析报告: 这时会列出所有可疑类，右键点击某一项，并选择Path to GC Roots-&gt;exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用AS分析方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">在主窗口中点击 Captures按钮，或者选择&nbsp;View &gt; Tools Windows &gt; Captures，打开Captures窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">打开堆快照文件夹；双击HPROF文件，打开查看工具界面；</span></span></li><li><span class="name"><span class="innerContentContainer">选择你想查看的堆:</span></span><ul><li><span class="name"><span class="innerContentContainer">App heap&nbsp;- 当前app使用的堆</span></span></li><li><span class="name"><span class="innerContentContainer">Image heap&nbsp;- 当前app在硬盘上的内存映射</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote heap&nbsp;- zygote 复制时继承来的库、运行时类和常量的数据集。zygote空间设备启动时创建，从不分配这里的空间。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">选择你想查看的视图选项：</span></span><ul><li><span class="name"><span class="innerContentContainer">Class List View</span></span></li><li><span class="name"><span class="innerContentContainer">Package Tree View</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Hprof会展示Java堆，包括如下信息：</span></span><ul><li><span class="name"><span class="innerContentContainer">按类展示实例对象的内存使用情况；</span></span></li><li><span class="name"><span class="innerContentContainer">每次垃圾回收事件的样本数据；</span></span></li><li><span class="name"><span class="innerContentContainer">帮助分析哪些对象类型也许会导致内存泄漏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工具显示了如下信息：</span></span><ul><li><span class="name"><span class="innerContentContainer">Class name	类名</span></span></li><li><span class="name"><span class="innerContentContainer">Total Count	该类的实例总数</span></span></li><li><span class="name"><span class="innerContentContainer">Heap Count	所选择的堆中该类的实例的数量</span></span></li><li><span class="name"><span class="innerContentContainer">Sizeof	单个实例所占空间大小（如果每个实例所占空间大小不一样则显示0）</span></span></li><li><span class="name"><span class="innerContentContainer">Shallow Size	堆里所有实例大小总和（Heap Count * Sizeof）</span></span></li><li><span class="name"><span class="innerContentContainer">Retained Size	该类所有实例所支配的内存大小</span></span></li><li><span class="name"><span class="innerContentContainer">Instance	具体的实例</span></span></li><li><span class="name"><span class="innerContentContainer">Reference Tree	所选实例的引用，以及指向该引用的引用。</span></span></li><li><span class="name"><span class="innerContentContainer">Depth	GC根节点到所选实例的最短路径的深度</span></span></li><li><span class="name"><span class="innerContentContainer">Shallow Size	所选实例的大小</span></span></li><li><span class="name"><span class="innerContentContainer">Dominating Size	所选实例所支配的内存大小</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">转化成标准的HPROF文件</span></span><ul><li><span class="name"><span class="innerContentContainer">转化成标准的HPROF文件后可以使用Android Studio之外的分析工具来分析。</span></span></li><li><span class="name"><span class="innerContentContainer">Captures窗口HPROF文件列表中选择文件，右键点击&nbsp;Export to standard .hprof</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>meminfo</b> 数据含义  ***</span></span><ul><li><span class="name"><span class="innerContentContainer">查看内存占用情况: adb shell dumpsys meminfo com.oppo.camera -d</span></span></li><li><span class="name"><span class="innerContentContainer"><b>反复抓取 dumpsys meminfo</b> 输出, 看 Total 是否一直增大, 如果是则很可能存在内存泄漏问题.</span></span></li><li><span class="name"><span class="innerContentContainer">列字段:</span></span><ul><li><span class="name"><span class="innerContentContainer">Pss total: Proportional set size是内核的度量，包括共享内存。</span></span><ul><li><span class="name"><span class="innerContentContainer">私有内存页按100%计算. </span></span></li><li><span class="name"><span class="innerContentContainer">共享内存则按共享进程的数量均分.</span></span><ul><li><span class="name"><span class="innerContentContainer">系统会将共享内存的总大小除以参与共享的进程数。例如，一个在两个进程间共享的内存页, 每个进程更占一半。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">按照这种方式, 就可以将所有进程的Pss数据相加得到总共的RAM消耗。</span></span></li><li><span class="name"><span class="innerContentContainer">在进程间比较Pss也能够大致比较两者权重。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Private Dirty: 这部分代表进程内存中不能交换到硬盘，也不能和其他的进程共享的部分。换句话说，这部分的消耗只有当应用被销毁的时候才会被系统回收。</span></span></li><li><span class="name"><span class="innerContentContainer">Private  Clean: 代表当从磁盘载入的时候还没有改变的内存部分. 只要一个页内的内存改变过，且在系统必须要写入时, 才将内存块标记为脏。</span></span></li><li><span class="name"><span class="innerContentContainer">Swapped Dirty:  交换空间.</span></span><ul><li><span class="name"><span class="innerContentContainer">Android设备使用FLASH做磁盘, FLASH不支持交换区机制，所以Android上的Swap 空间是放到RAM中的.</span></span></li><li><span class="name"><span class="innerContentContainer">Swapped Dirty只有当应用退出的时候才会被释放。</span></span></li><li><span class="name"><span class="innerContentContainer">Android使用 ZRAM 压缩内存页，先压缩再放入Swap 空间，需要的时候先解压再交换回去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Heap Size:  Size 是需要的内存. Size = Alloc + Free</span></span></li><li><span class="name"><span class="innerContentContainer">Heap Alloc:  Alloc 是分配了的内存.</span></span></li><li><span class="name"><span class="innerContentContainer">Heap Free:  Free 是未使用的内存.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">行字段:</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Native </b>Heap: 原生堆. 进程自身使用的内存，C\C++代码. 从mallinfo usmblks获得，代表最大总共分配空间. 例如Unity Engine Code， Native C malloc， 和 Mono VM。其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">Size = Alloc + Free</span></span></li><li><span class="name"><span class="innerContentContainer">Alloc: 从mallinfo uorblks获得，总共分配空间</span></span></li><li><span class="name"><span class="innerContentContainer">Free: 从mallinfo fordblks获得，代表总共剩余空间</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Dalvik </b>Heap : 代表Dalvik虚拟机分配的内存.  Java代码. 从Runtime totalMemory()获得，Dalvik Heap总共的内存大小。其中: </span></span><ul><li><span class="name"><span class="innerContentContainer">Size = Alloc + Free</span></span></li><li><span class="name"><span class="innerContentContainer">Alloc: Runtime totalMemory()-freeMemory() ，Dalvik Heap分配的内存大小。</span></span></li><li><span class="name"><span class="innerContentContainer">Free:从Runtime freeMemory()获得，Dalvik Heap剩余的内存大小。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Dalvik Other：类数据结构和索引占据内存</span></span></li><li><span class="name"><span class="innerContentContainer">Stack：栈内存</span></span></li><li><span class="name"><span class="innerContentContainer">Ashmem：不以dalvik- 开头的内存区域，匿名共享内存用来提供共享内存通过分配一个多个进程可以共享的带名称的内存块。匿名共享内存（Anonymous Shared Memory-Ashmem。Android匿名共享内存是基于Linux共享内存的，都是在tmpfs文件系统上新建文件，并将其映射到不同的进程空间，从而达到共享内存的目的，只是，Android在Linux的基础上进行了改造，并借助Binder+fd文件描述符实现了共享内存的传递。</span></span></li><li><span class="name"><span class="innerContentContainer">Other dev：内部driver占用的内存</span></span></li><li><span class="name"><span class="innerContentContainer">.so mmap: C库代码占用的内存</span></span></li><li><span class="name"><span class="innerContentContainer">.jar mmap: java文件代码占用的内存</span></span></li><li><span class="name"><span class="innerContentContainer">.apk mmap: apk代码占用的内存</span></span></li><li><span class="name"><span class="innerContentContainer">.ttf mmap: ttf文件代码占用的内存</span></span></li><li><span class="name"><span class="innerContentContainer">.dex mmap: dex文件代码占用内存。类函数的代码和常量占用的内存，dex mmap是映射classex.dex文件，Dalvik虚拟机从dex文件加载类信息和字符串常量等。Dex文件有索引区和Data区</span></span></li><li><span class="name"><span class="innerContentContainer">Other mmap: 其它文件占用的内存</span></span></li><li><span class="name"><span class="innerContentContainer">EGL mtrack: 这个部分是gralloc的内存使用。主要是SurfaceView和TextureView的总和。它也包括了帧缓冲区，因此大小也会取决于framebuffers的尺寸。支持的屏幕分辨率越高，EGL mtrack的数目越高。在这个测试中，帧缓冲区的分辨率被降低了来确保比较好的性能。降低帧缓存的大小也会降低这些缓存需要的内存量。</span></span></li><li><span class="name"><span class="innerContentContainer">GL mtrack &amp; Gfx dev: GL和Gfx是驱动反馈的GPU内存，主要是GL纹理大小的总和，GL命令缓冲区，固定的全局驱动RAM消耗以及Shader。需要指出，这些不会出现在旧的Android版本上。注意：客户空间驱动和内核空间驱动共享同一个内存空间。在某些Android版本上，这个部分会被重复计算两次，因此Gfx dev要比实际上使用的数值更大。</span></span></li><li><span class="name"><span class="innerContentContainer">Unknown: Unknown值得是系统不能确定分页属于上面的那种。这个部分包括原生分配或者运行时metadata，因为Adress Space Layout Randomization，这个工具没办法确定内存。Private Dirty是只用于自己应用的未知RAM。</span></span></li><li><span class="name"><span class="innerContentContainer">Objects and SQL 信息都是从Android Debug信息中获得。</span></span></li><li><span class="name"><span class="innerContentContainer">Total: 总计. 当 total 超过单个程序内存的最大限制时，OOM就可能出现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Objects (对象统计): </span></span></li><li><span class="name"><span class="innerContentContainer">Views:&nbsp; &nbsp; &nbsp; &nbsp;90&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ViewRootImpl:&nbsp; &nbsp; &nbsp; &nbsp; 1</span></span></li><li><span class="name"><span class="innerContentContainer"><b>AppContexts:&nbsp; &nbsp; &nbsp; &nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Activities:&nbsp; &nbsp; &nbsp; &nbsp; 1</b></span></span></li><li><span class="name"><span class="innerContentContainer">Assets:&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; AssetManagers:&nbsp; &nbsp; &nbsp; &nbsp; 2</span></span></li><li><span class="name"><span class="innerContentContainer">Local Binders:&nbsp; &nbsp; &nbsp; &nbsp;21&nbsp; &nbsp; &nbsp; &nbsp; Proxy Binders:&nbsp; &nbsp; &nbsp; &nbsp;28</span></span></li><li><span class="name"><span class="innerContentContainer">Parcel memory:&nbsp; &nbsp; &nbsp; &nbsp;18&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Parcel count:&nbsp; &nbsp; &nbsp; &nbsp;74</span></span></li><li><span class="name"><span class="innerContentContainer">Death Recipients:&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; &nbsp; OpenSSL Sockets:&nbsp; &nbsp; &nbsp; &nbsp; 2</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>procrank </b>数据含义</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell procrank，这个工具可以查看所有进程使用的内存量，从高到低列出每个进程使用的内存使用量。部分手机支持. </span></span><ul><li><span class="name"><span class="innerContentContainer">每个进程列出Vss，Rss，Pss，和Uss 这4个数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Vss - Virtual Set Size, 一个进程总共可以获取的寻址空间。这个指标表明一个进程关联的虚拟内存空间。</span></span></li><li><span class="name"><span class="innerContentContainer">Rss - Resident Set Size, 一个进程分配到的物理内存页。被多个进程共享的内存页被计算多次。</span></span></li><li><span class="name"><span class="innerContentContainer">Pss - Proportional Set Size, 和Rss类似，只不过将共享的内存页处理共享的进程数来计算。</span></span></li><li><span class="name"><span class="innerContentContainer">Uss - Unique Set Size, = Private Dirty的概念，表明进程内不能被分页到硬盘的数据，不能被其他进程共享的内存部分。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果对GC有疑问, 在类中重写 finalize() 方法会有用.</span></span><ul><li><span class="name"><span class="innerContentContainer">public void finalize() throws Throwable {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(Tag, "finalize(): " + this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} finally {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.finalize();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Android Malloc Debug: native代码内存调试工具</b></span></span><ul><li><span class="name"><span class="innerContentContainer">工具代码在: bionic/libc/bionic/malloc_debug_common.c/h/cpp. 下面说实操.</span></span></li><li><span class="name"><span class="innerContentContainer">准备一个userdebug或eng版本手机，尽量选择32bit机器，64bit设备会非常卡.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>下述命令, 请在使用前后关开java虚拟机.</b></span></span></li><li><span class="name"><span class="innerContentContainer">打开系统的malloc debug</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell setprop libc.debug.malloc &lt;配置项&gt;. 配置项有:</span></span></li><li><span class="name"><span class="innerContentContainer">0: 这是默认的等级，仅作最基本的判断</span></span></li><li><span class="name"><span class="innerContentContainer">1: 在malloc记录调用栈, 检测内存泄漏</span></span></li><li><span class="name"><span class="innerContentContainer">5: 分配的内存用0xeb填充，释放的内存用0xef填充, 可检测内存的overruns</span></span></li><li><span class="name"><span class="innerContentContainer">10: 内存分配打 pre-和 post- 的桩子，记录调用栈, 也可检测内存的overruns</span></span></li><li><span class="name"><span class="innerContentContainer">20: SDK模拟器上检测内存用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打开指定app的malloc debug, 有两种方式:</span></span><ul><li><span class="name"><span class="innerContentContainer">一种是: setprop wrap.com.oppo.camera "LIBC_DEBUG_MALLOC_OPTIONS=baketrace"</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是: setprop libc.debug.malloc.program "com.oppo.camera"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定位方法1: adb logcat | findstr "malloc_debug"</span></span></li><li><span class="name"><span class="innerContentContainer">定位方法2: 通过ddms来看内存泄漏. </span></span><ul><li><span class="name"><span class="innerContentContainer">先要配置ddms: 在~\.android\&nbsp;ddms.cfg&nbsp;文件后面添加native=true, 然后打开ddms, 就可以看到Native Heap了.</span></span></li><li><span class="name"><span class="innerContentContainer">在启动ddms前, 需要把 arm-linux-androideabi-addr2linux 所在的路径加到PATH环境变量中.</span></span></li><li><span class="name"><span class="innerContentContainer">点击 snapshot current native heap usageke, 根据提示在 symbol search path里输入相应库的符号表路径就行了.</span></span></li><li><span class="name"><span class="innerContentContainer">找到泄漏后，根据提示的backtrace地址，可以用NDK中的 arm-linux-androideabi-addr2line 工具算出对应的函数地址，</span></span></li><li><span class="name"><span class="innerContentContainer">也可以把堆栈排列成 tombstone 格式，然后用 stacktrace 工具求出函数调用关系。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">nativie_heapdump_viewer 使用方法</span></span><ul><li><span class="name"><span class="innerContentContainer">python ./nativie_heapdump_viewer.py --verbase &lt;backtrace文件路径&gt; --symbols &lt;符号表位置&gt; &gt; ./memlock_parse.log</span></span></li></ul></li></ul>
  </body>
</html>