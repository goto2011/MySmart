<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>03-Activity</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Application类</b></span></span><ul><li><span class="name"><span class="innerContentContainer">一个虚拟机线程中只会有一个Application对象, 该对象的生命周期和线程相同.</span></span></li><li><span class="name"><span class="innerContentContainer">Application的实质是一个Context, 它继承ContextWrapper。</span></span></li><li><span class="name"><span class="innerContentContainer">由于在Context中可以通过 getApplicationContext()获取到 Application对象，或者是通过Activity.getApplication()、Service.getApplication()获取到Application(都是同一个对象)，所以可以在Application保存全局的数据，供所有的Activity或者是Service使用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android线程架构</span></span><ul><li><span class="name"><span class="innerContentContainer">当启动一个App的时候，Android系统会启动一个Linux Process，该Process包含一个Thread，称为UI Thread, 即主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">系统在创建UI线程的时候会初始化一个Looper对象, 以及与其关联的MessageQueue对象;</span></span></li><li><span class="name"><span class="innerContentContainer">通常一个应用的所有组件都运行在UI Thread中.  </span></span></li><li><span class="name"><span class="innerContentContainer">通过在Manifest.xml中的代码块(&lt;activity&gt;&lt;service&gt;&lt;provider&gt;&lt;receiver&gt;)中的 android:process 属性可指定其运行在不同的process中。</span></span></li><li><span class="name"><span class="innerContentContainer">UI Thread中运行着许多重要的逻辑，如系统事件处理，用户输入事件处理，UI绘制，Service，Alarm等. </span></span></li><li><span class="name"><span class="innerContentContainer">UI线程5秒没有响应, 系统就会报ANR. 所以费时的逻辑应该放在子线程里.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>线程的生命周期</b></span></span><ul><li><span class="name"><span class="innerContentContainer">新建状态（New）：new实例化之后进入该状态, jvm为其分配内存，并初始化成员变量;</span></span></li><li><span class="name"><span class="innerContentContainer">就绪状态（<b>Runnable</b>）：线程调用start()之后就绪状态. jvm会为其创建方法调用栈和PC计数器, 等待cpu执行. 注意这时线程还没开始运行, 但已获得除CPU之外的所有资源.</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>还有一种方式进入就绪态:  yield()：线程把自己暂停, 主动释放CPU资源. 但是, 这里很关键, yield() 只会将线程转为就绪态, 而不是阻塞态. 而且它会强制调用系统调度器重新调度一次。</b></span></span></li><li><span class="name"><span class="innerContentContainer">当某个线程调用 <b>yield</b>() 暂停后，只要下一次系统调度时, 其优先级与当前运行线程相同或更高时, 就会重新获得执行机会。</span></span></li><li><span class="name"><span class="innerContentContainer">其它线程调用 notify() / notifyAll() 唤醒本线程. 调用前需要获取对象锁.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运行状态（Running）：经过系统调度, 线程获得CPU时间，开始执行 run()方法的代码；</span></span></li><li><span class="name"><span class="innerContentContainer">阻塞状态（<b>Blocked</b>）：线程由于各种原因进入阻塞状态, 包括：</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>join</b>(), 当前线程阻塞, 进入另外一个线程, 直到后者执行完毕;</span></span></li><li><span class="name"><span class="innerContentContainer"><b>sleep</b>(), 线程主动放弃CPU资源。</span></span><ul><li><span class="name"><span class="innerContentContainer">通过参数指定睡眠的微秒数.</span></span></li><li><span class="name"><span class="innerContentContainer">注意使用sleep方法时需要捕捉 InterruptedException, 或者抛出该异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>wait</b>(), 当前线程阻塞, 等待某个通知notify. 调用前需要获取对象锁.</span></span><ul><li><span class="name"><span class="innerContentContainer">一般是和 <b>notifyAll</b>() 成对出现. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞.</span></span></li><li><span class="name"><span class="innerContentContainer">线程试图获得一个同步锁，但是该锁被其他线程所持有.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>阻塞条件被消除后, 线程会进入就绪态. </b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">死亡状态（Dead）：线程运行完毕或异常退出，可使用 isAlive()获取状态。有三种死亡类型:</span></span><ul><li><span class="name"><span class="innerContentContainer">正常终止: 执行完所有工作, 正常结束.</span></span></li><li><span class="name"><span class="innerContentContainer">强制终止: 线程调用 stop() 或 destroy() 结束. LMK即是这种.</span></span></li><li><span class="name"><span class="innerContentContainer">异常终止: 执行过程中发生异常, 或者被系统强制杀死.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>应用 / Activity的启动和生命周期 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">系统先创建Application; 然后启动应用的首个activity。</span></span></li><li><span class="name"><span class="innerContentContainer">无论是Launcher(Launcher也是应用)启动一个activity, 还是应用内部启动一个activity, 第一步都是应用线程调用 startActivity(), 该函数通过Binder调用ams的 startActivity().</span></span></li><li><span class="name"><span class="innerContentContainer">ams 调用<b>Zygote的fork(), 复制创建一个虚拟机进程. 然后在进程上创建 ActivityThread. 相关代码在 </b>scheduleLaunchActivity() 中.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>ActivityThread 负责创建对应的Activity对象, </b>使用ClassLoader从程序文件中装载指定的Activity对应的Class文件, <b>加载布局和资源.  </b></span></span></li><li><span class="name"><span class="innerContentContainer">最后会调用 attach方法，然后在 PolicyManager实现一个IPolicy接口，接着实现一个 Policy对象。</span></span></li><li><span class="name"><span class="innerContentContainer">接着调用 makeNewWindow(Context)方法，该方法会返回一个 PhoneWindow对象，而 PhoneWindow 是Window的子类。</span></span></li><li><span class="name"><span class="innerContentContainer">在这个 PhoneWindow 持有一个DecorView的内部类，是所有应用窗口的根 View， 直接控制 Activity是否显示。</span></span></li><li><span class="name"><span class="innerContentContainer">DecorView里面有一个 LinearLayout。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout里面又有两个 FrameLayout, 他们分别拿来装 ActionBar(状态栏)和CustomView。</span></span></li><li><span class="name"><span class="innerContentContainer">而我们在 setContentView() 加载的布局就放到这个 <b>CustomView </b>中。</span></span></li><li><span class="name"><span class="innerContentContainer">整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。</span></span></li><li><span class="name"><span class="innerContentContainer">View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>在这个过程中, 会回调用户</b>activity<b>的 onCreate(), onStart(), onResume(). </b></span></span></li><li><span class="name"><span class="innerContentContainer">在onResume()中,  向WMS添加注册的应用主窗口。</span></span></li><li><span class="name"><span class="innerContentContainer">然后主窗口就显示在屏幕上.</span></span></li><li><span class="name"><span class="innerContentContainer">如果在 onCreate()，onStart()，onResume() 中做了耗时操作, 则应用启动会出现暂时的黑屏(常见，不算什么大事)。如果耗时超过一定的门限(一般是5秒)，则会出现 anr。</span></span></li><li><span class="name"><span class="innerContentContainer">梳理上面整个过程: activity -<b>binder</b>- AMS -<b>biner</b>- ActivityThread - PhoneWindow - DecorView - ActionBar+CustomView - View.</span></span></li><li><span class="name"><span class="innerContentContainer">执行完onResume()完之后，如果界面没有更新，应用UI主线程的looper会进入MessageQueue.nativePollOnce()。当有消息来临的时候，此looper便会被wake，执行消息。</span></span></li><li><span class="name"><span class="innerContentContainer">销毁过程中, 会先后调用 onPause() 和 onStop()， onDestroy(). </span></span></li><li><span class="name"><span class="innerContentContainer">调用完onPause()后不会立即调用onStop()，因为此时需要先调用栈中的前一个页面的 <b>onResume</b>(), 所以我们需要先切回到AMS进程去处理。此处需要多加注意。</span></span></li><li><span class="name"><span class="innerContentContainer">切换到后台时，先调用 onPause()，等新页面的 onResume() 调用完后，再调 onStop()。</span></span></li><li><span class="name"><span class="innerContentContainer">切换到前台时，调用 onRestart() - onStart() - onResume()。</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏切换的生命周期见后。</span></span></li><li><span class="name"><span class="innerContentContainer">对于 onStop() 的activity，如果出现lmk，或者系统定期清理，则会走 onDestroy() 彻底退出。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity生命周期 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Activity生命周期图  <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>onCreate&nbsp;</b>: Activity被创建时被回调，是生命周期第一个调用的方法，我们在创建Activity时一般会重写该方法做一些初始化的操作，如通过 setContentView 设置界面布局的资源，初始化所需要的组件信息等。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onStart&nbsp;</b>: Activity正在启动时回调，此时Activity已处于可见状态，但是还没有在前台显示，因此无法与用户进行交互。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onResume </b>: 当此方法回调时，则说明Activity已在前台可见，可与用户交互了, 即activity处于 Active/Running形态.</span></span><ul><li><span class="name"><span class="innerContentContainer">onResume与onStart的相同点是两者都表示Activity可见；</span></span></li><li><span class="name"><span class="innerContentContainer">不同点是onStart时Activity还在后台无法与用户交互，而onResume则表示已显示在前台，可与用户交互。</span></span></li><li><span class="name"><span class="innerContentContainer">当Activity停止后（ onPause 方法和 onStop方法被调用），重新回到前台时也会调用onResume方法.</span></span></li><li><span class="name"><span class="innerContentContainer">可以在onResume方法中初始化一些资源，比如重新初始化在 onPause 或者 onStop 方法中释放的资源。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>onPause </b>: Activity被切换到后台或停止的时候回调, 此时activity进入 Paused形态. 一般情况下 onStop方法接下来会马上被回调。</span></span><ul><li><span class="name"><span class="innerContentContainer">在onPause中我们可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示. <b>因为旧activity的 onPause方法执行完成后，新Activity的onResume方法才会被执行。</b></span></span></li><li><span class="name"><span class="innerContentContainer">onPause()和onStop()的区别是：前者是旧Activity还可见的状态；后者是旧Activity已经不可见。</span></span></li><li><span class="name"><span class="innerContentContainer">AlertDialog 和 PopWindow 不会触发onPause()和onStop().</span></span></li><li><span class="name"><span class="innerContentContainer">有一种极端情况是onPause方法执行后马上执行了onResume方法，一般是用户操作使当前Activity退居后台后又迅速切回来，此时onResume方法就会被回调。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>onStop </b>: 一般在onPause执行完成时回调，表示Activity即将停止进入Stopped形态，此时Activity不可见，仅在后台运行。在onStop方法可以做一些资源释放的操作（不能太耗时）。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onRestart </b>: 表示Activity正在重新启动，当Activity由<b>onStop</b>() 状态切换回前台时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onDestroy </b>: 此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做最终的资源释放。</span></span></li><li><span class="name"><span class="innerContentContainer">总结下: </span></span><ul><li><span class="name"><span class="innerContentContainer">Activity第一启动的时候执行: onCreate() -&gt; onStart() -&gt; onResume(). </span></span></li><li><span class="name"><span class="innerContentContainer">如果再有启动同一Activity的时候, 执行: onNewIntent() -&gt; onResart() -&gt; onStart() -&gt; onResume().</span></span></li><li><span class="name"><span class="innerContentContainer">如果android系统由于内存不足把已存在Activity释放掉了，那么再次调用的时候会重新启动Activity, 即执行: onCreate() -&gt; onStart() -&gt; onResume()。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>多线程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Thread类</span></span><ul><li><span class="name"><span class="innerContentContainer">Thread有如下主要函数：</span></span><ul><li><span class="name"><span class="innerContentContainer">run(): 线程运行时所执行的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">start(): 启动线程。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>sleep</b>() / sleep(long millis): 线程休眠，进入<b>阻塞</b>状态，sleep方法不会释放锁（其它线程不会进入synchronized方法体或方法块，不释放锁需要try/catch）</span></span></li><li><span class="name"><span class="innerContentContainer"><b>yield</b>(): 线程交出CPU，但是不会阻塞而是重置为<b>就绪</b>状态，不会释放锁。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>join</b>() / join(long millis) / join(long millis, int nanoseconds): 线程插队，执行完join()后, 主线程阻塞, 进入子线程执行; 等子线程执行完后, 再返回主线程join()后一行继续执行.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>wait</b>(): 进入阻塞状态，释放锁（其它线程可以进入synchronized代码块）</span></span></li><li><span class="name"><span class="innerContentContainer">interrupt(): 中断线程，注意只能中断阻塞状态的线程</span></span></li><li><span class="name"><span class="innerContentContainer">getId(): 获取当前线程的id</span></span></li><li><span class="name"><span class="innerContentContainer">getName() / setName(): 获取和设置线程的name</span></span></li><li><span class="name"><span class="innerContentContainer">getPriority() / setPriority(): 获取和设置线程的优先级，范围1-10，默认是5</span></span></li><li><span class="name"><span class="innerContentContainer">setDaemon() / isDaemo(): 设置为守护线程 / 是否是守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">currentThread(): 静态函数获取当前线程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">start() 和 run()的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">只有调用了start()方法，才会启动新线程，start() 会在新线程中调用 run()。</span></span></li><li><span class="name"><span class="innerContentContainer">如果只是调用run()方法，那么代码还是在本线程中执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sleep() 和 wait()的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">sleep方法和wait方法都可以用来放弃CPU一定的时间.</span></span></li><li><span class="name"><span class="innerContentContainer">不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">创建子线程的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 继承Thread，重写run()方法</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MyThread extends Thread{</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Overrid">@<span class="contentTagText">Overrid</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.run();</span></span></li><li><span class="name"><span class="innerContentContainer">// do something</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// Thread使用</span></span></li><li><span class="name"><span class="innerContentContainer">public void goThread(){</span></span><ul><li><span class="name"><span class="innerContentContainer">new MyThread().start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. <b>创建</b>Thread 匿名类，传入<b>Runnable接口，重写其中的run()方法来执行任务. 常见的做法。</b></span></span><ul><li><span class="name"><span class="innerContentContainer">new Thread(new Runnable() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run() {...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).start();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Runnable 接口和 Callable 接口的区别 <b>  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">Runnable接口中的 run() 方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已;</span></span></li><li><span class="name"><span class="innerContentContainer">Callable接口中的 call() 方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</span></span></li><li><span class="name"><span class="innerContentContainer">多线程执行充满着未知性，某条线程是否执行了？执行了多久？某条线程执行的时候期望的数据是否已经赋值完毕？很难及时知道，能做的只是等待任务执行完毕而已。</span></span></li><li><span class="name"><span class="innerContentContainer">而 Callable + Future/FutureTask 却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，所以非常有用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">1. runOnUiThread<b>， 最简单，多用于刷新界面的逻辑。</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android规定只有主线程才可以刷新界面. 那么如果子线程需要刷新界面？</span></span></li><li><span class="name"><span class="innerContentContainer">把更新ui的代码放在 Runnable对象的 run() 中。</span></span></li><li><span class="name"><span class="innerContentContainer">子线程需要更新 UI时，把Runnable 对象传给 Activity.<b>runOnUiThread</b>(Runnable) 即可。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果当前线程是UI线程，那么会被立即执行。</span></span></li><li><span class="name"><span class="innerContentContainer">如果当前线程不是UI线程, 操作是发布事件到UI线程的队列中去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">this.runOnUiThread(new Runnable() {   // 在 activity 类中调用</span></span><ul><li><span class="name"><span class="innerContentContainer">void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Do something …</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>2. Thread  + Handler + Looper <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Handler是一个胶水类. 它粘合两个线程, 所以它的代码分为两半。</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>一半在一个线程中发</b>Message或者Runnable对象；</span></span></li><li><span class="name"><span class="innerContentContainer"><b>另外一半在另一个线程处理收到的</b>Message或者Runnable对象<b>. </b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>看Handle代码, 要注意这个关系.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。</b></span></span></li><li><span class="name"><span class="innerContentContainer">Handler的同步原理</span></span><ul><li><span class="name"><span class="innerContentContainer">使用MessageQueue维护一个消息队列（实际上是链表）。</span></span></li><li><span class="name"><span class="innerContentContainer">当队列中没有Message时调用nativePollOnce挂起当前线程。</span></span></li><li><span class="name"><span class="innerContentContainer">当有新的任务时调用nativeWake唤起被挂起的线程，继续循环消息队列。</span></span></li><li><span class="name"><span class="innerContentContainer">对链表的操作使用synchronized关键字进行了代码块的加锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在子线程中创建一个Handle对象时，它会自动绑定创建它的线程。这部分是隐含的。</span></span></li><li><span class="name"><span class="innerContentContainer">在主线程中，可以通过 Thread.mHandler.<b>sendMessage</b>(msg) 或者 <a class="contentLink" target="_blank" rel="noreferrer" href="http://Thread.mHandler.post">Thread.mHandler.post</a>(Runnable)&nbsp;往子线程的消息队列发送事件，通知子线程某些事情发生。</span></span><ul><li><span class="name"><span class="innerContentContainer">sendMessage: 允许把一个包含消息数据的Message对象压入到消息队列中。有:</span></span><ul><li><span class="name"><span class="innerContentContainer">sendEmptyMessage(int)   // 发送空消息</span></span></li><li><span class="name"><span class="innerContentContainer">sendMessage(Message)   // 发送消息</span></span></li><li><span class="name"><span class="innerContentContainer">sendMessageAtTime(Message,long)   // 发送定时生效的消息</span></span></li><li><span class="name"><span class="innerContentContainer">sendMessageDelayed(Message,long)    // 指定延时多少毫秒后发送消息</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">post: 把一个Runnable对象入队到消息队列中. 有:</span></span><ul><li><span class="name"><span class="innerContentContainer">post(Runnable) </span></span></li><li><span class="name"><span class="innerContentContainer">postAtTime(Runnable,long)   // 指定时间</span></span></li><li><span class="name"><span class="innerContentContainer">postDelayed(Runnable,long)   // 延迟post</span></span></li><li><span class="name"><span class="innerContentContainer">其实1和3都是调用2, post 即定时为now, postDelayed 即定时为 now+指定延时.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无论是 sendMessage 还是 post, 最终都是sendMessage. 对于后者, 只是把 Runable对象放到message的 Runables属性中而已.</span></span></li><li><span class="name"><span class="innerContentContainer">创建msg对象时， 建议使用 Message.obtain(): 从message池中取一个对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">使用池是为了不每次new, 浪费内存.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>子线程在 Handler.handleMessage() 中处理收到的事件。</b></span></span></li><li><span class="name"><span class="innerContentContainer">要做到这件事，需要Looper对象帮忙。looper依赖于线程。</span></span><ul><li><span class="name"><span class="innerContentContainer">Looper的目的是保持持有它的线程处于存活状态。</span></span></li><li><span class="name"><span class="innerContentContainer">一个线程如果不持有Looper，则它的run()方法执行完就销毁了。这种情况不适合接受事件、处理事件的场景。</span></span></li><li><span class="name"><span class="innerContentContainer">Looper对象有几个要点：</span></span><ul><li><span class="name"><span class="innerContentContainer">线程默认没有 Looper；</span></span></li><li><span class="name"><span class="innerContentContainer">可以创建一个 Looper 并将它绑定到一个线程；</span></span></li><li><span class="name"><span class="innerContentContainer">每一个线程只能绑定一个 Looper。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建Looper</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 Looper.prepare() 即可。</span></span></li><li><span class="name"><span class="innerContentContainer">创建时会自动创建配套的MessageQueue。这部分是隐含的。</span></span></li><li><span class="name"><span class="innerContentContainer">调用Looper.<b>loop</b>()方法启动Looper.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UI线程的Looper</span></span><ul><li><span class="name"><span class="innerContentContainer">UI线程默认会创建Looper对象，相关代码在 ActivityThread.main() 中。</span></span></li><li><span class="name"><span class="innerContentContainer">所有的view.postDelay()都会走到UI线程的Looper的消息循环体中，Looper配合viewRootImpl 视图树的 handler 将所有的消息追加到主线程消息队列后面。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">public class CalPrime extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">static final String UPPER_NUM = "upper";</span></span></li><li><span class="name"><span class="innerContentContainer">EditText etNum;</span></span></li><li><span class="name"><span class="innerContentContainer">CalThread calThread;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义一个线程类</span></span></li><li><span class="name"><span class="innerContentContainer">class CalThread extends Thread {</span></span><ul><li><span class="name"><span class="innerContentContainer">public Handler mHandler;</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>run</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Looper.<b>prepare</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">mHandler = new <b>Handler</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 定义处理消息的方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>handleMessage</b>(Message msg) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(msg.what == 0x123) {</span></span><ul><li><span class="name"><span class="innerContentContainer">int upper = msg.getData().getInt(UPPER_NUM);</span></span></li><li><span class="name"><span class="innerContentContainer">List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">// 计算从2开始、到upper的所有质数</span></span></li><li><span class="name"><span class="innerContentContainer">for (int i = 2 ; i &lt;= upper ; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 用i处于从2开始、到i的平方根的所有数</span></span></li><li><span class="name"><span class="innerContentContainer">for (int j = 2 ; j &lt;= Math.sqrt(i) ; j++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 如果可以整除，表明这个数不是质数</span></span></li><li><span class="name"><span class="innerContentContainer">if(i != 2 &amp;&amp; i % j == 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">continue outer;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">nums.add(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 使用Toast显示统计出来的所有质数</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(CalPrime.this , nums.toString()</span></span><ul><li><span class="name"><span class="innerContentContainer">, Toast.LENGTH_LONG).show();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">Looper.<b>loop</b>();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.main);</span></span></li><li><span class="name"><span class="innerContentContainer">etNum = (EditText)findViewById(R.id.etNum);</span></span></li><li><span class="name"><span class="innerContentContainer">calThread = new CalThread();</span></span></li><li><span class="name"><span class="innerContentContainer">// 启动新线程</span></span></li><li><span class="name"><span class="innerContentContainer">calThread.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 为按钮的点击事件提供事件处理函数</span></span></li><li><span class="name"><span class="innerContentContainer">public void cal(View source){</span></span><ul><li><span class="name"><span class="innerContentContainer">// 创建消息</span></span></li><li><span class="name"><span class="innerContentContainer">Message msg = Message.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">msg.what = 0x123;</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle bundle = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">bundle.putInt(UPPER_NUM , Integer.parseInt(etNum.getText().toString()));</span></span></li><li><span class="name"><span class="innerContentContainer">msg.setData(bundle);</span></span></li><li><span class="name"><span class="innerContentContainer">// 向新线程中的Handler发送消息</span></span></li><li><span class="name"><span class="innerContentContainer">calThread.mHandler.<b>sendMessage</b>(msg);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Handler的</b>优缺点: </span></span><ul><li><span class="name"><span class="innerContentContainer">Handler用法简单明了，可以将多个异步任务更新UI的代码放在一起，清晰明了。</span></span></li><li><span class="name"><span class="innerContentContainer">如果仅处理单个异步任务，代码显得冗余.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适用范围: 多个异步任务的更新UI.</span></span></li><li><span class="name"><span class="innerContentContainer">Looper.loop为什么不会阻塞掉UI线程？ <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">loop()开启死循环后，会命令MessageQueue通过 next()方法取出之前储存的消息，如果有立刻被拿出来执行msg.target.dispatchMessage(msg);</span></span></li><li><span class="name"><span class="innerContentContainer">如果此时 MessageQueue中已经没有消息了，MessageQueue就会无限期的阻塞下去 <b>nativePollOnce</b>(ptr, nextPollTimeoutMillis)，同时释放cpu资源，这时候并不会造成UI线程卡顿;</span></span></li><li><span class="name"><span class="innerContentContainer">直到有新的消息存入队列enqueueMessage(Messagemsg, long when)，唤醒之前阻塞的线程 nativeWake(mPtr)，继续执行next()方法.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>3. HandlerThread: 封装的 Handler+Thread <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>HandlerThread</b>通过继承Thread类和封装Handler类的使用，从而使得创建新线程和与其他线程进行通信变得更加方便易用.</span></span><ul><li><span class="name"><span class="innerContentContainer">通过继承Thread类，快速地创建1个带有Looper对象的新工作线程.</span></span></li><li><span class="name"><span class="innerContentContainer">通过封装Handler类，快速创建Handler&nbsp;&amp; 与其他线程进行通信.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">HandlerThread的使用步骤分为5步:</span></span><ul><li><span class="name"><span class="innerContentContainer">// step1：创建HandlerThread实例对象</span></span></li><li><span class="name"><span class="innerContentContainer">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><ul><li><span class="name"><span class="innerContentContainer">HandlerThread mHandlerThread = new HandlerThread("handlerThread");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// step2：启动线程</span></span><ul><li><span class="name"><span class="innerContentContainer">mHandlerThread.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// step3：创建工作线程Handler &amp; 复写handleMessage（）</span></span></li><li><span class="name"><span class="innerContentContainer">// 关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span></li><li><span class="name"><span class="innerContentContainer">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><ul><li><span class="name"><span class="innerContentContainer">Handler workHandler = new Handler( handlerThread.getLooper() ) {</span></span><ul><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">public boolean handleMessage(Message msg) {</span></span><ul><li><span class="name"><span class="innerContentContainer">...//消息处理</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// step4：使用工作线程 Handler向工作线程的消息队列发送消息</span></span></li><li><span class="name"><span class="innerContentContainer">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><ul><li><span class="name"><span class="innerContentContainer">// a. 定义要发送的消息</span></span></li><li><span class="name"><span class="innerContentContainer">Message msg = Message.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">msg.what = 2; //消息的标识</span></span></li><li><span class="name"><span class="innerContentContainer">msg.obj = "B"; // 消息的存放</span></span></li><li><span class="name"><span class="innerContentContainer">// b. 通过Handler发送消息到其绑定的消息队列</span></span></li><li><span class="name"><span class="innerContentContainer">workHandler.sendMessage(msg);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">//  step5：结束线程，即停止线程的消息循环</span></span><ul><li><span class="name"><span class="innerContentContainer">mHandlerThread.quit();</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>4. </b>AsyncTask</span></span><ul><li><span class="name"><span class="innerContentContainer">AsyncTask是android提供的轻量级的异步类, 可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的状态(常用于实现UI进度更新)，最后反馈执行的结果给UI主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask通过一个阻塞队列BlockingQuery&lt;Runnable&gt;存储待执行的任务，利用静态线程池THREAD_POOL_EXECUTOR提供一定数量的线程，默认128个。</span></span></li><li><span class="name"><span class="innerContentContainer">默认采用串行任务执行器，循环取出任务交给THREAD_POOL_EXECUTOR中的线程执行，执行完一个，再执行下一个。</span></span></li><li><span class="name"><span class="innerContentContainer">不要手动调用onPreExecute()，doInBackground(Params... params)，onProgressUpdate(Progress... values)，onPostExecute(Result result)这几个方法。</span></span></li><li><span class="name"><span class="innerContentContainer">例子: </span></span></li><li><span class="name"><span class="innerContentContainer">// <b>自定义AsyncTask</b></span></span></li><li><span class="name"><span class="innerContentContainer">public class MyAsyncTask extends AsyncTask&lt;Integer,Integer,String&gt; {</span></span><ul><li><span class="name"><span class="innerContentContainer">private TextView txt;</span></span></li><li><span class="name"><span class="innerContentContainer">private ProgressBar pgbar;</span></span></li><li><span class="name"><span class="innerContentContainer">public MyAsyncTask(TextView txt,ProgressBar pgbar) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super();</span></span></li><li><span class="name"><span class="innerContentContainer">this.txt = txt;</span></span></li><li><span class="name"><span class="innerContentContainer">this.pgbar = pgbar;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在调用耗时操作前被调用, 常用于初始化, 比如进度条的显示. 该方法运行在UI线程.</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onPreExecute</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">txt.setText("开始执行异步线程");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在onPreExecute<b>()执行后马上执行. </b>该方法不运行在UI线程,主要用于异步操作.</span></span></li><li><span class="name"><span class="innerContentContainer">// 可调用 publishProgress()方法实时更新进度, 或者更新UI.</span></span></li><li><span class="name"><span class="innerContentContainer">protected String <b>doInBackground</b>(Integer... params) {</span></span><ul><li><span class="name"><span class="innerContentContainer">DelayOperator dop = new DelayOperator();</span></span></li><li><span class="name"><span class="innerContentContainer">int i = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">for (i = 10;i &lt;= 100;i+=10) {</span></span><ul><li><span class="name"><span class="innerContentContainer">dop.delay();</span></span></li><li><span class="name"><span class="innerContentContainer"><b>publishProgress</b>(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return  i + params[0].intValue() + "";</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在doBackground方法中,每次调用publishProgress方法都会触发该方法</span></span></li><li><span class="name"><span class="innerContentContainer">// 运行在UI线程中,可对UI控件进行操作</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onProgressUpdate</b>(Integer... values) {</span></span><ul><li><span class="name"><span class="innerContentContainer">int value = values[0];</span></span></li><li><span class="name"><span class="innerContentContainer">pgbar.setProgress(value);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在<b>doInBackground()执行完后, 该方法会被UI线程调用. 后台的处理结果将通过该方法传递给UI线程.</b></span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onPostExecute</b>(String result) {</span></span><ul><li><span class="name"><span class="innerContentContainer">txt.setText("异步线程执行完毕");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 用于在取消执行中的任务时更改UI</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onCancelled</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">txt.setText("异步线程被终止");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// MainActivity.java</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyActivity extends ActionBarActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private TextView txttitle;</span></span></li><li><span class="name"><span class="innerContentContainer">private ProgressBar pgbar;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btnupdate;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">txttitle = (TextView)findViewById(R.id.txttitle);</span></span></li><li><span class="name"><span class="innerContentContainer">pgbar = (ProgressBar)findViewById(R.id.pgbar);</span></span></li><li><span class="name"><span class="innerContentContainer">btnupdate = (Button)findViewById(R.id.btnupdate);</span></span></li><li><span class="name"><span class="innerContentContainer">btnupdate.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">MyAsyncTask myTask = new MyAsyncTask(txttitle,pgbar);</span></span></li><li><span class="name"><span class="innerContentContainer">myTask.execute(1000);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask的使用注意事项：</span></span><ul><li><span class="name"><span class="innerContentContainer">AsyncTask的类必须在主线程中加载，这一点已经在Android4.1以上版本上自动完成</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask 对象必须在主线程中创建</span></span></li><li><span class="name"><span class="innerContentContainer">execute方法必须在主线程中调用</span></span></li><li><span class="name"><span class="innerContentContainer">一个AsyncTask对象只能执行一次，否则会运行报错。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优缺点:</span></span><ul><li><span class="name"><span class="innerContentContainer">处理单个异步任务时代码简单，而且能获取到异步任务的进度.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过cancel方法取消还没执行完的AsyncTask.</span></span></li><li><span class="name"><span class="innerContentContainer">处理多个异步任务代码显得较多.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适用范围: 单个异步任务的处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>5. ThreadPoolExecutor: 线程池</b></span></span><ul><li><span class="name"><span class="innerContentContainer">ThreadPoolExecutor提供了一组线程池，可以管理多个线程并行执行。比较适合一组任务的执行。</span></span></li><li><span class="name"><span class="innerContentContainer">优势: </span></span><ul><li><span class="name"><span class="innerContentContainer">避免频繁地创建和销毁线程，达到线程对象的重用。</span></span></li><li><span class="name"><span class="innerContentContainer">使用线程池还可以根据项目灵活地控制并发的数目。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Executors利用工厂模式对ThreadPoolExecutor进行了封装，使用起来更加方便。</span></span><ul><li><span class="name"><span class="innerContentContainer">有4种工厂: </span></span><ul><li><span class="name"><span class="innerContentContainer">Executors.newFixedThreadPool():  创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化。</span></span></li><li><span class="name"><span class="innerContentContainer">Executors.newCachedThreadPool():  创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制.</span></span></li><li><span class="name"><span class="innerContentContainer">Executors.newScheduledThreadPool(): 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer.</span></span></li><li><span class="name"><span class="innerContentContainer">Executors.newSingleThreadExecutor(): 创建一个单线程化的executor，它只创建唯一的worker线程来执行任务.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">newSingleThreadScheduledExecutor(): 创建一个延迟执行的单线程线程池</span></span></li><li><span class="name"><span class="innerContentContainer">newWorkingStealingPool(int parallelism): 创建持有足够的线程的线程池来支持给定的并行级别，以充分支持多CPU并行能力。</span></span></li><li><span class="name"><span class="innerContentContainer">newWorkingStealingPool(): 根据CPU个数设置并行级别。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用线程池的步骤</span></span><ul><li><span class="name"><span class="innerContentContainer">调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。</span></span></li><li><span class="name"><span class="innerContentContainer">创建Runnable实现类或者Callable实现类的实例，作为线程的执行任务。</span></span></li><li><span class="name"><span class="innerContentContainer">调用ExecutorService对象的 submit() 来提交 Runnable 或者 Callable 实例。</span></span></li><li><span class="name"><span class="innerContentContainer">当没有任务时，使用shutdown()方法来关闭线程池。</span></span></li><li><span class="name"><span class="innerContentContainer">public class TestTreadPool{</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void main(String[] args)</span></span></li><li><span class="name"><span class="innerContentContainer">throws Exception{</span></span><ul><li><span class="name"><span class="innerContentContainer">ExecutorService pool = Executors.newFixedThreadPool(6);</span></span></li><li><span class="name"><span class="innerContentContainer">Runnable target = ()-&gt;{</span></span><ul><li><span class="name"><span class="innerContentContainer">for(int i=0;i&lt;100;i++) {</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println(Thread.currentThread().getName()</span></span><ul><li><span class="name"><span class="innerContentContainer">+ "的i值为："+ i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">// 向线程池中提交两个线程</span></span></li><li><span class="name"><span class="innerContentContainer">pool.submit(target);</span></span></li><li><span class="name"><span class="innerContentContainer">pool.submit(target);</span></span></li><li><span class="name"><span class="innerContentContainer">pool.shutdown();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适用范围: 批处理任务</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>6. </b>IntentService</span></span><ul><li><span class="name"><span class="innerContentContainer">IntentService继承自Service，是一个经过包装的轻量级的Service，用来接收并处理通过Intent传递的异步请求。客户端通过调用 startService(Intent) 启动一个IntentService，利用一个work线程依次处理顺序过来的请求，处理完成后自动结束Service。</span></span></li><li><span class="name"><span class="innerContentContainer">优缺点: 它是Service，比起其他线程来说具有更高的优先级，不容易被系统杀死，而能够保证任务的执行。</span></span></li><li><span class="name"><span class="innerContentContainer">特点: IntentService的优先级比单纯线程要高，所以适合执行一些高优先级的后台任务。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁与死锁</b> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">当有一个线程在对临界资源(内存, 代码块等)进行操作时，其他线程都不可以对这个临界资源进行操作，直到该线程完成操作。</span></span></li><li><span class="name"><span class="innerContentContainer">线程安全有几个级别:</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 可变. 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 绝对线程安全. 不管运行时环境如何，调用者都不需要额外的同步措施。</span></span><ul><li><span class="name"><span class="innerContentContainer">要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">不过绝对线程安全的类也有，比如说 CopyOnWriteArrayList、CopyOnWriteArraySet。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 相对线程安全. </span></span><ul><li><span class="name"><span class="innerContentContainer">相对线程安全也就是我们通常意义上所说的线程安全。</span></span></li><li><span class="name"><span class="innerContentContainer">像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此。</span></span></li><li><span class="name"><span class="innerContentContainer">如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是 fail-fast 机制。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. 线程非安全. ArrayList、LinkedList、HashMap等都是线程非安全的类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本上所有的并发模式在解决线程安全问题的问题上，都采用“序列化访问临界资源”的方案，即在同一时刻只能有一个线程访问临界资源（多个线程可能同时访问的数据或资源），也称同步互斥访问。</span></span></li><li><span class="name"><span class="innerContentContainer">线程安全是以牺牲程序运行效率为代价的，因此在注意线程安全的同时，也要注意不要滥用锁和同步方法，尽量只对那些会改变竞争资源的方法进行同步。</span></span></li><li><span class="name"><span class="innerContentContainer">锁的种类 --种类繁多，需要仔细理解。</span></span><ul><li><span class="name"><span class="innerContentContainer">偏向锁/轻量级锁/重量级锁   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">偏向锁（Biased Lock ）: 几乎无竞争的条件下使用.</span></span><ul><li><span class="name"><span class="innerContentContainer">偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。这是最常见的情况. 因此偏向锁是 <b>Synchronized 的默认状态.</b></span></span></li><li><span class="name"><span class="innerContentContainer">偏向锁是通过对象头实现。</span></span><ul><li><span class="name"><span class="innerContentContainer">对象头指Java对象的头信息, 每个对象都有, 占2个字长. </span></span></li><li><span class="name"><span class="innerContentContainer">第一个字叫Mark Word, 可唯一表示一个对象, 因此可用于做锁.</span></span></li><li><span class="name"><span class="innerContentContainer">第二个字保存类元信息（class metadata）的指针.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">偏向锁的获取方式是将对象头的&nbsp;MarkWord&nbsp;部分中， 标记上线程ID， 以表示哪一个线程获得了偏向锁。</span></span></li><li><span class="name"><span class="innerContentContainer">当同一个线程反复获取同步块时, 不再需要进行加锁和解锁的操作, 效率非常高. </span></span></li><li><span class="name"><span class="innerContentContainer">这也就要求, 当线程退出同步块时, 并不修改对象头的&nbsp;MarkWord&nbsp;字段. 只有在其它线程也访问同步块时再改.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">轻量级锁（ Lightweight Lock）: 轻度竞争的条件下使用.</span></span><ul><li><span class="name"><span class="innerContentContainer">在偏向锁的获取过程中， 发现有竞争时，会直接把所升级到轻量级锁上. </span></span></li><li><span class="name"><span class="innerContentContainer">其他线程会通过<b>自旋</b>的形式尝试获取锁，不会阻塞，提高性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重量级锁（Heavyweight Lock）: 重度竞争的情况下使用.</span></span><ul><li><span class="name"><span class="innerContentContainer">重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁升级为重量级锁。</span></span></li><li><span class="name"><span class="innerContentContainer">重量级锁会让他申请的线程进入<b>阻塞</b>，性能降低。</span></span></li><li><span class="name"><span class="innerContentContainer">重量级锁依赖于操作系统的互斥量（mutex） 实现，切换到重量级锁开销较大.</span></span></li><li><span class="name"><span class="innerContentContainer">重量级锁是通过对象的Monitor实现，monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">独享锁(互斥锁) / 共享锁(读写锁) <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">独享锁是指该锁一次只能被一个线程所持有. 也叫互斥锁.</span></span></li><li><span class="name"><span class="innerContentContainer">共享锁是指该锁可被多个线程所持有。也叫读写锁.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Synchronized</b> 是独享锁。</span></span></li><li><span class="name"><span class="innerContentContainer">而 Java的 <b>ReentrantLock</b> 是独享锁。</span></span></li><li><span class="name"><span class="innerContentContainer">对于Lock的另一个实现类 <b>ReadWriteLock</b>，其读锁是共享锁，其写锁是独享锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">读锁的共享锁可保证并发读是非常高效的.</span></span></li><li><span class="name"><span class="innerContentContainer">写锁是独享锁, 保证读写，写读，写写的过程是互斥的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">乐观锁 / 悲观锁</span></span><ul><li><span class="name"><span class="innerContentContainer">乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。</span></span></li><li><span class="name"><span class="innerContentContainer">悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语 <b>Synchronized </b>关键字的实现就是悲观锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">公平锁 / 非公平锁</span></span><ul><li><span class="name"><span class="innerContentContainer">公平锁是指多个线程按照申请锁的顺序来获取锁。</span></span></li><li><span class="name"><span class="innerContentContainer">非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</span></span></li><li><span class="name"><span class="innerContentContainer">非公平锁的优点在于吞吐量比公平锁大。</span></span></li><li><span class="name"><span class="innerContentContainer">Java <b>ReetrantLock</b>，可通过构造函数指定该锁是否是公平锁，默认是非公平锁。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Synchronized </b>也是一种非公平锁。由于其并不像 ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可重入锁</span></span><ul><li><span class="name"><span class="innerContentContainer">可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。可重入锁的一个好处是可一定程度避免死锁。</span></span></li><li><span class="name"><span class="innerContentContainer">对于Java <b>ReetrantLock</b>而言，从名字就可以看出是一个重入锁。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Synchronized</b> 也是一个可重入锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分段锁</span></span><ul><li><span class="name"><span class="innerContentContainer">分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</span></span></li><li><span class="name"><span class="innerContentContainer">我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</span></span></li><li><span class="name"><span class="innerContentContainer">当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</span></span></li><li><span class="name"><span class="innerContentContainer">但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</span></span></li><li><span class="name"><span class="innerContentContainer">分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自旋锁</span></span><ul><li><span class="name"><span class="innerContentContainer">在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用轮询的方式去尝试获取锁.</span></span></li><li><span class="name"><span class="innerContentContainer">这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</span></span></li><li><span class="name"><span class="innerContentContainer">自旋锁适用于能很快取到锁的场景下. 这是较常见的情况.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>加锁的方法</b> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>synchronized&nbsp;</b>关键字，修饰代码块. 保证同时刻只有一个线程进入该方法或者代码块. </span></span><ul><li><span class="name"><span class="innerContentContainer">这种最方便, 但是对性能影响也最高. 所以不能到处加 <b>synchronized</b>.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>原理: synchronized是从偏向锁开始，根据需要逐步升级到轻量级锁, 最后达到重量级锁.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>synchronized </b>有两种形式: </span></span></li><li><span class="name"><span class="innerContentContainer">第一种是作为前缀定义函数.</span></span><ul><li><span class="name"><span class="innerContentContainer">int count = 100;</span></span></li><li><span class="name"><span class="innerContentContainer">private <b>synchronized </b>void count() {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (count &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">isRunning = false;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二种是定义代码块.</span></span><ul><li><span class="name"><span class="innerContentContainer">private void count() {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>synchronized </b>(this) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (count &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">isRunning = false;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">volatile 关键字, 修饰变量</span></span><ul><li><span class="name"><span class="innerContentContainer">用volatile来定义变量，可以保证此变量对所有线程的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">它告诉虚拟机该变量随时可能更新，因此使用时每次都会重新计算，而不是使用寄存器的值。当一条线程修改了这个值，新值对于其他所有线程来说是立即得知的。</span></span></li><li><span class="name"><span class="innerContentContainer">volatile会降低性能。</span></span></li><li><span class="name"><span class="innerContentContainer">Volatile修饰的变量只能保证可见性, 不一定是线程安全的，比如 ii++。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重入锁Lock类(ReentrantLock), 实现线程同步</span></span><ul><li><span class="name"><span class="innerContentContainer">ReentrantLock 是 java.util.concurrent.Lock的实现类. </span></span></li><li><span class="name"><span class="innerContentContainer">提供了如下接口:</span></span><ul><li><span class="name"><span class="innerContentContainer">lock(): 获得锁</span></span></li><li><span class="name"><span class="innerContentContainer">unlock(): 释放锁</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:  </span></span></li><li><span class="name"><span class="innerContentContainer">private void count() {</span></span><ul><li><span class="name"><span class="innerContentContainer">private final ReentrantLock lock = new ReentrantLock();  // 创建可重入锁</span></span></li><li><span class="name"><span class="innerContentContainer">lock.lock();</span></span></li><li><span class="name"><span class="innerContentContainer">if (count &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">isRunning = false;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">lock.unlock();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ThreadLocal, 管理变量</span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个变量使用ThreadLocal进行管理，每一个使用该变量的线程都会获得该变量的副本，副本之间相互独立，所以每个线程都可以修改变量而不会对其它线程造成影响。</span></span></li><li><span class="name"><span class="innerContentContainer">数据不共享，自然就没有线程安全问题了.</span></span></li><li><span class="name"><span class="innerContentContainer">private static ThreadLocal&lt;Integer&gt; number = new ThreadLocal&lt;Integer&gt;(){</span></span><ul><li><span class="name"><span class="innerContentContainer">// 重写方法，设置默认值</span></span></li><li><span class="name"><span class="innerContentContainer">protected Integer initialValue() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return 1;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 自定义方法设置变量值</span></span></li><li><span class="name"><span class="innerContentContainer">public void saveNumber(int newNumber){</span></span><ul><li><span class="name"><span class="innerContentContainer">number.set(number.get() + newNumber);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 自定义方法获取变量值</span></span></li><li><span class="name"><span class="innerContentContainer">public int getNumber(){</span></span><ul><li><span class="name"><span class="innerContentContainer">return number.get();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Semaphore, 信号量</span></span><ul><li><span class="name"><span class="innerContentContainer">信号量维护了一个计数器. 如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</span></span></li><li><span class="name"><span class="innerContentContainer">Semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">死锁问题</span></span><ul><li><span class="name"><span class="innerContentContainer">产生死锁的四个必要条件： <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">互斥条件：一个资源每次只能被一个进程使用。</span></span></li><li><span class="name"><span class="innerContentContainer">请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span></span></li><li><span class="name"><span class="innerContentContainer">不剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。</span></span></li><li><span class="name"><span class="innerContentContainer">循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">目前处理死锁的方法可归结为4种 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">预防死锁：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</span></span></li><li><span class="name"><span class="innerContentContainer">避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</span></span></li><li><span class="name"><span class="innerContentContainer">检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。</span></span></li><li><span class="name"><span class="innerContentContainer">解除死锁：这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">四大组件都由AMS统一管理生命周期. </span></span></li><li><span class="name"><span class="innerContentContainer">ams相关代码</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks\base\core\java\android\app</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks\base\services\java\com\android\server\am</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks\base\services\java\com\android\server\wm</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>任务栈: 对Activity进行管理  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">APP一般是由多个Activity构成的。Android用 Task(任务)的概念将多个相关的Activity放在<b> Back Stack（回退堆栈）</b>中管理，以便进行Activity间的跳转与返回.</span></span></li><li><span class="name"><span class="innerContentContainer">注意，是相关的Activity，而不是同一个app的activity。有时候，同一个app的activity在不同的task （参见 taskAffinity ）；有时候，不同app的activity在同一个task。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>任务栈, 也叫task 栈, 或者 back栈</b></span></span><ul><li><span class="name"><span class="innerContentContainer">是一种用来放置Activity实例的容器，以栈的形式进行盛放Activity实例，也就是所谓的先进后出(LIFO).</span></span></li><li><span class="name"><span class="innerContentContainer">处于最顶部的叫栈顶，最底部叫栈底.</span></span></li><li><span class="name"><span class="innerContentContainer">常用操作: 入栈(<b>push</b>)，出栈(<b>pop</b>)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>栈内切换</b></span></span><ul><li><span class="name"><span class="innerContentContainer">当用户在主屏幕点击图标打开一个新的App，此时会创建一个<b>新的Task</b>. 然后开始把新产生的Activity入栈, 作为栈顶. </span></span></li><li><span class="name"><span class="innerContentContainer">当切换到新的Activity，那么该Activity会被压入栈中，成为新的栈顶。</span></span></li><li><span class="name"><span class="innerContentContainer">而当用户点击Back键，栈顶的Activity出栈，紧随其后的Activity来到栈顶。</span></span></li><li><span class="name"><span class="innerContentContainer">有一种特殊情况, 当我们在通讯录的APP中打开了短信APP的页面，但是此时不会新建一个栈，而是继续添加到栈1中。</span></span></li><li><span class="name"><span class="innerContentContainer">这是 Android推崇一种用户体验方式，即不同应用程序之间的切换能使用户感觉就像是同一个应用程序，连贯的用户体验，官方称其为seamless (无缝衔接）.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>栈间切换</b></span></span><ul><li><span class="name"><span class="innerContentContainer">同一时间系统会有多个task. 这些task 也组成一个 task堆栈. </span></span></li><li><span class="name"><span class="innerContentContainer">用户按下Home键回到桌面，再启动另一个应用，这时候<b>Task1</b>就被移到后台，成为<b>后台任务栈</b>，而刚启动的那个<b>Task2</b>就被调到前台，成为<b>前台任务栈</b>. </span></span></li><li><span class="name"><span class="innerContentContainer">点击recent键，打开之前的程序，然后<b>Task1</b>又回到前台了。</span></span></li><li><span class="name"><span class="innerContentContainer">如果Task1是通讯录的APP中打开了短信APP的页面, 现在回到桌面, 当我们点击主屏幕上通信录的图标打开APP，此时也不会创建新的栈，而是Task1回到前台。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意: 当调用到 onNewIntent(intent)的时候，需要使用 setIntent(intent)赋值给Activity的Intent. 否则后续的 getIntent()都是得到老的Intent。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity，application，task，stack的关系</span></span><ul><li><span class="name"><span class="innerContentContainer">application就是一个APK，所以多个activity对应一个application。</span></span></li><li><span class="name"><span class="innerContentContainer">task和它们的关系受制于activity启动参数。一般情况下，一个application中所有activity放到同一个task中，即task和application有一一对应的关系。</span></span></li><li><span class="name"><span class="innerContentContainer">task是activity栈。但是task自身也是焦点stack的一个元素。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">AndroidManifest.xml 中相关的配置项</span></span><ul><li><span class="name"><span class="innerContentContainer">taskAffinity 和 allowTaskReparenting <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">默认情况下，一个应用程序中的所有activity使用同一个Affinity，这让它们属于同一个Task。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 taskAffinity可指定该activity使用独立的Task。</span></span></li><li><span class="name"><span class="innerContentContainer">不同应用程序中的Activity可以共享同一个Affinity，同一个应用程序中的不同Activity 也可以设置成不同的Affinity。</span></span></li><li><span class="name"><span class="innerContentContainer">Affinity属性在2种情况下起作用：</span></span></li><li><span class="name"><span class="innerContentContainer">1）当启动 activity的Intent对象包含FLAG_ACTIVITY_NEW_TASK标记： 当传递给 startActivity()的Intent对象包含 FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的Activity寻找与当前Activity不同Task。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果要启动的 Activity的Affinity属性与当前所有的Task的Affinity属性都不相同，系统会新建一个带该Affinity属性的Task，并将要启动的Activity压到新建的Task栈中；</span></span></li><li><span class="name"><span class="innerContentContainer">否则将Activity压入同一Affinity属性的栈中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2）如果一个activity的 allowTaskReparenting属性为true， 那么它可以从一个Task（Task1）移到另外一个有相同Affinity的Task（Task2）中（Task2带到前台时）。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个APP从用户角度来看包含了多个"应用程序"，就可能需要对那些 Activity赋不同的Affinity值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Intent 中可以指定启动标志, 常见的包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_NEW_TASK: 放入新的task堆栈. 见上.</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_CLEAR_TOP</span></span></li><li><span class="name"><span class="innerContentContainer">FLAG_ACTIVITY_SINGLE_TOP</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>launchMode  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">activity启动模式, 常用且关键. 值域如下:</span></span></li><li><span class="name"><span class="innerContentContainer"><b>standard </b>(默认): 在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，会在A的上面再次启动一个A的实例，即当前的桟中的状态为A--&gt;A。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleTop: 如果一个以singleTop模式启动的Activity的实例已经存在于当前任务栈的栈顶， 那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例， 并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中， 那么再启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。 这时任务栈中还是这有一个A的实例。</span></span></li><li><span class="name"><span class="innerContentContainer">如果以singleTop模式启动的activity的一个实例已经存在与任务栈中，<b>但是不在栈顶</b>，那么它的行为和standard模式相同，也会创建多个实例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleTask: 创建一个新的实例时, 如果该实例在当前栈中已经存在，则不管它在不在栈顶, 直接将它移动到顶部，并且清空任务栈中这个activity上面所有的activity。</span></span><ul><li><span class="name"><span class="innerContentContainer">intent将被通过onNewIntent()发送.</span></span></li><li><span class="name"><span class="innerContentContainer">singleTask相当于singleTop的彻底版.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">singleInstance: 单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。比如来电界面.</span></span><ul><li><span class="name"><span class="innerContentContainer">当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">clearTaskOnLaunch: 清空栈</span></span><ul><li><span class="name"><span class="innerContentContainer">默认情况下, 当用户长时间离开Task（当前task被转移到后台）时，系统会清除task中栈底Activity外的所有Activity 。这样，当用户返回到Task时，只留下那个task最初始的Activity了。</span></span></li><li><span class="name"><span class="innerContentContainer">可通过修改 clearTaskOnLaunch 来改变这种行为. 其值域是: </span></span></li><li><span class="name"><span class="innerContentContainer">alwaysRetainTaskState: 如果栈底Activity的这个属性被设置为true，上述的情况就不会发生。 Task中的所有activity将被长时间保存。</span></span></li><li><span class="name"><span class="innerContentContainer">clearTaskOnLaunch: 如果栈底activity的这个属性被设置为true，一旦用户离开Task， 则 Task栈中的Activity将被清空到只剩下栈底activity。这种情况刚好与 alwaysRetainTaskState相反。即使用户只是短暂地离开，task也会返回到初始状态 （只剩下栈底acitivty）。</span></span></li><li><span class="name"><span class="innerContentContainer">finishOnTaskLaunch: 与clearTaskOnLaunch相似，但它只对单独的activity操 作，而不是整个Task。它可以结束任何Activity，包括栈底的Activity。 当它设置为true时，当前的Activity只在当前会话期间作为Task的一部分存在， 当用户退出Activity再返回时，它将不存在。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>进程优先级 adj <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">进程 omm_adj的大小跟进程的类型以及进程被调度的次序有关。</span></span></li><li><span class="name"><span class="innerContentContainer">在init.rc中，定义init进程的pid为1，omm_adj 被配置为-16，永远不会被杀死。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>ActivityManagerService 负责定义各种进程的 oom_adj.  </b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>adj 有如下值(也即进程有如下分类):    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">NATIVE_ADJ = -17;  // native进程（不被系统管理）</span></span></li><li><span class="name"><span class="innerContentContainer">SYSTEM_ADJ = -16;  // 系统进程, 永远不会被杀死. init进程就是-16.</span></span></li><li><span class="name"><span class="innerContentContainer">CORE_SERVER_ADJ = -12;   // 核心服务, 永远不会被杀死。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>FOREGROUND_APP_ADJ = 0;  // 前台进程, 一个应用切换到前台, 就会被赋值0. </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>特殊情况: talkback 没有界面, 但是只要打开, 其 adj 就是0 , 和前台进程优先级一样.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>VISIBLE_APP_ADJ  = 1;   // 用户可见进程. 包括systemui(状态栏, 导航栏等), widget控件, 输入法窗口等.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>PERCEPTIBLE_APP_ADJ = 2;  // 可感知进程. 比如后台音乐播放</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>HEAVY_WEIGHT_APP_ADJ = 4;  // 后台重量级进程 (在 system/rootdir/init.rc 中定义)</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>SERVICE_ADJ = 5;  // 服务进程</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>HOME_APP_ADJ = 6;  // </b>即 Launcher. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>PREVIOUS_APP_ADJ = 7;   // 上一个App的进程(往往通过back键或者home键切走的那个进程) . 优先级比服务进程低.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>CACHED_APP_MIN_ADJ = 9;  // 不可见进程的adj最小值. app切换到后台即是这个adj值.</b></span></span><ul><li><span class="name"><span class="innerContentContainer">后台进程的管理策略有多种：</span></span></li><li><span class="name"><span class="innerContentContainer">有较为积极的方式，一旦程序到达后台立即终止，这种方式会提高程序的运行速度，但无法加速程序的再次启动；</span></span></li><li><span class="name"><span class="innerContentContainer">也有较消极的方式，尽可能多的保留后台程序，虽然可能会影响到单个程序的运行速度，但在再次启动已启动的程序时，速度会有所提升。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内容供应节点（content provider）: 为保证provider所在进程的优先级高于或等于 客户端进程, 所以在被使用时, 它的adj和使用者一样, 使用结束后再恢复为空.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理Service生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer">Service是否是独立进程?</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Service没有设定属性android:process=”:remote”, Service会和Activity是在同一个进程中的，即主线程.</span></span></li><li><span class="name"><span class="innerContentContainer">如果Service设定属性android:process=”:remote”, 那么就会创建新进程.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Service的启动方式有两种：</span></span></li><li><span class="name"><span class="innerContentContainer">startService</span></span><ul><li><span class="name"><span class="innerContentContainer">ContextWrapper类中的startService(), 调用了ContextImpl的startService()。</span></span></li><li><span class="name"><span class="innerContentContainer">在startServiceCommon()中通过binder，调用了AMS服务的startService()。</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService.startServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">在AMS服务中，每个Service都使用一个ServiceRecord对象来描述，然后调用retrieveServiceLocked方法来查找一个和目标Service对应的ServiceRecord，最后将这个ServiceRecord对象封装在ServiceLookupResult对象中。</span></span></li><li><span class="name"><span class="innerContentContainer">查找方案是首先从AMS服务中的ServiceMap中查找，ServiceMap中保存了AMS服务中所有激活的Service信息，如果在ServiceMap中没有找到，说明该Service还没有启动。那么就需要从PMS服务中查找目标Service的信息并创建一个ServiceRecord对象。最后把它保存在对应的ServiceMap集合中。</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService. bringUpServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveService.realStartServiceLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityThread.handleCreateService()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bindService</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">管理BroadcastReceiver生命周期，分发和接受Broadcast</span></span></li><li><span class="name"><span class="innerContentContainer">管理ContentProvider生命周期</span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/c35313c52eef">https://www.jianshu.com/p/c35313c52eef</a></span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider&nbsp;封装了数据的跨进程传输，我们可以直接使用 getContentResolver() 拿到&nbsp;ContentResolver&nbsp;进行增删改查即可。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">处理应用程序的Crash</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">定时器</span></span><ul><li><span class="name"><span class="innerContentContainer">SystemClock.elapsedRealtime()：获得系统开机到现在经历的毫秒数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">横竖屏切换 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">横竖屏切换时，一般情况下会销毁当前的Activity然后重新创建一个. 其生命周期是：</span></span><ul><li><span class="name"><span class="innerContentContainer">onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用可强制横屏或竖屏</span></span><ul><li><span class="name"><span class="innerContentContainer">在AndroidManifest.xml中为Act添加一个属性：&nbsp;android:screenOrientation. 其值域是:</span></span></li><li><span class="name"><span class="innerContentContainer">unspecified: 默认值.由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向。</span></span></li><li><span class="name"><span class="innerContentContainer">landscape: 强制横屏显示（宽比高要长）</span></span></li><li><span class="name"><span class="innerContentContainer">portrait: 强制竖屏显示</span></span></li><li><span class="name"><span class="innerContentContainer">user: 用户当前首选的方向</span></span></li><li><span class="name"><span class="innerContentContainer">behind: 和Activity堆栈中前面那个Activity的方向一致.</span></span></li><li><span class="name"><span class="innerContentContainer">sensor: 有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。</span></span></li><li><span class="name"><span class="innerContentContainer">nosensor: 忽略物理感应器，这样就不会随着用户旋转设备而更改了（"unspecified"设置除外）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用可禁止在横竖屏切换时重新加载activity</span></span><ul><li><span class="name"><span class="innerContentContainer">在 manifest文件中给activity加一个属性： android:configChanges="orientation|keyboardHidden"</span></span></li><li><span class="name"><span class="innerContentContainer">重载 onConfigurationChanged().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">准备横竖屏两套布局，系统会根据屏幕状态自动加载：</span></span><ul><li><span class="name"><span class="innerContentContainer">res/layout-land: 横屏</span></span></li><li><span class="name"><span class="innerContentContainer">res/layout-port: 竖屏</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在onCreate()方法中判断横竖屏</span></span><ul><li><span class="name"><span class="innerContentContainer">if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE){</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.横屏);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else if (this.getResources().getConfiguration().orientation ==Configuration.ORIENTATION_PORTRAIT) {</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.竖屏);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统关闭自动旋转，应用如何获取横竖屏状态？</span></span><ul><li><span class="name"><span class="innerContentContainer">获取senserService句柄。</span></span></li><li><span class="name"><span class="innerContentContainer">注册监听回调。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统自定义Activity</span></span><ul><li><span class="name"><span class="innerContentContainer">拨打电话</span></span><ul><li><span class="name"><span class="innerContentContainer">// 给移动客服10086拨打电话</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("tel:10086");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_DIAL, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送短信</span></span><ul><li><span class="name"><span class="innerContentContainer">// 给10086发送内容为“Hello”的短信</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("smsto:10086");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_SENDTO, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("sms_body", "Hello");</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送彩信（相当于发送带附件的短信）</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_SEND);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("sms_body", "Hello");</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("content://media/external/images/media/23");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_STREAM, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setType("image/png");</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打开浏览器</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("http://www.baidu.com");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent&nbsp; = new Intent(Intent.ACTION_VIEW, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送电子邮件(阉割了Google服务的没戏)</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("mailto:<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:someone@domain.com">someone@domain.com</a>");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_SENDTO, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li><li><span class="name"><span class="innerContentContainer">// 给<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:someone@domain.com">someone@domain.com</a>发邮件发送内容为“Hello”的邮件</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_SEND);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_EMAIL, "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:someone@domain.com">someone@domain.com</a>");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_SUBJECT, "Subject");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_TEXT, "Hello");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setType("text/plain");</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li><li><span class="name"><span class="innerContentContainer">// 给多人发邮件</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent=new Intent(Intent.ACTION_SEND);</span></span></li><li><span class="name"><span class="innerContentContainer">String[] tos = {"<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:1@abc.com">1@abc.com</a>", "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:2@abc.com">2@abc.com</a>"}; // 收件人</span></span></li><li><span class="name"><span class="innerContentContainer">String[] ccs = {"<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:3@abc.com">3@abc.com</a>", "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:4@abc.com">4@abc.com</a>"}; // 抄送</span></span></li><li><span class="name"><span class="innerContentContainer">String[] bccs = {"<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:5@abc.com">5@abc.com</a>", "<a class="contentLink" target="_blank" rel="noreferrer" href="mailto:6@abc.com">6@abc.com</a>"}; // 密送</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_EMAIL, tos);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_CC, ccs);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_BCC, bccs);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_SUBJECT, "Subject");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(Intent.EXTRA_TEXT, "Hello");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setType("message/rfc822");</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">显示地图</span></span><ul><li><span class="name"><span class="innerContentContainer">// 打开Google地图中国北京位置（北纬39.9，东经116.3）</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("geo:39.9,116.3");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">路径规划</span></span><ul><li><span class="name"><span class="innerContentContainer">// 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4）</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("http://maps.google.com/maps?f=d&amp;saddr=39.9 116.3&amp;daddr=31.2 121.4");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多媒体播放</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_VIEW);</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("file:///sdcard/foo.mp3");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setDataAndType(uri, "audio/mp3");</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li><li><span class="name"><span class="innerContentContainer">// 获取SD卡下所有音频文件,然后播放第一首=-=</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打开摄像头拍照</span></span><ul><li><span class="name"><span class="innerContentContainer">// 打开拍照程序</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivityForResult(intent, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">// 取出照片数据</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle extras = intent.getExtras();</span></span></li><li><span class="name"><span class="innerContentContainer">Bitmap bitmap = (Bitmap) extras.get("data");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用系统相机应用程序，并存储拍下来的照片</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span></span></li><li><span class="name"><span class="innerContentContainer">time = Calendar.getInstance().getTimeInMillis();</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment</span></span></li><li><span class="name"><span class="innerContentContainer">.getExternalStorageDirectory().getAbsolutePath()+"/tucue", time + ".jpg")));</span></span></li><li><span class="name"><span class="innerContentContainer">startActivityForResult(intent, ACTIVITY_GET_CAMERA_IMAGE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取并剪切图片</span></span><ul><li><span class="name"><span class="innerContentContainer">// 获取并剪切图片</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_GET_CONTENT);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setType("image/*");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("crop", "true"); // 开启剪切</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("aspectX", 1); // 剪切的宽高比为1：2</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("aspectY", 2);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("outputX", 20); // 保存图片的宽和高</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("outputY", 40);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("output", Uri.fromFile(new File("/mnt/sdcard/temp"))); // 保存路径</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("outputFormat", "JPEG");// 返回格式</span></span></li><li><span class="name"><span class="innerContentContainer">startActivityForResult(intent, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">// 剪切特定图片</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent("com.android.camera.action.CROP");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setClassName("com.android.camera", "com.android.camera.CropImage");</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setData(Uri.fromFile(new File("/mnt/sdcard/temp")));</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("outputX", 1); // 剪切的宽高比为1：2</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("outputY", 2);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("aspectX", 20); // 保存图片的宽和高</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("aspectY", 40);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("scale", true);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("noFaceDetection", true);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.putExtra("output", Uri.parse("file:///mnt/sdcard/temp"));</span></span></li><li><span class="name"><span class="innerContentContainer">startActivityForResult(intent, 0);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打开Google Market</span></span><ul><li><span class="name"><span class="innerContentContainer">// 打开Google Market直接进入该程序的详细页面</span></span></li><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.parse("market://details?id=" + "com.demo.app");</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进入手机设置界面</span></span><ul><li><span class="name"><span class="innerContentContainer">// 进入无线网络设置界面（其它可以举一反三）</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivityForResult(intent, 0);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安装apk</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri installUri = Uri.fromParts("package", "xxx", null);</span></span></li><li><span class="name"><span class="innerContentContainer">returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">卸载apk</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri uri = Uri.fromParts("package", strPackageName, null);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it = new Intent(Intent.ACTION_DELETE, uri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(it);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送附件</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent it = new Intent(Intent.ACTION_SEND);</span></span></li><li><span class="name"><span class="innerContentContainer">it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");</span></span></li><li><span class="name"><span class="innerContentContainer">it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/eoe.mp3");</span></span></li><li><span class="name"><span class="innerContentContainer">sendIntent.setType("audio/mp3");</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(Intent.createChooser(it, "Choose Email Client"));</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进入联系人页面</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent();</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setAction(Intent.ACTION_VIEW);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setData(People.CONTENT_URI);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看指定联系人</span></span><ul><li><span class="name"><span class="innerContentContainer">Uri personUri = ContentUris.withAppendedId(People.CONTENT_URI, info.id);  //info.id联系人ID</span></span></li><li><span class="name"><span class="innerContentContainer">Intent intent = new Intent();</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setAction(Intent.ACTION_VIEW);</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setData(personUri);</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(intent);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity间的数据传递 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Intent </b>it = new Intent(MyActivity.this, MyActivity2.class);</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Bundle </b>bd = new Bundle();   // 新建Bundle对象,并把数据写入</span></span></li><li><span class="name"><span class="innerContentContainer">bd.putCharSequence("user",name);</span></span></li><li><span class="name"><span class="innerContentContainer">bd.putCharSequence("sex",sex);</span></span></li><li><span class="name"><span class="innerContentContainer">it.<b>putExtras</b>(bd);  // 将数据包Bundle绑定到Intent上</span></span></li><li><span class="name"><span class="innerContentContainer">startActivity(it);   // 启动第二个activity</span></span></li><li><span class="name"><span class="innerContentContainer">finish();   // 关闭第一个Activity</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity相关的原语</span></span><ul><li><span class="name"><span class="innerContentContainer">一次性关闭所有Activity</span></span><ul><li><span class="name"><span class="innerContentContainer">public class ActivityCollector {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 用一个list集合来存储所有Activity</span></span></li><li><span class="name"><span class="innerContentContainer">public static LinkedList&lt;Activity&gt; activities = new LinkedList&lt;Activity&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">public static void addActivity(Activity activity) {</span></span><ul><li><span class="name"><span class="innerContentContainer">activities.add(activity);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public static void removeActivity(Activity activity) {</span></span><ul><li><span class="name"><span class="innerContentContainer">activities.remove(activity);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public static void finishAll() {</span></span><ul><li><span class="name"><span class="innerContentContainer">for(Activity activity:activities) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(!activity.isFinishing()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">activity.finish();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">假如app中所有的activity 都继承自 BaseActivity.  在它的 onCreate() 中调用 ActivityCollector.addActivity(this);  在 onDestory() 中调用 ActivityCollector.removeActivity().</span></span></li><li><span class="name"><span class="innerContentContainer">然后在任何地方调用 ActivityCollector.finishAll() 即可关闭所有的activity.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">完全退出App</span></span><ul><li><span class="name"><span class="innerContentContainer">上面是关闭所有的activity, 但是app并没有退出, 因为还有service. </span></span></li><li><span class="name"><span class="innerContentContainer">下面是完全退出app的代码:</span></span></li><li><span class="name"><span class="innerContentContainer">public void AppExit(Context context) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityCollector.finishAll();</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager activityMgr = (ActivityManager) context</span></span><ul><li><span class="name"><span class="innerContentContainer">.getSystemService(Context.ACTIVITY_SERVICE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activityMgr.killBackgroundProcesses(context.getPackageName());</span></span></li><li><span class="name"><span class="innerContentContainer">System.exit(0);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (Exception ignored) {}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">为Activity设置过场动画</span></span><ul><li><span class="name"><span class="innerContentContainer">过场动画就是切换到另外的Activity时加上一些切换动画，比如淡入淡出，放大缩小，左右互推等.</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">通过style进行配置，这个是全局的哦，就是所有的Activity都会加载这个动画.</span></span></li><li><span class="name"><span class="innerContentContainer">(1) 在style.xml中自定义style：</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;!-- 默认Activity跳转动画 --&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;style name="default_animation" mce_bogus="1" parent="@android:style/Animation.Activity"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;item name="android:activityOpenEnterAnimation"&gt;@anim/default_anim_in&lt;/item&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item name="android:activityOpenExitAnimation"&gt;@anim/anim_stay&lt;/item&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item name="android:activityCloseEnterAnimation"&gt;@anim/anim_stay&lt;/item&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item name="android:activityCloseExitAnimation"&gt;@anim/default_anim_out&lt;/item&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/style&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">4个item分别代表:</span></span></li><li><span class="name"><span class="innerContentContainer">Activity A跳转到Activity B时Activity B进入动画;</span></span></li><li><span class="name"><span class="innerContentContainer">Activity A跳转到Activity B时Activity A退出动画;</span></span></li><li><span class="name"><span class="innerContentContainer">Activity B返回Activity A时Activity A的进入动画</span></span></li><li><span class="name"><span class="innerContentContainer">Activity B返回Activity A时ActivityB的退出动画</span></span></li><li><span class="name"><span class="innerContentContainer"><b>(2) 然后修改下AppTheme:</b>&lt;style name="AppTheme" mce_bogus="1" parent="@android:style/Theme.Light"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;item name="android:windowAnimationStyle"&gt;@style/default_animation&lt;/item&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/style&gt;</span></span></li><li><span class="name"><span class="innerContentContainer"><b>(3) 最后在appliction设置下：</b></span></span></li><li><span class="name"><span class="innerContentContainer">&lt;application</span></span><ul><li><span class="name"><span class="innerContentContainer">android:icon="@drawable/logo"</span></span></li><li><span class="name"><span class="innerContentContainer">android:label="@string/app_name"</span></span></li><li><span class="name"><span class="innerContentContainer">android:theme="@style/AppTheme" &gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">设置Activity全屏</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 代码隐藏ActionBar</span></span><ul><li><span class="name"><span class="innerContentContainer">在Activity的onCreate方法中调用getActionBar.hide();即可</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 通过requestWindowFeature设置</span></span><ul><li><span class="name"><span class="innerContentContainer">requestWindowFeature(Window.FEATURE_NO_TITLE);  // 需要在setContentView ()之前调用. </span></span></li><li><span class="name"><span class="innerContentContainer">把 requestWindowFeature(Window.FEATURE_NO_TITLE); 放在super.onCreate(savedInstanceState);前面就可以隐藏ActionBar而不报错。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 通过AndroidManifest.xml的theme</span></span><ul><li><span class="name"><span class="innerContentContainer">在需要全屏的Activity的标签内设置 theme = <span class="contentTag" title="Filter @android:style">@<span class="contentTagText">android:style</span><span class="contentTagNub"></span></span>/Theme.NoTitleBar.FullScreen</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">定义对话框风格的Activity</span></span><ul><li><span class="name"><span class="innerContentContainer">Activity一般是占满全屏的， 而Dialog则是占据部分屏幕的.</span></span></li><li><span class="name"><span class="innerContentContainer">直接设置下Activity的theme: android:theme="@android:style/Theme.Dialog" 即可.</span></span></li><li><span class="name"><span class="innerContentContainer">// 然后再设置左上角小图标</span></span></li><li><span class="name"><span class="innerContentContainer">requestWindowFeature(Window.FEATURE_LEFT_ICON);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.main);</span></span></li><li><span class="name"><span class="innerContentContainer">getWindow().setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, android.R.drawable.ic_lion_icon);</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置文字:</span></span></li><li><span class="name"><span class="innerContentContainer">setTitle(R.string.actdialog_title);  //XML代码中设置:android:label="@string/activity_dialog"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开源中国客户端Activity管理类</span></span><ul><li><span class="name"><span class="innerContentContainer">package net.oschina.app;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.util.Stack;</span></span></li><li><span class="name"><span class="innerContentContainer">import android.app.Activity;</span></span></li><li><span class="name"><span class="innerContentContainer">import android.app.ActivityManager;</span></span></li><li><span class="name"><span class="innerContentContainer">import android.content.Context;</span></span></li><li><span class="name"><span class="innerContentContainer">public class AppManager {</span></span><ul><li><span class="name"><span class="innerContentContainer">private static Stack&lt;Activity&gt; activityStack;</span></span></li><li><span class="name"><span class="innerContentContainer">private static AppManager instance;</span></span></li><li><span class="name"><span class="innerContentContainer">private AppManager(){}</span></span></li><li><span class="name"><span class="innerContentContainer">/* 单一实例 */</span></span></li><li><span class="name"><span class="innerContentContainer">public static AppManager getAppManager(){</span></span><ul><li><span class="name"><span class="innerContentContainer">if(instance==null){</span></span><ul><li><span class="name"><span class="innerContentContainer">instance=new AppManager();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return instance;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/**</span></span><ul><li><span class="name"><span class="innerContentContainer">添加Activity到堆栈</span></span></li><li><span class="name"><span class="innerContentContainer">*/</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">public void addActivity(Activity activity){</span></span><ul><li><span class="name"><span class="innerContentContainer">if(activityStack==null){</span></span><ul><li><span class="name"><span class="innerContentContainer">activityStack=new Stack&lt;Activity&gt;();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">activityStack.add(activity);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/* 获取当前Activity（堆栈中最后一个压入的） */</span></span></li><li><span class="name"><span class="innerContentContainer">public Activity currentActivity(){</span></span><ul><li><span class="name"><span class="innerContentContainer">Activity activity=activityStack.lastElement();</span></span></li><li><span class="name"><span class="innerContentContainer">return activity;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/* 结束当前Activity（堆栈中最后一个压入的） */</span></span></li><li><span class="name"><span class="innerContentContainer">public void finishActivity(){</span></span><ul><li><span class="name"><span class="innerContentContainer">Activity activity=activityStack.lastElement();</span></span></li><li><span class="name"><span class="innerContentContainer">finishActivity(activity);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/**</span></span><ul><li><span class="name"><span class="innerContentContainer">结束指定的Activity</span></span></li><li><span class="name"><span class="innerContentContainer">*/</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">public void finishActivity(Activity activity){</span></span><ul><li><span class="name"><span class="innerContentContainer">if(activity!=null){</span></span><ul><li><span class="name"><span class="innerContentContainer">activityStack.remove(activity);</span></span></li><li><span class="name"><span class="innerContentContainer">activity.finish();</span></span></li><li><span class="name"><span class="innerContentContainer">activity=null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/* 结束指定类名的Activity */</span></span></li><li><span class="name"><span class="innerContentContainer">public void finishActivity(Class&lt;?&gt; cls){</span></span><ul><li><span class="name"><span class="innerContentContainer">for (Activity activity : activityStack) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(activity.getClass().equals(cls) ){</span></span><ul><li><span class="name"><span class="innerContentContainer">finishActivity(activity);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/* 结束所有Activity */</span></span></li><li><span class="name"><span class="innerContentContainer">public void finishAllActivity(){</span></span><ul><li><span class="name"><span class="innerContentContainer">for (int i = 0, size = activityStack.size(); i &lt; size; i++){</span></span><ul><li><span class="name"><span class="innerContentContainer">if (null != activityStack.get(i)){</span></span><ul><li><span class="name"><span class="innerContentContainer">activityStack.get(i).finish();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">activityStack.clear();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">/* 退出应用程序 */</span></span></li><li><span class="name"><span class="innerContentContainer">public void AppExit(Context context) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">finishAllActivity();</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager activityMgr= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">activityMgr.restartPackage(context.getPackageName());</span></span></li><li><span class="name"><span class="innerContentContainer">System.exit(0);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (Exception e) {&nbsp; &nbsp; }</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul>
  </body>
</html>