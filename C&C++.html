<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>C&amp;C++  <span class="contentTag" title="Filter #Work">#<span class="contentTagText">Work</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">代码组织方式</span></span><ul><li><span class="name"><span class="innerContentContainer">C语言：头文件 .h 和 .c文件. 以文件为单位来组织的.</span></span></li><li><span class="name"><span class="innerContentContainer">C++：头文件也可以写代码.</span></span></li><li><span class="name"><span class="innerContentContainer">冒号（:）的用法 (c++)</span></span><ul><li><span class="name"><span class="innerContentContainer">类名后面的冒号是用于定义类的继承关系；</span></span></li><li><span class="name"><span class="innerContentContainer">构造函数后面的冒号用于成员变量的赋值，常见于const常量。如：</span></span><ul><li><span class="name"><span class="innerContentContainer">struct MyStruct{</span></span><ul><li><span class="name"><span class="innerContentContainer">MyStruct(): Param(initValue) {…}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">双冒号(::)的用法 (c++)</span></span><ul><li><span class="name"><span class="innerContentContainer">表示“域操作符”。申明一个类成员函数 void func()，则在类外定义它时，要写成void MyClass::func()</span></span></li><li><span class="name"><span class="innerContentContainer">用于函数前，表示是全局函数。例如 ::flock()</span></span></li><li><span class="name"><span class="innerContentContainer">表示应用成员函数或变量，等价于.号。</span></span><ul><li><span class="name"><span class="innerContentContainer">如：System::Math::Sqrt(), 等价于 System.Math.Sqrt()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">mian函数(主函数, 入口函数) <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">int main( int argc, char *argv[]) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return 0;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">预处理  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">防止头文件重复包含。有两种方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">常用: # ifndef  ***，# define  ***，# endif /* *** */</span></span></li><li><span class="name"><span class="innerContentContainer">文件第一行用: # pragma once</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">类和对象</span></span><ul><li><span class="name"><span class="innerContentContainer">class, 类定义(C++)</span></span><ul><li><span class="name"><span class="innerContentContainer">在C++中，对于类的定义和实现是否要分别在h文件和cpp文件中并没有做严格要求。但一般是要分开的。&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">// .h文件</span></span></li><li><span class="name"><span class="innerContentContainer">class MyClass : public SuperClass {</span></span><ul><li><span class="name"><span class="innerContentContainer">public: &nbsp;// 方法常公有</span></span><ul><li><span class="name"><span class="innerContentContainer">MyClass(); &nbsp; // 构造函数1，无参数。构造函数没有返回值。</span></span></li><li><span class="name"><span class="innerContentContainer">MyClass(int param); &nbsp; // 构造函数2，有参数。</span></span></li><li><span class="name"><span class="innerContentContainer">~MyClass(); &nbsp; // 析构函数。析构函数没有参数，也没有返回值。</span></span></li><li><span class="name"><span class="innerContentContainer">int myFunc1(); &nbsp;// 其它对外接口。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">private: // 属性常私有</span></span><ul><li><span class="name"><span class="innerContentContainer">static int staticParam = 0; &nbsp; // 静态成员属性。后文可看到，这是个访问计数。</span></span></li><li><span class="name"><span class="innerContentContainer">int myParam1;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">// .cpp文件</span></span></li><li><span class="name"><span class="innerContentContainer"># include &lt;MyClass.h&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">int&nbsp;MyClass::myParam1; &nbsp; &nbsp;// 属性要重新引用。这个略奇葩。</span></span></li><li><span class="name"><span class="innerContentContainer">MyClass::MyClass(): SuperClass() { &nbsp;// 显示调用父类的构造函数</span></span><ul><li><span class="name"><span class="innerContentContainer">myParam1 = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">staticParam++;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">MyClass::MyClass(int param): SuperClass() { &nbsp;// 显示调用父类的构造函数</span></span><ul><li><span class="name"><span class="innerContentContainer">myParam1 =&nbsp;param;</span></span></li><li><span class="name"><span class="innerContentContainer">staticParam++;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">MyClass::~MyClass() {</span></span><ul><li><span class="name"><span class="innerContentContainer">staticParam—;</span></span></li><li><span class="name"><span class="innerContentContainer">if (staticParam &lt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">LogE(“MyClass free erro.");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">int myFunc1() {</span></span><ul><li><span class="name"><span class="innerContentContainer">myParam1 *= 2.5;</span></span></li><li><span class="name"><span class="innerContentContainer">return myParam1;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">注意:（1）子类不能访问基类中的私有对象；</span></span></li><li><span class="name"><span class="innerContentContainer">（2）不要new基类，要new子类。new基类，就和子类无关了。</span></span></li><li><span class="name"><span class="innerContentContainer">（3）慎用友元.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">struct, 结构定义(C语言)</span></span><ul><li><span class="name"><span class="innerContentContainer">struct stuff {</span></span><ul><li><span class="name"><span class="innerContentContainer">char job[20];</span></span></li><li><span class="name"><span class="innerContentContainer">int age;</span></span></li><li><span class="name"><span class="innerContentContainer">float height;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} Qinwei;</span></span></li><li><span class="name"><span class="innerContentContainer">Qinwei是结构变量. 可以直接使用.</span></span></li><li><span class="name"><span class="innerContentContainer">在其他位置定义变量是, 需要用: struct stuff Qinwei2;</span></span></li><li><span class="name"><span class="innerContentContainer">使用 <b>typedef</b> struct stuff{}Qinwei;  这种方式定义, 则定义结构变量时, 直接用 Qinwei Qinwei3;  Qinwei相当于类型别名.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">static 关键字  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">用于静态量.</span></span></li><li><span class="name"><span class="innerContentContainer">用于定义函数, 即定义私有函数, 只能被本类或本文件访问.</span></span></li><li><span class="name"><span class="innerContentContainer">用于定义全局变量, 即定义私有全局变量, 只能被本类或本文件访问.</span></span></li><li><span class="name"><span class="innerContentContainer">用于定义局部变量, 即定义局部静态变量, 它虽然只能被所在函数访问, 但生命周期是全局的, 会保留上一次的值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">const 关键字 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">用于定义常量, 不可被修改.</span></span></li><li><span class="name"><span class="innerContentContainer">用于定义函数参数, 即不能被函数修改. 推荐使用.</span></span></li><li><span class="name"><span class="innerContentContainer">用于定义函数返回值, 即返回值的值不可修改. 很少用.</span></span></li><li><span class="name"><span class="innerContentContainer">用于定义函数, 即函数不可修改类数据成员的值.  推荐使用. (C++)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">extern 关键字 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">extern用于定义变量或者函数时, 以标示变量或者函数的定义在别的文件中, 编译时不再检查其有效性. 当然如果实际是无效的, 在链接时还是会报错.</span></span></li><li><span class="name"><span class="innerContentContainer">它还可以用于 链接指定. </span></span></li><li><span class="name"><span class="innerContentContainer">extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去编译.</span></span></li><li><span class="name"><span class="innerContentContainer">因为 C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$. 因为c++支持多态.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">std::make_unique</span></span><ul><li><span class="name"><span class="innerContentContainer">C++V11上支持, VS 2015支持.</span></span></li><li><span class="name"><span class="innerContentContainer">make_unique 同&nbsp;unique_ptr 、auto_ptr&nbsp;等一样，都是&nbsp;smart pointer;</span></span></li><li><span class="name"><span class="innerContentContainer">可以取代new 并且无需 delete pointer，有助于代码管理。</span></span></li><li><span class="name"><span class="innerContentContainer">make_unique&nbsp;创建并返回 unique_ptr&nbsp;至指定类型的对象，这一点从其构造函数能看出来。make_unique相较于unique_ptr 则更加安全。</span></span></li><li><span class="name"><span class="innerContentContainer">推荐使用.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">explicit 关键字  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">仅用于类的构造函数上。功能是禁止类的隐式类型转换。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">auto 关键字 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">auto 表示不知道数据的类型，而由编译器来推导。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Hello world</span></span><ul><li><span class="name"><span class="innerContentContainer"># include &lt;stdio.h&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">int main( void )&nbsp;{</span></span><ul><li><span class="name"><span class="innerContentContainer">printf("Hello world!\n");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">编译：cc hello.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注释</span></span><ul><li><span class="name"><span class="innerContentContainer">// 单行注释</span></span></li><li><span class="name"><span class="innerContentContainer">/* 多行</span></span></li><li><span class="name"><span class="innerContentContainer">注释 */</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log打印</span></span><ul><li><span class="name"><span class="innerContentContainer">打印到文件</span></span><ul><li><span class="name"><span class="innerContentContainer">fprintf(fp, “%s %s\t %s\t%s\t%s\n”, __DATA__, __TIME, __FILE__, __LINE__, argv[0]);&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印堆栈  --android上不可用</span></span><ul><li><span class="name"><span class="innerContentContainer"># include &lt;execinfo.h&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">void * array[16];</span></span></li><li><span class="name"><span class="innerContentContainer">int stack_num = backtrace(array, 16);</span></span></li><li><span class="name"><span class="innerContentContainer">char ** stacktrace = backtrace_symbols(array, stack_num);</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGE("stack begin:");</span></span></li><li><span class="name"><span class="innerContentContainer">for (int ii=0; ii&lt;stack_num; ++ii) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ALOGE("\t%s", stacktrace[ii]);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">free(stacktrace);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印堆栈  --Android可用</span></span><ul><li><span class="name"><span class="innerContentContainer"># include &lt;utils/CallStack.h&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">新版本(多新不清楚, 先用这个)</span></span><ul><li><span class="name"><span class="innerContentContainer">android::CallStack stack(" begin:");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">老版本</span></span><ul><li><span class="name"><span class="innerContentContainer">android::CallStack stack;</span></span></li><li><span class="name"><span class="innerContentContainer">stack.update();</span></span></li><li><span class="name"><span class="innerContentContainer">stack.log("begin:");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">编译文件中加入对 libutils 库的 shared 依赖。</span></span></li><li><span class="name"><span class="innerContentContainer">编译开关： 为了自带符号表，开关加上 -rdynamic, -g</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">函数（传值、传地址、传引用）</span></span><ul><li><span class="name"><span class="innerContentContainer">一般函数: int myFunc(int ii, char * string) {…}&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">变参函数</span></span><ul><li><span class="name"><span class="innerContentContainer">void simple_va_fun(int start, …) {</span></span><ul><li><span class="name"><span class="innerContentContainer">va_list arg_prt;</span></span></li><li><span class="name"><span class="innerContentContainer">int nArgValue = start; &nbsp; // 第一个参数</span></span></li><li><span class="name"><span class="innerContentContainer">int nArgCount = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">va_start(arg_ptr, start);</span></span></li><li><span class="name"><span class="innerContentContainer">do {   // 遍历各个参数</span></span><ul><li><span class="name"><span class="innerContentContainer">++nArgCount;</span></span></li><li><span class="name"><span class="innerContentContainer">printf(“the %d argument is %d”,&nbsp;nArgCount,&nbsp;nArgValue);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} while (nArgValue != -1);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">宏定义中使用可变参数</span></span><ul><li><span class="name"><span class="innerContentContainer">c99支持 ## _VA_ARGS_ 宏。</span></span></li><li><span class="name"><span class="innerContentContainer"># define debug(… ) printf (_VA_ARGS_)</span></span></li><li><span class="name"><span class="innerContentContainer">使用时：debug(“y=%d\n”, y);</span></span></li><li><span class="name"><span class="innerContentContainer">gcc还支持一种格式，就是：# define dbprint(format, args…) frpintf(stderr, format, ##args)&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">参数传递分为传值、传地址、传引用。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">基本数据类型、<b>结构体</b>默认是传值. </span></span></li><li><span class="name"><span class="innerContentContainer">数组、字符串、指针、对象默认是传地址。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">除语义差异外，传值涉及值拷贝，可能有性能问题。</span></span></li><li><span class="name"><span class="innerContentContainer">c++中提供传引用的方法，推荐使用。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">void myFunc(int &amp;param) {…}   // 用&amp;定义</span></span></li><li><span class="name"><span class="innerContentContainer">函数体中直接使用变量名 param，不需要加什么符号。</span></span></li><li><span class="name"><span class="innerContentContainer">传参时也直接传，myFunc(myParam) ，不需要加什么符号，所以相对简单。</span></span></li><li><span class="name"><span class="innerContentContainer">传引用的参数，在退出函数后还可以保持，这个和指针类似。但是和指针不同的是，引用不能做指针运算。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">整数&amp;布尔量&amp;枚举量</span></span><ul><li><span class="name"><span class="innerContentContainer">整数常量</span></span><ul><li><span class="name"><span class="innerContentContainer">二进制数： 0b101, 0B01。注意，只有部分编译器支持这种写法。</span></span></li><li><span class="name"><span class="innerContentContainer">八进制数： 0712（以数字零开始）</span></span></li><li><span class="name"><span class="innerContentContainer">十进制数：无前缀</span></span></li><li><span class="name"><span class="innerContentContainer">十六进制：0x123abc， 0X789def</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">整数</span></span><ul><li><span class="name"><span class="innerContentContainer">char ii; &nbsp;// 8位，正负128</span></span></li><li><span class="name"><span class="innerContentContainer">short ii;   // 16位。 正负 </span></span></li><li><span class="name"><span class="innerContentContainer">int ii; &nbsp; // 32位。正负20亿</span></span></li><li><span class="name"><span class="innerContentContainer">long ii; &nbsp;// 32位。long跨平台性稍差，不建议使用。</span></span></li><li><span class="name"><span class="innerContentContainer">long long ii; &nbsp;// 64位</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">负数和有符号数</span></span><ul><li><span class="name"><span class="innerContentContainer">负数在有符号数中用补码表示。补码是绝对值按位取反+1。</span></span></li><li><span class="name"><span class="innerContentContainer">int和uint运算时，int会先转为uint。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>位运算</b> --C语言的特色，而且不想设想的那么简单</span></span><ul><li><span class="name"><span class="innerContentContainer">设置整数的bit 3，保证其他位不变</span></span><ul><li><span class="name"><span class="innerContentContainer">a |= (1&lt;&lt;3);</span></span></li><li><span class="name"><span class="innerContentContainer"># define SET_BIT(x,n)    (x | 1U&lt;&lt;(n-1))</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置整数的bit 3~bit 7，保持其他位不变</span></span><ul><li><span class="name"><span class="innerContentContainer">a |= (0x1f&lt;&lt;3);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">清除整数的bit 15，保证其他位不变</span></span><ul><li><span class="name"><span class="innerContentContainer">a &amp;= ~(1&lt;&lt;15);</span></span></li><li><span class="name"><span class="innerContentContainer"># define CLEAR_BIT(x,n) (x &amp; ~(1U&lt;&lt;(n-1)))</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">清除整数的bit 15~bit 23，保持其他位不变</span></span><ul><li><span class="name"><span class="innerContentContainer">a &amp;= ~(0x1ff&lt;&lt;15);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">取出整数的bit 3~bit 8</span></span><ul><li><span class="name"><span class="innerContentContainer">(a &amp; (0x3f&lt;&lt;3)) &gt;&gt;= 3</span></span></li><li><span class="name"><span class="innerContentContainer"># define GET_BIT(x,n,m)    (x &amp; ~(~0U&lt;&lt;(m-n+1))&lt;&lt;(n-1)) &gt;&gt;(n-1)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">给整数的bit 7～bit 17赋值 937，其余位不受影响</span></span><ul><li><span class="name"><span class="innerContentContainer">要赋值就需要把要赋值的那几位清零&amp;，然后把需要赋值的数左移到那几位上就可以了。</span></span></li><li><span class="name"><span class="innerContentContainer">a &amp;= (~(0x7ff&lt;&lt;7));</span></span></li><li><span class="name"><span class="innerContentContainer">a |= (937&lt;&lt;7);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">给整数的bit 7～bit 17中的值加17，其余位不受影响</span></span><ul><li><span class="name"><span class="innerContentContainer">要加值，就要把那几位的数字取出来，然后把那几位清零&amp;，之后右移，相加，左移，再置1。</span></span></li><li><span class="name"><span class="innerContentContainer">tmp = a &amp; (0x7ff&lt;&lt;7);</span></span></li><li><span class="name"><span class="innerContentContainer">a &amp;= (~(0x7ff&lt;&lt;7));</span></span></li><li><span class="name"><span class="innerContentContainer">tmp &gt;&gt;= 7;</span></span></li><li><span class="name"><span class="innerContentContainer">tmp += 17;</span></span></li><li><span class="name"><span class="innerContentContainer">tmp &lt;&lt;= 7;</span></span></li><li><span class="name"><span class="innerContentContainer">a |= tmp;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">intptr_t</span></span><ul><li><span class="name"><span class="innerContentContainer">C99 标准新增的数据类型.</span></span></li><li><span class="name"><span class="innerContentContainer">intptr_t是一个整数, 其长度总是所在平台的位数，方便用于存放地址。</span></span></li><li><span class="name"><span class="innerContentContainer">这个纯是为了跨平台.</span></span></li><li><span class="name"><span class="innerContentContainer">不过, Linux内核基本不用这个数据类型.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">布尔量</span></span><ul><li><span class="name"><span class="innerContentContainer">c用 char 表示布尔变量。0表示false，非0表示true。</span></span></li><li><span class="name"><span class="innerContentContainer">c++有bool类型，有true和false两个值。但在逻辑运算中，默认非零为true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">枚举量</span></span><ul><li><span class="name"><span class="innerContentContainer">enum enumType {</span></span><ul><li><span class="name"><span class="innerContentContainer">Monday = 0,</span></span></li><li><span class="name"><span class="innerContentContainer">TuesDay = 1,</span></span></li><li><span class="name"><span class="innerContentContainer">…</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">enumType WeekDay;</span></span></li><li><span class="name"><span class="innerContentContainer">enum数据类型被当做int型， 占4个字节。</span></span></li><li><span class="name"><span class="innerContentContainer">如果想限制为1个字节长度，可用如下方式，但仅在C++11之后可以用。</span></span><ul><li><span class="name"><span class="innerContentContainer">typedef enum weekday: unsigned char {</span></span></li><li><span class="name"><span class="innerContentContainer">SUN, MON, TUE, WED, THU, FRI, SAT</span></span></li><li><span class="name"><span class="innerContentContainer">} weekday_t;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">浮点数</span></span><ul><li><span class="name"><span class="innerContentContainer">浮点数在内存中按科学计数法来存储。其整数部分始终是一个个位数。</span></span></li><li><span class="name"><span class="innerContentContainer">float number; &nbsp;// 32位。小数部分占23位，相当于十进制的6-7位，所以其精度是支持6-7位小数。</span></span></li><li><span class="name"><span class="innerContentContainer">double complex; &nbsp;// 128位。小数部分占52位，精度为15-16位小数。</span></span></li><li><span class="name"><span class="innerContentContainer">整数强转为浮点数，需要显式强转。</span></span></li><li><span class="name"><span class="innerContentContainer">float常量以 F或f结尾。</span></span></li><li><span class="name"><span class="innerContentContainer">double常量以D或者d结尾。</span></span></li><li><span class="name"><span class="innerContentContainer">没有后缀默认是double常量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常量&amp;全局变量&amp;静态变量</span></span><ul><li><span class="name"><span class="innerContentContainer">常量：const int ii = 32;</span></span></li><li><span class="name"><span class="innerContentContainer">全局变量：在函数外部定义的变量, 可以被其它代码文件调用。</span></span><ul><li><span class="name"><span class="innerContentContainer">.data段 保存进程所有的已初始化的全局变量.</span></span></li><li><span class="name"><span class="innerContentContainer">.bss段 保存进程未初始化的全局变量.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静态全局变量：全局变量加 static. 只能被所在的文件访问, 其它文件不能访问.</span></span><ul><li><span class="name"><span class="innerContentContainer">存放位置和全局变量相同.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静态局部变量: 局部变量(即在函数内部定义) 加 static. </span></span><ul><li><span class="name"><span class="innerContentContainer">如果没有初始化, 会被自动赋值为0. </span></span></li><li><span class="name"><span class="innerContentContainer">静态局部变量会统一放在 .data 段. </span></span></li><li><span class="name"><span class="innerContentContainer">全局存在, 但是只能被所在的文件访问, 其它文件不能访问.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">运算符表（优先级由高到底）</span></span><ul><li><span class="name"><span class="innerContentContainer">() [] -&gt; . &nbsp; 括号（函数等），数组，两种结构成员访问. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">! ~ ++ -- + - * &amp; (类型) sizeof &nbsp;取反，按位取反，增量，减量，正负号，间接，取地址，类型转换，求大小. 由右向左</span></span><ul><li><span class="name"><span class="innerContentContainer">~： 按位取反</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">/ % &nbsp;乘，除，取模. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">+ - &nbsp;加，减. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;&lt; &gt;&gt; &nbsp;左移，右移. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">&lt; &lt;= &gt;= &gt; &nbsp;小于，小于等于，大于等于，大于. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">== != &nbsp;等于，不等于. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">&amp; &nbsp;按位与. 由左向右。两个位都是1才是1，否则都是0.</span></span></li><li><span class="name"><span class="innerContentContainer">^ &nbsp;按位异或. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">| &nbsp;按位或. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">&amp;&amp; &nbsp;逻辑与. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">|| &nbsp;逻辑或. 由左向右</span></span></li><li><span class="name"><span class="innerContentContainer">? : &nbsp;条件. 由右向左</span></span></li><li><span class="name"><span class="innerContentContainer">= += -= *= /= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &nbsp;各种赋值. 由右向左</span></span></li><li><span class="name"><span class="innerContentContainer">, &nbsp;逗号（顺序） &nbsp;由左向右</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据的拆箱和装箱</span></span></li><li><span class="name"><span class="innerContentContainer">指针&amp;引用</span></span><ul><li><span class="name"><span class="innerContentContainer">定义指针: int *myPtr = &amp;myInt;</span></span></li><li><span class="name"><span class="innerContentContainer">使用指针访问值: *myPtr; // 即myInt</span></span></li><li><span class="name"><span class="innerContentContainer">打印地址: printf("%p", myPtr);</span></span></li><li><span class="name"><span class="innerContentContainer">指针使用前, 务必要判空. if (myPtr != NULL), 或者 if(myPtr) </span></span></li><li><span class="name"><span class="innerContentContainer">指针的运算: ++、--、+、-</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，运算的单位取决于数据的类型，而不是一个字节。如果是数组，一次跳转的距离可能远远超出意料之外。</span></span></li><li><span class="name"><span class="innerContentContainer">我试过一次跳过4G，当然是bug了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>引用（c++）</b></span></span><ul><li><span class="name"><span class="innerContentContainer">int m;</span></span></li><li><span class="name"><span class="innerContentContainer">int &amp;n = m; &nbsp;// n相当于m的别名，对n的任何操作就是对m的操作。</span></span></li><li><span class="name"><span class="innerContentContainer">引用和指针的区别  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">引用必须在定义的同时被初始化，而且只能初始化为合法的存储单元. 指针没有这个限制.</span></span></li><li><span class="name"><span class="innerContentContainer">引用初始化后，就不能再更改引用关系。指针没有这个限制.</span></span></li><li><span class="name"><span class="innerContentContainer">指针可以跳转, 运算, 引用不可以.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">c++提供的指针强转的序列关键字</span></span><ul><li><span class="name"><span class="innerContentContainer">c++中对指针强转做了一些保护. </span></span></li><li><span class="name"><span class="innerContentContainer">const_cast 的功能是去掉类型的const或者volatile属性. 如:</span></span><ul><li><span class="name"><span class="innerContentContainer">const Sa ra;</span></span></li><li><span class="name"><span class="innerContentContainer">Sa &amp;rb =&nbsp;const_cast&lt;Sa &amp;&gt;(ra);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">static_cast: 静态类型转换. 用于基类和子类间的转换, 不支持非继承关系的类型之间的转换. 如:</span></span><ul><li><span class="name"><span class="innerContentContainer">int n = 8;</span></span></li><li><span class="name"><span class="innerContentContainer">double d = static_cast&lt;double&gt;(n);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dynamic_cast: 动态类型转换. 也是用于基类和子类间的转换, 而且会做转换类型检查, 不安全的会返回null. 所谓安全, 就是指只能从子类转化为基类.</span></span></li><li><span class="name"><span class="innerContentContainer">reinterpret_cast: 无条件强制, 仅重新解释类型, 不做任何二进制的转换. 和C的强制类似, 没有安全保障.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">android 智能指针(sp/wp)</span></span><ul><li><span class="name"><span class="innerContentContainer">android定义了两类智能指针, 强指针sp(strong pointer)/弱指针(weak pointer), 相关代码在:</span></span></li><li><span class="name"><span class="innerContentContainer">/system/core/include/utils/strongpointer.h</span></span></li><li><span class="name"><span class="innerContentContainer">/system/core/include/utils/RefBase.h</span></span></li><li><span class="name"><span class="innerContentContainer">/system/core/libutils/RefBase.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">sp与一般意义上的智能指针概念相同, 通过引用计数来记录有多少个使用者在使用一个对象, 如果所有使用者都放弃了对该对象的引用, 则对象自动销毁.</span></span></li><li><span class="name"><span class="innerContentContainer">wp也指向一个对象, 但wp仅记录对象地址, 不管理对象的生命周期, 所以不能通过该指针访问该对象.</span></span></li><li><span class="name"><span class="innerContentContainer">要用sp/wp来个对象, 那么它需要满足两个条件:</span></span><ul><li><span class="name"><span class="innerContentContainer">要是RefBase的子类;</span></span></li><li><span class="name"><span class="innerContentContainer">要定义虚拟的析构函数, 即 virtual ~myClass();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sp的使用</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化:sp&lt;myClass&gt;sp = new myClass();</span></span></li><li><span class="name"><span class="innerContentContainer">调用接口: sp-&gt;myFunction();</span></span></li><li><span class="name"><span class="innerContentContainer">获取原来的对象: sp.get();</span></span></li><li><span class="name"><span class="innerContentContainer">指针重新赋值: sp重载了operate=, 重新赋值会自动将原来的引用减一, 新的引用加一.</span></span></li><li><span class="name"><span class="innerContentContainer">手动清理: sp.clear();</span></span></li><li><span class="name"><span class="innerContentContainer">不用时, 将sp指针改为null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">wp的使用</span></span><ul><li><span class="name"><span class="innerContentContainer">wp不能直接使用, 用之前要先升级为sp, 即sp = wp.promote();</span></span></li><li><span class="name"><span class="innerContentContainer">promote()失败表示对象已经销毁. 所以需要检查得到的sp指针是否为空. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">C++智能指针: std::unique_ptr</span></span><ul><li><span class="name"><span class="innerContentContainer">c++标准库提供的智能指针解决方案. 用法是: </span></span><ul><li><span class="name"><span class="innerContentContainer">std::unique_ptr&lt;MyClass&gt; myPtr = new MyClass;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">对象判空</span></span><ul><li><span class="name"><span class="innerContentContainer">if (myObj &lt;&gt; NULL) {...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对象的元属性</span></span><ul><li><span class="name"><span class="innerContentContainer">sizeof()</span></span></li><li><span class="name"><span class="innerContentContainer">typeof()</span></span><ul><li><span class="name"><span class="innerContentContainer">typeof 支持的情况不太统一.&nbsp;它的作用是自动推导表达式的数据类型，以解决泛型编程中有些类型由模板参数决定而难以表示的问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">c++中新增 typeid 关键字, 更强大.</span></span><ul><li><span class="name"><span class="innerContentContainer"># include &lt;typeinfo&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">MyClass myObj;</span></span></li><li><span class="name"><span class="innerContentContainer">const type_info &amp;myInfo = typeid(myObj);</span></span></li><li><span class="name"><span class="innerContentContainer">cout &lt;&lt;myInfo.name() &lt;&lt; “|” &lt;&lt; myInfo.raw_name() &lt;&lt; “|” &lt;&lt; myInfo.hash_code() &lt;&lt; endl;</span></span></li><li><span class="name"><span class="innerContentContainer">输出: class MyClass | .?MyClass@@ | 1035034553</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">For&amp;While</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>for</b> (int ii = 1; ii &lt; limit; ii++) {...}   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><b>while</b> (myInt &lt;= 100) {…}  // 先循环一遍再判断 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><b>do</b> {…} <b>while</b> (myInt &lt;= 100)  // 先判断再循环  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">while(1) { }   // 死循环</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">If&amp;Switch</span></span><ul><li><span class="name"><span class="innerContentContainer">if (myInt &gt; 0) {...}</span></span></li><li><span class="name"><span class="innerContentContainer">switch(myInt) {</span></span><ul><li><span class="name"><span class="innerContentContainer">case 1:</span></span><ul><li><span class="name"><span class="innerContentContainer">…</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">case 2:</span></span><ul><li><span class="name"><span class="innerContentContainer">…</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">default:</span></span><ul><li><span class="name"><span class="innerContentContainer">…</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">转义符</span></span><ul><li><span class="name"><span class="innerContentContainer">\n: 换行</span></span></li><li><span class="name"><span class="innerContentContainer">\r: 回车</span></span></li><li><span class="name"><span class="innerContentContainer">\t: Tab符</span></span></li><li><span class="name"><span class="innerContentContainer">\f: 清屏并换页</span></span></li><li><span class="name"><span class="innerContentContainer">\\: \本身</span></span></li><li><span class="name"><span class="innerContentContainer">%%: %本身</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串定义  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">c语言的字符串是一个以’\0’结尾的字符数组. 有两种方式定义:</span></span></li><li><span class="name"><span class="innerContentContainer"># include &lt;string.h&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">char myString[] = “Hello world!”;</span></span></li><li><span class="name"><span class="innerContentContainer">char *myString =&nbsp;“Hello world!”; &nbsp; &nbsp;// 此时myString指向常量区. 做指针运算的时候要格外小心.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">unicode字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">andorid 中, string8.h 是系统提供的utf8字符串类. 还有&nbsp;string16.h 类.</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/native/include/utils/String8.h.   其用法是:</span></span></li><li><span class="name"><span class="innerContentContainer">String8 myStr1(“Hello android");</span></span></li><li><span class="name"><span class="innerContentContainer">String8 myStr2(“ is good! ^_^");</span></span></li><li><span class="name"><span class="innerContentContainer">String8 add8 = str1 + str2; &nbsp; // 用比较自然的方法连接字符串</span></span></li><li><span class="name"><span class="innerContentContainer">cout&lt;&lt;"name:"&lt;&lt;add8.string()&lt;&lt;endl; &nbsp;// 通过string()得到它的字符串.</span></span></li><li><span class="name"><span class="innerContentContainer">add8.setTo(“Hello world”); &nbsp;// 字符串重新定义</span></span></li><li><span class="name"><span class="innerContentContainer">add8.append(" is good!”); &nbsp; // 另外一种连接字符串的方式</span></span></li><li><span class="name"><span class="innerContentContainer">cout&lt;&lt;String8::format("hello %c","world").string()&lt;&lt;endl; &nbsp;// 还可以这样.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串取长</span></span><ul><li><span class="name"><span class="innerContentContainer">uint strlen(const char *);   长度不包括结束符”\0”.</span></span></li><li><span class="name"><span class="innerContentContainer">sizeof 和 strlen 的区别 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">sizeof 是一个操作符，strlen 是库函数。</span></span></li><li><span class="name"><span class="innerContentContainer">sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串去空格</span></span><ul><li><span class="name"><span class="innerContentContainer">int stringTrim(char * p, char * buf){</span></span><ul><li><span class="name"><span class="innerContentContainer">int ret = 0, ncount = 0, begin = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">int end =&nbsp;strlen(p) - 1;</span></span></li><li><span class="name"><span class="innerContentContainer">if (p == NULL || buf == NULL) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return -1; &nbsp; &nbsp;// fail</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">while (isspace(p[begin]) &amp;&amp; p[begin] != '\0'){</span></span><ul><li><span class="name"><span class="innerContentContainer">begin++;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">while (isspace(p[end]) &amp;&amp; end&gt;0){</span></span><ul><li><span class="name"><span class="innerContentContainer">end--;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">ncount = end&nbsp;- begin&nbsp;+ 1;</span></span></li><li><span class="name"><span class="innerContentContainer">strncpy_s(buf, ncount + 1, p + i, ncount);</span></span></li><li><span class="name"><span class="innerContentContainer">buf[ncount] = '\0';</span></span></li><li><span class="name"><span class="innerContentContainer">return ret;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串拼接</span></span><ul><li><span class="name"><span class="innerContentContainer">char *strcat(char *dest, const char *src); &nbsp; // 返回指向 dest 的指针.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串截取</span></span><ul><li><span class="name"><span class="innerContentContainer">char *strncpy(char *dest, char *src, int n); &nbsp; // 返回指向 dest 的指针. &nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">注意第三个参数 n 不包括结束符, 所以dest的size一定要不小于n+1.</span></span></li><li><span class="name"><span class="innerContentContainer">如果要实现截取从m开始到n的,可以这样做:</span></span></li><li><span class="name"><span class="innerContentContainer">strncpy(dest ,str + n , m-n);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串比较</span></span><ul><li><span class="name"><span class="innerContentContainer">int strcmp(const char *s1, const char *s2);</span></span></li><li><span class="name"><span class="innerContentContainer">返回值为0表示相等, 大于零表示 str1 比较大, 反之 str2 比较大.</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种, strncmp(str1, str2, int n);   // 只比较前n个字符.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串查找</span></span><ul><li><span class="name"><span class="innerContentContainer">在字符串str1中定位字符串str2首次出现的位置</span></span><ul><li><span class="name"><span class="innerContentContainer">const char * <b>strstr</b> ( const char * str1, cosnt char *str2);   // 没有找到返回 NULL.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回在字符串str1里找到字符串str2里的任意一个字符之前已查找的字符数量</span></span><ul><li><span class="name"><span class="innerContentContainer">size_t strcspn ( const char * str1, const char * str2);   // 不是太好理解,  例如:</span></span></li><li><span class="name"><span class="innerContentContainer">char *str = "Linux was first developed for 386/486-based pcs. “;</span></span></li><li><span class="name"><span class="innerContentContainer">printf("%d\n", strcspn(str, "1234567890"));</span></span></li><li><span class="name"><span class="innerContentContainer">返回值是:计算到出现数字字符为止, 所以返回"3"出现前的长度(有点像正则表达式)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在字符串str1里定位字符串str2里任意一个首次出现的字符: const char * strpbrk (const char * str1, const char * str2);</span></span></li><li><span class="name"><span class="innerContentContainer">返回字符串str1从开始字符到第一个不在str2中的字符个数: size_t strspn ( const char * str1, const char * str2);</span></span></li><li><span class="name"><span class="innerContentContainer">在指定内存里查找给定字符: void * memchr ( const void * str, int character, size_t num); // character为要找的字</span></span></li><li><span class="name"><span class="innerContentContainer">在指定字符串里定位给定字符: char * strchr ( const char * str, int character);</span></span></li><li><span class="name"><span class="innerContentContainer">在字符串里定位给定字符最后一次出现的位置: const char * strrchr ( const char * str, int character);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串替换</span></span><ul><li><span class="name"><span class="innerContentContainer">char *replacestr(char *strbuf, char *sstr, char *dstr){</span></span><ul><li><span class="name"><span class="innerContentContainer">char *p,*p1;</span></span></li><li><span class="name"><span class="innerContentContainer">int len;</span></span></li><li><span class="name"><span class="innerContentContainer">if ((strbuf == NULL)||(sstr == NULL)||(dstr == NULL)) return NULL;</span></span></li><li><span class="name"><span class="innerContentContainer">p = strstr(strbuf, sstr);</span></span></li><li><span class="name"><span class="innerContentContainer">if (p == NULL) return NULL;&nbsp;&nbsp;// 不包含子串则直接退出</span></span></li><li><span class="name"><span class="innerContentContainer">len = strlen(strbuf) + strlen(dstr) - strlen(sstr);</span></span></li><li><span class="name"><span class="innerContentContainer">p1 = malloc(len);</span></span></li><li><span class="name"><span class="innerContentContainer">bzero(p1, len);</span></span></li><li><span class="name"><span class="innerContentContainer">strncpy(p1, strbuf, p - strbuf);</span></span></li><li><span class="name"><span class="innerContentContainer">strcat(p1, dstr);</span></span></li><li><span class="name"><span class="innerContentContainer">p += strlen(sstr);</span></span></li><li><span class="name"><span class="innerContentContainer">strcat(p1, p);</span></span></li><li><span class="name"><span class="innerContentContainer">return p1;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串切分</span></span><ul><li><span class="name"><span class="innerContentContainer">char *strtok(char *str, const char *delim); str为要切分的字符串，delim为分隔符字符串。</span></span></li><li><span class="name"><span class="innerContentContainer">返回值：从str开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。</span></span></li><li><span class="name"><span class="innerContentContainer">另外:&nbsp;strtok函数线程不安全，可以使用strtok_r替代。</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">char s[] = "Golden Global&nbsp;View,disk * desk";</span></span></li><li><span class="name"><span class="innerContentContainer">const char *d = " ,*";</span></span></li><li><span class="name"><span class="innerContentContainer">char *p;</span></span></li><li><span class="name"><span class="innerContentContainer">p = strtok(s,d);</span></span></li><li><span class="name"><span class="innerContentContainer">while(p)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">printf("%s\n",p);</span></span></li><li><span class="name"><span class="innerContentContainer">p=strtok(NULL,d);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串的格式化输出  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">格式化输出:  int <b>snprintf</b>(char *str, size_t n, char * format [, argument, ...]); &nbsp;//&nbsp;将格式化的数据写入字符串.</span></span></li><li><span class="name"><span class="innerContentContainer">其中: str 为要写入的字符串；</span></span></li><li><span class="name"><span class="innerContentContainer">n 是要写入的字节数。 <b>注意，</b>由于字符串尾部要放一个 0x0，所以实际上只会拷贝 n-1 个字节。</span></span></li><li><span class="name"><span class="innerContentContainer">format 为格式化字符串，与printf()函数相同；</span></span><ul><li><span class="name"><span class="innerContentContainer">%d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十进制有符号整数</span></span></li><li><span class="name"><span class="innerContentContainer">%3d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;输出3位整型数, 不够3位右对齐.</span></span></li><li><span class="name"><span class="innerContentContainer">%04d&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位。</span></span></li><li><span class="name"><span class="innerContentContainer">%ld&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  &nbsp;输出长整型, 即long整数.</span></span></li><li><span class="name"><span class="innerContentContainer">%lld&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  &nbsp;输出long long整数.</span></span></li><li><span class="name"><span class="innerContentContainer">%-7d &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 输出7位整数,左对齐.</span></span></li><li><span class="name"><span class="innerContentContainer">%u &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十进制无符号整数</span></span></li><li><span class="name"><span class="innerContentContainer">%xhh, %XHH &nbsp; &nbsp; &nbsp;无符号以十六进制表示的整数.</span></span></li><li><span class="name"><span class="innerContentContainer">%0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  无符号以八进制表示的整数</span></span></li><li><span class="name"><span class="innerContentContainer">%f &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 浮点数</span></span></li><li><span class="name"><span class="innerContentContainer">%9.2f&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;输出场宽为9的浮点数, 其中小数位为2, 整数位为6, 小数点占一位, 不够9位右对齐。</span></span></li><li><span class="name"><span class="innerContentContainer">%lf &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 输出double浮点数</span></span></li><li><span class="name"><span class="innerContentContainer">%e &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指数形式的浮点数</span></span></li><li><span class="name"><span class="innerContentContainer">%s &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串</span></span></li><li><span class="name"><span class="innerContentContainer">%8s&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 输出8个字符的字符串, 不够8个字符右对齐。</span></span></li><li><span class="name"><span class="innerContentContainer">%6.9s &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出一个长度不小于6且不大于9的字符串。若大于9, 则多余内容将被删除。</span></span></li><li><span class="name"><span class="innerContentContainer">%-10s &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出10个字符, 左对齐.</span></span></li><li><span class="name"><span class="innerContentContainer">%c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单个字符</span></span></li><li><span class="name"><span class="innerContentContainer">%p &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针的值</span></span></li><li><span class="name"><span class="innerContentContainer">%g &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动选择合适的表示法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">argument 为变量。</span></span></li><li><span class="name"><span class="innerContentContainer">类似函数还有:&nbsp;printf(), sprintf().&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">返回值：成功返回写字符的总数，其中不包括结尾的null字符；失败返回一个负数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">格式化输入</span></span><ul><li><span class="name"><span class="innerContentContainer">int sscanf( string str, string format, mixed var1, mixed var2 ... ); &nbsp; // 从字符串输入格式化字符串. 例如:</span></span><ul><li><span class="name"><span class="innerContentContainer">int a, b, c;</span></span></li><li><span class="name"><span class="innerContentContainer">sscanf("2006:03:18", "%d:%d:%d", a, b, c);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">int scanf( const char *format [,argument]... ); &nbsp;  // 从屏幕输入格式化字符串.</span></span></li><li><span class="name"><span class="innerContentContainer">上面这两个函数的关键是参数format具有和正则表达式类似的功能. 其语法结构是:</span></span></li><li><span class="name"><span class="innerContentContainer">{%[*] [width] [{h | l | I64 | L}]type | ' ' | '\t' | '\n' | 非%符号}</span></span></li><li><span class="name"><span class="innerContentContainer">亦可用于格式中, (即 %*d 和 %*s) 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)</span></span></li><li><span class="name"><span class="innerContentContainer">{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。</span></span></li><li><span class="name"><span class="innerContentContainer">width表示读取宽度。</span></span></li><li><span class="name"><span class="innerContentContainer">{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。</span></span></li><li><span class="name"><span class="innerContentContainer">type :这就很多了，就是%s,%d之类。</span></span></li><li><span class="name"><span class="innerContentContainer">特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值</span></span></li><li><span class="name"><span class="innerContentContainer">支持集合操作：</span></span></li><li><span class="name"><span class="innerContentContainer">%[a-z] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)</span></span></li><li><span class="name"><span class="innerContentContainer">%[aB'] 匹配a、B、'中一员，贪婪性</span></span></li><li><span class="name"><span class="innerContentContainer">%[^a] 匹配非a的任意字符，贪婪性</span></span></li><li><span class="name"><span class="innerContentContainer">例1:</span></span></li><li><span class="name"><span class="innerContentContainer">取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span></span></li><li><span class="name"><span class="innerContentContainer">sscanf("123456abcdedfBCDEF", "%[^A-Z]", buf);</span></span></li><li><span class="name"><span class="innerContentContainer">printf("%s\n", buf);</span></span></li><li><span class="name"><span class="innerContentContainer">结果为：123456abcdedf</span></span></li><li><span class="name"><span class="innerContentContainer">例2:</span></span></li><li><span class="name"><span class="innerContentContainer">给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 "iios/"过滤掉，再将非'@'的一串内容送到buf中</span></span></li><li><span class="name"><span class="innerContentContainer">sscanf("iios/12DDWDFF@122", "%*[^/]/%[^@]", buf);</span></span></li><li><span class="name"><span class="innerContentContainer">printf("%s\n", buf);</span></span></li><li><span class="name"><span class="innerContentContainer">结果为：12DDWDFF</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">对时间的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">在c/c++中, 最小的计时单位是1毫秒.</span></span></li><li><span class="name"><span class="innerContentContainer"># include &lt;sys/time.h&gt;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">获取系统时间</span></span><ul><li><span class="name"><span class="innerContentContainer">long long getCurrentTime() {  // 返回微秒数(百万分之秒)</span></span><ul><li><span class="name"><span class="innerContentContainer">struct timeval tv;</span></span></li><li><span class="name"><span class="innerContentContainer">gettimeofday(&amp;tv, NULL); &nbsp; //&nbsp;gettimeofday()返回1970年1月1日到现在的时间.</span></span></li><li><span class="name"><span class="innerContentContainer">return tv.tv_sec * 1000,000 + tv.tv_usec;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">日历时间的两种格式</span></span><ul><li><span class="name"><span class="innerContentContainer">通过tm结构来获得日期和时间，tm结构在time.h中的定义如下：</span></span></li><li><span class="name"><span class="innerContentContainer">struct tm {</span></span><ul><li><span class="name"><span class="innerContentContainer">int tm_sec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 秒 – 取值区间为[0,59] */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_min;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 分 - 取值区间为[0,59] */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_hour;&nbsp;&nbsp;&nbsp;&nbsp;/* 时 - 取值区间为[0,23] */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_mday;&nbsp;&nbsp;&nbsp;&nbsp;/* 一个月中的日期 - 取值区间为[1,31] */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_mon;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_year;&nbsp;&nbsp;&nbsp;&nbsp;/* 年份，其值等于实际年份减去1900 */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_wday;&nbsp;&nbsp;&nbsp;&nbsp;/* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_yday;&nbsp;&nbsp;&nbsp;&nbsp;/* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */</span></span></li><li><span class="name"><span class="innerContentContainer">int tm_isdst;&nbsp;&nbsp;&nbsp;/* 夏令时标识符，实行夏令时的时候，tm_isdst为正不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负*/</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">这种时间表示叫分解时间(broken-down time).</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种日历时间（Calendar Time）, 是通过time_t数据类型来表示的，用time_t表示的时间是从一个时间点（1970年1月1日0时0分0秒）到此时的秒数.</span></span></li><li><span class="name"><span class="innerContentContainer">typedef long time_t;  // 对time_t数据类型的值来说，它所表示的时间不能晚于2038年1月18日19时14分07秒.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时间格式间的转化</span></span><ul><li><span class="name"><span class="innerContentContainer">time_t mktime(struct tm * timeptr); &nbsp; // 将tm时间转化为time_t时间</span></span></li><li><span class="name"><span class="innerContentContainer">time_t time(time_t * timer); &nbsp; // 获取从指定的timer时间到现在的秒数</span></span></li><li><span class="name"><span class="innerContentContainer">char * asctime(const struct tm * timeptr); &nbsp;// 将tm时间转为字符串.</span></span></li><li><span class="name"><span class="innerContentContainer">char * ctime(const time_t *timer); &nbsp; &nbsp;// 将time_t时间转为字符串, 并遵循系统时间格式.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取两个时间间的间隔:  double difftime(time_t time1, time_t time0); &nbsp; // 单位为秒.</span></span></li><li><span class="name"><span class="innerContentContainer">时区处理</span></span><ul><li><span class="name"><span class="innerContentContainer">struct tm * localtime(const time_t * timer); &nbsp; // 将time_t时间转化为当前系统时区下的tm时间</span></span></li><li><span class="name"><span class="innerContentContainer">struct tm * gmtime(const time_t *timer); &nbsp; // 将time_t时间转化为世界标准时间下的tm时间</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自定义时间格式</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 strftime（）函数将时间格式化为我们想要的格式. 它的原型如下：</span></span></li><li><span class="name"><span class="innerContentContainer">size_t strftime(char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);</span></span></li><li><span class="name"><span class="innerContentContainer">其中 format 支持的格式有好几十种. 此处不再累述.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">数组</span></span><ul><li><span class="name"><span class="innerContentContainer">数组的定义和遍历</span></span></li><li><span class="name"><span class="innerContentContainer">数组的size</span></span></li><li><span class="name"><span class="innerContentContainer">数组元素的访问</span></span></li><li><span class="name"><span class="innerContentContainer">数组元素的新增、删除</span></span></li><li><span class="name"><span class="innerContentContainer">排序</span></span></li><li><span class="name"><span class="innerContentContainer">不可变数组 Tuple</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">内存模型</span></span><ul><li><span class="name"><span class="innerContentContainer">内存空间的逻辑结构</span></span><ul><li><span class="name"><span class="innerContentContainer">由低到高分别是:</span></span></li><li><span class="name"><span class="innerContentContainer">代码段(.text)</span></span><ul><li><span class="name"><span class="innerContentContainer">编译的时候由编译器分配的。</span></span></li><li><span class="name"><span class="innerContentContainer">存放程序代码.</span></span></li><li><span class="name"><span class="innerContentContainer">一般为只读. 某些架构也允许代码段为可写，即允许运行时修改程序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据段(.data)</span></span><ul><li><span class="name"><span class="innerContentContainer">编译的时候由编译器分配的。</span></span></li><li><span class="name"><span class="innerContentContainer">存放初始化的全局变量和静态变量. </span></span></li><li><span class="name"><span class="innerContentContainer">分为只读数据段和读写数据段。&nbsp;字符串常量一般放在只读数据段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BSS段(.bss)</span></span><ul><li><span class="name"><span class="innerContentContainer">存放程序中未初始化的全局变量和静态变量, 即默认初始化为0的变量.</span></span></li><li><span class="name"><span class="innerContentContainer">编译的时候由编译器分配的。</span></span></li><li><span class="name"><span class="innerContentContainer">BSS段在应用程序的二进制映象文件中并不存在, 而是在程序加载时展开到内存的. 因此不占用磁盘空间.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">堆</span></span><ul><li><span class="name"><span class="innerContentContainer">程序运行的时候由系统分配的。</span></span></li><li><span class="name"><span class="innerContentContainer">使用 malloc/free 动态管理的内存段.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">栈</span></span><ul><li><span class="name"><span class="innerContentContainer">也叫堆栈. 程序运行的时候由系统分配的。</span></span></li><li><span class="name"><span class="innerContentContainer">存放程序创建的局部变量, 进入函数时分配, 退出函数时自动释放.</span></span></li><li><span class="name"><span class="innerContentContainer">在linux上用户态进程的默认堆栈大小是8M，可以用ulimit查看和修改。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">字节序</span></span><ul><li><span class="name"><span class="innerContentContainer">x86芯片字节序为低字节在低地址, 高字节在高地址. 即小头.</span></span></li><li><span class="name"><span class="innerContentContainer">arm芯片字节序为高字节在低地址, 低字节在高地址. 即大头.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读写寄存器</span></span><ul><li><span class="name"><span class="innerContentContainer">写一个Long: void WRITE_REGISTER_ULONG(PULONG Register, ULONG Value);</span></span></li><li><span class="name"><span class="innerContentContainer">其实现是: # define&nbsp;WRITE_REGISTER_ULONG(addr, val) (*(volatile UNIT32)*)(addr)=(val))</span></span></li><li><span class="name"><span class="innerContentContainer">addr是统一编址的内存地址, 寄存器资源在内存地址的具体映射由硬件定义.</span></span></li><li><span class="name"><span class="innerContentContainer">volatile为关键字, 表示本code不可因为寄存器的优化而忽略, 且要求每次都字节读取. 与硬件和中断打交道的代码, 千万不要忘记&nbsp;volatile.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">android区分32位/64位的宏: # ifdefined(__LP64__)&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存申请</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>void *malloc(int num);    // </b>在堆区分配一块指定大小的内存空间. 不默认初始化.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>void *calloc(int num, int size);    // </b>在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>void *realloc(void *address, int newsize);   // </b>重新分配内存，把内存大小扩展到&nbsp;<b>newsize</b>。</span></span></li><li><span class="name"><span class="innerContentContainer">返回值 void * 表示未确定类型的指针。它可以通过类型转换强制转换为任何其它类型的指针。</span></span></li><li><span class="name"><span class="innerContentContainer">使用分配而来的内存块前, 务必判空.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存释放</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>void free(void *address);     // </b>释放 address 所指向的动态分配的内存块.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">以下函数需要包含头文件 string.h.</span></span></li><li><span class="name"><span class="innerContentContainer">内存拷贝</span></span><ul><li><span class="name"><span class="innerContentContainer">void *memcpy(void *dest, const void *src, size_t n);</span></span></li><li><span class="name"><span class="innerContentContainer">void* memmove(void* dst,const void* src,size_t n);   // 与memcpy()在于, 当src和dest所指的内存区域重叠时，memmove仍然可以正确的处理，不过执行效率上会比memcpy略慢。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存清零</span></span><ul><li><span class="name"><span class="innerContentContainer">memset(buffer,&nbsp;0,&nbsp;sizeof(buffer));</span></span></li><li><span class="name"><span class="innerContentContainer">memset(buffer,&nbsp;0x,&nbsp;sizeof(buffer));  // 一个字节一个字节的赋值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存比较</span></span><ul><li><span class="name"><span class="innerContentContainer">int memcmp(const void* buf1,const void* buf2,unsigned int count);</span></span></li><li><span class="name"><span class="innerContentContainer">返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">当buf1 == buf2时，返回值=0</span></span></li><li><span class="name"><span class="innerContentContainer">当buf1&gt;buf2时，返回值&gt;0</span></span></li><li><span class="name"><span class="innerContentContainer">当buf1&lt;buf2时，返回值&lt;0</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存查找</span></span><ul><li><span class="name"><span class="innerContentContainer">void* <b>memchr</b>(const void* buf,int ch,size_t count);</span></span></li><li><span class="name"><span class="innerContentContainer">从buf所指内存区的前count个字节查找字符ch，当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回null.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">文件系统</span></span><ul><li><span class="name"><span class="innerContentContainer">获取系统目录/当前目录/跳转</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹和文件的的存在性</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹的新建/删除</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹的遍历</span></span></li><li><span class="name"><span class="innerContentContainer">文件的新建/删除</span></span></li><li><span class="name"><span class="innerContentContainer">文件的读/写</span></span></li><li><span class="name"><span class="innerContentContainer">获取文件长度</span></span></li><li><span class="name"><span class="innerContentContainer">文件的改名/修改属性</span></span></li><li><span class="name"><span class="innerContentContainer">行读</span></span></li><li><span class="name"><span class="innerContentContainer">行写</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类的进一步讨论</span></span><ul><li><span class="name"><span class="innerContentContainer">虚函数和纯虚函数(C++) <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">凡在子类中要重写的函数, 其类定义要加 virtual 关键字. </span></span></li><li><span class="name"><span class="innerContentContainer">子类也可以不实现虚函数, 此时用父类的实现.</span></span></li><li><span class="name"><span class="innerContentContainer">没有加&nbsp;virtual 的函数, 子类不可覆盖.</span></span></li><li><span class="name"><span class="innerContentContainer">对于要求每个子类都实现的函数, 父类定义时应定义为<b>纯虚函数</b>. 定义形式是: virtual myFunc() = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">如果 new 一个父类, 则纯虚函数就不存在. 所以永远不要 new 一个父类.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">父类如何调用子类的函数?</span></span><ul><li><span class="name"><span class="innerContentContainer">不推荐这样做. 实在不行可通过new一个子类来访问.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">子类不能调用父类的私有函数, 但可调用 protected 函数.  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">友元函数和友元类</span></span><ul><li><span class="name"><span class="innerContentContainer">通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</span></span></li><li><span class="name"><span class="innerContentContainer">友元函数:友元函数是可以直接访问类的私有成员和受保护成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明. 声明格式是:</span></span><ul><li><span class="name"><span class="innerContentContainer">friend 类型 函数名(形式参数);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">友元函数的声明可以放在类的任何位置, 没有区别. 数量也没有限制.</span></span></li><li><span class="name"><span class="innerContentContainer">友元类 ：友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类的私有成员和受保护成员。</span></span></li><li><span class="name"><span class="innerContentContainer">申明友元类的语句格式如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">friend class 类名;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意:&nbsp;友元关系不能被继承。父类的友元, 不是子类的友元.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟继承</span></span><ul><li><span class="name"><span class="innerContentContainer">即 SubClass : virtue public MainClass</span></span></li><li><span class="name"><span class="innerContentContainer">c++ 支持多重继承，因此可能存在难以发现的循环继承问题，使用虚拟继承可解决这个问题。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">集合(set)</span></span><ul><li><span class="name"><span class="innerContentContainer">集合的特点是每个元素最多出现一次，即不允许重复元素。</span></span></li><li><span class="name"><span class="innerContentContainer">定义</span></span></li><li><span class="name"><span class="innerContentContainer">size</span></span></li><li><span class="name"><span class="innerContentContainer">遍历</span></span></li><li><span class="name"><span class="innerContentContainer">判空</span></span></li><li><span class="name"><span class="innerContentContainer">增删改</span></span></li><li><span class="name"><span class="innerContentContainer">排序</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字典 (hash)</span></span><ul><li><span class="name"><span class="innerContentContainer">散列算法</span></span><ul><li><span class="name"><span class="innerContentContainer">Hash Algorithm，又称哈希算法，杂凑算法，是一种从任意长度的数据中创造小的数字「指纹」的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">特点有：</span></span><ul><li><span class="name"><span class="innerContentContainer">唯一性。</span></span></li><li><span class="name"><span class="innerContentContainer">标志与文件的每一个字节都相关，而且难以找到逆向规律。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">冲突：即两个数据产生的hash指重复.</span></span></li><li><span class="name"><span class="innerContentContainer">流行的 Hash 算法包括 SHA-1 和 SHA-2。</span></span><ul><li><span class="name"><span class="innerContentContainer">MD5 已不建议使用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">定义</span></span><ul><li><span class="name"><span class="innerContentContainer">android中, KeyedVector.h：定义使用关键字的向量模板KeyedVector. 用字符串key来随机访问数据.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">size</span></span></li><li><span class="name"><span class="innerContentContainer">遍历</span></span></li><li><span class="name"><span class="innerContentContainer">元素的新增/修改/删除</span></span></li><li><span class="name"><span class="innerContentContainer">排序</span></span></li><li><span class="name"><span class="innerContentContainer">unordered_map</span></span><ul><li><span class="name"><span class="innerContentContainer">这种map不会根据key排序，存储时按key的hash值判断元素是否重复。</span></span></li><li><span class="name"><span class="innerContentContainer">item-&gt;first, key</span></span></li><li><span class="name"><span class="innerContentContainer">item-&gt;second, value</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">链表</span></span></li><li><span class="name"><span class="innerContentContainer">异常处理</span></span><ul><li><span class="name"><span class="innerContentContainer">为什么使用空指针会造成data abort？地址0难道不是一个合法的地址吗？</span></span><ul><li><span class="name"><span class="innerContentContainer">为了捕捉空指针错误，编译器故意将地址空间的最低部分设为不可使用的，因此任何时候使用地址0（以及极小的地址，比如地址13），都会产生错误。这个故意留的“空洞”一般为几K。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">UT&amp;Debug</span></span><ul><li><span class="name"><span class="innerContentContainer">assert</span></span><ul><li><span class="name"><span class="innerContentContainer">原型定义在 assert.h。</span></span></li><li><span class="name"><span class="innerContentContainer">void assert( int expression );</span></span></li><li><span class="name"><span class="innerContentContainer">如果 expression 为0， 则先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。</span></span></li><li><span class="name"><span class="innerContentContainer">版本发布时，可通过在 # include &lt;assert.h&gt; 之前插入 # define NDEBUG 来禁用assert调用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">C/C++中的段错误（Segmentation fault） https://www.cnblogs.com/hello--the-world/archive/2012/05/31/2528326.html</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">平台兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">泛型 (C++)</span></span><ul><li><span class="name"><span class="innerContentContainer">C++模板分为函数模板和类模板.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">函数模板:  template &lt;class 形参1, class 形参2, …&gt; 返回值类型 函数名(参数列表) {…};  例如:</span></span><ul><li><span class="name"><span class="innerContentContainer">template &lt;class T&gt; void swap(T&amp; a, T&amp;b){</span></span><ul><li><span class="name"><span class="innerContentContainer">T c;</span></span></li><li><span class="name"><span class="innerContentContainer">c = a;</span></span></li><li><span class="name"><span class="innerContentContainer">a = b;</span></span></li><li><span class="name"><span class="innerContentContainer">b = c;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用时:</span></span><ul><li><span class="name"><span class="innerContentContainer">int a = 0, b = 1;</span></span></li><li><span class="name"><span class="innerContentContainer">swap(a, b);</span></span></li><li><span class="name"><span class="innerContentContainer">float c = 0.1, d = 0.2;</span></span></li><li><span class="name"><span class="innerContentContainer">swap(c, d);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类模板: template &lt;class 形参1, class 形参2, …&gt; class 类名 {…}; 例如:</span></span></li><li><span class="name"><span class="innerContentContainer">template &lt;class T&gt; class A {</span></span><ul><li><span class="name"><span class="innerContentContainer">public:</span></span></li><li><span class="name"><span class="innerContentContainer">A();</span></span></li><li><span class="name"><span class="innerContentContainer">T add(T a, T b);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">template &lt;class T&gt; class A::add(T a, T b) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return a+b;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">使用时:</span></span></li><li><span class="name"><span class="innerContentContainer">A&lt;int&gt; a;</span></span></li><li><span class="name"><span class="innerContentContainer">count &lt;&lt; a.add(2, 3)&lt;&lt;endl;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多线程</span></span><ul><li><span class="name"><span class="innerContentContainer">启动子线程</span></span><ul><li><span class="name"><span class="innerContentContainer"># include &lt;thread&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">std::thread Reader(ReaderBlockedThread, mSynchronized, &amp;mFw);</span></span></li><li><span class="name"><span class="innerContentContainer">其中: Reader 为进程名</span></span></li><li><span class="name"><span class="innerContentContainer">ReaderBlockedThread 为全局函数</span></span></li><li><span class="name"><span class="innerContentContainer">mFw 为函数参数表</span></span></li><li><span class="name"><span class="innerContentContainer">Reader.<b>join</b>();  &nbsp;// join() 会阻塞当前线程, 直到新线程执行完毕后join()才会返回.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">互斥锁</span></span><ul><li><span class="name"><span class="innerContentContainer">互斥类: Mutex; 例如:</span></span></li><li><span class="name"><span class="innerContentContainer">Mutex mLock;</span></span></li><li><span class="name"><span class="innerContentContainer">使用时:</span></span></li><li><span class="name"><span class="innerContentContainer">mLock.lock();</span></span></li><li><span class="name"><span class="innerContentContainer">mLock.unlock();</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种利用对象的自动析构机制而实现的锁自动释放的形式:</span></span></li><li><span class="name"><span class="innerContentContainer">{ &nbsp; // 大括号不能少</span></span><ul><li><span class="name"><span class="innerContentContainer">AutoMutex _L(mLock);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} &nbsp; // 出大括号时锁自动失败.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">线程锁</span></span><ul><li><span class="name"><span class="innerContentContainer">pthread_mutex_lock();</span></span></li><li><span class="name"><span class="innerContentContainer">pthread_mutex_unlock();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">其它有意思的话题</span></span><ul><li><span class="name"><span class="innerContentContainer">这个宏定义为什么要写成do~while结构？</span></span><ul><li><span class="name"><span class="innerContentContainer"># define ErrChk(iserr)\</span></span></li><li><span class="name"><span class="innerContentContainer">do {\</span></span><ul><li><span class="name"><span class="innerContentContainer">if ((iserr) != 0) {\</span></span><ul><li><span class="name"><span class="innerContentContainer">ChkErrorFail(__FILE__,__LINE__, # iserr);\</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}\</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}while(0)</span></span></li><li><span class="name"><span class="innerContentContainer">A1：假如不用do-while(0)：</span></span></li><li><span class="name"><span class="innerContentContainer"># define SOME_MACRO \</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething1(); \</span></span></li><li><span class="name"><span class="innerContentContainer">dosomething2();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">if (i&gt;0)</span></span><ul><li><span class="name"><span class="innerContentContainer">SOME_MACRO</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">else</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething3();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">试试看，编译能不能通过？</span></span></li><li><span class="name"><span class="innerContentContainer">你可能认为可以这样：</span></span></li><li><span class="name"><span class="innerContentContainer">if (i&gt;0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">SOME_MACRO</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">else</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething3();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">没错，但如果宏是你定义的，但由别人使用，能保证别人一定会怎么用吗？</span></span></li><li><span class="name"><span class="innerContentContainer">Q2：可以这样啊</span></span></li><li><span class="name"><span class="innerContentContainer"># define SOME_MACRO {\</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething1(); \</span></span></li><li><span class="name"><span class="innerContentContainer">dosomething2();\</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">A2：你这种写法在例子中是没错。但是，假设某个旧版本中：</span></span></li><li><span class="name"><span class="innerContentContainer"># define SOME_MACROdosomething()</span></span></li><li><span class="name"><span class="innerContentContainer">已经有很多应用了，此时你为了增强其功能而升级：</span></span></li><li><span class="name"><span class="innerContentContainer"># define SOME_MACRO \</span></span></li><li><span class="name"><span class="innerContentContainer">do { \</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething1(); \</span></span></li><li><span class="name"><span class="innerContentContainer">dosomething2(); \</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} while(0)</span></span></li><li><span class="name"><span class="innerContentContainer">这样的兼容性就很好，但如果采用</span></span></li><li><span class="name"><span class="innerContentContainer"># define SOME_MACRO \</span></span></li><li><span class="name"><span class="innerContentContainer">{ \</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething1(); \</span></span></li><li><span class="name"><span class="innerContentContainer">dosomething2(); \</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">就不能保证其它的程序能正确编译，如</span></span></li><li><span class="name"><span class="innerContentContainer">if (i&gt;0)</span></span><ul><li><span class="name"><span class="innerContentContainer">SOME_MACRO; &nbsp;&nbsp;&nbsp;&nbsp;// 注意有分号</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">elses</span></span><ul><li><span class="name"><span class="innerContentContainer">dosomething3();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">说白了，以前的宏定义是单语句，这样的宏定义一般习惯都不会带上分号，当你把宏升级成多语句时，最后也不能带上分号，但{...}表面上没有分号，实际上数据块等同于已经有了分号，所以编译时可能出错。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">C++ 11</span></span><ul><li><span class="name"><span class="innerContentContainer">赋值语句，除了 int ii = 1; 还支持 ii = {1}; ii{1}; 这两种。</span></span></li><li><span class="name"><span class="innerContentContainer">空指针，nullptr 替代 NULL。</span></span></li><li><span class="name"><span class="innerContentContainer">lambda 表达式</span></span></li><li><span class="name"><span class="innerContentContainer">STL, 标准模板库</span></span><ul><li><span class="name"><span class="innerContentContainer">命名空间是 std::</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">menu class</span></span></li></ul></li></ul>
  </body>
</html>