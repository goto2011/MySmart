<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">04-Debug&amp;Log</span><ul><li><span class="name">常见LOG    ***</span><ul><li><span class="name">系统重启： beginning of main|beginning of system </span></li><li><span class="name">crash开始： beginning of crash</span></li><li><span class="name">系统进入桌面： system now ready</span></li><li><span class="name">一级crash： crash|fatal|backtrace|died|watchdog|goodbye|shutting down vm|Androidruntime| am_crash|am_kill|service crashed|java.lang.runtimeexception|exit zygote</span></li><li><span class="name">二级crash：Err|fail|unexpected|system.err|java.lang|Systrace</span></li><li><span class="name">卡死冻屏: held by|blocked|caused by|locked|waiting on|locked</span></li><li><span class="name">ANR： ANR in|Input event dispatching timed out</span></li><li><span class="name">input 子系统： Inputreader|inputdispatcher|eventhub|inputmanager_dispatch</span></li><li><span class="name">接收广播： received broadcast|onReceive， 太多，建议直接搜广播名</span></li><li><span class="name">Usb对话框： showMtpDialog : mode</span></li><li><span class="name">Log溢出： identical</span></li><li><span class="name">binder溢出： binder_alloc_buf, no vma</span></li><li><span class="name">丢帧： Choreographer: Skipped</span></li><li><span class="name">垃圾回收： Starting a blocking GC Alloc|GC freed</span></li><li><span class="name">CPU占用率： CPU usage</span></li><li><span class="name">应用启动： Start proc|New app record|Displayed</span></li><li><span class="name">焦点窗口切换： Set focused app to</span></li><li><span class="name">进程名</span></li><li><span class="name">进程ID</span></li><li><span class="name">数据库更新： onSharedPreferenceChanged</span></li><li><span class="name">处理事件： handleMessage, what</span></li></ul></li><li><span class="name">查看camera器件属性和状态</span><ul><li><span class="name">adb shell dumpsys media.camera, 注意 stream[0], [1]</span></li></ul></li><li><span class="name">systrace: 分析性能问题</span><ul><li><span class="name">systrace负责收集Android关键子系统（如surfaceflinger、wms等Framework模块、服务，View系统等）的运行信息。</span></li><li><span class="name">systrace由3部分组成：</span><ul><li><span class="name">内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</span></li><li><span class="name">数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</span></li><li><span class="name">数据分析工具：<a class="contentLink" target="_blank" rel="noreferrer" href="http://Android提供一个systrace.py">Android提供一个systrace.py</a>（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 </span></li><li><span class="name">从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.</span></li></ul></li><li><span class="name">抓取方法：</span><ul><li><span class="name">AS 进入Tools &gt; Android &gt; Monitor 抓取。</span></li><li><span class="name">或者使用 monitor.bat , 选择线程。</span></li><li><span class="name">选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。</span></li><li><span class="name">然后复现问题，抓对应的 systrace.</span></li><li><span class="name">设置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件）。</span></li></ul></li><li><span class="name">分析方法：</span><ul><li><span class="name">chrome中打开 <a class="contentLink" target="_blank" rel="noreferrer" href="chrome://tracing">chrome://tracing</a>,  把文件拖进去</span></li><li><span class="name">找对应的线程</span></li><li><span class="name">遍历快捷键:</span><ul><li><span class="name">w: 放大</span></li><li><span class="name">s: 缩小</span></li><li><span class="name">a: 后退</span></li><li><span class="name">d: 前进</span></li><li><span class="name">方向键: 四处遍历</span></li><li><span class="name">f: 直接放大当前</span></li><li><span class="name">m: 高亮当前</span></li><li><span class="name">v: 高亮整个 vsync</span></li><li><span class="name">0(数字): 恢复到最初状态</span></li></ul></li><li><span class="name">卡顿看 UIThread , 每个"F"都是一帧, 绿色表示不卡, 其它颜色表示卡.</span></li></ul></li><li><span class="name">界面刷新一般包括如下几个步骤：</span><ul><li><span class="name">SurfaceFlinger中的 EventThread 唤醒了应用程序UI线程，表明现在是渲染新帧的时候了。</span></li><li><span class="name">应用程序使用CPU和GPU资源在UI线程，RenderThread和hwuiTasks中渲染帧。这部分占UI的大部分。</span></li><li><span class="name">应用程序通过binder将绘制好的帧发送到SurfaceFlinger并进入睡眠状态。</span></li><li><span class="name">SurfaceFlinger中的第二个EventThread唤醒SurfaceFlinger来触发组合和显示输出。如果SurfaceFlinger确定没有任何工作要完成，它将返回睡眠状态。</span></li><li><span class="name">SurfaceFlinger通过HWC / HWC2或GL处理组合。 HWC / HWC2组合更快，更低的功耗，但会受到SOC的限制。这一步通常需要4-6ms，但是可以与步骤2重叠，因为Android应用程序总是三重缓冲。 （虽然应用程序总是三重缓冲，但在SurfaceFlinger中只能有一个待处理帧，因此和双重缓存差不多。）</span></li><li><span class="name">SurfaceFlinger通过驱动程序调度最终输出，并返回睡眠状态，等待EventThread唤醒。</span></li></ul></li><li><span class="name">systrace 加点</span><ul><li><span class="name">代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();</span></li><li><span class="name">必须成对出现, 且在同一个线程.</span></li><li><span class="name">一般在 release 中生效.</span></li></ul></li></ul></li><li><span class="name">卡顿问题</span><ul><li><span class="name">使用 traceView 观察CPU的执行情况, 找出耗时操作.</span></li><li><span class="name">打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧.</span></li><li><span class="name">华为应用启动门限：500ms，从点击图标到 activity ouResume的时间。</span></li></ul></li><li><span class="name">ANR问题</span><ul><li><span class="name">ANR：Application Not Responding</span></li><li><span class="name">ANR出现的原因</span><ul><li><span class="name">主线程频繁进行耗时的操作：如数据库读写</span></li><li><span class="name">多线程操作的死锁，主线程被block；</span></li><li><span class="name">主线程被Binder 对端block；</span></li><li><span class="name">System Server中WatchDog出现ANR；</span></li><li><span class="name">service binder的连接达到上线无法和和System Server通信</span></li><li><span class="name">系统资源已耗尽（管道、CPU、IO）</span></li></ul></li><li><span class="name">种类</span><ul><li><span class="name">用户输入5S</span><ul><li><span class="name">logKey：Input event dispatching timed out</span></li></ul></li><li><span class="name">广播：前台10S，后台60S</span><ul><li><span class="name">logKey：Timeout of broadcast BroadcastRecord</span></li></ul></li><li><span class="name">服务：前台20S，后台200S</span><ul><li><span class="name">logKey：Timeout executing service</span></li></ul></li><li><span class="name">ContentProvider：10S</span><ul><li><span class="name">logKey：timeout publishing content providers</span></li></ul></li></ul></li><li><span class="name">服务启动时ANR 的原因</span><ul><li><span class="name">Service创建之前会延迟发送一个消息，而这个消息就是ANR的起源；</span></li><li><span class="name">Service创建完毕，在规定的时间之内执行完毕onCreate()方法就移除这个消息，就不会产生ANR了；</span></li><li><span class="name">在规定的时间之内没有完成onCreate()的调用，消息被执行，ANR发生。</span></li></ul></li><li><span class="name">ANR日志</span><ul><li><span class="name">写anr log的代码在 ActivityManagerService.dumpStackTraces()</span></li><li><span class="name">旧版本系统(&lt;=8.0)</span></li><li><span class="name">data/anr/traces.txt</span></li><li><span class="name">adb pull data/anr/traces.txt</span></li><li><span class="name">以通过在设备的shell中使用setprop和getprop对系统属性进行设置和读取：</span></li><li><span class="name">getpropdalvik.vm.stack-trace-file</span></li><li><span class="name">setpropdalvik.vm.stack-trace-file /tmp/stack-traces.txt</span></li><li><span class="name">新版本系统(&gt;=9.0)</span><ul><li><span class="name">一次anr一个log文件</span></li></ul></li><li><span class="name">/data/anr/目录中有多个 anr_XXX文件</span></li></ul></li></ul></li><li><span class="name">内存泄漏 (参见"20-Memory" )</span></li><li><span class="name">稳定性（tombstone、systrace、Monkey等）</span></li><li><span class="name">Native层稳定性问题</span></li></ul>
  </body>
</html>