<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>30-Linux&amp;内核</b></span></span><ul><li><span class="name"><span class="innerContentContainer">操作系统背景知识</span></span><ul><li><span class="name"><span class="innerContentContainer">四位计算机的原理及其实现 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">操作系统的分类</span></span><ul><li><span class="name"><span class="innerContentContainer">单内核</span></span><ul><li><span class="name"><span class="innerContentContainer">整个系统为一个单独的进程来实现, 所有内核服务都在同一个地址空间内运行. 可直接调用函数.</span></span></li><li><span class="name"><span class="innerContentContainer">Linux属于单内核.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">微内核</span></span><ul><li><span class="name"><span class="innerContentContainer">内核功能划分为多个独立进程, 分别有自己的地址空间. </span></span></li><li><span class="name"><span class="innerContentContainer">所以不能直接调用函数, 而是通过IPC消息来完成内核通讯. </span></span></li><li><span class="name"><span class="innerContentContainer">优势在于安全, 一个进程的死掉一般不影响另一个. </span></span></li><li><span class="name"><span class="innerContentContainer">缺点是IPC开销较之函数调用大很多, 所以性能不佳. </span></span></li><li><span class="name"><span class="innerContentContainer">WinNT 和 mac osx 都属于微内核.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux的取舍</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux 提供了抢占式内核, 支持内核线程, 以及动态装载内核模块的功能, 汲取了微内核的精华.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux 方案设计的务实态度</span></span><ul><li><span class="name"><span class="innerContentContainer">任何改变都要针对现实中确实存在的问题, 经过完善的设计并有正确简洁的实现.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux基本特点</span></span><ul><li><span class="name"><span class="innerContentContainer">Unix的优点</span></span><ul><li><span class="name"><span class="innerContentContainer">简洁. unix 仅提供几百个系统调用. 而其它系统往往提供数千个系统调用，windows7 好几万。</span></span></li><li><span class="name"><span class="innerContentContainer">抽象。在系统中, 所有的东西都被看做文件. 对数据和设备的操作都可以抽象为 open/read/write/ioctl/close。</span></span></li><li><span class="name"><span class="innerContentContainer">内核使用c语言, 具有惊人的移植能力。</span></span></li><li><span class="name"><span class="innerContentContainer">进程创建迅速, 有一个非常独特的fork() 系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">简洁稳定的系统间通信原语.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">1991年, Linux诞生。</span></span></li><li><span class="name"><span class="innerContentContainer">内核没有libc库和其它库, 但是大部分库函数已得到实现.</span></span></li><li><span class="name"><span class="innerContentContainer">没有实现的最著名的是 printf(), 请用 printk() 代替. </span></span><ul><li><span class="name"><span class="innerContentContainer">printk 可以设置优先级. 如: printk(KERN_ERR "This is a error!");</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内核开发的特点  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">没有内存保护机制；</span></span></li><li><span class="name"><span class="innerContentContainer">不要在内核中使用浮点数；</span></span></li><li><span class="name"><span class="innerContentContainer">内核栈很小。不要在栈中使用大的结构.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linxu环境&amp;编译</span></span><ul><li><span class="name"><span class="innerContentContainer">内核编译文件: KCONFIG、Makefile</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">进程管理</span></span><ul><li><span class="name"><span class="innerContentContainer">进程</span></span><ul><li><span class="name"><span class="innerContentContainer">进程是操作系统最基本的抽象之一。</span></span></li><li><span class="name"><span class="innerContentContainer">进程即处在执行期的程序. 除程序代码外, 还有文件句柄, 信号, 内核内部数据, 处理器状态, 地址空间, 以及一个或多个线程 .</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">线程</span></span><ul><li><span class="name"><span class="innerContentContainer">即进程中活动的对象. 内核调度的对象是线程, 而不是进程。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux中, 每个线程都有自己的 task_struct.</span></span></li><li><span class="name"><span class="innerContentContainer">在内核眼里, 线程就是进程, 不过线程可以和自己的兄弟线程共享地址空间而已.</span></span></li><li><span class="name"><span class="innerContentContainer">Linux线程和windows线程的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">windows等操作系统上, 线程被称为轻量级进程,&nbsp;进程和线程分别有一套机制来管理.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">在Linux上, 由于进程就足够轻了. 所以就不做过多的区分.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">linux进程的堆栈</span></span><ul><li><span class="name"><span class="innerContentContainer">linux每个用户进程都有自己的堆栈，而且有两个，一个为系统堆栈，除1K的进程控制块外，还有7K的空间供内核进程调度时用于保存进程上下文。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建进程（fork，进程复制)</span></span><ul><li><span class="name"><span class="innerContentContainer">linux 中经常通过复制一个现有进程来创建新的进程. </span></span><ul><li><span class="name"><span class="innerContentContainer">目的是快速创建。因为在创建进程过程中仅需要分配新的PID 即可完成.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用 fork 的进程被称为<b>父进程</b>.</span></span></li><li><span class="name"><span class="innerContentContainer">新产生的进程被称为<b>子进程</b>。</span></span></li><li><span class="name"><span class="innerContentContainer">在该调用结束时, 在返回点这个相同位置上, 父进程恢复执行, 子进程开始执行。</span></span></li><li><span class="name"><span class="innerContentContainer">fork系统调用从内核中返回两次:</span></span><ul><li><span class="name"><span class="innerContentContainer">一次回到父进程;</span></span></li><li><span class="name"><span class="innerContentContainer">一次回到新诞生的子进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">fork 通过返回值来判断现在跑在哪一个进程里。返回值为0表示当前进程为新产生的子进程，不为零（实际为pid）的即为父进程。</span></span></li><li><span class="name"><span class="innerContentContainer">fork之后这两个进程的关系</span></span><ul><li><span class="name"><span class="innerContentContainer">创建后的子进程和父进程共享同一个地址空间的拷贝.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">只有在需要写入时，才会把父进程的相应页写入子进程的地址空间.&nbsp; 这叫写时拷贝技术.</span></span></li><li><span class="name"><span class="innerContentContainer">如果创建子进程后马上调用 exec() 来 load 自己的代码映像(一般情况是如此) , 则拷贝不需要发生. 因为此种情况下父进程和子进程的地址空间完全不相干.</span></span></li><li><span class="name"><span class="innerContentContainer">这样做提高性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">子进程如何加载自己的代码？</span></span><ul><li><span class="name"><span class="innerContentContainer">调用child()加载。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">创建线程</span></span><ul><li><span class="name"><span class="innerContentContainer">创建进程和创建线程基本一样. </span></span></li><li><span class="name"><span class="innerContentContainer">不同点在于, 创建线程时, 需要指明共享资源.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程退出</span></span><ul><li><span class="name"><span class="innerContentContainer">进程退出时要清理如下资源：</span></span><ul><li><span class="name"><span class="innerContentContainer">内核定时器；</span></span></li><li><span class="name"><span class="innerContentContainer">用户地址空间；</span></span></li><li><span class="name"><span class="innerContentContainer">IPC信号；</span></span></li><li><span class="name"><span class="innerContentContainer">文件描述符；</span></span></li><li><span class="name"><span class="innerContentContainer">文件系统数据；</span></span></li><li><span class="name"><span class="innerContentContainer">进程命名空间；</span></span></li><li><span class="name"><span class="innerContentContainer">信号处理函数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">经过这一轮清理后, 进程进入僵死状态, 它还占有的资源就是内核栈, thread_info, task_struct, 其目的是向其父进程提供信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程控制块（也叫进程描述符）</span></span><ul><li><span class="name"><span class="innerContentContainer">每个进程都用进程控制块来描述, 在 sched.h 中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">所有的进程描述符放在一个叫 task list 的双向链表中. </span></span></li><li><span class="name"><span class="innerContentContainer">字段包括：</span></span></li><li><span class="name"><span class="innerContentContainer">进程序号：PID。默认情况下，最大值为32768，这个值可以改。</span></span></li><li><span class="name"><span class="innerContentContainer">PPID：父进程序号。所有进程都是PID为1的 init进程的后代。</span></span></li><li><span class="name"><span class="innerContentContainer">进程状态：state。值域包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">task_running：进程可执行(即就绪态). </span></span><ul><li><span class="name"><span class="innerContentContainer">它或者正在执行, 或者在运行队列中等待执行。</span></span></li><li><span class="name"><span class="innerContentContainer">进程在用户空间中执行的唯一可能的状态。</span></span></li><li><span class="name"><span class="innerContentContainer">正在执行的进程, 可以被优先级更高的进程抢占, 此时被抢占的进程处在运行队列中等待执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">task_interruptible：进程在睡眠, 或者说被阻塞.&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">进程为了等待特定事件, 在等待队列中睡眠. </span></span></li><li><span class="name"><span class="innerContentContainer">一旦等待的事件发生, 进程被唤醒并重新置入运行队列. </span></span></li><li><span class="name"><span class="innerContentContainer">阻塞中的线程也可以被信号提前唤醒.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">task_uninterruptible</span></span><ul><li><span class="name"><span class="innerContentContainer">除了不会因为接受到信号而被唤醒外, 这个状态和上一个一样. </span></span></li><li><span class="name"><span class="innerContentContainer">在进程执行重要操作时, 比如持有信号量, 为了避免被信号打断当前流程, 而是用此状态. </span></span></li><li><span class="name"><span class="innerContentContainer">这个状态较少使用.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">task_zombile：僵死</span></span><ul><li><span class="name"><span class="innerContentContainer">进程已经结束, 但是父进程还没有调用 wait4() 系统调用. </span></span></li><li><span class="name"><span class="innerContentContainer">为了父进程能够知道其状态, 子进程的进程描述符仍被保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">task_stopped：停止</span></span><ul><li><span class="name"><span class="innerContentContainer">进程收到stop信号时退出，释放所有资源。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">vruntime： 虚拟运行时间</span></span></li><li><span class="name"><span class="innerContentContainer">sum_exec_runtime：进程总共执行的实际时间</span></span></li><li><span class="name"><span class="innerContentContainer">prev_sum_exec_runtime：上次该进程被调度时已经占用的实际时间。</span></span></li><li><span class="name"><span class="innerContentContainer">ideal_runtime：在一个调度周期中进程应该运行的实际时间</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">陷入</span></span><ul><li><span class="name"><span class="innerContentContainer">一般程序在用户空间执行. </span></span></li><li><span class="name"><span class="innerContentContainer">当它调用了一个系统调用, 或者触发了一个异常, 它就陷入了内核空间。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核线程</span></span><ul><li><span class="name"><span class="innerContentContainer">内核经常需要在后台执行一些操作，通过内核线程完成. </span></span></li><li><span class="name"><span class="innerContentContainer">内核线程没有独立的地址空间, 它使用统一的内核空间. 其它和普通进程一样。</span></span></li><li><span class="name"><span class="innerContentContainer">一般内核线程会一直执行. </span></span></li><li><span class="name"><span class="innerContentContainer">在需要的时候, 它会被唤醒和执行, 然后再次休眠.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程调度</span></span><ul><li><span class="name"><span class="innerContentContainer">2.5之前，Linux 使用传统的UNIX调度算法，即时间片 + 优先级的调度器。</span></span></li><li><span class="name"><span class="innerContentContainer">2.5上，linux 使用了 O(1) 的调度算法。</span></span></li><li><span class="name"><span class="innerContentContainer">2.6.23 上，linux 使用了完全公平调度器（CFS），不使用时间片。</span></span><ul><li><span class="name"><span class="innerContentContainer">同时支持实时调度（仅在实时操作系统上使用，少见）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux 的两种优先级</span></span><ul><li><span class="name"><span class="innerContentContainer">普通优先级</span></span><ul><li><span class="name"><span class="innerContentContainer">nice值由 -20到19。</span></span></li><li><span class="name"><span class="innerContentContainer">默认值为0。</span></span></li><li><span class="name"><span class="innerContentContainer">值越大优先级越低。</span></span></li><li><span class="name"><span class="innerContentContainer">nice 值还可以决定分配的时间片的大小, -20 最长 19 最短。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实时优先级</span></span><ul><li><span class="name"><span class="innerContentContainer">nice 值由 0 到 99. </span></span></li><li><span class="name"><span class="innerContentContainer">任何实时进程的优先级都高于普通进程。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">所谓完全公平调度（CFS），就是在选取下个进程的时候，总是选取当前所有普通进程中运行时间最少的进程。</span></span></li><li><span class="name"><span class="innerContentContainer">但是这里的运行时间，并不是实际运行时间，而是虚拟运行时间。这是CFS 调度算法的关键。</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重(优先级)</span></span></li><li><span class="name"><span class="innerContentContainer">NICE_0_LOAD/ 权重(优先级) 即衰减因子。</span></span></li><li><span class="name"><span class="innerContentContainer">对于正常优先级的任务（nice值为 0），衰减因子为1，虚拟运行时间与实际物理运行时间是相同的。</span></span></li><li><span class="name"><span class="innerContentContainer">对于底优先级任务，衰减因子大于1，它的虚拟运行时间上升得越快，因此相当于优先级会更快的衰减。</span></span></li><li><span class="name"><span class="innerContentContainer">对于底优先级任务，衰减因子小于1，它的虚拟运行时间上升得越慢，因此相当于优先级会更慢的衰减。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CFS把线程分为I/O 密集型 和 CPU 密集型</span></span><ul><li><span class="name"><span class="innerContentContainer">I/O 密集型：在运行很短时间后就会阻塞以便等待更多的 I/O。</span></span><ul><li><span class="name"><span class="innerContentContainer">大部分时间都在等待用户交互.&nbsp;比如文字编辑。</span></span></li><li><span class="name"><span class="innerContentContainer">此类程序应该有更高的优先级。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU 密集型：只要有在处理器上运行的机会，就会用完它的时间片。</span></span><ul><li><span class="name"><span class="innerContentContainer">大部分时间都在进行cpu处理. 比如视频编解码程序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">判断依据</span></span><ul><li><span class="name"><span class="innerContentContainer">看进程休眠的时间长短. 长的就是I/O 密集型，短的就是CPU 密集型。</span></span></li><li><span class="name"><span class="innerContentContainer">这个推断机制准确得惊人, 而且反应极快, 当一个进程由IO消耗性转变为CPU消耗型, 调度程序会很快做出反应.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。</span></span></li><li><span class="name"><span class="innerContentContainer">这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CFS 采用红黑树来管理task控制块</span></span><ul><li><span class="name"><span class="innerContentContainer">当一个任务变成可运行时，它被添加到树上。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个任务变成不可运行时（例如，当阻塞等待 I/O 时），它从树上被删除。</span></span></li><li><span class="name"><span class="innerContentContainer">一般来说，得到较少处理时间的任务（虚拟运行时间较小）会偏向树的左侧；得到较多处理时间的任务会偏向树的右侧。</span></span></li><li><span class="name"><span class="innerContentContainer">根据二分搜索树的性质，最左侧的结点有最小的键值；从 CFS 调度程序角度而言，这也是具有最高优先级的任务。</span></span></li><li><span class="name"><span class="innerContentContainer">由于红黑树是平衡的，找到最左侧结点会需要&nbsp;O(lgN)&nbsp;操作（这里 N 为树内结点总数）。</span></span></li><li><span class="name"><span class="innerContentContainer">不过，为高效起见，Linux 调度程序将这个值缓存在变量 rb_leftmost 中，从而确定哪个任务运行只需检索缓存的值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>调度时机</b></span></span><ul><li><span class="name"><span class="innerContentContainer">分为3步：</span></span></li><li><span class="name"><span class="innerContentContainer">1. 判断是否应该被抢占的时机</span></span><ul><li><span class="name"><span class="innerContentContainer">当当前进程的本次调度占用实际时间， 大于ideal_runtime时；</span></span></li><li><span class="name"><span class="innerContentContainer">当前进程的 vruntime(虚拟运行时间)大于红黑树中最小的进程的vruntime，且差值大于ideal_time时</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 应该被抢占，也不会被马上抢占。仅仅在该进程上打一个标签TIF_NEED_RESCHED。</span></span></li><li><span class="name"><span class="innerContentContainer">3. 真正发生抢占的时机</span></span><ul><li><span class="name"><span class="innerContentContainer">当前task主动释放cpu；</span></span><ul><li><span class="name"><span class="innerContentContainer">进程退出</span></span></li><li><span class="name"><span class="innerContentContainer">进程收到stop信号</span></span></li><li><span class="name"><span class="innerContentContainer">进程代码显式的调用 schedule()函数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当前task被阻塞；</span></span></li><li><span class="name"><span class="innerContentContainer">当前task进行系统调用，完成，从内核态返回用户态时。</span></span></li><li><span class="name"><span class="innerContentContainer">从中断处理上下文返回用户空间。</span></span></li><li><span class="name"><span class="innerContentContainer">从异常处理上下文返回用户空间。</span></span></li><li><span class="name"><span class="innerContentContainer">在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这时也是一个执行抢占的时机。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">实时调度</span></span><ul><li><span class="name"><span class="innerContentContainer">linux 提供了两种实时调度策略: sched_fifo 和 sched_rr.</span></span></li><li><span class="name"><span class="innerContentContainer">前者非时间片, 即这种优先级的进程会一直执行下去, 直到它被阻塞或主动释放cpu. 但是可以被更高优先级的进程抢占.</span></span></li><li><span class="name"><span class="innerContentContainer">后者即带时间片的sched_fifo.</span></span></li><li><span class="name"><span class="innerContentContainer">linux 的实时调度算法提供了一种软实时工作方式, 它不能保证总能满足实时进程的需求。尽管如此, 2.6 的核心可以满足非常严格的实时要求.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核抢占</span></span><ul><li><span class="name"><span class="innerContentContainer">内核抢占是在2.5.4版本发布时加入, 同SMP(Symmetrical Multi-Processing, 对称多处理器), 作为内核的可选配置。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统调用</span></span><ul><li><span class="name"><span class="innerContentContainer">系统调用时用户空间访问内核的唯一手段。除异常和陷入外, 它是内核唯一的合法入口。</span></span></li><li><span class="name"><span class="innerContentContainer">linux 的系统调用是作为c库的一部分提供的. </span></span></li><li><span class="name"><span class="innerContentContainer">系统调用在内核中实现, 运行于内核空间。应用程序不需要关注系统调用.</span></span></li><li><span class="name"><span class="innerContentContainer">API和系统调用的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">API是由OS提供的、供应用程序使用的编程接口. </span></span></li><li><span class="name"><span class="innerContentContainer">它的实现可以是一个系统调用, 也可以是多个系统调用, 亦可和系统调用无关.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">POSIX标准</span></span><ul><li><span class="name"><span class="innerContentContainer">linux 最流行的API 是基于POSIX标准的。</span></span></li><li><span class="name"><span class="innerContentContainer">标准是IEEE负责发布的, </span></span></li><li><span class="name"><span class="innerContentContainer">目的是为了基于unix 的可移植操作系统的标准. </span></span></li><li><span class="name"><span class="innerContentContainer">linux与之兼容. </span></span></li><li><span class="name"><span class="innerContentContainer">windows , 也提供了和POSIX兼容的库.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">机制和策略</span></span><ul><li><span class="name"><span class="innerContentContainer">关于unix的界面设计有一句格言: "提供机制而不是策略". </span></span></li><li><span class="name"><span class="innerContentContainer">换句话说, unix的系统调用抽象出用于完成某种确定目的的函数; 至于这些函数怎么使用完全不需要内核去关心.</span></span></li><li><span class="name"><span class="innerContentContainer">区分机制(mechanism)和策略（policy）是Unix设计中的一大亮点。</span></span></li><li><span class="name"><span class="innerContentContainer">大部分的编程问题都可以被切割成两个部分：“需要提供什么功能”（机制）和“怎样实现这些功能”（策略）。</span></span></li><li><span class="name"><span class="innerContentContainer">如果由程序中的独立部分分别负责机制和策略的实现，那么开发软件就更容易，也更容易适应不同的需求。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux抽象出对这些对象的执行机制</span></span><ul><li><span class="name"><span class="innerContentContainer">程序的执行机制--进程；</span></span></li><li><span class="name"><span class="innerContentContainer">内核函数的执行机制--线程；</span></span></li><li><span class="name"><span class="innerContentContainer">中断服务程序的执行机制--中断信号触发；</span></span></li><li><span class="name"><span class="innerContentContainer">中断下半部的执行机制--softirq，tasklet，工作队列；</span></span></li><li><span class="name"><span class="innerContentContainer">系统调用的执行--软中断（int $0x80触发）。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统调用在内核中实现</span></span><ul><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">asmlinkage long sys_getpid(void){</span></span><ul><li><span class="name"><span class="innerContentContainer"> return current-&gt;tgid;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">函数声明中有asmlinkage, 所有系统调用都需要这个限定词.</span></span></li><li><span class="name"><span class="innerContentContainer">系统调用 get_pid() 在内核中被定义为 sys_getpid(). 这个是linux系统调用都遵守的命名规则, 即加入 sys_ 前缀.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统调用号</span></span><ul><li><span class="name"><span class="innerContentContainer">每个系统调用都被赋予一个系统调用号. </span></span></li><li><span class="name"><span class="innerContentContainer">一旦被分配, 就不能有任何变更. </span></span></li><li><span class="name"><span class="innerContentContainer">该列表存储在 sys_call_table 中.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">调用过程</span></span><ul><li><span class="name"><span class="innerContentContainer">应用程序如何通知内核自己需要执行一个系统调用？</span></span><ul><li><span class="name"><span class="innerContentContainer">软中断. 通过引发一个异常来促使系统切换到内核态去执行异常处理程序.&nbsp; </span></span></li><li><span class="name"><span class="innerContentContainer">x86系统上的软中断是通过 int $0x80指令产生. </span></span></li><li><span class="name"><span class="innerContentContainer">这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序, 而该程序就是系统调用处理程序, 即 system_call().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统陷入内核空间还不够, 系统调用号是如何传入的呢? </span></span><ul><li><span class="name"><span class="innerContentContainer">x86上是通过eax寄存器传递的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统调用还有参数, 要如何传递?</span></span><ul><li><span class="name"><span class="innerContentContainer">寄存器. </span></span></li><li><span class="name"><span class="innerContentContainer">x86 上, ebx, ecx, edx, esi 和 edi 可以放前5个参数. </span></span></li><li><span class="name"><span class="innerContentContainer">如果有6个或以上的参数(不多见), 则有一个寄存器存放指向所有参数的用户空间的指针.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回值放在哪里？</span></span><ul><li><span class="name"><span class="innerContentContainer">返回值也是放在寄存器的. x86上是eax.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">整个流程如下</span></span><ul><li><span class="name"><span class="innerContentContainer">用户程序调用 read() -&gt; c库封装的代码 -&gt; system_call() -&gt; sys_read().</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统调用上下文</span></span><ul><li><span class="name"><span class="innerContentContainer">内核在执行系统调用时, 处在进程上下文。</span></span></li><li><span class="name"><span class="innerContentContainer">在进程上下文中, 内核可以休眠和被抢占。</span></span></li><li><span class="name"><span class="innerContentContainer">休眠的能力非常重要</span></span><ul><li><span class="name"><span class="innerContentContainer">明系统调用可以使用内核提供的绝大部分功能. </span></span></li><li><span class="name"><span class="innerContentContainer">与之对应的是, 由于中断上下文不具休眠能力, 导致其能进行的操作相当受限.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统调用的参数检验</span></span><ul><li><span class="name"><span class="innerContentContainer">最重要的检查是检查用户传入的指针是否有效.</span></span></li><li><span class="name"><span class="innerContentContainer">别对别人会怎么用它做过多的假设. 比如不要对字节长度和字节序做假设.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">参数是属于用户空间的;</span></span></li><li><span class="name"><span class="innerContentContainer">参数在该进程的地址空间内的 , 也就是说不能属于其它进程.</span></span></li><li><span class="name"><span class="innerContentContainer">参数访问必须有对应的权限.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">权限检查</span></span><ul><li><span class="name"><span class="innerContentContainer">针对调用者是否有合法权限. 采用 capable() 函数来检查. </span></span></li><li><span class="name"><span class="innerContentContainer">比如, capable(CAP_SYS_NICE) 可检查调用者是否有权改变其它进程的nice值。</span></span></li><li><span class="name"><span class="innerContentContainer">相关权限列表见 linux/capability.h。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">向用户空间读写数据</span></span><ul><li><span class="name"><span class="innerContentContainer">写，核提供了copy_to_user(), 它需要三个参数: </span></span><ul><li><span class="name"><span class="innerContentContainer">进程空间的目标内存地址, </span></span></li><li><span class="name"><span class="innerContentContainer">内核空间的源地址, </span></span></li><li><span class="name"><span class="innerContentContainer">需要拷贝的字节数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读内核提供了 copy_from_user()。</span></span></li><li><span class="name"><span class="innerContentContainer">如果执行失败, 两个函数返回的都是没能完成拷贝的数据的字节数. </span></span></li><li><span class="name"><span class="innerContentContainer">如果成功, 返回0.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建新的系统调用已经不再被允许了。替代办法是创建一个设备节点。</span></span><ul><li><span class="name"><span class="innerContentContainer">通过 open() close() , read() 和 write()访问它. </span></span></li><li><span class="name"><span class="innerContentContainer">用&nbsp; ioctl() 进行特别的设置操作和获取特别的信息.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">中断&amp;异常&amp;下半部</span></span><ul><li><span class="name"><span class="innerContentContainer">中断</span></span><ul><li><span class="name"><span class="innerContentContainer">中断使得硬件得以和CPU进行通讯。</span></span></li><li><span class="name"><span class="innerContentContainer">它本质上是一种特殊的电信号, 由外设发给处理器。</span></span></li><li><span class="name"><span class="innerContentContainer">处理器一经检测到此信号, 便中断自己的当前工作转而处理中断。</span></span></li><li><span class="name"><span class="innerContentContainer">中断随时会发生。</span></span></li><li><span class="name"><span class="innerContentContainer">中断请求线(IRQ)</span></span><ul><li><span class="name"><span class="innerContentContainer">不同的设备对应的中断不同。每个中断都通过一个唯一的数字标示来区分. 这些中断值被称为IRQ. </span></span></li><li><span class="name"><span class="innerContentContainer">比如x86上, IRQ0 是时钟中断, IRQ1 是键盘中断. </span></span></li><li><span class="name"><span class="innerContentContainer">PCI 总线上的设备的中断IRQ是动态分配的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断处理程序(ISR)</span></span><ul><li><span class="name"><span class="innerContentContainer">ISR 是被内核调用来响应中断的. 它运行在中断上下文中。</span></span></li><li><span class="name"><span class="innerContentContainer">除此之外, ISR 就是普通的c函数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注册中断处理程序(ISR): request_irq()</span></span><ul><li><span class="name"><span class="innerContentContainer">中断处理程序是管理硬件的驱动程序的组成部分。</span></span></li><li><span class="name"><span class="innerContentContainer">如果设备使用中断 (大部分设备都如此), 那么相应的驱动程序会注册一个中断处理程序。</span></span></li><li><span class="name"><span class="innerContentContainer">注册isr用request_irq()，其参数表是：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 表示要分配的中断号. 对于传统设备, 比如部分时钟和键盘, 这个值是定死的. 而对于大多数其它设备, 这个值要么是通过探测获取, 或者在编程动态确定.</span></span></li><li><span class="name"><span class="innerContentContainer">2. 即中断处理程序的指针. 其原型是确定的.</span></span></li><li><span class="name"><span class="innerContentContainer">3. irqflags 可以为0, 也可以为如下值:</span></span><ul><li><span class="name"><span class="innerContentContainer">SA_INTERRUPT: 表示为快中断. 加此标志的中断会在禁止所有中断的情况下运行. 这使得FIQ 的处理不被打扰. 一般IRQ则只屏蔽自己这条中断线, 而其它中断都是激活的.</span></span></li><li><span class="name"><span class="innerContentContainer">SA_SAMPLE_RANDOM: 表示当前isr 的中断间隔时间作为熵源填充到内核的熵池中. 熵池是为了产生真随机数.</span></span></li><li><span class="name"><span class="innerContentContainer">SA_SHIRQ: 表示当前isr 和 其它isr共享同一个中断线. 同一中断线上注册的每个处理程序都必须指定这个标志.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. devname 是入中断有关的设备的名字的ascii 码字符串. 这个名字会被 /proc/irq 和 /proc/interrupt 使用.</span></span></li><li><span class="name"><span class="innerContentContainer">5. dev_id 主要用于共享中断线. 当一个中断处理程序需要释放时, 此参数将提供唯一的标示信息, 以便从共享中断线的诸多中断处理函数中删除指定的一个.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回值:</span></span><ul><li><span class="name"><span class="innerContentContainer">0 表示成功. </span></span></li><li><span class="name"><span class="innerContentContainer">非0 表示失败. 最常见的错误是:</span></span><ul><li><span class="name"><span class="innerContentContainer">-EBUSY, 表示给定的中断线已经在使用, 或者没有共享中断线没有加 SA_SHIRQ。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">调用 request_irq() 可能会睡眠</span></span><ul><li><span class="name"><span class="innerContentContainer">在注册过程中,内核需要在 /proc/irq 中增加一个项, proc_mkdir()即是干这个的,proc_mkdir()通过 proc_create()对这个新的profs项进行设置。而后者会调用 kmalloc()请求内存。而后者可以睡眠。</span></span></li><li><span class="name"><span class="innerContentContainer">由于它会睡眠，所以不能在中断上下文或其它不允许阻塞的代码中调用。</span></span></li><li><span class="name"><span class="innerContentContainer">只能在进程上下文调用此函数。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">释放ISR: free_irq()</span></span><ul><li><span class="name"><span class="innerContentContainer">对于非共享中断线, 释放中断处理程序将导致该中断线禁用。</span></span></li><li><span class="name"><span class="innerContentContainer">必须在进程上下文调用此函数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实现ISR</span></span><ul><li><span class="name"><span class="innerContentContainer">ISR是无需考虑重入的. </span></span></li><li><span class="name"><span class="innerContentContainer">因为当一个给定的isr 在执行时, 相应的中断线在所有的cpu上都会被屏蔽掉.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">共享中断线</span></span><ul><li><span class="name"><span class="innerContentContainer">系统支持的中断线数量有限，所以一些设备需要共享中断线。</span></span></li><li><span class="name"><span class="innerContentContainer">软件上，可以往一个IRQ上注册多个ISR。</span></span></li><li><span class="name"><span class="innerContentContainer">内核收到一个中断后, 它将依次调用在该中断线上注册的每一个ISR.</span></span></li><li><span class="name"><span class="innerContentContainer">所以, ISR必须有办法得知它的设备是否真的产生了中断. </span></span></li><li><span class="name"><span class="innerContentContainer">这既需要硬件支持, 也需要ISR中有相应的处理逻辑. </span></span></li><li><span class="name"><span class="innerContentContainer">如果ISR与之相关的硬件并没有产生中断, 则它应该立即退出，把CPU让给下一个ISR。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断从硬件到内核的路由</span></span><ul><li><span class="name"><span class="innerContentContainer">硬件设备: 产生一个中断(电信号)；</span></span></li><li><span class="name"><span class="innerContentContainer">中断控制器将其传给给CPU。</span></span></li><li><span class="name"><span class="innerContentContainer">CPU: 如果该中断不被禁止, CPU会中断当前工作, 关闭中断系统, 然后跳到内存中预定义的位置(即ISR的入口点)开始执行. </span></span><ul><li><span class="name"><span class="innerContentContainer">每条中断线都对应一个唯一的位置. 所以, 内核就知道所接受的IRQ号了.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">do_IRQ(): 计算中断号,确认该号上是否注册有isr.</span></span><ul><li><span class="name"><span class="innerContentContainer">如果没有, 则跳到ret_from_intr()执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">handle_IRQ_evnet(): 主要做如下事：</span></span><ul><li><span class="name"><span class="innerContentContainer">禁止本中断线, 或者禁止所有中断线(依赖于中断线属性是否有SA_INTERRUPT)；</span></span></li><li><span class="name"><span class="innerContentContainer">运行该线注册的所有isr.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果注册期间指定了SA_SAMPLE_RANDOM属性, 则调用 add_interrupt_randomness().</span></span></li><li><span class="name"><span class="innerContentContainer">isr调用完后，调用ret_from_intr(): 检查是否有必要进行经常调度. 细节如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">重新调度是否正在挂起(即设置了 need_resched), 而且内核正在访问用户空间(即中断了用户进程), 则调用 schedule().</span></span></li><li><span class="name"><span class="innerContentContainer">如果内核正在返回内核空间(即中断了内核), 只有在 preempt_count 为0 时, schedule() 才会被调用(否则, 抢占内核便是不安全的).</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">中断上下文和进程上下文</span></span><ul><li><span class="name"><span class="innerContentContainer">这两个概念都只和内核空间有关系. 表明内核运行的两种状态。</span></span></li><li><span class="name"><span class="innerContentContainer">进程上下文是一种内核所处的操作模式, 此时内核代表进程执行，包括；</span></span><ul><li><span class="name"><span class="innerContentContainer">执行系统调用</span></span></li><li><span class="name"><span class="innerContentContainer">运行内核线程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在进程上下文下, 可以做如下事:</span></span><ul><li><span class="name"><span class="innerContentContainer">可以通过current宏关联当前进程. </span></span></li><li><span class="name"><span class="innerContentContainer">可以睡眠.</span></span></li><li><span class="name"><span class="innerContentContainer">可以调用调度程序.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断上下文</span></span><ul><li><span class="name"><span class="innerContentContainer">和进程没有什么关系. 所以current 宏指向的是被中断的进程.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">不可以睡眠. 因为没有进程的背景, 如何睡眠? 阻塞后如何重新调度? 因此, 不可以在中断上下文中调用那些会导致睡眠的函数.</span></span></li><li><span class="name"><span class="innerContentContainer">中断上下文具有严格的时间限制. 必须尽可能的迅速简洁. 应该尽量把工作从isr中分离出来, 放在下半部来执行.</span></span></li><li><span class="name"><span class="innerContentContainer">中断上下文具有严格的空间限制. </span></span><ul><li><span class="name"><span class="innerContentContainer">2.6版本之前, isr 没有自己的栈, 相反它们共享被中断进程的内核栈. 内核栈的大小为两页, 具体说, 32位系统为8KB, 62位系统为16K.</span></span></li><li><span class="name"><span class="innerContentContainer">2.6版本后, 提供了一个选项, 把内核栈的大小减为1页. 这减轻了内存的压力, 因为系统中每个进程原来都需要8K不可换出的内核内存. </span></span></li><li><span class="name"><span class="innerContentContainer">为了应对栈的减少, isr有了自己的栈, 每个cpu一个, 大小为4K. 这个栈称为中断栈.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Proc fs</span></span><ul><li><span class="name"><span class="innerContentContainer">ProcFS是一个虚拟文件系统, 它只存在于内核内存, 一般安装于 /proc 目录下. </span></span></li><li><span class="name"><span class="innerContentContainer">在proc中读写文件都要调用内核函数, 这些函数模仿从真实文件中读和写.</span></span></li><li><span class="name"><span class="innerContentContainer">/proc/interrupts 存放和中断相关的统计信息。</span></span></li><li><span class="name"><span class="innerContentContainer">cat 它，可以查看如下数据：LOC:&nbsp; &nbsp; 8603870&nbsp; &nbsp; 5633075&nbsp; &nbsp;Local timer interrupts</span></span><ul><li><span class="name"><span class="innerContentContainer">其中, 第一列为中断线, 这里不显示没有注册处理程序的中断线.</span></span></li><li><span class="name"><span class="innerContentContainer">第二列为接受到的中断数目的计数器. 我们可以看到,时钟中断已经发生了 8603870次.</span></span></li><li><span class="name"><span class="innerContentContainer">第三列式处理这个中断的中断控制器. 在具有 IO APIC的系统上, 多数中断都会用 IO-APIC-edge.</span></span></li><li><span class="name"><span class="innerContentContainer">最后一列是与这个中断相关的设备名称. 这个名称是通过 devname 提供给函数&nbsp; request_irq()的. </span></span><ul><li><span class="name"><span class="innerContentContainer">如果中断线是共享的, 比如中断16, 则所有设备都会列出.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">procfs 代码位于 fs/proc, 创建 /proc/interrupts 的函数叫做 show_interruptes()。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断控制, 禁止和激活中断</span></span><ul><li><span class="name"><span class="innerContentContainer">所谓中断控制, 即禁止当前处理器的中断系统, 或者屏蔽掉整个机器的一条中断线.</span></span></li><li><span class="name"><span class="innerContentContainer">中断控制的目的是需要提供同步. </span></span><ul><li><span class="name"><span class="innerContentContainer">通过禁止中断, 可以确保某个 isr 不会抢占当前代码. </span></span></li><li><span class="name"><span class="innerContentContainer">禁止中断, 还可以禁止内核抢占.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断控制不能够防止来自其它CPU的并发访问. 而锁可以. 这是两个层面的事. 即锁防止其它CPU的并发访问, 而禁止中断防止来自其它ISR的并发访问.</span></span></li><li><span class="name"><span class="innerContentContainer">api包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">禁止当前CPU上的本地中断: local_irq_disable()</span></span></li><li><span class="name"><span class="innerContentContainer">激活它们: local_irq_enable()</span></span></li><li><span class="name"><span class="innerContentContainer">禁止中断并保存状态: local_irq_save(flags);&nbsp; &nbsp; // flags 为uint32.</span></span></li><li><span class="name"><span class="innerContentContainer">恢复中断状态: local_irq_restore(flags);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">后两者更安全. 因为local_irq_enable() 会无条件激活所有中断, 如果某个中断可能在开始之前就关闭了.</span></span></li><li><span class="name"><span class="innerContentContainer">后两者必须在同一个函数中调用.</span></span></li><li><span class="name"><span class="innerContentContainer">所有这四个函数既可以在中断中调用, 也可以在进程上下文中调用.</span></span></li><li><span class="name"><span class="innerContentContainer">禁止指定中断线</span></span><ul><li><span class="name"><span class="innerContentContainer">disable_irq(uint irq): 禁止中断线, </span></span><ul><li><span class="name"><span class="innerContentContainer">函数只有在当前正在执行的所有isr都完成后, 才能返回. </span></span></li><li><span class="name"><span class="innerContentContainer">所以调用者要确保不再指定线上传递新的中断。</span></span></li><li><span class="name"><span class="innerContentContainer">同时要确保已经开始执行的isr已经全部退出。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">disable_irq_nosync(uint irq): </span></span><ul><li><span class="name"><span class="innerContentContainer">禁止指定中断线, 异步调用. 没有上面函数的限制.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">enable_irq(uint irq): 激活中断线.</span></span></li><li><span class="name"><span class="innerContentContainer">syncchronize_irq(uint irq):&nbsp; 等待特定的isr的退出.</span></span></li><li><span class="name"><span class="innerContentContainer">这些函数实际上很少使用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">in_interrupt(): 如果内核存在中断上下文, 返回非0.</span></span></li><li><span class="name"><span class="innerContentContainer">in_irq(): 内核在执行isr 时, 返回非0.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">上半部和下半部</span></span><ul><li><span class="name"><span class="innerContentContainer">中断是需要尽快被处理掉的。</span></span><ul><li><span class="name"><span class="innerContentContainer">首先硬件可能有严格的时序限制。</span></span></li><li><span class="name"><span class="innerContentContainer">其次系统的其它被打断的部分需要尽快回去恢复。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">但是很多中断需要处理的工作量很大, 比如网卡.</span></span></li><li><span class="name"><span class="innerContentContainer">因此我们一般把中断处理切分为两部分：</span></span><ul><li><span class="name"><span class="innerContentContainer">上半部即isr，只完成有严格时限的部分. </span></span></li><li><span class="name"><span class="innerContentContainer">第二部分就叫下半步. 下半部的实现机制有好几种.</span></span></li><li><span class="name"><span class="innerContentContainer">理想状态下, 最好 isr 将所有工作都交给下半部执行. 所以, 很多isr处理逻辑除了做最小范围的状态维护外, 就发一个下半部请求, 然后就直接返回了. (推荐这么做)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">什么逻辑放在isr，基本的规则是：  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个任务对时间非常敏感, 比如将数据从硬件读入内存; 那么就放在isr;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">如果一个任务和硬件相关, 比如操作硬件对中断的到达进行确认, 那么就放在isr;</span></span></li><li><span class="name"><span class="innerContentContainer">如果一个任务要保证不被其它中断(特别是同一中断线的中断)打断, 将其放在isr 中执行;</span></span></li><li><span class="name"><span class="innerContentContainer">凡不是必须放在isr 的任务, 都应该放在下半部.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">下半部的执行时机</span></span><ul><li><span class="name"><span class="innerContentContainer">下半部一般并不和isr隔了一段时间再执行, 相反, 多数情况下半部会在isr返回后马上执行.</span></span></li><li><span class="name"><span class="innerContentContainer">下半部的关键在于当它们运行时, <b>允许响应所有的中断。</b></span></span></li><li><span class="name"><span class="innerContentContainer">锁中断的时间长短, 对系统的性能影响极大.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">下半部实现机制</span></span><ul><li><span class="name"><span class="innerContentContainer">历史机制（现在已淘汰）</span></span><ul><li><span class="name"><span class="innerContentContainer">最早的机制是BH(bottom half)。2.5 内核去掉. 被软中断(softirq)、工作队列取代。</span></span></li><li><span class="name"><span class="innerContentContainer">任务队列（task queue）, 也是在2.5 内核去掉。被工作队列取代。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软中断(SoftIRQ)</span></span><ul><li><span class="name"><span class="innerContentContainer">运行在中断上下文。</span></span></li><li><span class="name"><span class="innerContentContainer">软中断使用较少, 一般用于象网络这种对性能要求高的情况下. </span></span></li><li><span class="name"><span class="innerContentContainer">代码位于 /kernel/softirq.c</span></span></li><li><span class="name"><span class="innerContentContainer">软中断由 softirq_action 结构管理：</span></span><ul><li><span class="name"><span class="innerContentContainer">struct softirq_action{</span></span><ul><li><span class="name"><span class="innerContentContainer">void (*action)(struct softirq_action *);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软中断需要在编译期间静态分配。</span></span></li><li><span class="name"><span class="innerContentContainer">softirq.c 定义了 NR_SOFTIRQS个该结构体的数组。</span></span><ul><li><span class="name"><span class="innerContentContainer">NR_SOFTIRQS为软中断的枚举量,每个被注册的软中断都占据该数组的一项。</span></span></li><li><span class="name"><span class="innerContentContainer">目前该值为 10. 即系统最多可能有10个软中断。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核代码中明确要求不要再分配新的软中断。因此不建议使用. </span></span></li><li><span class="name"><span class="innerContentContainer">执行软中断的时机</span></span><ul><li><span class="name"><span class="innerContentContainer">从一个 isr 返回时;</span></span></li><li><span class="name"><span class="innerContentContainer">在 ksoftirqd 内核线程中;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">在那些显式执行待处理的软中断的代码, 比如网络子系统就是自行重复触发的.</span></span></li><li><span class="name"><span class="innerContentContainer">不管哪种方式, 软中断都在 do_softirq() 中. </span></span></li><li><span class="name"><span class="innerContentContainer">do_softirq() 会遍历寻找所有待处理的软中断, 并根据其优先级依次调用其处理函数.</span></span></li><li><span class="name"><span class="innerContentContainer">目前, 只有网络和SCSI 两个子系统直接使用软中断. </span></span></li><li><span class="name"><span class="innerContentContainer">此外, 内核定时器和 tasklet 都是建立在软中断上的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软中断的类型 （同时也是其优先级，排在前面的优先级高）</span></span><ul><li><span class="name"><span class="innerContentContainer">HI_SOFTIRQ（高优先级的tasklet）</span></span></li><li><span class="name"><span class="innerContentContainer">TIMER_SOFTIRQ（内核定时器）</span></span></li><li><span class="name"><span class="innerContentContainer">NET_TX_SOFTIRQ（发送网络数据包）</span></span></li><li><span class="name"><span class="innerContentContainer">NET_RX_SOFTIRQ（接收网络数据包）</span></span></li><li><span class="name"><span class="innerContentContainer">BLOCK_SOFTIRQ（块设备？）</span></span></li><li><span class="name"><span class="innerContentContainer">BLOCK_IOPOLL_SOFTIRQ（块设备io池？）</span></span></li><li><span class="name"><span class="innerContentContainer">TASKLET_SOFTIRQ（tasklet）</span></span></li><li><span class="name"><span class="innerContentContainer">SCHED_SOFTIRQ</span></span></li><li><span class="name"><span class="innerContentContainer">HRTIMER_SOFTIRQ</span></span></li><li><span class="name"><span class="innerContentContainer">RCU_SOFTIRQ</span></span></li><li><span class="name"><span class="innerContentContainer">NR_SOFTIRQS</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软中断的使用方法</span></span><ul><li><span class="name"><span class="innerContentContainer">分配索引.</span></span></li><li><span class="name"><span class="innerContentContainer">注意, 由于其次序决定优先级, 所以不一定总是添加到列表的末尾.</span></span></li><li><span class="name"><span class="innerContentContainer">注册处理函数. 调用 open_softirq()</span></span><ul><li><span class="name"><span class="innerContentContainer">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span></span></li><li><span class="name"><span class="innerContentContainer">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span></span></li><li><span class="name"><span class="innerContentContainer">软中断处理程序执行时, 允许响应中断, 当前CPU的软中断被禁止, 但是其他CPU 仍可以执行别的软中断, 甚至是自身. 所以 ,软中断中使用全局变量会很麻烦 , 如果加锁来防止自身的并发执行, 那么软中断就没有任何使用的必要了.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">触发软中断</span></span><ul><li><span class="name"><span class="innerContentContainer">raise_softirq_irqoff(TASKLET_SOFTIRQ);</span></span></li><li><span class="name"><span class="innerContentContainer">raise_softirq(NET_TX_SOFTIRQ);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">触发的时机</span></span><ul><li><span class="name"><span class="innerContentContainer">在isr中触发软中断是最常见的形式. </span></span></li><li><span class="name"><span class="innerContentContainer">在这种情况下, isr 执行硬件设备的相关操作, 然后触发相应的软中断, 最后退出. </span></span></li><li><span class="name"><span class="innerContentContainer">内核执行完 isr 后, 马上就会调 do_softirq().</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tasklet</span></span><ul><li><span class="name"><span class="innerContentContainer">运行在中断上下文。</span></span></li><li><span class="name"><span class="innerContentContainer">tasklet 是通过软中断实现的。相当于软中断的二级扩展.</span></span></li><li><span class="name"><span class="innerContentContainer">tasklet是中断上下文, 不可睡眠.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工作队列(work queue)</span></span><ul><li><span class="name"><span class="innerContentContainer">工作队列可以把工作推后，交由一个<b>内核线程</b>去执行. 也就是说, 工作队列运行在<b>进程上下文</b>。</span></span><ul><li><span class="name"><span class="innerContentContainer">需要注意的是，尽管工作队列运行在进程上下文中，但它不能访问用户空间.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果推后执行的任务需要<b>睡眠</b>，那么就选择工作队列。如果推后执行的任务不需要睡眠，那么就选择tasklet。</span></span></li><li><span class="name"><span class="innerContentContainer">工作用&lt;linux/workqueue.h&gt;中定义的work_struct结构表示.</span></span></li><li><span class="name"><span class="innerContentContainer">这些结构被连接成链表。当一个工作者线程被唤醒时，它会执行它的链表上的所有工作。工作被执行完毕，它就将相应的work_struct对象从链表上移去。当链表上不再有对象的时候，它就会继续休眠。</span></span></li><li><span class="name"><span class="innerContentContainer">构建工作队列</span></span><ul><li><span class="name"><span class="innerContentContainer">可通过DECLARE_WORK在编译时静态地建该结构：</span></span><ul><li><span class="name"><span class="innerContentContainer">DECLARE_WORK(name,&nbsp;void&nbsp;(*func) (void*),&nbsp;void&nbsp;*data);</span></span></li><li><span class="name"><span class="innerContentContainer">这样就会静态地创建一个名为name，待执行函数为func，参数为data的work_struct结构。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">也可以动态的构建:</span></span><ul><li><span class="name"><span class="innerContentContainer">INIT_WORK(struct&nbsp;work_struct *work, woid(*func) (void&nbsp;*),&nbsp;void&nbsp;*data);  // 这会动态地初始化一个由work指向的工作。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">指定工作队列中待执行的函数</span></span><ul><li><span class="name"><span class="innerContentContainer">待执行的函数的原型是： void&nbsp;work_handler(void*data)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对工作进行调度</span></span><ul><li><span class="name"><span class="innerContentContainer">想要把给定工作的待处理函数提交给缺省的events工作线程，只需调用</span></span><ul><li><span class="name"><span class="innerContentContainer">schedule_work(&amp;work)；</span></span></li><li><span class="name"><span class="innerContentContainer">work马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">有时候并不希望工作马上就被执行，而是希望它经过一段延迟以后再执行。在这种情况下，可以调度它在指定的时间执行：</span></span><ul><li><span class="name"><span class="innerContentContainer">schedule_delayed_work(&amp;work,delay);</span></span></li><li><span class="name"><span class="innerContentContainer">这时，&amp;work指向的work_struct直到delay指定的时钟节拍用完以后才会执行。</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">临界区</span></span><ul><li><span class="name"><span class="innerContentContainer">中断不能用临界区的原因</span></span><ul><li><span class="name"><span class="innerContentContainer">如果中断要访问的临界区正在被进程使用，则中断会被进程阻塞，会导致系统的不稳定。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">临界区的概念</span></span><ul><li><span class="name"><span class="innerContentContainer">首先临界区是个资源，该资源不允许并发访问，一个时间只允许一个任务使用。</span></span></li><li><span class="name"><span class="innerContentContainer">一个模块中访问临界资源的那段代码叫临界区。</span></span></li><li><span class="name"><span class="innerContentContainer">为了保护临界资源，要求不同任务互斥的访问临界区。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">临界区之死锁问题</span></span><ul><li><span class="name"><span class="innerContentContainer">如果两个进程互相持有对方要的临界区，那么就出现死锁问题。</span></span></li><li><span class="name"><span class="innerContentContainer">解决办法</span></span><ul><li><span class="name"><span class="innerContentContainer">一个进程只允许进一个临界区；</span></span></li><li><span class="name"><span class="innerContentContainer">要求所有进程用同一个顺序进入临界区。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">临界区之饥饿问题</span></span><ul><li><span class="name"><span class="innerContentContainer">发生场景如下：三个进程，优先级A&gt;B&gt;C，C进临界区，B占据CPU，A想进临界区。</span></span></li><li><span class="name"><span class="innerContentContainer">显然，A被阻塞，C必须等B执行完，所以A反而需要等待低优先级B。这事不合理的。</span></span></li><li><span class="name"><span class="innerContentContainer">解决方法：优先级反转，临时将占据临界区的进程优先级提高。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">异常</span></span><ul><li><span class="name"><span class="innerContentContainer">异常由 CPU 产生(换句话说, 是软件产生)。</span></span></li><li><span class="name"><span class="innerContentContainer">大部分由于当前运行代码出现问题导致, 比如除零异常, 缺页异常, 以及系统调用异常.</span></span></li><li><span class="name"><span class="innerContentContainer">异常和中断</span></span><ul><li><span class="name"><span class="innerContentContainer">异常和中断的处理非常类似. 而且又因为异常要考虑与处理器时钟同步，异常常被称为同步中断.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">进程间通讯机制</span></span><ul><li><span class="name"><span class="innerContentContainer">管道（pipe）</span></span><ul><li><span class="name"><span class="innerContentContainer">用于有亲缘关系的进程间的通讯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">命名管道（named pipe）</span></span><ul><li><span class="name"><span class="innerContentContainer">除有管道的一切功能外，还允许无亲缘关系的进程间的通讯（因为有名字）。、</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">信号（signal）</span></span><ul><li><span class="name"><span class="innerContentContainer">信号实现较复杂。用于通知进程有某事发生。接口为sigal和sigaction，两者兼容。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">消息队列（message）</span></span><ul><li><span class="name"><span class="innerContentContainer">信号能承载的信息少，管道只能承载无符号字节流，为克服这两种不足，设计了消息队列，可以存放多个且格式化的信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">共享内存</span></span><ul><li><span class="name"><span class="innerContentContainer">使得多个进程可以访问同一个内存空间，是最快的IPC实现方式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">信号量（semaphore）</span></span><ul><li><span class="name"><span class="innerContentContainer">主要作为进程间同步手段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">socket</span></span><ul><li><span class="name"><span class="innerContentContainer">更为一般的IPC方式。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">统一编址</span></span><ul><li><span class="name"><span class="innerContentContainer">arm将ram、rom、mpu、硬件寄存器、外设上的储存单元，统一放在同一个内存地址空间。</span></span></li><li><span class="name"><span class="innerContentContainer">mpu：Memory Protection Unit</span></span><ul><li><span class="name"><span class="innerContentContainer">相当于裁剪了的mmu，最大支持8个region。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">mmu：内存管理单元，负责管理内存的硬件。</span></span><ul><li><span class="name"><span class="innerContentContainer">功能包括：虚存到物理地址的转换、内存保护、对cache的管理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">参考文档见 ARM software interface。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存0地址禁止访问</span></span><ul><li><span class="name"><span class="innerContentContainer">为了捕捉空指针，将从0开始的若干K的地址空间设置为禁止访问。</span></span></li><li><span class="name"><span class="innerContentContainer">这是一个优雅的设计。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">arm的跳转指令只有26B的寻址空间</span></span><ul><li><span class="name"><span class="innerContentContainer">因此，链接两个较大.o文件，经常失败。</span></span></li><li><span class="name"><span class="innerContentContainer">解决办法是把函数调用改成函数指针调用。</span></span></li><li><span class="name"><span class="innerContentContainer">在汇编下可看到两种方式的不同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟内存</span></span><ul><li><span class="name"><span class="innerContentContainer">是一种内存管理的技术，核心点有两个：</span></span></li><li><span class="name"><span class="innerContentContainer">将多个物理内存碎片，整合为一个连续的地址空间；</span></span></li><li><span class="name"><span class="innerContentContainer">还可以将部分内存交换到外存中，在需要时再交换进内核。</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟内存的优势</span></span><ul><li><span class="name"><span class="innerContentContainer">提高物理内存的使用效率，使得大型程序的编写更简单。</span></span></li><li><span class="name"><span class="innerContentContainer">支持多任务。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存页式管理</span></span><ul><li><span class="name"><span class="innerContentContainer">现代os中，内存以页的方式管理。</span></span></li><li><span class="name"><span class="innerContentContainer">每页大小位2的n次方，一般为4K。</span></span></li><li><span class="name"><span class="innerContentContainer">对于4K的页，地址尾部的12位作为页内偏移量，其余位为页号（虚拟页号）。</span></span></li><li><span class="name"><span class="innerContentContainer">mmu负责虚拟页号转换为物理页号，这个过程要map（映射）。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有找到，则产生缺页异常（page fault）。</span></span></li><li><span class="name"><span class="innerContentContainer">缺页处理</span></span><ul><li><span class="name"><span class="innerContentContainer">将尝试找空白页，并建立页表项，并将外存上的数据load到内存。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有空白页，则找最旧的页，将其原内容保存到外存，然后释放其空间再使用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存页用页表项来管理。包括如下字段：</span></span><ul><li><span class="name"><span class="innerContentContainer">脏位</span></span></li><li><span class="name"><span class="innerContentContainer">存取位（标识最后访问时间）</span></span></li><li><span class="name"><span class="innerContentContainer">mode（用户态还是核心态）</span></span></li><li><span class="name"><span class="innerContentContainer">是否被cache</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel的swap方案</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种方案：交换分区和交换文件。</span></span></li><li><span class="name"><span class="innerContentContainer">分区方式效率更高，因为文件是非连续的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">linux内存管理api</span></span><ul><li><span class="name"><span class="innerContentContainer">set_page_address() 和 page_address()，只针对高端内存。</span></span></li><li><span class="name"><span class="innerContentContainer">ioremap()   // 内存分配，地址是虚地址</span></span></li><li><span class="name"><span class="innerContentContainer">phys_to_page() / virb_to_page()   // 虚地址和实地址的互转</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">linux内存分配方法</span></span><ul><li><span class="name"><span class="innerContentContainer">SLUB方式。</span></span></li><li><span class="name"><span class="innerContentContainer">其调试宏为 CONFIG_SLUB_DEBUG=y，打开后有更详细的panic信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用内存分区</span></span><ul><li><span class="name"><span class="innerContentContainer">code区</span></span><ul><li><span class="name"><span class="innerContentContainer">又叫text段。存放代码本身。</span></span></li><li><span class="name"><span class="innerContentContainer">如果程序试图写这个区域，会产生一个P abort异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ro区</span></span><ul><li><span class="name"><span class="innerContentContainer">又叫常量段。存放只读数据，常量放在这里。</span></span></li><li><span class="name"><span class="innerContentContainer">如果程序试图写这里，会产生一个D abort异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">rw区</span></span><ul><li><span class="name"><span class="innerContentContainer">又叫数据段。存放初始化为非零值的全局变量和静态变量。</span></span></li><li><span class="name"><span class="innerContentContainer">这些变量在code区另有一个映像，即内存中会有两份。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">zi区</span></span><ul><li><span class="name"><span class="innerContentContainer">又叫BSS段。存放初始化为零的全局变量和静态变量。</span></span></li><li><span class="name"><span class="innerContentContainer">在代码中只保留zi区的大小，运行时再展开，系统会自动间这个区域初始化为全零。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">nzi区</span></span><ul><li><span class="name"><span class="innerContentContainer">重启时这段区域不做清零处理。目前只有diagdiag_nzi.c&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">堆栈区：其它都是堆栈。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">文件系统  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/c365fbe9a586">https://workflowy.com/#/c365fbe9a586</a></span></span></li><li><span class="name"><span class="innerContentContainer">设备管理 (也叫IO管理)</span></span><ul><li><span class="name"><span class="innerContentContainer">设备大致分为<b>块设备</b>(block device) 和 <b>字符设备</b>(character device).</span></span><ul><li><span class="name"><span class="innerContentContainer">块设备: 把数据存储在固定长度的块中, 每块有自己的地址. 一般块大小在512B-16K之间. </span></span><ul><li><span class="name"><span class="innerContentContainer">块设备的基本特征是能独立的读写单个块.</span></span></li><li><span class="name"><span class="innerContentContainer">典型的块设备比如硬盘, SD卡.</span></span></li><li><span class="name"><span class="innerContentContainer">从本质上讲，字符设备和块设备其实只有接口不同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符设备: 以字符为单位发送或接收一个字符流, 不考虑任何块结构.</span></span><ul><li><span class="name"><span class="innerContentContainer">象文件一样、可以按字节流访问的设备。</span></span></li><li><span class="name"><span class="innerContentContainer">其驱动程序通常需要open、close、read和write等接口。</span></span></li><li><span class="name"><span class="innerContentContainer">字符设备不编址, 也不寻址.</span></span></li><li><span class="name"><span class="innerContentContainer">典型的字符设备比如显示器, 网卡, 鼠标. 大部分非存储的设备, 都是字符设备.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络设备较特殊, 单独列. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">还有另外一种分类方法，即根据总线类型分，比如USB、串行设备、SCSI、I2C、FireWire等。</span></span><ul><li><span class="name"><span class="innerContentContainer">内核一般会提供这类设备的附加层，比如USB驱动层，实现其共有特性，从而降低特定设备的驱动开发者的工作量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主设备号和次设备号</span></span><ul><li><span class="name"><span class="innerContentContainer">在/dev 下执行 ls -l，可以列出当前系统的设备文件，其中第一个字母为c的表示字符设备，b表示块设备。另外，还可以看到两个数字，表示主设备号和次设备号。</span></span></li><li><span class="name"><span class="innerContentContainer">主设备号对应相应的驱动程序。多数设备按照一个主设备号对应一个驱动程序的原则来组织。</span></span></li><li><span class="name"><span class="innerContentContainer">次设备号由内核使用，和设备文件一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">dev_t类型</span></span><ul><li><span class="name"><span class="innerContentContainer">用来存储设备编号。在2.6.0的内核中，它是32bit，其中前12bit表示主设备号，后20bit表示次设备号。</span></span></li><li><span class="name"><span class="innerContentContainer">获取主次设备号的宏：</span></span><ul><li><span class="name"><span class="innerContentContainer">MAJOR(dev_t dev);</span></span></li><li><span class="name"><span class="innerContentContainer">MINOR(dev_t dev);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将主次设备号转化为dev_t类型，使用 MKDEV(int major, iint minor);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">存储器映像IO</span></span><ul><li><span class="name"><span class="innerContentContainer">部分系统把设备控制器上的存储空间(寄存器和cache), 作为通用存储器地址空间的一部分.</span></span></li><li><span class="name"><span class="innerContentContainer">又叫统一编址.</span></span></li><li><span class="name"><span class="innerContentContainer">这个映射关系是CPU硬件具体映射关系参见芯片的软硬件接口规格.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>DMA</b>: direct memory access, 直接存储器访问</span></span><ul><li><span class="name"><span class="innerContentContainer">很多<b>块设备</b>支持DMA模式.</span></span></li><li><span class="name"><span class="innerContentContainer">没有DMA时, 磁盘如何读?</span></span><ul><li><span class="name"><span class="innerContentContainer">1. CPU向磁盘控制器发出读指令, 同时提供读的磁盘地址.</span></span></li><li><span class="name"><span class="innerContentContainer">2. 控制器从磁盘驱动器串行地一位一位的读一个快(或者一个扇区, sector), 直到把整块信息放入控制器的内部缓冲区中去.</span></span></li><li><span class="name"><span class="innerContentContainer">3. 控制器计算校验和, 以确保没有读错误发生.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 控制器产生一个中断, 提醒CPU.</span></span></li><li><span class="name"><span class="innerContentContainer">5. 操作系统收到中断, 进入isr. 它重复的从缓冲区中一次一个字节的读取该块的数据, 并把它存入通用存储器中.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DMA针对的是第四部. 因为这一步浪费了CPU时间.</span></span></li><li><span class="name"><span class="innerContentContainer">有DMA时, 磁盘如何读?</span></span><ul><li><span class="name"><span class="innerContentContainer">1. CPU除了向控制器提供读块的磁盘地址外, 还需要向控制器提供两个信息: 读出块要送往内存的起始地址和要传输的字节数.</span></span></li><li><span class="name"><span class="innerContentContainer">2. 控制器将整个块从设备读入其内部缓冲区, 并进行校验. (即上面的2和3)</span></span></li><li><span class="name"><span class="innerContentContainer">3.  控制器将缓冲区的第一个字节拷贝到指定的通用存储器的地址上. 然后分别对DMA地址和DMA计算器进行步增和步减的操作, 重复, 直到DMA计数变成零.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 控制器发中断信号. 此时操作系统不需要拷贝数据了, 因为数据已经在内存中.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动模块入口是: module_init().</span></span></li><li><span class="name"><span class="innerContentContainer">驱动子系统入口是: subsys_initcall()。</span></span></li><li><span class="name"><span class="innerContentContainer">volatile 关键字</span></span><ul><li><span class="name"><span class="innerContentContainer">在向总线上写数据的时候，总线的地址指针和数据指针必须用volatile进行定义。</span></span></li><li><span class="name"><span class="innerContentContainer">以防止编译过程中将某些数据的写入步骤给优化掉。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Shell</span></span><ul><li><span class="name"><span class="innerContentContainer">命令行界面参见"LinuxBash"</span></span></li><li><span class="name"><span class="innerContentContainer">GNOME: 图形用户桌面环境</span></span></li></ul></li></ul>
  </body>
</html>