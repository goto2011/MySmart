<?xml version="1.0"?>
<opml version="2.0">
  <head>
    <ownerEmail>
      likecatbook@163.com
    </ownerEmail>
  </head>
  <body>
    <outline text="&lt;b&gt;01-Java&lt;/b&gt;">
      <outline text="#最小编程规范">
        <outline text="命名模板">
          <outline text="输出        out" />
          <outline text="输入	in" />
          <outline text="模板	template" />
          <outline text="执行/执行中	run/running" />
          <outline text="名称	name" />
          <outline text="密码	password  (不要用缩写psw，或者cipher等。)" />
          <outline text="序列号	id " />
          <outline text="读/写	read/write " />
          <outline text="特性	feature" />
          <outline text="版本	version" />
          <outline text="分支	branch" />
          <outline text="工程	project" />
          <outline text="驱动	driver" />
          <outline text="报告	report" />
          <outline text="模块	module" />
          <outline text="进程	process" />
          <outline text="线程	thread" />
          <outline text="参数	param" />
          <outline text="属性	attri" />
          <outline text="帮助	help" />
          <outline text="打印	print" />
          <outline text="测试代码	TEST_CODE" />
          <outline text="选择	choice" />
          <outline text="命令/脚本	cmd" />
          <outline text="日期/时间	date/time" />
          <outline text="间隔	inter/interval" />
          <outline text="修改	modify" />
          <outline text="按下	press  (点击鼠标也用press，不用 hit、beat 等。)" />
          <outline text="步骤	step" />
          <outline text="产生/新建/创建/制造/制作	make (不用build/create等；统一化)" />
          <outline text="拷贝	copy" />
          <outline text="升级/更新	update " />
          <outline text="编译	compile" />
          <outline text="发送/接受	send/receive" />
          <outline text="源/对象.目标	res/des (不要用source/destince。res/des 对比强烈，很醒目，出现在一起不会错。)" />
          <outline text="根	   root" />
          <outline text="关键	key (不要用keyword，显得累赘。)" />
          <outline text="邮件	mail (不用email)" />
          <outline text="存在性	exist" />
          <outline text="调试	debug  (不要缩写为dbg，影响可读性。)" />
          <outline text="库/基线	base  (不用 database)" />
          <outline text="备份/恢复	backup/resume  (backup可以缩写为back，但会影响可读性)" />
          <outline text="错误/警告/信息	Error:/Warn:/Info:" />
          <outline text="定制	custom" />
          <outline text="运营商/客户	vendor" />
          <outline text="待完成	// TODO:" />
          <outline text="检查	check  (不要使用review、examine、inspecte等。归一。)" />
          <outline text="分配	alloc" />
          <outline text="备注	remark" />
          <outline text="计数器	count" />
          <outline text="配置	config  (不要用options、setting等。归一。)" />
          <outline text="用户	user  (指代所有使用工具的人。不用 consumer、handler、operator、runner 等。归一。)" />
          <outline text="重启	reboot (不要用restart, reset等。归一。)" />
          <outline text="服务器/客户机	server/client" />
          <outline text="新/旧	new/old" />
          <outline text="开/关	open/close" />
          <outline text="取/设	get/set" />
          <outline text="控制	control" />
          <outline text="索引/序号	index" />
          <outline text="值	value" />
          <outline text="字体	font" />
          <outline text="颜色	color" />
          <outline text="文本	text" />
          <outline text="线条	line" />
          <outline text="长/高/重	length/height/weigh" />
          <outline text="开关/切换	switch" />
          <outline text="操作/处理/工作/任务/职责  job  (不要用 work、task、role等，归一。)" />
          <outline text="操作/处理/作用（动词性） handle  (不要用 work、operate、treate、do、deal、task等，归一。还要斟酌, 是不是用do更好。)" />
          <outline text="初始化	init" />
          <outline text="文件夹名  path (不用dir, folder等)" />
          <outline text="文件名     file  (不用 filename这种累赘表达)" />
          <outline text="标示	flag" />
          <outline text="自A到B	from_A_to_B" />
          <outline text="在某个平台上，基于某个平台	on   (不用over 或者 base。)" />
          <outline text="A和B	A_and_B" />
          <outline text="A作用于B	A_to_B" />
          <outline text="指针        ptr_" />
          <outline text="字符串    str_" />
          <outline text="局部变量	my_" />
          <outline text="全局变量	g_" />
          <outline text="指向自身	self_" />
          <outline text="接口	i_" />
          <outline text="多个	multi_" />
          <outline text="当前	cur_" />
          <outline text="上一个	last_" />
          <outline text="下一个	next_" />
          <outline text="开始	start_" />
          <outline text="结束	end_" />
          <outline text="之后	after_" />
          <outline text="之前	before_" />
          <outline text="自动化	auto_" />
          <outline text="是否	is_" />
          <outline text="是否使能	use_" />
          <outline text="原始	ori_" />
        </outline>
        <outline text="左括号 { 不独占一行;" />
        <outline text="包名: 全小写。请采用 com.公司名.模块名.子系统名.类名 方式." />
        <outline text="类名:各单词首字母大写;" />
        <outline text="方法名: 第一个单词小写, 其它单词首字母大写;" />
        <outline text="属性名: 前缀m, 各单词首字母大写;" />
        <outline text="局部变量:前缀 my, 各单词首字母大写." />
      </outline>
      <outline text="#代码组织方式">
        <outline text="java文件由如下部分组成: " />
        <outline text="包申明: 即申明自己是谁, 方便别人导入.  只能放在Java文件的第一行. 如: package com.imagescan.tools;  #面试题 " />
        <outline text="Java约定, 包名和文件路径保持一致.包名即 路径.类名/接口名." />
        <outline text="导入包: 即导入别的包, 方便在自己类中调用. 一般紧接着包申明.  #面试题">
          <outline text="包是java的一级概念. 将相关的类放到一个文件夹中, 这个文件夹就叫类包, 简称包." />
          <outline text="调用其它包中的类时, 需要先导入包, 然后在代码中直接用类名. " />
          <outline text="也可以在调用时使用完整的包名(不推荐)." />
          <outline text="编译器在寻址包名时, 会查找当前目录和系统环境变量 classpath 包含的目录." />
          <outline text="import java.util.Data;" />
          <outline text="可以使用通配符*, 比如: import java.util.*;" />
          <outline text="其中以 java/javax 开头的包为核心包, 以 com.org 开头的包为各组织提供的." />
          <outline text="Java编译器会默认导入jdk的java.lang包中的所有类, 其中定义了system/string/object/math等常用类,这些类不需要显式导入." />
        </outline>
        <outline text="接下来是类定义, 即普通代码." />
      </outline>
      <outline text="#类和对象">
        <outline text="java代码的基本组成单位是类, 所有代码都放在类中." />
        <outline text="java没有头文件." />
        <outline text="一个代码文件只能放一个 public 类, 文件名和该类名相同. " />
        <outline text="当一个文件中放多个类时, 其它类叫内部类, 内部类不能是 public 类." />
        <outline text="类的定义">
          <outline text="public class MyClass extends ParentClass {">
            <outline text="protected string money;" />
            <outline text="private int age;" />
            <outline text="int money;  // 默认是 private的" />
            <outline text="public void barking(){...}" />
          </outline>
          <outline text="}" />
          <outline text="关键字 extends 表示继承自其父类. 如果没有显式定义父类, 则默认继承自 Object类. 该类是java所有类的基类." />
        </outline>
        <outline text="程序的入口  #面试题 ">
          <outline text="是 public static void main(string[] args) {}." />
          <outline text="main()必须放在某个public类中, 它直接被java解析器调用. 用户代码不能调用." />
          <outline text="main()必须使用 public static void属性. 即它是静态方法, 使用规则见下." />
          <outline text="每个public类都可以有main(), 运行时用哪个为入口在编译器中指定. 一般用这个特性来做UT." />
        </outline>
        <outline text="构造函数">
          <outline text="类的构造函数会在new该类时被调用. 构造函数用于初始化一个类." />
          <outline text="构造函数和类名相同, 属性为 public void." />
          <outline text="如果没有显式定义构造函数, 则编译器会自动生成一个无参数的构造函数." />
          <outline text="一个类支持多个构造函数, 只要参数不同." />
        </outline>
        <outline text="析构函数">
          <outline text="java不需要析构函数, 但java垃圾回收只支持 new创造的对象, 某些类不是通过new生成, 那么就需要定义 finalize(), 它是 protected的." />
          <outline text="系统垃圾回收的时机不确定. java 提供system.gc()方法, 应用调用它可强制启动回收. 但并不是马上." />
        </outline>
        <outline text="&lt;b&gt;静态类&amp;amp;静态区域&amp;amp;静态方法  #面试题&lt;/b&gt;">
          <outline text="static表示静态的意思." />
          <outline text="static 修饰类, 表示它是&lt;b&gt;静态类&lt;/b&gt;, 常用于工具类, 不需要new可直接用. ">
            <outline text="静态类跟静态方法一样, 只能访问类的静态成员." />
          </outline>
          <outline text="用 static {} 定义类的静态区域, 位于所有方法之外, 一般放在类的最开始.">
            <outline text="静态区域在类加载时被调用, 只执行一次.一般用于类的静态成员的初始化." />
            <outline text="它不能被代码主动调用. " />
            <outline text="可以多个, 但不建议." />
          </outline>
          <outline text="static修饰方法, 表示静态方法. ">
            <outline text="如: public static void myFunc(){}" />
            <outline text="静态方法又叫类方法, 不需要new一个类就可直接调用它. 如 MyClass.myFunc()." />
            <outline text="类方法只能访问类的其它类方法和静态属性, 如果要访问类的其它资源, 则需要new这个类." />
          </outline>
        </outline>
        <outline text="&lt;b&gt;final 关键字  #面试题&lt;/b&gt;">
          <outline text="final 表示最终的, 不可改变的意思. " />
          <outline text="修饰类, 表示该类不可被继承. " />
          <outline text="修饰方法, 表示该方法不可被子类的方法覆盖, 也不支持重载. 所有 private 方法隐含带 final 属性. 而且 final类中的方法默认为final的.">
            <outline text="final 不可以修饰构造方法." />
          </outline>
        </outline>
        <outline text="&lt;b&gt;abstract 关键字  #面试题&lt;/b&gt;">
          <outline text="abstract 和 final 有反义词的意思." />
          <outline text="修饰类, 表示&lt;b&gt;抽象类&lt;/b&gt;. 抽象类不可实例化, 只能被继承. 但它可以作为对象类型. ">
            <outline text="继承抽象类必须重写所有抽象方法." />
            <outline text="一个类只要有一个抽象方法, 那它就是抽象类, 不可实例化, 只能实例化它的子类." />
            <outline text="抽象类可以不包含任何抽象方法." />
            <outline text="抽象类不能定义 final方法." />
          </outline>
          <outline text="修饰方法, 表示&lt;b&gt;抽象方法&lt;/b&gt;. 子类必须重写所有抽象方法." />
        </outline>
        <outline text="&lt;b&gt;构造代码块&lt;/b&gt;">
          <outline text="格式: {...}, 放在函数外. 一般为函数最开始." />
          <outline text="构造块的作用是给类的多个对象的共性部分进行初始化." />
          <outline text="对象一建立就会运行构造块, 而且优先于构造函数. 不能用代码调用构造块." />
          <outline text="构造块和构造函数的区别是: 构造块是给所有对象进行统一初始化, 而构造函数则是对特定对象进行初始化. 构造函数可以多个, 但构造块只有一个." />
        </outline>
        <outline text="&lt;b&gt;this指针&lt;/b&gt;">
          <outline text="this指向当前对象自身. 所以只能用于方法体内.  this不可用于静态方法和静态块." />
          <outline text="this常用于如下几个场景:">
            <outline text="成员变量和参数同名, 成员变量别屏蔽, 用this来引用成员变量." />
            <outline text="构造方法通过this来调用另一个构造方法, 如:">
              <outline text="Public MyClass() {">
                <outline text="this(0, “null&quot;);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="方法中返回当前实例的引用." />
          </outline>
        </outline>
        <outline text="&lt;b&gt;super 关键字&lt;/b&gt;">
          <outline text="super()   // 调用基类的构造方法, 只能放在构造方法的第一行." />
          <outline text="super.myFunc()  // 调用基类被覆盖的方法." />
        </outline>
        <outline text="接口的使用方法 #面试题 ">
          <outline text="// 定义接口" />
          <outline text="interface 接口名称 [extends 其他的接口名] {">
            <outline text="// 声明变量. 必须有初始化的值." />
            <outline text="// 抽象方法" />
          </outline>
          <outline text="}" />
          <outline text="// 使用接口" />
          <outline text="public class 类名 &lt;b&gt;implements &lt;/b&gt;接口名称 { ... }" />
          <outline text="类可以继承多个接口。" />
        </outline>
        <outline text="抽象类和接口的区别">
          <outline text="抽象类可以有构造方法，接口中不能有构造方法。" />
          <outline text="抽象类中可以有普通成员变量，接口中没有普通成员变量。" />
          <outline text="抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。" />
          <outline text="抽象类中的方法的权限可以多种，接口中的抽象方法只能是 public 类型的。" />
          <outline text="抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的。" />
          <outline text="一个类可以继承多个接口，但只能继承一个抽象类。" />
        </outline>
        <outline text="类的实例化过程">
          <outline text="父类中的static代码块，子类（即当前类）的static。" />
          <outline text="顺序执行父类的普通代码块。" />
          <outline text="父类的构造函数。" />
          <outline text="子类普通代码块。" />
          <outline text="子类的构造函数，按顺序执行。" />
          <outline text="子类方法的执行。" />
        </outline>
        <outline text="重载和重写的区别 #面试题 ">
          <outline text="重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型不做限制。" />
          <outline text="每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。" />
          <outline text="重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。" />
          <outline text="重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。" />
          <outline text="重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。" />
        </outline>
        <outline text="静态内部类 / 匿名内部类 / 内部类的关系 #面试题 ">
          <outline text="内部类">
            <outline text="成员内部类可访问外部类所有的方法和成员变量。" />
            <outline text="不能有静态的方法和成员变量。" />
            <outline text="持有外部类引用" />
          </outline>
          <outline text="静态内部类">
            <outline text="只能访问外部类的静态成员变量与静态方法。" />
            <outline text="静态内部类的非静态成员可访问外部类的静态变量，而不可访问外部类的非静态变量。" />
            <outline text="不持有外部类引用" />
          </outline>
          <outline text="匿名内部类">
            <outline text="没有类名，没有class关键字也没有extends和implements等关键字修饰。" />
            <outline text="类的定义和对象的实例化同时进行。" />
            <outline text="持有外部类引用" />
          </outline>
        </outline>
        <outline text="类加载器（ClassLoader）">
          <outline text="类加载器负责在运行时查找和装入类文件中的类。是一个重要的Java运行时系统组件。" />
          <outline text="类加载器包括：">
            <outline text="根加载器（BootStrap）">
              <outline text="一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；" />
              <outline text="JVM不会向Java程序提供对Bootstrap的引用。" />
            </outline>
            <outline text="扩展加载器（Extension）">
              <outline text="从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；" />
            </outline>
            <outline text="系统加载器（System）">
              <outline text="又叫应用类加载器，其父类是Extension。" />
              <outline text="它是应用最广泛的类加载器。" />
              <outline text="它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。" />
            </outline>
            <outline text="用户自定义类加载器（java.lang.ClassLoader的子类）。" />
          </outline>
          <outline text="类加载的过程">
            <outline text="创建一个字节数组读入.class文件；" />
            <outline text="产生与所加载类对应的Class对象，作为该类的数据访问入口。此时该对象还不可用。" />
            <outline text="当类被加载后就进入连接阶段，这一阶段包括">
              <outline text="验证：包括4种类型的验证：">
                <outline text="文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型." />
                <outline text="元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。" />
                <outline text="字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。" />
                <outline text="符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。" />
              </outline>
              <outline text="准备：为类的&lt;b&gt;静态变量&lt;/b&gt;分配内存并设置默认值。" />
              <outline text="解析：将符号引用替换为直接引用。" />
            </outline>
            <outline text="最后JVM对类进行初始化：">
              <outline text="如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；" />
              <outline text="如果类中存在初始化语句，就依次执行这些初始化语句。到这个阶段，才开始执行类中的代码。" />
            </outline>
          </outline>
        </outline>
      </outline>
      <outline text="#HelloWorld">
        <outline text="/* HelloWorld.java */" />
        <outline text="public Class HelloWorld{">
          <outline text="public static woid main(string arg[]) {">
            <outline text="System.out.println(“Hello, world!&quot;);" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="}" />
        <outline text="编译:  javac HelloWorld.java" />
        <outline text="java HelloWorld.java" />
      </outline>
      <outline text="#注释">
        <outline text="// 支持单行" />
        <outline text="/* 支持多行 */" />
      </outline>
      <outline text="#Log打印">
        <outline text="最简单的方式是 system.print.out() , err() 这样直接在控制台打印消息了。" />
        <outline text="java.util.logging ; 在JDK 1.4 版本之后，提供了日志的API ，可以往文件中写日志了。" />
        <outline text="log4j , 最强大的记录日志的方式。 可以通过配置 .properties 或是 .xml 的文件， 配置日志的目的地，格式等等。" />
        <outline text="log4j 是 apache 提供的库。下载路径http://logging.apache.org/log4j/1.2/download.html  .  例如:">
          <outline text="import org.apache.log4j.Logger;" />
          <outline text="import org.apache.log4j.PropertyConfigurator;" />
          <outline text="// 1. create log" />
          <outline text="Logger log = Logger.getLogger(TestLog4j.class);" />
          <outline text="// 2. get log config file" />
          <outline text="PropertyConfigurator.configure(&quot;log4j.properties&quot;);" />
          <outline text="// 3. start log.  还有 log.info, log.warn, log.fatal 等打印级别." />
          <outline text="log.debug(&quot;Here is some DEBUG&quot;);" />
          <outline text="log.error(&quot;Here is some ERROR&quot;);" />
        </outline>
        <outline text="commons-logging, 最综合和常见的日志记录方式， 经常是和log4j 结合起来使用。" />
        <outline text="打印堆栈">
          <outline text="+ (new Exception(&quot;&quot;)). printStackTrace();" />
        </outline>
      </outline>
      <outline text="#函数">
        <outline text="函数基本形式">
          <outline text="@ override" />
          <outline text="public void myFunc(Bundle savedData) {...}" />
          <outline text="其中: @ override, 表示该方法可以在子类中被覆盖." />
        </outline>
        <outline text="函数权限">
          <outline text="public: 可以被 其它类 调用;" />
          <outline text="friendly: 只能被 自身/子类/本包的其他类 调用." />
          <outline text="protect: 只能被自身/子类调用." />
          <outline text="private: 只能被自身调用." />
        </outline>
        <outline text="传值/传引用">
          <outline text="在Java里, 只有如下两种数据是按值传递:">
            <outline text="基本类型" />
            <outline text="按照下面这种定义方式的String, 就是直接使用双引号定义字符串方式：String str = “Java私塾”;" />
          </outline>
          <outline text="其它的都是按引用传递。" />
        </outline>
      </outline>
      <outline text="#整数">
        <outline text="整数">
          <outline text="int ii = 5;  // 32位整数" />
          <outline text="其它类型有: byte(8位), short(16位), long(64位)" />
        </outline>
        <outline text="枚举值">
          <outline text="public static enum MyType{">
            <outline text="ModeType1, ModeType2" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="自带字符串的枚举量">
          <outline text="private static HashMap&amp;lt;String, State&amp;gt; sStates = Maps.newHashMap();" />
          <outline text="public enum State {">
            <outline text="RUNNING(&quot;running&quot;)," />
            <outline text="STOPPING(&quot;stopping&quot;)," />
            <outline text="STOPPED(&quot;stopped&quot;)," />
            <outline text="RESTARTING(&quot;restarting&quot;);" />
            <outline text="&lt;b&gt;State&lt;/b&gt;(String state) {">
              <outline text="sStates.put(state, this);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
      </outline>
      <outline text="#布尔量">
        <outline text="boolean 只有两个值, true 和 false.  不能与整数进行转换." />
      </outline>
      <outline text="#浮点数">
        <outline text="float f = 2.3f;   // 占用4个字节, 32位, 取值范围从 10^-38 到 10^38, 和 -10^38到-10^-38之间. 后缀f必须要." />
        <outline text="double d = 2.3;   // 占用8个字节, 64位, 取值范围从 10^-308 到 10^308, 和 -10^308 到 -10^-308 之间. 小数默认是float类型." />
        <outline text="浮点数有精度限制, 不能用 == 比较两个浮点数." />
      </outline>
      <outline text="#常量">
        <outline text="常量用 final 修饰. 即不可改变的变量." />
        <outline text="需要在声明时给定初值。" />
        <outline text="常量一般也是全局变量和静态变量, 如: public final static double PI = 3.14159;" />
        <outline text="final也可以修饰局部变量, 用于避免变量被重新赋值." />
      </outline>
      <outline text="#全局变量">
        <outline text="全局变量用 public 修饰. 使用时用这样的: MyClass.myValue;" />
      </outline>
      <outline text="#静态变量">
        <outline text="静态变量用 static 修饰. 局部可见, 全局存在. 和c一样." />
      </outline>
      <outline text="#运算符表">
        <outline text="优先级按照从高到低的顺序书写，也就是优先级为1的优先级最高，优先级14的优先级最低。" />
        <outline text="1	() [] .	从左到右" />
        <outline text="2	! +(正) -(负) ~(非运算) ++ --	从右向左" />
        <outline text="3	* / %	从左向右" />
        <outline text="4	+(加) -(减)	从左向右" />
        <outline text="5	&amp;lt;&amp;lt; &amp;gt;&amp;gt;(算数右移) &amp;gt;&amp;gt;&amp;gt;(逻辑右移)	从左向右" />
        <outline text="6	&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= instanceof	从左向右" />
        <outline text="7	== !=	从左向右" />
        <outline text="8	&amp;amp;(按位与)	从左向右" />
        <outline text="9	^(异或)	从左向右" />
        <outline text="10	|	从左向右" />
        <outline text="11	&amp;amp;&amp;amp;	从左向右" />
        <outline text="12	||	从左向右" />
        <outline text="13	?:	从右向左" />
        <outline text="14	= += -= *= /= %= &amp;amp;= |= ^= ~= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;= &amp;gt;&amp;gt;&amp;gt;=	从右向左" />
      </outline>
      <outline text="#基本数据类型装箱  #面试题 ">
        <outline text="为了方便大家的习惯, java中有8种基础数据类型没有包装为类, 包括 byte/short/int/long/char/float/double/boolean. " />
        <outline text="基本数据类型可以直接使用, 不需要new. 如: int myInt = 500;" />
        <outline text="但是由于它们不是对象, 在序列化等场景下不太方便, 所以java提供了装箱类, 包括:">
          <outline text="byte -&amp;gt; Byte" />
          <outline text="boolean -&amp;gt; Boolean" />
          <outline text="short -&amp;gt; Short" />
          <outline text="char -&amp;gt; Character" />
          <outline text="int -&amp;gt; Integer" />
          <outline text="long -&amp;gt; Long" />
          <outline text="float -&amp;gt; Float" />
          <outline text="double -&amp;gt; Double" />
        </outline>
        <outline text="装箱">
          <outline text="即将基础类型包装为对象. 如:" />
          <outline text="int myInt = 500;" />
          <outline text="Integer myInt2 = new Integar(myInt);" />
          <outline text="一旦装箱, 其值就不可以更改." />
        </outline>
        <outline text="拆箱">
          <outline text="将对象转化为基础类. 如:" />
          <outline text="int myInt = myInt2.intValue();" />
        </outline>
        <outline text="装箱类支持 toString(). toString()是类方法, 所以不需要new一个对象就可以用. 如:">
          <outline text="String myStr = Interger.toString(500);" />
        </outline>
        <outline text="自动拆箱和装箱">
          <outline text="java在 1.5(5.0) 之后提供了自动拆箱和装箱功能, 语法和使用基本数据类型类似. 如:" />
          <outline text="Integer myInt = 500;" />
        </outline>
      </outline>
      <outline text="#指针和引用">
        <outline text="Java没有指针. 但是有引用." />
        <outline text="Java把引用作为默认调用方式, 所以并没有专门的运算符或关键字给引用." />
        <outline text="引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。" />
        <outline text="Java把引用分为4种 #面试题">
          <outline text="强引用">
            <outline text="只要引用还存在，GC就永远不会回收." />
            <outline text="Object obj = new Object(), obj 就是强引用。通过关键字new创建的对象所关联的引用就是强引用。" />
            <outline text="当JVM内存空间不足，JVM宁愿抛出 OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会回收具有强引用的“存活”对象。" />
            <outline text="强引用是全局变量时, 需要通过 obj = null; 来释放." />
            <outline text="强应用是局部变量时, 当所在代码块运行完成后, 就会自动释放." />
          </outline>
          <outline text="软引用">
            <outline text="软引用当内存不足的时候才会回收。" />
            <outline text="软引用通过 SoftReference 类实现。" />
            <outline text="JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。" />
            <outline text="使用软引用对象之前需要判断对象是否还存活。" />
            <outline text="常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。" />
          </outline>
          <outline text="弱引用">
            <outline text="可有可无，GC时首先被回收。" />
            <outline text="通过 WeakReference 类实现。" />
            <outline text="每次GC时都会直接回收弱引用对象。" />
            <outline text="由于GC进程的优先级较低，所以弱引用对象并不是很快就会被回收。" />
            <outline text="弱应用同样可用于内存敏感的缓存。" />
          </outline>
          <outline text="虚引用">
            <outline text="最弱的一种引用，回收时机未知。当程序需要知道某个对象是否已经被垃圾回收时，可以使用虚引用。" />
            <outline text="通过 PhantomReference 类来实现。" />
            <outline text="无法通过虚引用访问对象的任何属性或函数。" />
            <outline text="当虚引用已经被放到引用队列，则其指向的对象已经被垃圾回收。" />
          </outline>
        </outline>
      </outline>
      <outline text="#对象判空">
        <outline text="对象判空: if (myObject != null) {…}" />
        <outline text="NullObject模式: 整一个NullObject与原有对象实现相同的接口或继承同一个父类. 目的是让调用者不需要判空.  要补充代码." />
      </outline>
      <outline text="#对象的元属性">
        <outline text="得到当前方法的名字">
          <outline text="String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();" />
        </outline>
        <outline text="返回类名/类类型/接口名">
          <outline text="forName(&quot;类名&quot;)   // 返回一个Class对象的引用. 用于类没有加载时加载它." />
          <outline text="getName() // 返回包含包名的类名." />
          <outline text="getSimpleName() // 返回不包含包名的类名." />
          <outline text="getCanonicalName()  // 返回全限定类名." />
          <outline text="getInterface()  // 返回全限定的接口." />
          <outline text="getSuperClass() // 返回直接父类" />
        </outline>
        <outline text="instanceof 操作符">
          <outline text="用于判断当前类是否是指定类的之类." />
          <outline text="if (mySubObj instanceof myObj) {…}" />
        </outline>
        <outline text="获取包名和类名">
          <outline text="android中, 可通过 getPachageName() 获取包名, 通过 getClassName() 获取类名." />
        </outline>
        <outline text="类的class type对象">
          <outline text="Java把类的元属性也对象化了, 即 ClassType. 它是静态对象, 系统加载一个类时就会自动创建它的 ClassType 对象, 不需要手动创建. 其用法是:" />
          <outline text="已知类, 获取 Class 对象(推荐用这种):">
            <outline text="Class myClassType = myClass.Class;" />
          </outline>
          <outline text="已知对象, 获取其Class对象">
            <outline text="Class myClassType = myObject.getClass();" />
          </outline>
          <outline text="上面这两种的区别在于第二种只能由对象调用." />
          <outline text="通过类名字符串获取其Class对象">
            <outline text="Class myClassType = Class.forName(&quot;MyClassName&quot;);" />
          </outline>
        </outline>
        <outline text="对象判等">
          <outline text="用 == 比较两个对象, 实际对比的是两个对象的地址是不是相同, 即确认这两个对象是不是同一个, 而一般对象对比的初衷是对比两个不同的对象是否具有同样的属性." />
          <outline text="常用的是用 equals()来对比两个对象的值是否相同." />
          <outline text="java.io.file, java.util.Date, java.lang.string,包装类（Integer,Double等）等, 提供的比较规则为：如果两个对象的类型一致，并且值一致，则返回true,这些类有：" />
          <outline text="用户自定义的类, 要自己提供 equals()定义." />
        </outline>
        <outline text="对象比较">
          <outline text="Comparable接口">
            <outline text="类继承Comparable接口后，就必须实现 compareTo() 方法。" />
            <outline text="该方法用于约定对象的排序规则。" />
          </outline>
          <outline text="Comparator接口">
            <outline text="对于已经实现了Comparable接口的类，如何在不修改其代码的前提下改变它的排序规则呢？" />
            <outline text="使用Comparator接口。" />
          </outline>
        </outline>
        <outline text="深复制和浅复制  #面试题 ">
          <outline text="通过调用 clone() 复制一个现有的对象, 是快速生成一个对象的方式.">
            <outline text="MyClass myClass1 = new MyClass(23, &quot;zhang&quot;);" />
            <outline text="MyClass myClass2 = (MyClass) myClass1.clone();" />
          </outline>
          <outline text="复制的时候有两种方式: 深复制和浅复制." />
          <outline text="对于对象的基础数据类型成员, 无论哪种复制都是直接copy 副本. 但是对于对象成员, 浅复制只复制对象的引用. 深复制则复制对象的副本." />
          <outline text="clone()执行的是浅拷贝. 如果需要深拷贝, 则需要复写clone()." />
          <outline text="要复写clone(), 需要类 implements Cloneable." />
          <outline text="深复制要求在引用链上的每一级对象都要复写clone(), 显式的拷贝。所以它是相当麻烦的." />
        </outline>
        <outline text="RTTI (运行时对象类型识别, runtime type identification)">
          <outline text="在java中, 所有的类型转化都是在运行时进行正确性检查的." />
        </outline>
        <outline text="Class.newInstance()">
          <outline text="根据类的class对象new一个新对象." />
          <outline text="这是实现虚拟构造器的一种途径. 它允许你申明: 我不确切的知道类型, 先创建一个对象再说." />
          <outline text="newInstance() 创建的对象必须有默认的构造器." />
        </outline>
        <outline text="泛化引用">
          <outline text="Class 对象可指向任何类, 不方便在编译时识别出类型错误. 为弥补这一点, 可使用泛化引用来限定Class对象引用的类型, 方便编译器执行额外的类型检查." />
          <outline text="Class&amp;lt;MyClass&amp;gt; myClass = MyClass.class;   // MyClass 是泛化引用" />
        </outline>
        <outline text="&lt;b&gt;反射: 通过字符串进行函数调用  #面试题 &lt;/b&gt;">
          <outline text="通过ClassType 字符串实例化类">
            <outline text="Class&amp;lt;?&amp;gt; myClass = null;" />
            <outline text="myClass = class.forName(&quot;myClassType&quot;);" />
            <outline text="myObject = (myClassType)myClass.newInstance();" />
            <outline text="myClassType 中必须有无参数构造函数." />
          </outline>
          <outline text="获取构造方法(包括私有的)">
            <outline text="public Constructor getConstructor(Class… parameterTypes); // 获得指定的构造方法，注意只能获得 public 权限的构造方法" />
            <outline text="public Constructor getDeclaredConstructor(Class… parameterTypes);  // 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。" />
            <outline text="public Constructor[] getConstructors() throws SecurityException;   // 获得所有 public 访问权限的构造方法" />
            <outline text="public Constructor[] getDeclaredConstructors() throws SecurityException;  // 获得所有的构造方法，包括（public, private,protected,默认权限的）" />
            <outline text="例如: " />
            <outline text="public static void printConstructor(String className) {">
              <outline text="try {">
                <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                <outline text="&lt;b&gt;Constructor&lt;/b&gt;&amp;lt;?&amp;gt;[] constructors = aClass.&lt;b&gt;getConstructors&lt;/b&gt;();" />
                <outline text="print(constructors);" />
                <outline text="Constructor&amp;lt;?&amp;gt;[] declaredConstructors = aClass.&lt;b&gt;getDeclaredConstructors&lt;/b&gt;();" />
                <outline text="print(declaredConstructors);" />
              </outline>
              <outline text="} catch (ClassNotFoundException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="获取所有成员变量">
            <outline text="public static void printFiled(String className) {">
              <outline text="try {">
                <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                <outline text="Field[] fields = aClass.&lt;b&gt;getFields&lt;/b&gt;();" />
                <outline text="PrintUtils.print(fields);" />
                <outline text="Field[] declaredFields = aClass.&lt;b&gt;getDeclaredFields&lt;/b&gt;();" />
                <outline text="PrintUtils.print(declaredFields);" />
              </outline>
              <outline text="} catch (ClassNotFoundException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="获得指定成员变量">
            <outline text="public static Field getFiled(String className, String filedName) {">
              <outline text="Object o = null;" />
              <outline text="try {">
                <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                <outline text="Field declaredField = aClass.&lt;b&gt;getDeclaredField&lt;/b&gt;(filedName);" />
                <outline text="//   if not public,you should call this" />
                <outline text="declaredField.&lt;b&gt;setAccessible&lt;/b&gt;(true);" />
                <outline text="return declaredField;" />
              </outline>
              <outline text="} catch (ClassNotFoundException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="} catch (NoSuchFieldException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="}" />
              <outline text="return null;" />
            </outline>
            <outline text="}" />
            <outline text="调用方: Field field =getFiled(&quot;MyClassName&quot;, &quot;age&quot;);" />
          </outline>
          <outline text="获取所有方法">
            <outline text="public static void printMethods(String className) {">
              <outline text="try {">
                <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                <outline text="Method[] declaredMethods = aClass.&lt;b&gt;getDeclaredMethods&lt;/b&gt;();" />
                <outline text="PrintUtils.print(declaredMethods);" />
              </outline>
              <outline text="} catch (ClassNotFoundException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="执行指定方法">
            <outline text="public static void testMethod(){">
              <outline text="Person person=new Person();" />
              <outline text="Method method = &lt;b&gt;getMethod&lt;/b&gt;(CLASS_NAME, &quot;FunctionName&quot;, String.class);" />
              <outline text="try {">
                <outline text="// 执行方法，结果保存在 person 中" />
                <outline text="Object o = method.&lt;b&gt;invoke&lt;/b&gt;(person, CHINA);" />
                <outline text="// 拿到我们传递进取的参数 country 的值 China" />
                <outline text="String country = person.country;" />
                <outline text="PrintUtils.print(country);" />
              </outline>
              <outline text="} catch (IllegalAccessException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="} catch (InvocationTargetException e) {">
                <outline text="e.printStackTrace();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
      </outline>
      <outline text="#for循环">
        <outline text="for (ii = 0; ii &amp;lt; length; ii++) {...}  // 和C的语言一样" />
        <outline text="for (变量 * : 数组) {...}   效率较高, 建议使用. 如: ">
          <outline text="for (String myStr : myStrs) {...}   // myStrs是字符串数组. " />
          <outline text="变量类型和数组元素类型匹配." />
        </outline>
      </outline>
      <outline text="#where循环">
        <outline text="while (布尔表达式) {...}" />
        <outline text="do {...} while (布尔表达式)" />
        <outline text="break;   // 用于跳出里层的循环, 继续执行循环下面的语句. " />
        <outline text="continue;  // 用于跳出当次循环, 跳转到布尔表达式." />
      </outline>
      <outline text="#if和switch">
        <outline text="和c一样." />
      </outline>
      <outline text="#字符串">
        <outline text="#转义字符">
          <outline text="\&quot;: 双引号" />
          <outline text="\': 单引号 " />
          <outline text="\\: 反斜线 " />
          <outline text="\0: 空字符 " />
          <outline text="\r: 回车" />
          <outline text="\n: 换行" />
          <outline text="\t: table跳格" />
          <outline text="\u: Unicode码, 比如: $ =&amp;gt; \u0024; { =&amp;gt; \u007B." />
        </outline>
        <outline text="#字符串定义">
          <outline text="字符串对象String  #面试题 ">
            <outline text="String myString = new String(&quot;my string&quot;);" />
            <outline text="java语言中, &quot;my string&quot;这种标量, 本身就是String 对象, 由编辑器进行初始化." />
          </outline>
          <outline text="&lt;b&gt;可变字符串：StringBuffer 和 StringBuilder  #面试题 &lt;/b&gt;">
            <outline text="String字符串初始化后, 内容不能再改变. 将一个字符串变量指向新值, 则会new一个新的字符串对象, 原来的字符串会进入垃圾回收. 所以性能会比较差." />
            <outline text="如果字符串频繁变化, 这有必要使用 StringBuffer. 它的性能比 new一个新字符串对象要快很多.">
              <outline text="StringBuffer myStr = new StringBuffer(&quot;String init&quot;);" />
              <outline text="myStr.append(&quot;2st. string&quot;);" />
            </outline>
            <outline text="StringBuffer是线程安全的。因为 StringBuffer 有缓冲区。" />
            <outline text="可变字符串类 StringBuilder, 则是线程不安全的. 但它性能更快.">
              <outline text="StringBuilder的所有方法和 StringBuffer 都一样。" />
              <outline text="但是它们都没有被 synchronized 修饰, 所以性能高." />
              <outline text="StringBuilderJava 5中引入的. " />
            </outline>
          </outline>
          <outline text="三者在执行速度上：StringBuilder &amp;gt; StringBuffer &amp;gt; String (由于String是常量，不可改变，拼接时会重新创建新的对象)。" />
          <outline text="字符串和整型的相互转换">
            <outline text="String str = String.valueOf(2);" />
            <outline text="int i = Integer.parseInt(str); // 需要捕捉异常: NumberFormatException" />
          </outline>
          <outline text="字符Char --没必要用字符数组表达字符串">
            <outline text="Char myChar = 'a';    // 单引号是字符, 双引号是字符串." />
          </outline>
          <outline text="String 转化为 Char">
            <outline text="Char myChar = myString.charAt(index);" />
          </outline>
          <outline text="String 转化为 Char[]">
            <outline text="Char myChars[] = myString.toCharArray();" />
          </outline>
          <outline text="Char 转化为String">
            <outline text="String myString = String.valueOf('C');" />
          </outline>
        </outline>
        <outline text="#字符串判空">
          <outline text="if (myString.length() == 0)    // 空串" />
          <outline text="if (null == myString)     // 字符串对象没有初始化" />
        </outline>
        <outline text="#字符串取长">
          <outline text="myString.length();" />
        </outline>
        <outline text="#字符串比较" />
        <outline text="#字符串去空格">
          <outline text="myString.trim();   // 前后去空格" />
        </outline>
        <outline text="&lt;b&gt;#字符串拼接  #面试题&lt;/b&gt;">
          <outline text="字符串可通过 + 号连接, 这是最直观的.">
            <outline text="String是常量，不可改变，拼接时会重新创建新的对象." />
            <outline text="因此在大循环体内进行字符串拼接, 则可能出现海量的对象创建和销毁, 导致性能问题." />
            <outline text="解决办法是: 单线程下字符串的串联用StringBuilder，多线程下字符串的串联用StrngBuffer。" />
          </outline>
          <outline text="基本数据类型与字符串连接时, 会自动转化为字符串. " />
          <outline text="对象要自动转为字符串, 需要重载 toString() 方法." />
          <outline text="可变字符串&lt;b&gt;StringBuffer 和 StringBuilder, &lt;/b&gt;用 append() 来拼接." />
        </outline>
        <outline text="#字符串截取" />
        <outline text="#字符串查找" />
        <outline text="#字符串替换" />
        <outline text="#字符串拆分" />
        <outline text="#字符串的格式化输出" />
        <outline text="#正则表达式" />
      </outline>
      <outline text="#时间处理">
        <outline text="#获取系统时间">
          <outline text="System.currentTimeMillis();" />
        </outline>
        <outline text="#日期时间">
          <outline text="方法1: java.util.Date = java.text.DateFormat.getDateInstance().parse(date String);" />
          <outline text="方法2: SimpleDateFormat format = new SimpleDateFormat( &quot;dd.MM.yyyy&quot; );">
            <outline text="Date date = format.parse( myString );" />
          </outline>
          <outline text="把 Java util.Date 转成 sql.Date">
            <outline text="java.util.Date utilDate = new java.util.Date();" />
            <outline text="java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());" />
          </outline>
        </outline>
        <outline text="#时区" />
      </outline>
      <outline text="#数组">
        <outline text="#定义数组">
          <outline text="array 的size是固定的，不能动态改变，且一个array只能存放同一种数据类型。" />
          <outline text="array的创建">
            <outline text="&lt;b&gt;int[]&lt;/b&gt; myArray = new int[mySize];" />
            <outline text="int[] myArray = {value0, value1, ...};" />
            <outline text="或者: int myArray[];   // 可以用, 但不常见." />
          </outline>
          <outline text="java.util.Arrays 类能方便地操作数组. 它的函数都是静态函数, 不需要new." />
        </outline>
        <outline text="#遍历数据">
          <outline text="数组元素的访问方式, 最典型的是下标, 即 myArray[1];" />
          <outline text="int size = myArray.length;" />
          <outline text="for (int ii = 1; ii &amp;lt; size; ii++) {">
            <outline text="myArray[ii]...;" />
          </outline>
          <outline text="}" />
          <outline text="还有一种: " />
          <outline text="for(int value: myArray) {">
            <outline text="value...;" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="#取长">
          <outline text="myArray.size()" />
        </outline>
        <outline text="#数组元素的新增删除">
          <outline text="Java数组元素的数量是固定, 不能新增删除." />
        </outline>
        <outline text="#数组元素的查询">
          <outline text="public static int Arrays.binarySearch(Object[] a, Object key);" />
          <outline text="在排好序的array中寻找元素 (用折半排序, 时间成本是logN)。" />
          <outline text="如果查找值包含在数组中，则返回搜索键的索引；否则返回 - 1." />
        </outline>
        <outline text="#数组排序">
          <outline text="public static void Arrays.sort(Object[] a);" />
          <outline text="对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。" />
        </outline>
      </outline>
      <outline text="#异常处理">
        <outline text="#常见异常类型">
          <outline text="Java内置异常类 @iFile" />
        </outline>
        <outline text="#异常处理">
          <outline text="try {">
            <outline text="// 程序代码" />
          </outline>
          <outline text="} catch(ExceptionName e1) {">
            <outline text="// Catch 块：异常处理" />
          </outline>
          <outline text="} finally {">
            <outline text="// finally 块：无论如何都会被执行。即使try块中有return，在return之前，也会调用finally块。" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="#自定义异常">
          <outline text="所有异常都必须是 Throwable 的子类。" />
          <outline text="如果希望写一个检查性异常类，则需要继承 Exception 类。" />
          <outline text="如果希望写一个运行时异常类，那么需要继承 RuntimeException 类。" />
        </outline>
      </outline>
      <outline text="#内存管理">
        <outline text="#内存模型">
          <outline text="堆">
            <outline text="存放对象实例。new 出来的类实例在这里分配内存。" />
            <outline text="堆的大小由-Xms指定，默认是物理内存的1/64；最大值由-Xmx指定，默认是物理内存的1/4。" />
            <outline text="默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。">
              <outline text="比例可由 -XX:MinHeapFreeRatio 指定。" />
            </outline>
            <outline text="默认空余内存大于70%时，就会减少内存，直到-Xms设置的大小。">
              <outline text="比例可由 -XX:MaxHeapFreeRatio 指定。" />
            </outline>
          </outline>
          <outline text="虚拟机栈">
            <outline text="每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。" />
            <outline text="本地方法栈，则是为虚拟机使用到的Native方法服务。" />
            <outline text="如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError异常。" />
            <outline text="如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。" />
          </outline>
          <outline text="方法区">
            <outline text="存储已经加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。" />
            <outline text="该区内少发生垃圾回收。" />
          </outline>
          <outline text="程序计数器">
            <outline text="当前线程所执行的字节码的行号指示器。" />
          </outline>
        </outline>
        <outline text="#内存销毁 ">
          <outline text="finalize方法">
            <outline text="gc在销毁对象时，会回调finalize()方法。" />
            <outline text="通过重写finalize()，我们可以跟踪对象的销毁过程。" />
          </outline>
          <outline text="GC，Gabage Collection，垃圾收集。一般仅指对堆内存的回收。常见的算法有：">
            <outline text="Reference Counting" />
            <outline text="Mark Sweep">
              <outline text=".NET CLR 使用。" />
              <outline text="Java VM 使用。" />
            </outline>
            <outline text="Copy Collection" />
          </outline>
          <outline text="请求垃圾收集的API">
            <outline text="System.gc()" />
            <outline text="Runtime.getRuntime().gc()" />
          </outline>
          <outline text="GC分为：">
            <outline text="Minor GC">
              <outline text="通常发生在新生代的Eden区，在这个区的对象生存期短。" />
            </outline>
            <outline text="Full Gc / Major GC ">
              <outline text="发生在老年代" />
            </outline>
          </outline>
          <outline text="内存判定对象可回收的算法有两种机制：引用计数算法 和 可达性分析法。">
            <outline text="引用计数算法">
              <outline text="给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。" />
              <outline text="计数器变为0时，内存块就被释放。" />
              <outline text="实际上很少使用，因为它难以解决对象之间相互循环引用的问题。" />
            </outline>
          </outline>
          <outline text="可达性分析法">
            <outline text="通过一系列被称为 GCRoots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。" />
            <outline text="可作为GC Roots的对象主要有：">
              <outline text="栈帧中的本地变量" />
              <outline text="本地方法栈中Native方法引用的对象" />
              <outline text="方法区中类静态属性引用的对象" />
              <outline text="方法区中常量引用的对象" />
            </outline>
            <outline text="GC回收算法： 分代收集算法">
              <outline text="分代收集算法是当前商用虚拟机广泛采用的一种算法。" />
              <outline text="根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。" />
              <outline text="新生代：刚分配不久的对象生存期短，每次回收都会有大量对象死去。">
                <outline text="使用『复制算法』，只需复制少量存活对象即可。" />
                <outline text="复制算法要点：">
                  <outline text="把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。" />
                  <outline text="当这一块的内存用尽后，把还存活着的对象『复制』到另外一块上面，再将这一块内存空间一次清理掉。" />
                  <outline text="实现简单，运行高效。" />
                  <outline text="缺点：在对象存活率较高时就要进行较多的复制操作，效率将会变低。" />
                </outline>
              </outline>
              <outline text="老年代：分配时间较久后还活着的对象, 继续存活的概率较大。">
                <outline text="使用『标记—清理算法』或者『标记—整理算法』，只需标记较少的回收对象即可。" />
                <outline text="标记-清除算法：">
                  <outline text="首先『标记』出所有需要回收的对象，然后统一『清除』所有被标记的对象。" />
                  <outline text="标记和清除两个过程的效率都不高；" />
                  <outline text="而且清除之后会产生大量不连续的内存碎片。" />
                </outline>
                <outline text="标记-整理算法：">
                  <outline text="首先『标记』出所有需要回收的对象，然后进行『整理』，使得存活的对象都向一端移动，最后直接清理掉端边界以外的内存。" />
                  <outline text="标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片&quot;。" />
                </outline>
              </outline>
            </outline>
            <outline text="新生代如何进化成老年代？">
              <outline text="对象优先在新生代区中分配，若没有足够空间，触发GC；" />
              <outline text="特别大的对象，直接进入老年态；" />
              <outline text="如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1；" />
              <outline text="若年龄超过一定限制（15），则被晋升到老年态。" />
            </outline>
          </outline>
        </outline>
      </outline>
      <outline text="#文件系统">
        <outline text="#文件路径分隔符">
          <outline text="String sep = System.getProperty(&quot;file.separator&quot;);" />
          <outline text="myFile = new File('d:'+sep+&quot;study&quot;, &quot;data.txt&quot;);" />
        </outline>
        <outline text="#回车换行符">
          <outline text="System.getProperty(&quot;line.separator&quot;);" />
          <outline text="因为操作系统的不同，换行符操也不同：">
            <outline text="/r Mac" />
            <outline text="/n Unix/Linux" />
            <outline text="/r/n Windows" />
          </outline>
        </outline>
        <outline text="#文件夹和文件的存在性" />
        <outline text="#遍历文件夹">
          <outline text="File dir = new File(&quot;directoryName&quot;);" />
          <outline text="String[] children = dir.list();" />
          <outline text="if (children == null) {">
            <outline text="// Either dir does not exist or is not a directory" />
          </outline>
          <outline text="} else {">
            <outline text="for (int i=0; i &amp;lt; children.length; i++) {">
              <outline text="// Get filename of file or directory" />
              <outline text="String filename = children[i];" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="// It is also possible to filter the list of returned files." />
          <outline text="// This example does not return any files that start with `.'." />
          <outline text="FilenameFilter filter = new FilenameFilter() {">
            <outline text="public boolean accept(File dir, String name) {">
              <outline text="return !name.startsWith(&quot;.&quot;);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="children = dir.list(filter);" />
          <outline text="// The list of files can also be retrieved as File objects" />
          <outline text="File[] files = dir.listFiles();" />
          <outline text="// This filter only returns directories" />
          <outline text="FileFilter fileFilter = new FileFilter() {">
            <outline text="public boolean accept(File file) {">
              <outline text="return file.isDirectory();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="files = dir.listFiles(fileFilter);" />
        </outline>
        <outline text="#新建文件夹" />
        <outline text="#删除文件夹" />
        <outline text="#返回和修改当前路径" />
        <outline text="#创建文件" />
        <outline text="#读文件" />
        <outline text="#写文件">
          <outline text="向文件末尾添加内容">
            <outline text="BufferedWriter out = null;" />
            <outline text="try {">
              <outline text="out = new BufferedWriter(new FileWriter(”filename”, true));" />
              <outline text="out.write(”aString”);" />
            </outline>
            <outline text="} catch (IOException e) {">
              <outline text="// error processing code" />
            </outline>
            <outline text="} finally {">
              <outline text="if (out != null) {">
                <outline text="out.close();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="#返回文件长度" />
        <outline text="#文件改名改属性" />
        <outline text="#删除文件" />
        <outline text="#文件系统原语">
          <outline text="解析/读取XML 文件">
            <outline text="package net.viralpatel.java.xmlparser;" />
            <outline text="import java.io.File;" />
            <outline text="import javax.xml.parsers.DocumentBuilder;" />
            <outline text="import javax.xml.parsers.DocumentBuilderFactory;" />
            <outline text="import org.w3c.dom.Document;" />
            <outline text="import org.w3c.dom.Element;" />
            <outline text="import org.w3c.dom.Node;" />
            <outline text="import org.w3c.dom.NodeList;" />
            <outline text="public class XMLParser {">
              <outline text="public void getAllUserNames(String fileName) {">
                <outline text="try {">
                  <outline text="DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();" />
                  <outline text="DocumentBuilder db = dbf.newDocumentBuilder();" />
                  <outline text="File file = new File(fileName);" />
                  <outline text="if (file.exists()) {">
                    <outline text="Document doc = db.parse(file);" />
                    <outline text="Element docEle = doc.getDocumentElement();" />
                    <outline text="// Print root element of the document" />
                    <outline text="System.out.println(&quot;Root element of the document: &quot; + docEle.getNodeName());" />
                    <outline text="NodeList studentList = docEle.getElementsByTagName(&quot;student&quot;);" />
                    <outline text="// Print total student elements in document" />
                    <outline text="System.out.println(&quot;Total students: &quot; + studentList.getLength());" />
                    <outline text="if (studentList != null &amp;amp;&amp;amp; studentList.getLength() &amp;gt; 0) {">
                      <outline text="for (int i = 0; i &amp;lt; studentList.getLength(); i++) {">
                        <outline text="Node node = studentList.item(i);" />
                        <outline text="if (node.getNodeType() == Node.ELEMENT_NODE) {">
                          <outline text="System.out.println(&quot;=====================&quot;);" />
                          <outline text="Element e = (Element) node;" />
                          <outline text="NodeList nodeList = e.getElementsByTagName(&quot;name&quot;);" />
                          <outline text="System.out.println(&quot;Name: &quot; + nodeList.item(0).getChildNodes().item(0).getNodeValue());" />
                          <outline text="nodeList = e.getElementsByTagName(&quot;grade&quot;);" />
                          <outline text="System.out.println(&quot;Grade: &quot; + nodeList.item(0).getChildNodes().item(0).getNodeValue());" />
                          <outline text="nodeList = e.getElementsByTagName(&quot;age&quot;);" />
                          <outline text="System.out.println(&quot;Age: &quot; + nodeList.item(0).getChildNodes().item(0).getNodeValue());" />
                        </outline>
                        <outline text="}" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="} else {">
                      <outline text="System.exit(1);" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="} catch (Exception e) {">
                  <outline text="System.out.println(e);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
              <outline text="public static void main(String[] args) {">
                <outline text="XMLParser parser = new XMLParser();" />
                <outline text="parser.getAllUserNames(&quot;c:\\test.xml&quot;);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="创建 JSON 格式的数据文件">
            <outline text="import org.json.JSONObject;" />
            <outline text="..." />
            <outline text="JSONObject json = new JSONObject();" />
            <outline text="json.put(&quot;city&quot;, &quot;Mumbai&quot;);" />
            <outline text="json.put(&quot;country&quot;, &quot;India&quot;);" />
            <outline text="..." />
            <outline text="String output = json.toString();" />
          </outline>
          <outline text="创建ZIP和JAR文件">
            <outline text="import java.util.zip.*;" />
            <outline text="import java.io.*;" />
            <outline text="public class ZipIt {">
              <outline text="public static void main(String args[]) throws IOException {">
                <outline text="if (args.length &amp;lt; 2) {">
                  <outline text="System.err.println(&quot;usage: java ZipIt Zip.zip file1 file2 file3&quot;);" />
                  <outline text="System.exit(-1);" />
                </outline>
                <outline text="}" />
                <outline text="File zipFile = new File(args[0]);" />
                <outline text="if (zipFile.exists()) {">
                  <outline text="System.err.println(&quot;Zip file already exists, please try another&quot;);" />
                  <outline text="System.exit(-2);" />
                </outline>
                <outline text="}" />
                <outline text="FileOutputStream fos = new FileOutputStream(zipFile);" />
                <outline text="ZipOutputStream zos = new ZipOutputStream(fos);" />
                <outline text="int bytesRead;" />
                <outline text="byte[] buffer = new byte[1024];" />
                <outline text="CRC32 crc = new CRC32();" />
                <outline text="for (int i=1, n=args.length; i &amp;lt; n; i++) {">
                  <outline text="String name = args[i];" />
                  <outline text="File file = new File(name);" />
                  <outline text="if (!file.exists()) {">
                    <outline text="System.err.println(&quot;Skipping: &quot; + name);" />
                    <outline text="continue;" />
                  </outline>
                  <outline text="}" />
                  <outline text="BufferedInputStream bis = new BufferedInputStream(">
                    <outline text="new FileInputStream(file));" />
                  </outline>
                  <outline text="crc.reset();" />
                  <outline text="while ((bytesRead = bis.read(buffer)) != -1) {">
                    <outline text="crc.update(buffer, 0, bytesRead);" />
                  </outline>
                  <outline text="}" />
                  <outline text="bis.close();" />
                  <outline text="// Reset to beginning of input stream" />
                  <outline text="bis = new BufferedInputStream(new FileInputStream(file));" />
                  <outline text="ZipEntry entry = new ZipEntry(name);" />
                  <outline text="entry.setMethod(ZipEntry.STORED);" />
                  <outline text="entry.setCompressedSize(file.length());" />
                  <outline text="entry.setSize(file.length());" />
                  <outline text="entry.setCrc(crc.getValue());" />
                  <outline text="zos.putNextEntry(entry);" />
                  <outline text="while ((bytesRead = bis.read(buffer)) != -1) {">
                    <outline text="zos.write(buffer, 0, bytesRead);" />
                  </outline>
                  <outline text="}" />
                  <outline text="bis.close();" />
                </outline>
                <outline text="}" />
                <outline text="zos.close();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="使用NIO进行快速的文件拷贝">
            <outline text="public static void fileCopy( File in, File out) throws IOException {">
              <outline text="FileChannel inChannel = new FileInputStream( in ).getChannel();" />
              <outline text="FileChannel outChannel = new FileOutputStream( out ).getChannel();" />
              <outline text="try {" />
              <outline text="// inChannel.transferTo(0, inChannel.size(), outChannel);   // original -- apparently has trouble copying large files on Windows" />
              <outline text="// magic number for Windows, 64Mb - 32Kb)">
                <outline text="int maxCount = (64 * 1024 * 1024) - (32 * 1024);" />
                <outline text="long size = inChannel.size();" />
                <outline text="long position = 0;" />
                <outline text="while ( position &amp;lt; size) {">
                  <outline text="position += inChannel.transferTo( position, maxCount, outChannel );" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="} finally {">
                <outline text="if ( inChannel != null) {">
                  <outline text="inChannel.close();" />
                </outline>
                <outline text="}" />
                <outline text="if ( outChannel != null) {">
                  <outline text="outChannel.close();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="使用iText JAR生成PDF">
            <outline text="import java.io.File;" />
            <outline text="import java.io.FileOutputStream;" />
            <outline text="import java.io.OutputStream;" />
            <outline text="import java.util.Date;" />
            <outline text="import com.lowagie.text.Document;" />
            <outline text="import com.lowagie.text.Paragraph;" />
            <outline text="import com.lowagie.text.pdf.PdfWriter;" />
            <outline text="public class GeneratePDF {">
              <outline text="public static void main(String[] args) {">
                <outline text="try {">
                  <outline text="OutputStream file = new FileOutputStream(new File(&quot;C:\\Test.pdf&quot;));" />
                  <outline text="Document document = new Document();" />
                  <outline text="PdfWriter.getInstance(document, file);" />
                  <outline text="document.open();" />
                  <outline text="document.add(new Paragraph(&quot;Hello Kiran&quot;));" />
                  <outline text="document.add(new Paragraph(new Date().toString()));" />
                  <outline text="document.close();" />
                  <outline text="file.close();" />
                </outline>
                <outline text="} catch (Exception e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
      </outline>
      <outline text="#字典 #面试题">
        <outline text="#字典定义">
          <outline text="Map集合中的键对象不允许重复，也就说，任意两个键对象通过equals()方法比较的结果都是false.，但是可以将任意多个键独享映射到同一个值对象上。" />
          <outline text="标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap。" />
          <outline text="HashMap：Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。" />
          <outline text="LinkedHashMap： 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。" />
          <outline text="TreeMap ： 基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在 于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。" />
          <outline text="WeakHashMao ：弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。" />
          <outline text="IdentifyHashMap： : 使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计。" />
        </outline>
        <outline text="#字典size">
          <outline text="int size() ：返回集合中元素的数目" />
        </outline>
        <outline text="#判断元素存在性">
          <outline text="用 containsKey()和 containsValue() 测试 Map中是否包含某个“键”或“值”。" />
        </outline>
        <outline text="#字典遍历">
          <outline text="for (Map.Entry&amp;lt;Integer, String&amp;gt; entry : map.entrySet()) {">
            <outline text="// Map.entry&amp;lt;Integer,String&amp;gt; 映射项（键-值对）  有几个方法：用上面的名字entry " />
            <outline text="entry.getKey() ;entry.getValue(); entry.setValue();" />
            <outline text="//map.entrySet()  返回此映射中包含的映射关系的 Set视图。" />
            <outline text="System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot;+ entry.getValue());" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="#成员的新增删除">
          <outline text="Object &lt;b&gt;put&lt;/b&gt;(Object key, Object value)： 向集合中加入元素" />
          <outline text="Object remove(Object key)： 删除与KEY相关的元素" />
          <outline text="void putAll(Map t)：  将来自特定映像的所有元素添加给该映像" />
          <outline text="void clear()：从映像中删除所有映射" />
        </outline>
        <outline text="#查找key">
          <outline text="使用keySet()抽取key序列，将map中的所有keys生成一个Set。" />
        </outline>
        <outline text="#查找value">
          <outline text="Object get(Object key)：获得与关键字key相关的 value 。" />
          <outline text="使用values()抽取value序列，将map中的所有values生成一个Collection。" />
          <outline text="为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。" />
        </outline>
        <outline text="#排序" />
        <outline text="Android定制的字典类: SparseArray">
          <outline text="目的是节省内存开销. 方法是通过避免 基本数据类型的装箱操作." />
          <outline text="#字典定义">
            <outline text="SparseArray sparseArray = new SparseArray&amp;lt;&amp;gt;();    // 默认容量是10" />
            <outline text="SparseArray sparseArray = new SparseArray&amp;lt;&amp;gt;(capacity);  // 指定容量." />
          </outline>
          <outline text="#成员的新增删除">
            <outline text="sparseArray.put(int key,Student value);  // key永远是int型数据." />
            <outline text="sparseArray.remove(int key);" />
          </outline>
        </outline>
      </outline>
      <outline text="#UT" />
      <outline text="#平台兼容性" />
      <outline text="#泛型" />
      <outline text="#宏定义" />
      <outline text="集合">
        <outline text="Java的集合可以存放不同类型的对象. 但不能放基本数据类型." />
        <outline text="可以使用集合提供的ReadOnly方法，以只读方式来使用集合。该方法将返回一个集合的只读版本。" />
        <outline text="&lt;b&gt;Collection接口 #面试题 &lt;/b&gt;">
          <outline text="collection 定义集合的最基本的接口，List和Set都继承自&lt;b&gt;Collection接口.&lt;/b&gt;" />
          <outline text="boolean add(Object o) ：向集合中加入一个对象的引用" />
          <outline text="void clear()：删除集合中所有的对象，即不再持有这些对象的引用" />
          <outline text="boolean isEmpty() ：判断集合是否为空" />
          <outline text="boolean contains(Object o) ： 判断集合中是否持有特定对象的引用" />
          <outline text="boolean remove(Object o) ：从集合中删除一个对象的引用" />
          <outline text="int size() ：返回集合中元素的数目" />
          <outline text="Object[] toArray() ： 返回一个数组，该数组中包括集合中的所有元素" />
          <outline text="&lt;b&gt;Iterartor&lt;/b&gt; &lt;b&gt;iterator&lt;/b&gt;() ：返回一个Iterator对象，可以用来遍历集合中的元素. iterator&lt;b&gt; 接口定义了如下方法:&lt;/b&gt;">
            <outline text="hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true" />
            <outline text="next() ：返回下一个元素" />
            <outline text="remove()：从集合中删除上一个有next()方法返回的元素。" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;List&lt;/b&gt;: 可以自动扩展的列表. 可存放重复对象。 #面试题">
          <outline text="List接口主要实现类包括：">
            <outline text="ArrayList() : 代表长度可以改变的数组。可对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢。">
              <outline text="ListIterator只应该用来由后向前遍历 ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。" />
            </outline>
            <outline text="LinkedList(): 在实现中采用链表数据结构。插入和删除速度快，随机访问速度慢。">
              <outline text="具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法使得LinkedList可以当作堆栈、队列和双向队列使用。" />
            </outline>
          </outline>
          <outline text="List 的 get(int index) 方法放回集合中由参数index指定的索引位置的对象，下标从“0” 开始。" />
          <outline text="使用 迭代器（Iterator）遍历:">
            <outline text="Iterator it=list.iterator();" />
            <outline text="while(it.hashNext()){">
              <outline text="System.out.println(it.next());" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;Set&lt;/b&gt;: 没有重复的集合 #面试题 ">
          <outline text="set是最简单的一种集合，集合中的对象不存在重复，不按特定的方式排序。" />
          <outline text="set接口主要实现了两个实现类：" />
          <outline text="HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快. ">
            <outline text="存入HashSet的对象必须定义hashCode()。" />
          </outline>
          <outline text="TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。">
            <outline text="保存次序的set, 底层为树结构。" />
          </outline>
          <outline text="LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。">
            <outline text="在使用迭代器遍历Set时，结果会按元素插入的次序显示。" />
          </outline>
          <outline text="set具有与Collection完全一样的接口，没有任何额外的功能，实际上Set就是Collection,只是行为不同: set不保存重复的元素." />
        </outline>
        <outline text="TreeSet, TreeList, Tree** : 自动排序的组数" />
        <outline text="把 Array 转换成 Map">
          <outline text="import java.util.Map;" />
          <outline text="import org.apache.commons.lang.ArrayUtils;" />
          <outline text="public class Main {">
            <outline text="public static void main(String[] args) {">
              <outline text="String[][] countries = { { &quot;United States&quot;, &quot;New York&quot; }, { &quot;United Kingdom&quot;, &quot;London&quot; },">
                <outline text="{ &quot;Netherland&quot;, &quot;Amsterdam&quot; }, { &quot;Japan&quot;, &quot;Tokyo&quot; }, { &quot;France&quot;, &quot;Paris&quot; } }" />
              </outline>
              <outline text="Map countryCapitals = ArrayUtils.toMap(countries);" />
              <outline text="System.out.println(&quot;Capital of Japan is &quot; + countryCapitals.get(&quot;Japan&quot;));" />
              <outline text="System.out.println(&quot;Capital of France is &quot; + countryCapitals.get(&quot;France&quot;));" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="改变数组的大小">
          <outline text="private static Object resizeArray (Object oldArray, int newSize) {">
            <outline text="int oldSize = java.lang.reflect.Array.getLength(oldArray);" />
            <outline text="Class elementType = oldArray.getClass().getComponentType();" />
            <outline text="Object newArray = java.lang.reflect.Array.newInstance(">
              <outline text="elementType,newSize);" />
            </outline>
            <outline text="int preserveLength = Math.min(oldSize,newSize);" />
            <outline text="if (preserveLength &amp;gt; 0)">
              <outline text="System.arraycopy (oldArray,0,newArray,0,preserveLength);" />
            </outline>
            <outline text="return newArray;" />
          </outline>
          <outline text="}" />
        </outline>
      </outline>
      <outline text="媒体">
        <outline text="创建图片的缩略图">
          <outline text="private void createThumbnail(String filename, int thumbWidth, int thumbHeight, int quality, String outFilename)">
            <outline text="throws InterruptedException, FileNotFoundException, IOException {" />
            <outline text="// load image from filename" />
            <outline text="Image image = Toolkit.getDefaultToolkit().getImage(filename);" />
            <outline text="MediaTracker mediaTracker = new MediaTracker(new Container());" />
            <outline text="mediaTracker.addImage(image, 0);" />
            <outline text="mediaTracker.waitForID(0);" />
            <outline text="// use this to test for errors at this point: System.out.println(mediaTracker.isErrorAny());" />
            <outline text="// determine thumbnail size from WIDTH and HEIGHT" />
            <outline text="double thumbRatio = (double)thumbWidth / (double)thumbHeight;" />
            <outline text="int imageWidth = image.getWidth(null);" />
            <outline text="int imageHeight = image.getHeight(null);" />
            <outline text="double imageRatio = (double)imageWidth / (double)imageHeight;" />
            <outline text="if (thumbRatio &amp;lt; imageRatio) {">
              <outline text="thumbHeight = (int)(thumbWidth / imageRatio);" />
            </outline>
            <outline text="} else {">
              <outline text="thumbWidth = (int)(thumbHeight * imageRatio);" />
            </outline>
            <outline text="}" />
            <outline text="// draw original image to thumbnail image object and" />
            <outline text="// scale it to the new size on-the-fly" />
            <outline text="BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB);" />
            <outline text="Graphics2D graphics2D = thumbImage.createGraphics();" />
            <outline text="graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);" />
            <outline text="graphics2D.drawImage(image, 0, 0, thumbWidth, thumbHeight, null);" />
            <outline text="// save thumbnail image to outFilename" />
            <outline text="BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename));" />
            <outline text="JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);" />
            <outline text="JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage);" />
            <outline text="quality = Math.max(0, Math.min(quality, 100));" />
            <outline text="param.setQuality((float)quality / 100.0f, false);" />
            <outline text="encoder.setJPEGEncodeParam(param);" />
            <outline text="encoder.encode(thumbImage);" />
            <outline text="out.close();" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="抓屏程序">
          <outline text="import java.awt.Dimension;" />
          <outline text="import java.awt.Rectangle;" />
          <outline text="import java.awt.Robot;" />
          <outline text="import java.awt.Toolkit;" />
          <outline text="import java.awt.image.BufferedImage;" />
          <outline text="import javax.imageio.ImageIO;" />
          <outline text="import java.io.File;" />
          <outline text="public void captureScreen(String fileName) throws Exception {">
            <outline text="Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();" />
            <outline text="Rectangle screenRectangle = new Rectangle(screenSize);" />
            <outline text="Robot robot = new Robot();" />
            <outline text="BufferedImage image = robot.createScreenCapture(screenRectangle);" />
            <outline text="ImageIO.write(image, &quot;png&quot;, new File(fileName));" />
          </outline>
          <outline text="}" />
        </outline>
      </outline>
      <outline text="网络">
        <outline text="HTTP 代理设置">
          <outline text="System.getProperties().put(&quot;http.proxyHost&quot;, &quot;someProxyURL&quot;);" />
          <outline text="System.getProperties().put(&quot;http.proxyPort&quot;, &quot;someProxyPort&quot;);" />
          <outline text="System.getProperties().put(&quot;http.proxyUser&quot;, &quot;someUserName&quot;);" />
          <outline text="System.getProperties().put(&quot;http.proxyPassword&quot;, &quot;somePassword&quot;);" />
        </outline>
        <outline text="发送邮件">
          <outline text="import javax.mail.*;" />
          <outline text="import javax.mail.internet.*;" />
          <outline text="import java.util.*;" />
          <outline text="public void postMail(String recipients[ ], String subject, String message , String from) throws MessagingException {">
            <outline text="boolean debug = false;">
              <outline text="//Set the host smtp address" />
              <outline text="Properties props = new Properties();" />
              <outline text="props.put(&quot;mail.smtp.host&quot;, &quot;smtp.example.com&quot;);" />
            </outline>
            <outline text="// create some properties and get the default Session" />
            <outline text="Session session = Session.getDefaultInstance(props, null);" />
            <outline text="session.setDebug(debug);" />
            <outline text="// create a message" />
            <outline text="Message msg = new MimeMessage(session);" />
            <outline text="// set the from and to address" />
            <outline text="InternetAddress addressFrom = new InternetAddress(from);" />
            <outline text="msg.setFrom(addressFrom);" />
            <outline text="InternetAddress[] addressTo = new InternetAddress[recipients.length];" />
            <outline text="for (int i = 0; i &amp;lt; recipients.length; i++) {">
              <outline text="addressTo[i] = new InternetAddress(recipients[i]);" />
            </outline>
            <outline text="}" />
            <outline text="msg.setRecipients(Message.RecipientType.TO, addressTo);" />
            <outline text="// Optional : You can also set your custom headers in the Email if you Want" />
            <outline text="msg.addHeader(&quot;MyHeaderName&quot;, &quot;myHeaderValue&quot;);" />
            <outline text="// Setting the Subject and Content Type" />
            <outline text="msg.setSubject(subject);" />
            <outline text="msg.setContent(message, &quot;text/plain&quot;);" />
            <outline text="Transport.send(msg);" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="发送代数据的HTTP 请求">
          <outline text="import java.io.BufferedReader;" />
          <outline text="import java.io.InputStreamReader;" />
          <outline text="import java.net.URL;" />
          <outline text="public class Main {">
            <outline text="public static void main(String[] args) {">
              <outline text="try {">
                <outline text="URL my_url = new URL(&quot;http://coolshell.cn/&quot;);" />
                <outline text="BufferedReader br = new BufferedReader(new InputStreamReader(my_url.openStream()));" />
                <outline text="String strTemp = &quot;&quot;;" />
                <outline text="while(null != (strTemp = br.readLine())){" />
                <outline text="System.out.println(strTemp);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="} catch (Exception ex) {">
              <outline text="ex.printStackTrace();" />
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
      </outline>
      <outline text="设计模式">
        <outline text="单例 Singleton示例1  #面试题 ">
          <outline text="public class SimpleSingleton {">
            <outline text="private static SimpleSingleton singleInstance = new SimpleSingleton();" />
            <outline text="//Marking default constructor private" />
            <outline text="//to avoid direct instantiation." />
            <outline text="private SimpleSingleton() {" />
            <outline text="}" />
            <outline text="//Get instance for class SimpleSingleton" />
            <outline text="public static SimpleSingleton getInstance() {">
              <outline text="return singleInstance;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="单例 Singleton示例2  #面试题 ">
          <outline text="public enum SimpleSingleton {">
            <outline text="INSTANCE;" />
            <outline text="public void doSomething() {" />
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="//Call the method from Singleton:" />
          <outline text="SimpleSingleton.INSTANCE.doSomething();" />
        </outline>
      </outline>
      <outline text="Lamada表达式 #面试题 ">
        <outline text="λ表达式本质上是一个匿名方法。比如：">
          <outline text="public int add(int x, int y) {">
            <outline text="return x + y;" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="转成λ表达式后是这个样子: (int x, int y) -&amp;gt; x + y;" />
        <outline text="参数类型也可以省略：(x, y) -&amp;gt; x + y; //返回两数之和" />
        <outline text="或者 (x, y) -&amp;gt; { return x + y; }" />
        <outline text="可见λ表达式有三部分组成：参数列表，箭头（-&amp;gt;），以及一个表达式或语句块。" />
        <outline text="如果没有参数, 就省事了:  () -&amp;gt; { System.out.println(&quot;Hello Lambda!&quot;); }" />
        <outline text="如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：">
          <outline text="c -&amp;gt; { return c.size(); }" />
        </outline>
        <outline text="λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。">
          <outline text="Thread gaoDuanDaQiShangDangCi = new Thread( () -&amp;gt; {">
            <outline text="System.out.println(&quot;This is from an anonymous method (lambda exp).&quot;);" />
          </outline>
          <outline text="} );" />
          <outline text="并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。" />
        </outline>
        <outline text="更多高级的内容参见: https://www.jb51.net/article/104903.htm" />
      </outline>
      <outline text="Kotlin">
        <outline text="一个用于多平台应用的静态编程语言。非常年轻。" />
        <outline text="Kotlin完全兼容Java的语言，可以编译成Java字节码，支持在JVM上运行。" />
        <outline text="也可以编译成JavaScript，方便在没有JVM的设备上运行。" />
        <outline text="在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。" />
      </outline>
    </outline>
  </body>
</opml>