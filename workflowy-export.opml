<?xml version="1.0"?>
<opml version="2.0">
  <head>
    <ownerEmail>
      likecatbook@163.com
    </ownerEmail>
  </head>
  <body>
    <outline text="&lt;b&gt;Android  #Work&lt;/b&gt;">
      <outline text="&lt;b&gt;01-Java&lt;/b&gt;">
        <outline text="#最小编程规范">
          <outline text="命名模板">
            <outline text="输出        out" />
            <outline text="输入	in" />
            <outline text="模板	template" />
            <outline text="执行/执行中	run/running" />
            <outline text="名称	name" />
            <outline text="密码	password  (不要用缩写psw，或者cipher等。)" />
            <outline text="序列号	id " />
            <outline text="读/写	read/write " />
            <outline text="特性	feature" />
            <outline text="版本	version" />
            <outline text="分支	branch" />
            <outline text="工程	project" />
            <outline text="驱动	driver" />
            <outline text="报告	report" />
            <outline text="模块	module" />
            <outline text="进程	process" />
            <outline text="线程	thread" />
            <outline text="参数	param" />
            <outline text="属性	attri" />
            <outline text="帮助	help" />
            <outline text="打印	print" />
            <outline text="测试代码	TEST_CODE" />
            <outline text="选择	choice" />
            <outline text="命令/脚本	cmd" />
            <outline text="日期/时间	date/time" />
            <outline text="间隔	inter/interval" />
            <outline text="修改	modify" />
            <outline text="按下	press  (点击鼠标也用press，不用 hit、beat 等。)" />
            <outline text="步骤	step" />
            <outline text="产生/新建/创建/制造/制作	make (不用build/create等；统一化)" />
            <outline text="拷贝	copy" />
            <outline text="升级/更新	update " />
            <outline text="编译	compile" />
            <outline text="发送/接受	send/receive" />
            <outline text="源/对象.目标	res/des (不要用source/destince。res/des 对比强烈，很醒目，出现在一起不会错。)" />
            <outline text="根	   root" />
            <outline text="关键	key (不要用keyword，显得累赘。)" />
            <outline text="邮件	mail (不用email)" />
            <outline text="存在性	exist" />
            <outline text="调试	debug  (不要缩写为dbg，影响可读性。)" />
            <outline text="库/基线	base  (不用 database)" />
            <outline text="备份/恢复	backup/resume  (backup可以缩写为back，但会影响可读性)" />
            <outline text="错误/警告/信息	Error:/Warn:/Info:" />
            <outline text="定制	custom" />
            <outline text="运营商/客户	vendor" />
            <outline text="待完成	// TODO:" />
            <outline text="检查	check  (不要使用review、examine、inspecte等。归一。)" />
            <outline text="分配	alloc" />
            <outline text="备注	remark" />
            <outline text="计数器	count" />
            <outline text="配置	config  (不要用options、setting等。归一。)" />
            <outline text="用户	user  (指代所有使用工具的人。不用 consumer、handler、operator、runner 等。归一。)" />
            <outline text="重启	reboot (不要用restart, reset等。归一。)" />
            <outline text="服务器/客户机	server/client" />
            <outline text="新/旧	new/old" />
            <outline text="开/关	open/close" />
            <outline text="取/设	get/set" />
            <outline text="控制	control" />
            <outline text="索引/序号	index" />
            <outline text="值	value" />
            <outline text="字体	font" />
            <outline text="颜色	color" />
            <outline text="文本	text" />
            <outline text="线条	line" />
            <outline text="长/高/重	length/height/weigh" />
            <outline text="开关/切换	switch" />
            <outline text="操作/处理/工作/任务/职责  job  (不要用 work、task、role等，归一。)" />
            <outline text="操作/处理/作用（动词性） handle  (不要用 work、operate、treate、do、deal、task等，归一。还要斟酌, 是不是用do更好。)" />
            <outline text="初始化	init" />
            <outline text="文件夹名  path (不用dir, folder等)" />
            <outline text="文件名     file  (不用 filename这种累赘表达)" />
            <outline text="标示	flag" />
            <outline text="自A到B	from_A_to_B" />
            <outline text="在某个平台上，基于某个平台	on   (不用over 或者 base。)" />
            <outline text="A和B	A_and_B" />
            <outline text="A作用于B	A_to_B" />
            <outline text="指针        ptr_" />
            <outline text="字符串    str_" />
            <outline text="局部变量	my_" />
            <outline text="全局变量	g_" />
            <outline text="指向自身	self_" />
            <outline text="接口	i_" />
            <outline text="多个	multi_" />
            <outline text="当前	cur_" />
            <outline text="上一个	last_" />
            <outline text="下一个	next_" />
            <outline text="开始	start_" />
            <outline text="结束	end_" />
            <outline text="之后	after_" />
            <outline text="之前	before_" />
            <outline text="自动化	auto_" />
            <outline text="是否	is_" />
            <outline text="是否使能	use_" />
            <outline text="原始	ori_" />
          </outline>
          <outline text="左括号 { 不独占一行;" />
          <outline text="包名: 全小写。请采用 com.公司名.模块名.子系统名.类名 方式." />
          <outline text="类名:各单词首字母大写;" />
          <outline text="方法名: 第一个单词小写, 其它单词首字母大写;" />
          <outline text="属性名: 前缀m, 各单词首字母大写;" />
          <outline text="局部变量:前缀 my, 各单词首字母大写." />
        </outline>
        <outline text="#代码组织方式">
          <outline text="java文件由如下部分组成: " />
          <outline text="包申明: 即申明自己是谁, 方便别人导入.  只能放在Java文件的第一行. 如: package com.imagescan.tools;  #面试题 " />
          <outline text="Java约定, 包名和文件路径保持一致.包名即 路径.类名/接口名." />
          <outline text="导入包: 即导入别的包, 方便在自己类中调用. 一般紧接着包申明.  #面试题">
            <outline text="包是java的一级概念. 将相关的类放到一个文件夹中, 这个文件夹就叫类包, 简称包." />
            <outline text="调用其它包中的类时, 需要先导入包, 然后在代码中直接用类名. " />
            <outline text="也可以在调用时使用完整的包名(不推荐)." />
            <outline text="编译器在寻址包名时, 会查找当前目录和系统环境变量 classpath 包含的目录." />
            <outline text="import java.util.Data;" />
            <outline text="可以使用通配符*, 比如: import java.util.*;" />
            <outline text="其中以 java/javax 开头的包为核心包, 以 com.org 开头的包为各组织提供的." />
            <outline text="Java编译器会默认导入jdk的java.lang包中的所有类, 其中定义了system/string/object/math等常用类,这些类不需要显式导入." />
          </outline>
          <outline text="接下来是类定义, 即普通代码." />
        </outline>
        <outline text="#类和对象">
          <outline text="java代码的基本组成单位是类, 所有代码都放在类中." />
          <outline text="java没有头文件." />
          <outline text="一个代码文件只能放一个 public 类, 文件名和该类名相同. " />
          <outline text="当一个文件中放多个类时, 其它类叫内部类, 内部类不能是 public 类." />
          <outline text="类的定义">
            <outline text="public class MyClass extends ParentClass {">
              <outline text="protected string money;" />
              <outline text="private int age;" />
              <outline text="int money;  // 默认是 private的" />
              <outline text="public void barking(){...}" />
            </outline>
            <outline text="}" />
            <outline text="关键字 extends 表示继承自其父类. 如果没有显式定义父类, 则默认继承自 Object类. 该类是java所有类的基类." />
          </outline>
          <outline text="程序的入口  #面试题 ">
            <outline text="是 public static void main(string[] args) {}." />
            <outline text="main()必须放在某个public类中, 它直接被java解析器调用. 用户代码不能调用." />
            <outline text="main()必须使用 public static void属性. 即它是静态方法, 使用规则见下." />
            <outline text="每个public类都可以有main(), 运行时用哪个为入口在编译器中指定. 一般用这个特性来做UT." />
          </outline>
          <outline text="构造函数">
            <outline text="类的构造函数会在new该类时被调用. 构造函数用于初始化一个类." />
            <outline text="构造函数和类名相同, 属性为 public void." />
            <outline text="如果没有显式定义构造函数, 则编译器会自动生成一个无参数的构造函数." />
            <outline text="一个类支持多个构造函数, 只要参数不同." />
          </outline>
          <outline text="析构函数">
            <outline text="java不需要析构函数, 但java垃圾回收只支持 new创造的对象, 某些类不是通过new生成, 那么就需要定义 finalize(), 它是 protected的." />
            <outline text="系统垃圾回收的时机不确定. java 提供system.gc()方法, 应用调用它可强制启动回收. 但并不是马上." />
          </outline>
          <outline text="&lt;b&gt;静态类&amp;amp;静态区域&amp;amp;静态方法  #面试题&lt;/b&gt;">
            <outline text="static表示静态的意思." />
            <outline text="static 修饰类, 表示它是&lt;b&gt;静态类&lt;/b&gt;, 常用于工具类, 不需要new可直接用. ">
              <outline text="静态类跟静态方法一样, 只能访问类的静态成员." />
            </outline>
            <outline text="用 static {} 定义类的静态区域, 位于所有方法之外, 一般放在类的最开始.">
              <outline text="静态区域在类加载时被调用, 只执行一次.一般用于类的静态成员的初始化." />
              <outline text="它不能被代码主动调用. " />
              <outline text="可以多个, 但不建议." />
            </outline>
            <outline text="static修饰方法, 表示静态方法. ">
              <outline text="如: public static void myFunc(){}" />
              <outline text="静态方法又叫类方法, 不需要new一个类就可直接调用它. 如 MyClass.myFunc()." />
              <outline text="类方法只能访问类的其它类方法和静态属性, 如果要访问类的其它资源, 则需要new这个类." />
            </outline>
          </outline>
          <outline text="&lt;b&gt;final 关键字  #面试题&lt;/b&gt;">
            <outline text="final 表示最终的, 不可改变的意思. " />
            <outline text="修饰类, 表示该类不可被继承. " />
            <outline text="修饰方法, 表示该方法不可被子类的方法覆盖, 也不支持重载. 所有 private 方法隐含带 final 属性. 而且 final类中的方法默认为final的.">
              <outline text="final 不可以修饰构造方法." />
            </outline>
          </outline>
          <outline text="&lt;b&gt;abstract 关键字  #面试题&lt;/b&gt;">
            <outline text="abstract 和 final 有反义词的意思." />
            <outline text="修饰类, 表示&lt;b&gt;抽象类&lt;/b&gt;. 抽象类不可实例化, 只能被继承. 但它可以作为对象类型. ">
              <outline text="继承抽象类必须重写所有抽象方法." />
              <outline text="一个类只要有一个抽象方法, 那它就是抽象类, 不可实例化, 只能实例化它的子类." />
              <outline text="抽象类可以不包含任何抽象方法." />
              <outline text="抽象类不能定义 final方法." />
            </outline>
            <outline text="修饰方法, 表示&lt;b&gt;抽象方法&lt;/b&gt;. 子类必须重写所有抽象方法." />
          </outline>
          <outline text="&lt;b&gt;构造代码块&lt;/b&gt;">
            <outline text="格式: {...}, 放在函数外. 一般为函数最开始." />
            <outline text="构造块的作用是给类的多个对象的共性部分进行初始化." />
            <outline text="对象一建立就会运行构造块, 而且优先于构造函数. 不能用代码调用构造块." />
            <outline text="构造块和构造函数的区别是: 构造块是给所有对象进行统一初始化, 而构造函数则是对特定对象进行初始化. 构造函数可以多个, 但构造块只有一个." />
          </outline>
          <outline text="&lt;b&gt;this指针&lt;/b&gt;">
            <outline text="this指向当前对象自身. 所以只能用于方法体内.  this不可用于静态方法和静态块." />
            <outline text="this常用于如下几个场景:">
              <outline text="成员变量和参数同名, 成员变量别屏蔽, 用this来引用成员变量." />
              <outline text="构造方法通过this来调用另一个构造方法, 如:">
                <outline text="Public MyClass() {">
                  <outline text="this(0, “null&quot;);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="方法中返回当前实例的引用." />
            </outline>
          </outline>
          <outline text="&lt;b&gt;super 关键字&lt;/b&gt;">
            <outline text="super()   // 调用基类的构造方法, 只能放在构造方法的第一行." />
            <outline text="super.myFunc()  // 调用基类被覆盖的方法." />
          </outline>
          <outline text="接口的使用方法 #面试题 ">
            <outline text="// 定义接口" />
            <outline text="interface 接口名称 [extends 其他的接口名] {">
              <outline text="// 声明变量. 必须有初始化的值." />
              <outline text="// 抽象方法" />
            </outline>
            <outline text="}" />
            <outline text="// 使用接口" />
            <outline text="public class 类名 &lt;b&gt;implements &lt;/b&gt;接口名称 { ... }" />
            <outline text="类可以继承多个接口。" />
          </outline>
          <outline text="抽象类和接口的区别">
            <outline text="抽象类可以有构造方法，接口中不能有构造方法。" />
            <outline text="抽象类中可以有普通成员变量，接口中没有普通成员变量。" />
            <outline text="抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。" />
            <outline text="抽象类中的方法的权限可以多种，接口中的抽象方法只能是 public 类型的。" />
            <outline text="抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的。" />
            <outline text="一个类可以继承多个接口，但只能继承一个抽象类。" />
          </outline>
          <outline text="类的实例化过程">
            <outline text="父类中的static代码块，子类（即当前类）的static。" />
            <outline text="顺序执行父类的普通代码块。" />
            <outline text="父类的构造函数。" />
            <outline text="子类普通代码块。" />
            <outline text="子类的构造函数，按顺序执行。" />
            <outline text="子类方法的执行。" />
          </outline>
          <outline text="重载和重写的区别 #面试题 ">
            <outline text="重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型不做限制。" />
            <outline text="每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。" />
            <outline text="重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。" />
            <outline text="重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。" />
            <outline text="重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。" />
          </outline>
          <outline text="静态内部类 / 匿名内部类 / 内部类的关系 #面试题 ">
            <outline text="内部类">
              <outline text="成员内部类可访问外部类所有的方法和成员变量。" />
              <outline text="不能有静态的方法和成员变量。" />
              <outline text="持有外部类引用" />
            </outline>
            <outline text="静态内部类">
              <outline text="只能访问外部类的静态成员变量与静态方法。" />
              <outline text="静态内部类的非静态成员可访问外部类的静态变量，而不可访问外部类的非静态变量。" />
              <outline text="不持有外部类引用" />
            </outline>
            <outline text="匿名内部类">
              <outline text="没有类名，没有class关键字也没有extends和implements等关键字修饰。" />
              <outline text="类的定义和对象的实例化同时进行。" />
              <outline text="持有外部类引用" />
            </outline>
          </outline>
          <outline text="类加载器（ClassLoader）">
            <outline text="类加载器负责在运行时查找和装入类文件中的类。是一个重要的Java运行时系统组件。" />
            <outline text="类加载器包括：">
              <outline text="根加载器（BootStrap）">
                <outline text="一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；" />
                <outline text="JVM不会向Java程序提供对Bootstrap的引用。" />
              </outline>
              <outline text="扩展加载器（Extension）">
                <outline text="从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；" />
              </outline>
              <outline text="系统加载器（System）">
                <outline text="又叫应用类加载器，其父类是Extension。" />
                <outline text="它是应用最广泛的类加载器。" />
                <outline text="它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。" />
              </outline>
              <outline text="用户自定义类加载器（java.lang.ClassLoader的子类）。" />
            </outline>
            <outline text="类加载的过程">
              <outline text="创建一个字节数组读入.class文件；" />
              <outline text="产生与所加载类对应的Class对象，作为该类的数据访问入口。此时该对象还不可用。" />
              <outline text="当类被加载后就进入连接阶段，这一阶段包括">
                <outline text="验证：包括4种类型的验证：">
                  <outline text="文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型." />
                  <outline text="元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。" />
                  <outline text="字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。" />
                  <outline text="符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。" />
                </outline>
                <outline text="准备：为类的&lt;b&gt;静态变量&lt;/b&gt;分配内存并设置默认值。" />
                <outline text="解析：将符号引用替换为直接引用。" />
              </outline>
              <outline text="最后JVM对类进行初始化：">
                <outline text="如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；" />
                <outline text="如果类中存在初始化语句，就依次执行这些初始化语句。到这个阶段，才开始执行类中的代码。" />
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="#HelloWorld">
          <outline text="/* HelloWorld.java */" />
          <outline text="public Class HelloWorld{">
            <outline text="public static woid main(string arg[]) {">
              <outline text="System.out.println(“Hello, world!&quot;);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="编译:  javac HelloWorld.java" />
          <outline text="java HelloWorld.java" />
        </outline>
        <outline text="#注释">
          <outline text="// 支持单行" />
          <outline text="/* 支持多行 */" />
        </outline>
        <outline text="#Log打印">
          <outline text="最简单的方式是 system.print.out() , err() 这样直接在控制台打印消息了。" />
          <outline text="java.util.logging ; 在JDK 1.4 版本之后，提供了日志的API ，可以往文件中写日志了。" />
          <outline text="log4j , 最强大的记录日志的方式。 可以通过配置 .properties 或是 .xml 的文件， 配置日志的目的地，格式等等。" />
          <outline text="log4j 是 apache 提供的库。下载路径http://logging.apache.org/log4j/1.2/download.html  .  例如:">
            <outline text="import org.apache.log4j.Logger;" />
            <outline text="import org.apache.log4j.PropertyConfigurator;" />
            <outline text="// 1. create log" />
            <outline text="Logger log = Logger.getLogger(TestLog4j.class);" />
            <outline text="// 2. get log config file" />
            <outline text="PropertyConfigurator.configure(&quot;log4j.properties&quot;);" />
            <outline text="// 3. start log.  还有 log.info, log.warn, log.fatal 等打印级别." />
            <outline text="log.debug(&quot;Here is some DEBUG&quot;);" />
            <outline text="log.error(&quot;Here is some ERROR&quot;);" />
          </outline>
          <outline text="commons-logging, 最综合和常见的日志记录方式， 经常是和log4j 结合起来使用。" />
          <outline text="打印堆栈">
            <outline text="+ (new Exception(&quot;&quot;)). printStackTrace();" />
          </outline>
        </outline>
        <outline text="#函数">
          <outline text="函数基本形式">
            <outline text="@ override" />
            <outline text="public void myFunc(Bundle savedData) {...}" />
            <outline text="其中: @ override, 表示该方法可以在子类中被覆盖." />
          </outline>
          <outline text="函数权限">
            <outline text="public: 可以被 其它类 调用;" />
            <outline text="friendly: 只能被 自身/子类/本包的其他类 调用." />
            <outline text="protect: 只能被自身/子类调用." />
            <outline text="private: 只能被自身调用." />
          </outline>
          <outline text="传值/传引用">
            <outline text="在Java里, 只有如下两种数据是按值传递:">
              <outline text="基本类型" />
              <outline text="按照下面这种定义方式的String, 就是直接使用双引号定义字符串方式：String str = “Java私塾”;" />
            </outline>
            <outline text="其它的都是按引用传递。" />
          </outline>
        </outline>
        <outline text="#整数">
          <outline text="整数">
            <outline text="最常见的，int， 32位整数。">
              <outline text="int ii = 5;" />
            </outline>
            <outline text="其它，byte, 8位" />
            <outline text="short, 16位" />
            <outline text="long, 64位. 直接数要加L后缀。">
              <outline text="long x = 88888888L;" />
            </outline>
          </outline>
          <outline text="枚举值">
            <outline text="public static enum MyType{">
              <outline text="ModeType1, ModeType2" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="自带字符串的枚举量">
            <outline text="private static HashMap&amp;lt;String, State&amp;gt; sStates = Maps.newHashMap();" />
            <outline text="public enum State {">
              <outline text="RUNNING(&quot;running&quot;)," />
              <outline text="STOPPING(&quot;stopping&quot;)," />
              <outline text="STOPPED(&quot;stopped&quot;)," />
              <outline text="RESTARTING(&quot;restarting&quot;);" />
              <outline text="&lt;b&gt;State&lt;/b&gt;(String state) {">
                <outline text="sStates.put(state, this);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="#布尔量">
          <outline text="boolean 只有两个值, true 和 false.  不能与整数进行转换." />
        </outline>
        <outline text="#浮点数">
          <outline text="浮点数有两种： float, double." />
          <outline text="float f = 2.3f;   // 占用4个字节, 32位, 取值范围从 10^-38 到 10^38, 和 -10^38到-10^-38之间.">
            <outline text="后缀f 必须要." />
          </outline>
          <outline text="double d = 2.3;   // 占用8个字节, 64位, 取值范围从 10^-308 到 10^308, 和 -10^308 到 -10^-308 之间. " />
          <outline text="小数默认是double类型的。" />
          <outline text="浮点数有精度限制, 不能用 == 比较两个浮点数." />
        </outline>
        <outline text="#常量">
          <outline text="常量用 final 修饰. 即不可改变的变量." />
          <outline text="需要在声明时给定初值。" />
          <outline text="常量一般也是全局变量和静态变量, 如: public final static double PI = 3.14159;" />
          <outline text="final也可以修饰局部变量, 用于避免变量被重新赋值." />
        </outline>
        <outline text="#全局变量">
          <outline text="全局变量用 public 修饰. 使用时用这样的: MyClass.myValue;" />
        </outline>
        <outline text="#静态变量">
          <outline text="静态变量用 static 修饰. 局部可见, 全局存在. 和c一样." />
        </outline>
        <outline text="#运算符表">
          <outline text="优先级按照从高到低的顺序书写，也就是优先级为1的优先级最高，优先级14的优先级最低。" />
          <outline text="1	() [] .	从左到右" />
          <outline text="2	! +(正) -(负) ~(非运算) ++ --	从右向左" />
          <outline text="3	* / %	从左向右" />
          <outline text="4	+(加) -(减)	从左向右" />
          <outline text="5	&amp;lt;&amp;lt; &amp;gt;&amp;gt;(算数右移) &amp;gt;&amp;gt;&amp;gt;(逻辑右移)	从左向右" />
          <outline text="6	&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= instanceof	从左向右" />
          <outline text="7	== !=	从左向右" />
          <outline text="8	&amp;amp;(按位与)	从左向右" />
          <outline text="9	^(异或)	从左向右" />
          <outline text="10	|	从左向右" />
          <outline text="11	&amp;amp;&amp;amp;	从左向右" />
          <outline text="12	||	从左向右" />
          <outline text="13	?:	从右向左" />
          <outline text="14	= += -= *= /= %= &amp;amp;= |= ^= ~= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;= &amp;gt;&amp;gt;&amp;gt;=	从右向左" />
        </outline>
        <outline text="#基本数据类型装箱  #面试题 ">
          <outline text="为了方便大家的习惯, java中有8种基础数据类型没有包装为类, 包括 byte/short/int/long/char/float/double/boolean. " />
          <outline text="基本数据类型可以直接使用, 不需要new. 如: int myInt = 500;" />
          <outline text="但是由于它们不是对象, 在序列化等场景下不太方便, 所以java提供了装箱类, 包括:">
            <outline text="byte -&amp;gt; Byte" />
            <outline text="boolean -&amp;gt; Boolean" />
            <outline text="short -&amp;gt; Short" />
            <outline text="char -&amp;gt; Character" />
            <outline text="int -&amp;gt; Integer" />
            <outline text="long -&amp;gt; Long" />
            <outline text="float -&amp;gt; Float" />
            <outline text="double -&amp;gt; Double" />
          </outline>
          <outline text="装箱">
            <outline text="即将基础类型包装为对象. 如:" />
            <outline text="int myInt = 500;" />
            <outline text="Integer myInt2 = new Integar(myInt);" />
            <outline text="一旦装箱, 其值就不可以更改." />
          </outline>
          <outline text="拆箱">
            <outline text="将对象转化为基础类. 如:" />
            <outline text="int myInt = myInt2.intValue();" />
          </outline>
          <outline text="装箱类支持 toString(). toString()是类方法, 所以不需要new一个对象就可以用. 如:">
            <outline text="String myStr = Interger.toString(500);" />
          </outline>
          <outline text="自动拆箱和装箱">
            <outline text="java在 1.5(5.0) 之后提供了自动拆箱和装箱功能, 语法和使用基本数据类型类似. 如:" />
            <outline text="Integer myInt = 500;" />
          </outline>
        </outline>
        <outline text="#指针和引用">
          <outline text="Java没有指针. 但是有引用." />
          <outline text="Java把引用作为默认调用方式, 所以并没有专门的运算符或关键字给引用." />
          <outline text="引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。" />
          <outline text="Java把引用分为4种 #面试题">
            <outline text="强引用">
              <outline text="只要引用还存在，GC就永远不会回收." />
              <outline text="Object obj = new Object(), obj 就是强引用。通过关键字new创建的对象所关联的引用就是强引用。" />
              <outline text="当JVM内存空间不足，JVM宁愿抛出 OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会回收具有强引用的“存活”对象。" />
              <outline text="强引用是全局变量时, 需要通过 obj = null; 来释放." />
              <outline text="强应用是局部变量时, 当所在代码块运行完成后, 就会自动释放." />
            </outline>
            <outline text="软引用">
              <outline text="软引用当内存不足的时候才会回收。" />
              <outline text="软引用通过 SoftReference 类实现。" />
              <outline text="JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。" />
              <outline text="使用软引用对象之前需要判断对象是否还存活。" />
              <outline text="常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。" />
            </outline>
            <outline text="弱引用">
              <outline text="可有可无，GC时首先被回收。" />
              <outline text="通过 WeakReference 类实现。" />
              <outline text="每次GC时都会直接回收弱引用对象。" />
              <outline text="由于GC进程的优先级较低，所以弱引用对象并不是很快就会被回收。" />
              <outline text="弱应用同样可用于内存敏感的缓存。" />
            </outline>
            <outline text="虚引用">
              <outline text="最弱的一种引用，回收时机未知。当程序需要知道某个对象是否已经被垃圾回收时，可以使用虚引用。" />
              <outline text="通过 PhantomReference 类来实现。" />
              <outline text="无法通过虚引用访问对象的任何属性或函数。" />
              <outline text="当虚引用已经被放到引用队列，则其指向的对象已经被垃圾回收。" />
            </outline>
          </outline>
        </outline>
        <outline text="#对象判空">
          <outline text="对象判空: if (myObject != null) {…}" />
          <outline text="NullObject模式: 整一个NullObject与原有对象实现相同的接口或继承同一个父类. 目的是让调用者不需要判空.  要补充代码." />
        </outline>
        <outline text="#对象的元属性">
          <outline text="得到当前方法的名字">
            <outline text="String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();" />
          </outline>
          <outline text="返回类名/类类型/接口名">
            <outline text="forName(&quot;类名&quot;)   // 返回一个Class对象的引用. 用于类没有加载时加载它." />
            <outline text="getName() // 返回包含包名的类名." />
            <outline text="getSimpleName() // 返回不包含包名的类名." />
            <outline text="getCanonicalName()  // 返回全限定类名." />
            <outline text="getInterface()  // 返回全限定的接口." />
            <outline text="getSuperClass() // 返回直接父类" />
          </outline>
          <outline text="instanceof 操作符">
            <outline text="用于判断当前类是否是指定类的之类." />
            <outline text="if (mySubObj instanceof myObj) {…}" />
          </outline>
          <outline text="获取包名和类名">
            <outline text="android中, 可通过 getPachageName() 获取包名, 通过 getClassName() 获取类名." />
          </outline>
          <outline text="类的class type对象">
            <outline text="Java把类的元属性也对象化了, 即 ClassType. 它是静态对象, 系统加载一个类时就会自动创建它的 ClassType 对象, 不需要手动创建. 其用法是:" />
            <outline text="已知类, 获取 Class 对象(推荐用这种):">
              <outline text="Class myClassType = myClass.Class;" />
            </outline>
            <outline text="已知对象, 获取其Class对象">
              <outline text="Class myClassType = myObject.getClass();" />
            </outline>
            <outline text="上面这两种的区别在于第二种只能由对象调用." />
            <outline text="通过类名字符串获取其Class对象">
              <outline text="Class myClassType = Class.forName(&quot;MyClassName&quot;);" />
            </outline>
          </outline>
          <outline text="对象判等">
            <outline text="用 == 比较两个对象, 实际对比的是两个对象的地址是不是相同, 即确认这两个对象是不是同一个, 而一般对象对比的初衷是对比两个不同的对象是否具有同样的属性." />
            <outline text="常用的是用 equals()来对比两个对象的值是否相同." />
            <outline text="java.io.file, java.util.Date, java.lang.string,包装类（Integer,Double等）等, 提供的比较规则为：如果两个对象的类型一致，并且值一致，则返回true,这些类有：" />
            <outline text="用户自定义的类, 要自己提供 equals()定义." />
          </outline>
          <outline text="对象比较">
            <outline text="Comparable接口">
              <outline text="类继承Comparable接口后，就必须实现 compareTo() 方法。" />
              <outline text="该方法用于约定对象的排序规则。" />
            </outline>
            <outline text="Comparator接口">
              <outline text="对于已经实现了Comparable接口的类，如何在不修改其代码的前提下改变它的排序规则呢？" />
              <outline text="使用Comparator接口。" />
            </outline>
          </outline>
          <outline text="深复制和浅复制  #面试题 ">
            <outline text="通过调用 clone() 复制一个现有的对象, 是快速生成一个对象的方式.">
              <outline text="MyClass myClass1 = new MyClass(23, &quot;zhang&quot;);" />
              <outline text="MyClass myClass2 = (MyClass) myClass1.clone();" />
            </outline>
            <outline text="复制的时候有两种方式: 深复制和浅复制." />
            <outline text="对于对象的基础数据类型成员, 无论哪种复制都是直接copy 副本. 但是对于对象成员, 浅复制只复制对象的引用. 深复制则复制对象的副本." />
            <outline text="clone()执行的是浅拷贝. 如果需要深拷贝, 则需要复写clone()." />
            <outline text="要复写clone(), 需要类 implements Cloneable." />
            <outline text="深复制要求在引用链上的每一级对象都要复写clone(), 显式的拷贝。所以它是相当麻烦的." />
          </outline>
          <outline text="RTTI (运行时对象类型识别, runtime type identification)">
            <outline text="在java中, 所有的类型转化都是在运行时进行正确性检查的." />
          </outline>
          <outline text="Class.newInstance()">
            <outline text="根据类的class对象new一个新对象." />
            <outline text="这是实现虚拟构造器的一种途径. 它允许你申明: 我不确切的知道类型, 先创建一个对象再说." />
            <outline text="newInstance() 创建的对象必须有默认的构造器." />
          </outline>
          <outline text="泛化引用">
            <outline text="Class 对象可指向任何类, 不方便在编译时识别出类型错误. 为弥补这一点, 可使用泛化引用来限定Class对象引用的类型, 方便编译器执行额外的类型检查." />
            <outline text="Class&amp;lt;MyClass&amp;gt; myClass = MyClass.class;   // MyClass 是泛化引用" />
          </outline>
          <outline text="&lt;b&gt;反射: 通过字符串进行函数调用  #面试题 &lt;/b&gt;">
            <outline text="通过ClassType 字符串实例化类">
              <outline text="Class&amp;lt;?&amp;gt; myClass = null;" />
              <outline text="myClass = class.forName(&quot;myClassType&quot;);" />
              <outline text="myObject = (myClassType)myClass.newInstance();" />
              <outline text="myClassType 中必须有无参数构造函数." />
            </outline>
            <outline text="获取构造方法(包括私有的)">
              <outline text="public Constructor getConstructor(Class… parameterTypes); // 获得指定的构造方法，注意只能获得 public 权限的构造方法" />
              <outline text="public Constructor getDeclaredConstructor(Class… parameterTypes);  // 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。" />
              <outline text="public Constructor[] getConstructors() throws SecurityException;   // 获得所有 public 访问权限的构造方法" />
              <outline text="public Constructor[] getDeclaredConstructors() throws SecurityException;  // 获得所有的构造方法，包括（public, private,protected,默认权限的）" />
              <outline text="例如: " />
              <outline text="public static void printConstructor(String className) {">
                <outline text="try {">
                  <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                  <outline text="&lt;b&gt;Constructor&lt;/b&gt;&amp;lt;?&amp;gt;[] constructors = aClass.&lt;b&gt;getConstructors&lt;/b&gt;();" />
                  <outline text="print(constructors);" />
                  <outline text="Constructor&amp;lt;?&amp;gt;[] declaredConstructors = aClass.&lt;b&gt;getDeclaredConstructors&lt;/b&gt;();" />
                  <outline text="print(declaredConstructors);" />
                </outline>
                <outline text="} catch (ClassNotFoundException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="获取所有成员变量">
              <outline text="public static void printFiled(String className) {">
                <outline text="try {">
                  <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                  <outline text="Field[] fields = aClass.&lt;b&gt;getFields&lt;/b&gt;();" />
                  <outline text="PrintUtils.print(fields);" />
                  <outline text="Field[] declaredFields = aClass.&lt;b&gt;getDeclaredFields&lt;/b&gt;();" />
                  <outline text="PrintUtils.print(declaredFields);" />
                </outline>
                <outline text="} catch (ClassNotFoundException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="获得指定成员变量">
              <outline text="public static Field getFiled(String className, String filedName) {">
                <outline text="Object o = null;" />
                <outline text="try {">
                  <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                  <outline text="Field declaredField = aClass.&lt;b&gt;getDeclaredField&lt;/b&gt;(filedName);" />
                  <outline text="//   if not public,you should call this" />
                  <outline text="declaredField.&lt;b&gt;setAccessible&lt;/b&gt;(true);" />
                  <outline text="return declaredField;" />
                </outline>
                <outline text="} catch (ClassNotFoundException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="} catch (NoSuchFieldException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
                <outline text="return null;" />
              </outline>
              <outline text="}" />
              <outline text="调用方: Field field =getFiled(&quot;MyClassName&quot;, &quot;age&quot;);" />
            </outline>
            <outline text="获取所有方法">
              <outline text="public static void printMethods(String className) {">
                <outline text="try {">
                  <outline text="Class&amp;lt;?&amp;gt; aClass = Class.forName(className);" />
                  <outline text="Method[] declaredMethods = aClass.&lt;b&gt;getDeclaredMethods&lt;/b&gt;();" />
                  <outline text="PrintUtils.print(declaredMethods);" />
                </outline>
                <outline text="} catch (ClassNotFoundException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="执行指定方法">
              <outline text="public static void testMethod(){">
                <outline text="Person person=new Person();" />
                <outline text="Method method = &lt;b&gt;getMethod&lt;/b&gt;(CLASS_NAME, &quot;FunctionName&quot;, String.class);" />
                <outline text="try {">
                  <outline text="// 执行方法，结果保存在 person 中" />
                  <outline text="Object o = method.&lt;b&gt;invoke&lt;/b&gt;(person, CHINA);" />
                  <outline text="// 拿到我们传递进取的参数 country 的值 China" />
                  <outline text="String country = person.country;" />
                  <outline text="PrintUtils.print(country);" />
                </outline>
                <outline text="} catch (IllegalAccessException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="} catch (InvocationTargetException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
        </outline>
        <outline text="#for循环">
          <outline text="for (ii = 0; ii &amp;lt; length; ii++) {...}  // 和C的语言一样" />
          <outline text="for (变量 * : 数组) {...}   效率较高, 建议使用. 如: ">
            <outline text="for (String myStr : myStrs) {...}   // myStrs是字符串数组. " />
            <outline text="变量类型和数组元素类型匹配." />
          </outline>
        </outline>
        <outline text="#where循环">
          <outline text="while (布尔表达式) {...}" />
          <outline text="do {...} while (布尔表达式)" />
          <outline text="break;   // 用于跳出里层的循环, 继续执行循环下面的语句. " />
          <outline text="continue;  // 用于跳出当次循环, 跳转到布尔表达式." />
        </outline>
        <outline text="#if和switch">
          <outline text="和c一样." />
        </outline>
        <outline text="#字符串">
          <outline text="#转义字符">
            <outline text="\&quot;: 双引号" />
            <outline text="\': 单引号 " />
            <outline text="\\: 反斜线 " />
            <outline text="\0: 空字符 " />
            <outline text="\r: 回车" />
            <outline text="\n: 换行" />
            <outline text="\t: table跳格" />
            <outline text="\u: Unicode码, 比如: $ =&amp;gt; \u0024; { =&amp;gt; \u007B." />
          </outline>
          <outline text="#字符串定义">
            <outline text="字符串对象String  #面试题 ">
              <outline text="String myString = new String(&quot;my string&quot;);" />
              <outline text="java语言中, &quot;my string&quot;这种标量, 本身就是String 对象, 由编辑器进行初始化." />
            </outline>
            <outline text="&lt;b&gt;可变字符串：StringBuffer 和 StringBuilder  #面试题 &lt;/b&gt;">
              <outline text="String字符串初始化后, 内容不能再改变. 将一个字符串变量指向新值, 则会new一个新的字符串对象, 原来的字符串会进入垃圾回收. 所以性能会比较差." />
              <outline text="如果字符串频繁变化, 这有必要使用 StringBuffer. 它的性能比 new一个新字符串对象要快很多.">
                <outline text="StringBuffer myStr = new StringBuffer(&quot;String init&quot;);" />
                <outline text="myStr.append(&quot;2st. string&quot;);" />
              </outline>
              <outline text="StringBuffer是线程安全的。因为 StringBuffer 有缓冲区。" />
              <outline text="可变字符串类 StringBuilder, 则是线程不安全的. 但它性能更快.">
                <outline text="StringBuilder的所有方法和 StringBuffer 都一样。" />
                <outline text="但是它们都没有被 synchronized 修饰, 所以性能高." />
                <outline text="StringBuilderJava 5中引入的. " />
              </outline>
            </outline>
            <outline text="三者在执行速度上：StringBuilder &amp;gt; StringBuffer &amp;gt; String (由于String是常量，不可改变，拼接时会重新创建新的对象)。" />
            <outline text="字符串和整型的相互转换">
              <outline text="String str = String.valueOf(2);" />
              <outline text="int i = Integer.parseInt(str); // 需要捕捉异常: NumberFormatException" />
            </outline>
            <outline text="字符Char --没必要用字符数组表达字符串">
              <outline text="Char myChar = 'a';    // 单引号是字符, 双引号是字符串." />
            </outline>
            <outline text="String 转化为 Char">
              <outline text="Char myChar = myString.charAt(index);" />
            </outline>
            <outline text="String 转化为 Char[]">
              <outline text="Char myChars[] = myString.toCharArray();" />
            </outline>
            <outline text="Char 转化为String">
              <outline text="String myString = String.valueOf('C');" />
            </outline>
          </outline>
          <outline text="#字符串判空">
            <outline text="if (myString.length() == 0)    // 空串" />
            <outline text="if (null == myString)     // 字符串对象没有初始化" />
          </outline>
          <outline text="#字符串取长">
            <outline text="myString.length();" />
          </outline>
          <outline text="#字符串比较" />
          <outline text="#字符串去空格">
            <outline text="myString.trim();   // 前后去空格" />
          </outline>
          <outline text="&lt;b&gt;#字符串拼接  #面试题&lt;/b&gt;">
            <outline text="字符串可通过 + 号连接, 这是最直观的.">
              <outline text="String是常量，不可改变，拼接时会重新创建新的对象." />
              <outline text="因此在大循环体内进行字符串拼接, 则可能出现海量的对象创建和销毁, 导致性能问题." />
              <outline text="解决办法是: 单线程下字符串的串联用StringBuilder，多线程下字符串的串联用StrngBuffer。" />
            </outline>
            <outline text="基本数据类型与字符串连接时, 会自动转化为字符串. " />
            <outline text="对象要自动转为字符串, 需要重载 toString() 方法." />
            <outline text="可变字符串&lt;b&gt;StringBuffer 和 StringBuilder, &lt;/b&gt;用 append() 来拼接." />
          </outline>
          <outline text="#字符串截取" />
          <outline text="#字符串查找" />
          <outline text="#字符串替换" />
          <outline text="#字符串拆分" />
          <outline text="#字符串的格式化输出" />
          <outline text="#正则表达式" />
        </outline>
        <outline text="#时间处理">
          <outline text="#获取系统时间">
            <outline text="System.currentTimeMillis();" />
          </outline>
          <outline text="#日期时间">
            <outline text="方法1: java.util.Date = java.text.DateFormat.getDateInstance().parse(date String);" />
            <outline text="方法2: SimpleDateFormat format = new SimpleDateFormat( &quot;dd.MM.yyyy&quot; );">
              <outline text="Date date = format.parse( myString );" />
            </outline>
            <outline text="把 Java util.Date 转成 sql.Date">
              <outline text="java.util.Date utilDate = new java.util.Date();" />
              <outline text="java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());" />
            </outline>
          </outline>
          <outline text="#时区" />
        </outline>
        <outline text="#数组">
          <outline text="#定义数组">
            <outline text="array 的size是固定的，不能动态改变，且一个array只能存放同一种数据类型。" />
            <outline text="array的创建">
              <outline text="&lt;b&gt;int[]&lt;/b&gt; myArray = new int[mySize];" />
              <outline text="int[] myArray = {value0, value1, ...};" />
              <outline text="或者: int myArray[];   // 可以用, 但不常见." />
            </outline>
            <outline text="java.util.Arrays 类能方便地操作数组. 它的函数都是静态函数, 不需要new." />
          </outline>
          <outline text="#遍历数据">
            <outline text="数组元素的访问方式, 最典型的是下标, 即 myArray[1];" />
            <outline text="int size = myArray.length;" />
            <outline text="for (int ii = 1; ii &amp;lt; size; ii++) {">
              <outline text="myArray[ii]...;" />
            </outline>
            <outline text="}" />
            <outline text="还有一种: " />
            <outline text="for(int value: myArray) {">
              <outline text="value...;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="#取长">
            <outline text="myArray.size()" />
          </outline>
          <outline text="#数组元素的新增删除">
            <outline text="Java数组元素的数量是固定, 不能新增删除." />
          </outline>
          <outline text="#数组元素的查询">
            <outline text="public static int Arrays.binarySearch(Object[] a, Object key);" />
            <outline text="在排好序的array中寻找元素 (用折半排序, 时间成本是logN)。" />
            <outline text="如果查找值包含在数组中，则返回搜索键的索引；否则返回 - 1." />
          </outline>
          <outline text="#数组排序">
            <outline text="public static void Arrays.sort(Object[] a);" />
            <outline text="对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。" />
          </outline>
        </outline>
        <outline text="#异常处理">
          <outline text="#常见异常类型">
            <outline text="Java内置异常类 @iFile" />
          </outline>
          <outline text="#异常处理">
            <outline text="try {">
              <outline text="// 程序代码" />
            </outline>
            <outline text="} catch(ExceptionName e1) {">
              <outline text="// Catch 块：异常处理" />
            </outline>
            <outline text="} finally {">
              <outline text="// finally 块：无论如何都会被执行。即使try块中有return，在return之前，也会调用finally块。" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="#自定义异常">
            <outline text="所有异常都必须是 Throwable 的子类。" />
            <outline text="如果希望写一个检查性异常类，则需要继承 Exception 类。" />
            <outline text="如果希望写一个运行时异常类，那么需要继承 RuntimeException 类。" />
          </outline>
        </outline>
        <outline text="#内存管理">
          <outline text="#内存模型">
            <outline text="堆">
              <outline text="存放对象实例。new 出来的类实例在这里分配内存。" />
              <outline text="堆的大小由-Xms指定，默认是物理内存的1/64；最大值由-Xmx指定，默认是物理内存的1/4。" />
              <outline text="默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。">
                <outline text="比例可由 -XX:MinHeapFreeRatio 指定。" />
              </outline>
              <outline text="默认空余内存大于70%时，就会减少内存，直到-Xms设置的大小。">
                <outline text="比例可由 -XX:MaxHeapFreeRatio 指定。" />
              </outline>
            </outline>
            <outline text="虚拟机栈">
              <outline text="每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。" />
              <outline text="本地方法栈，则是为虚拟机使用到的Native方法服务。" />
              <outline text="如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError异常。" />
              <outline text="如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。" />
            </outline>
            <outline text="方法区">
              <outline text="存储已经加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。" />
              <outline text="该区内少发生垃圾回收。" />
            </outline>
            <outline text="程序计数器">
              <outline text="当前线程所执行的字节码的行号指示器。" />
            </outline>
          </outline>
          <outline text="#内存销毁 ">
            <outline text="finalize方法">
              <outline text="gc在销毁对象时，会回调finalize()方法。" />
              <outline text="通过重写finalize()，我们可以跟踪对象的销毁过程。" />
            </outline>
            <outline text="GC，Gabage Collection，垃圾收集。一般仅指对堆内存的回收。常见的算法有：">
              <outline text="Reference Counting" />
              <outline text="Mark Sweep">
                <outline text=".NET CLR 使用。" />
                <outline text="Java VM 使用。" />
              </outline>
              <outline text="Copy Collection" />
            </outline>
            <outline text="请求垃圾收集的API">
              <outline text="System.gc()" />
              <outline text="Runtime.getRuntime().gc()" />
            </outline>
            <outline text="GC分为：">
              <outline text="Minor GC">
                <outline text="通常发生在新生代的Eden区，在这个区的对象生存期短。" />
              </outline>
              <outline text="Full Gc / Major GC ">
                <outline text="发生在老年代" />
              </outline>
            </outline>
            <outline text="内存判定对象可回收的算法有两种机制：引用计数算法 和 可达性分析法。">
              <outline text="引用计数算法">
                <outline text="给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。" />
                <outline text="计数器变为0时，内存块就被释放。" />
                <outline text="实际上很少使用，因为它难以解决对象之间相互循环引用的问题。" />
              </outline>
            </outline>
            <outline text="可达性分析法">
              <outline text="通过一系列被称为 GCRoots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。" />
              <outline text="可作为GC Roots的对象主要有：">
                <outline text="栈帧中的本地变量" />
                <outline text="本地方法栈中Native方法引用的对象" />
                <outline text="方法区中类静态属性引用的对象" />
                <outline text="方法区中常量引用的对象" />
              </outline>
              <outline text="GC回收算法： 分代收集算法">
                <outline text="分代收集算法是当前商用虚拟机广泛采用的一种算法。" />
                <outline text="根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。" />
                <outline text="新生代：刚分配不久的对象生存期短，每次回收都会有大量对象死去。">
                  <outline text="使用『复制算法』，只需复制少量存活对象即可。" />
                  <outline text="复制算法要点：">
                    <outline text="把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。" />
                    <outline text="当这一块的内存用尽后，把还存活着的对象『复制』到另外一块上面，再将这一块内存空间一次清理掉。" />
                    <outline text="实现简单，运行高效。" />
                    <outline text="缺点：在对象存活率较高时就要进行较多的复制操作，效率将会变低。" />
                  </outline>
                </outline>
                <outline text="老年代：分配时间较久后还活着的对象, 继续存活的概率较大。">
                  <outline text="使用『标记—清理算法』或者『标记—整理算法』，只需标记较少的回收对象即可。" />
                  <outline text="标记-清除算法：">
                    <outline text="首先『标记』出所有需要回收的对象，然后统一『清除』所有被标记的对象。" />
                    <outline text="标记和清除两个过程的效率都不高；" />
                    <outline text="而且清除之后会产生大量不连续的内存碎片。" />
                  </outline>
                  <outline text="标记-整理算法：">
                    <outline text="首先『标记』出所有需要回收的对象，然后进行『整理』，使得存活的对象都向一端移动，最后直接清理掉端边界以外的内存。" />
                    <outline text="标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片&quot;。" />
                  </outline>
                </outline>
              </outline>
              <outline text="新生代如何进化成老年代？">
                <outline text="对象优先在新生代区中分配，若没有足够空间，触发GC；" />
                <outline text="特别大的对象，直接进入老年态；" />
                <outline text="如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1；" />
                <outline text="若年龄超过一定限制（15），则被晋升到老年态。" />
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="#文件系统">
          <outline text="#文件路径分隔符">
            <outline text="String sep = System.getProperty(&quot;file.separator&quot;);" />
            <outline text="myFile = new File('d:'+sep+&quot;study&quot;, &quot;data.txt&quot;);" />
          </outline>
          <outline text="#回车换行符">
            <outline text="System.getProperty(&quot;line.separator&quot;);" />
            <outline text="因为操作系统的不同，换行符操也不同：">
              <outline text="/r Mac" />
              <outline text="/n Unix/Linux" />
              <outline text="/r/n Windows" />
            </outline>
          </outline>
          <outline text="#文件夹和文件的存在性" />
          <outline text="#遍历文件夹">
            <outline text="File dir = new File(&quot;directoryName&quot;);" />
            <outline text="String[] children = dir.list();" />
            <outline text="if (children == null) {">
              <outline text="// Either dir does not exist or is not a directory" />
            </outline>
            <outline text="} else {">
              <outline text="for (int i=0; i &amp;lt; children.length; i++) {">
                <outline text="// Get filename of file or directory" />
                <outline text="String filename = children[i];" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="// It is also possible to filter the list of returned files." />
            <outline text="// This example does not return any files that start with `.'." />
            <outline text="FilenameFilter filter = new FilenameFilter() {">
              <outline text="public boolean accept(File dir, String name) {">
                <outline text="return !name.startsWith(&quot;.&quot;);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="children = dir.list(filter);" />
            <outline text="// The list of files can also be retrieved as File objects" />
            <outline text="File[] files = dir.listFiles();" />
            <outline text="// This filter only returns directories" />
            <outline text="FileFilter fileFilter = new FileFilter() {">
              <outline text="public boolean accept(File file) {">
                <outline text="return file.isDirectory();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="files = dir.listFiles(fileFilter);" />
          </outline>
          <outline text="#新建文件夹" />
          <outline text="#删除文件夹" />
          <outline text="#返回和修改当前路径" />
          <outline text="#创建文件" />
          <outline text="#读文件" />
          <outline text="#写文件">
            <outline text="向文件末尾添加内容">
              <outline text="BufferedWriter out = null;" />
              <outline text="try {">
                <outline text="out = new BufferedWriter(new FileWriter(”filename”, true));" />
                <outline text="out.write(”aString”);" />
              </outline>
              <outline text="} catch (IOException e) {">
                <outline text="// error processing code" />
              </outline>
              <outline text="} finally {">
                <outline text="if (out != null) {">
                  <outline text="out.close();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
          <outline text="#返回文件长度" />
          <outline text="#文件改名改属性" />
          <outline text="#删除文件" />
          <outline text="#文件系统原语">
            <outline text="解析/读取XML 文件">
              <outline text="package net.viralpatel.java.xmlparser;" />
              <outline text="import java.io.File;" />
              <outline text="import javax.xml.parsers.DocumentBuilder;" />
              <outline text="import javax.xml.parsers.DocumentBuilderFactory;" />
              <outline text="import org.w3c.dom.Document;" />
              <outline text="import org.w3c.dom.Element;" />
              <outline text="import org.w3c.dom.Node;" />
              <outline text="import org.w3c.dom.NodeList;" />
              <outline text="public class XMLParser {">
                <outline text="public void getAllUserNames(String fileName) {">
                  <outline text="try {">
                    <outline text="DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();" />
                    <outline text="DocumentBuilder db = dbf.newDocumentBuilder();" />
                    <outline text="File file = new File(fileName);" />
                    <outline text="if (file.exists()) {">
                      <outline text="Document doc = db.parse(file);" />
                      <outline text="Element docEle = doc.getDocumentElement();" />
                      <outline text="// Print root element of the document" />
                      <outline text="System.out.println(&quot;Root element of the document: &quot; + docEle.getNodeName());" />
                      <outline text="NodeList studentList = docEle.getElementsByTagName(&quot;student&quot;);" />
                      <outline text="// Print total student elements in document" />
                      <outline text="System.out.println(&quot;Total students: &quot; + studentList.getLength());" />
                      <outline text="if (studentList != null &amp;amp;&amp;amp; studentList.getLength() &amp;gt; 0) {">
                        <outline text="for (int i = 0; i &amp;lt; studentList.getLength(); i++) {">
                          <outline text="Node node = studentList.item(i);" />
                          <outline text="if (node.getNodeType() == Node.ELEMENT_NODE) {">
                            <outline text="System.out.println(&quot;=====================&quot;);" />
                            <outline text="Element e = (Element) node;" />
                            <outline text="NodeList nodeList = e.getElementsByTagName(&quot;name&quot;);" />
                            <outline text="System.out.println(&quot;Name: &quot; + nodeList.item(0).getChildNodes().item(0).getNodeValue());" />
                            <outline text="nodeList = e.getElementsByTagName(&quot;grade&quot;);" />
                            <outline text="System.out.println(&quot;Grade: &quot; + nodeList.item(0).getChildNodes().item(0).getNodeValue());" />
                            <outline text="nodeList = e.getElementsByTagName(&quot;age&quot;);" />
                            <outline text="System.out.println(&quot;Age: &quot; + nodeList.item(0).getChildNodes().item(0).getNodeValue());" />
                          </outline>
                          <outline text="}" />
                        </outline>
                        <outline text="}" />
                      </outline>
                      <outline text="} else {">
                        <outline text="System.exit(1);" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="} catch (Exception e) {">
                    <outline text="System.out.println(e);" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
                <outline text="public static void main(String[] args) {">
                  <outline text="XMLParser parser = new XMLParser();" />
                  <outline text="parser.getAllUserNames(&quot;c:\\test.xml&quot;);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="创建 JSON 格式的数据文件">
              <outline text="import org.json.JSONObject;" />
              <outline text="..." />
              <outline text="JSONObject json = new JSONObject();" />
              <outline text="json.put(&quot;city&quot;, &quot;Mumbai&quot;);" />
              <outline text="json.put(&quot;country&quot;, &quot;India&quot;);" />
              <outline text="..." />
              <outline text="String output = json.toString();" />
            </outline>
            <outline text="创建ZIP和JAR文件">
              <outline text="import java.util.zip.*;" />
              <outline text="import java.io.*;" />
              <outline text="public class ZipIt {">
                <outline text="public static void main(String args[]) throws IOException {">
                  <outline text="if (args.length &amp;lt; 2) {">
                    <outline text="System.err.println(&quot;usage: java ZipIt Zip.zip file1 file2 file3&quot;);" />
                    <outline text="System.exit(-1);" />
                  </outline>
                  <outline text="}" />
                  <outline text="File zipFile = new File(args[0]);" />
                  <outline text="if (zipFile.exists()) {">
                    <outline text="System.err.println(&quot;Zip file already exists, please try another&quot;);" />
                    <outline text="System.exit(-2);" />
                  </outline>
                  <outline text="}" />
                  <outline text="FileOutputStream fos = new FileOutputStream(zipFile);" />
                  <outline text="ZipOutputStream zos = new ZipOutputStream(fos);" />
                  <outline text="int bytesRead;" />
                  <outline text="byte[] buffer = new byte[1024];" />
                  <outline text="CRC32 crc = new CRC32();" />
                  <outline text="for (int i=1, n=args.length; i &amp;lt; n; i++) {">
                    <outline text="String name = args[i];" />
                    <outline text="File file = new File(name);" />
                    <outline text="if (!file.exists()) {">
                      <outline text="System.err.println(&quot;Skipping: &quot; + name);" />
                      <outline text="continue;" />
                    </outline>
                    <outline text="}" />
                    <outline text="BufferedInputStream bis = new BufferedInputStream(">
                      <outline text="new FileInputStream(file));" />
                    </outline>
                    <outline text="crc.reset();" />
                    <outline text="while ((bytesRead = bis.read(buffer)) != -1) {">
                      <outline text="crc.update(buffer, 0, bytesRead);" />
                    </outline>
                    <outline text="}" />
                    <outline text="bis.close();" />
                    <outline text="// Reset to beginning of input stream" />
                    <outline text="bis = new BufferedInputStream(new FileInputStream(file));" />
                    <outline text="ZipEntry entry = new ZipEntry(name);" />
                    <outline text="entry.setMethod(ZipEntry.STORED);" />
                    <outline text="entry.setCompressedSize(file.length());" />
                    <outline text="entry.setSize(file.length());" />
                    <outline text="entry.setCrc(crc.getValue());" />
                    <outline text="zos.putNextEntry(entry);" />
                    <outline text="while ((bytesRead = bis.read(buffer)) != -1) {">
                      <outline text="zos.write(buffer, 0, bytesRead);" />
                    </outline>
                    <outline text="}" />
                    <outline text="bis.close();" />
                  </outline>
                  <outline text="}" />
                  <outline text="zos.close();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="使用NIO进行快速的文件拷贝">
              <outline text="public static void fileCopy( File in, File out) throws IOException {">
                <outline text="FileChannel inChannel = new FileInputStream( in ).getChannel();" />
                <outline text="FileChannel outChannel = new FileOutputStream( out ).getChannel();" />
                <outline text="try {" />
                <outline text="// inChannel.transferTo(0, inChannel.size(), outChannel);   // original -- apparently has trouble copying large files on Windows" />
                <outline text="// magic number for Windows, 64Mb - 32Kb)">
                  <outline text="int maxCount = (64 * 1024 * 1024) - (32 * 1024);" />
                  <outline text="long size = inChannel.size();" />
                  <outline text="long position = 0;" />
                  <outline text="while ( position &amp;lt; size) {">
                    <outline text="position += inChannel.transferTo( position, maxCount, outChannel );" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="} finally {">
                  <outline text="if ( inChannel != null) {">
                    <outline text="inChannel.close();" />
                  </outline>
                  <outline text="}" />
                  <outline text="if ( outChannel != null) {">
                    <outline text="outChannel.close();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="使用iText JAR生成PDF">
              <outline text="import java.io.File;" />
              <outline text="import java.io.FileOutputStream;" />
              <outline text="import java.io.OutputStream;" />
              <outline text="import java.util.Date;" />
              <outline text="import com.lowagie.text.Document;" />
              <outline text="import com.lowagie.text.Paragraph;" />
              <outline text="import com.lowagie.text.pdf.PdfWriter;" />
              <outline text="public class GeneratePDF {">
                <outline text="public static void main(String[] args) {">
                  <outline text="try {">
                    <outline text="OutputStream file = new FileOutputStream(new File(&quot;C:\\Test.pdf&quot;));" />
                    <outline text="Document document = new Document();" />
                    <outline text="PdfWriter.getInstance(document, file);" />
                    <outline text="document.open();" />
                    <outline text="document.add(new Paragraph(&quot;Hello Kiran&quot;));" />
                    <outline text="document.add(new Paragraph(new Date().toString()));" />
                    <outline text="document.close();" />
                    <outline text="file.close();" />
                  </outline>
                  <outline text="} catch (Exception e) {">
                    <outline text="e.printStackTrace();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
        </outline>
        <outline text="#字典 #面试题">
          <outline text="#字典定义">
            <outline text="Map集合中的键对象不允许重复，也就说，任意两个键对象通过equals()方法比较的结果都是false.，但是可以将任意多个键独享映射到同一个值对象上。" />
            <outline text="标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap。" />
            <outline text="HashMap：Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。" />
            <outline text="LinkedHashMap： 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。" />
            <outline text="TreeMap ： 基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在 于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。" />
            <outline text="WeakHashMao ：弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。" />
            <outline text="IdentifyHashMap： : 使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计。" />
          </outline>
          <outline text="#字典size">
            <outline text="int size() ：返回集合中元素的数目" />
          </outline>
          <outline text="#判断元素存在性">
            <outline text="用 containsKey()和 containsValue() 测试 Map中是否包含某个“键”或“值”。" />
          </outline>
          <outline text="#字典遍历">
            <outline text="for (Map.Entry&amp;lt;Integer, String&amp;gt; entry : map.entrySet()) {">
              <outline text="// Map.entry&amp;lt;Integer,String&amp;gt; 映射项（键-值对）  有几个方法：用上面的名字entry " />
              <outline text="entry.getKey() ;entry.getValue(); entry.setValue();" />
              <outline text="//map.entrySet()  返回此映射中包含的映射关系的 Set视图。" />
              <outline text="System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot;+ entry.getValue());" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="#成员的新增删除">
            <outline text="Object &lt;b&gt;put&lt;/b&gt;(Object key, Object value)： 向集合中加入元素" />
            <outline text="Object remove(Object key)： 删除与KEY相关的元素" />
            <outline text="void putAll(Map t)：  将来自特定映像的所有元素添加给该映像" />
            <outline text="void clear()：从映像中删除所有映射" />
          </outline>
          <outline text="#查找key">
            <outline text="使用keySet()抽取key序列，将map中的所有keys生成一个Set。" />
          </outline>
          <outline text="#查找value">
            <outline text="Object get(Object key)：获得与关键字key相关的 value 。" />
            <outline text="使用values()抽取value序列，将map中的所有values生成一个Collection。" />
            <outline text="为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。" />
          </outline>
          <outline text="#排序" />
          <outline text="Android定制的字典类: SparseArray">
            <outline text="目的是节省内存开销. 方法是通过避免 基本数据类型的装箱操作." />
            <outline text="#字典定义">
              <outline text="SparseArray sparseArray = new SparseArray&amp;lt;&amp;gt;();    // 默认容量是10" />
              <outline text="SparseArray sparseArray = new SparseArray&amp;lt;&amp;gt;(capacity);  // 指定容量." />
            </outline>
            <outline text="#成员的新增删除">
              <outline text="sparseArray.put(int key,Student value);  // key永远是int型数据." />
              <outline text="sparseArray.remove(int key);" />
            </outline>
          </outline>
        </outline>
        <outline text="#UT" />
        <outline text="#平台兼容性" />
        <outline text="#泛型" />
        <outline text="#宏定义" />
        <outline text="集合">
          <outline text="Java的集合可以存放不同类型的对象. 但不能放基本数据类型." />
          <outline text="可以使用集合提供的ReadOnly方法，以只读方式来使用集合。该方法将返回一个集合的只读版本。" />
          <outline text="&lt;b&gt;Collection接口 #面试题 &lt;/b&gt;">
            <outline text="collection 定义集合的最基本的接口，List和Set都继承自&lt;b&gt;Collection接口.&lt;/b&gt;" />
            <outline text="boolean add(Object o) ：向集合中加入一个对象的引用" />
            <outline text="void clear()：删除集合中所有的对象，即不再持有这些对象的引用" />
            <outline text="boolean isEmpty() ：判断集合是否为空" />
            <outline text="boolean contains(Object o) ： 判断集合中是否持有特定对象的引用" />
            <outline text="boolean remove(Object o) ：从集合中删除一个对象的引用" />
            <outline text="int size() ：返回集合中元素的数目" />
            <outline text="Object[] toArray() ： 返回一个数组，该数组中包括集合中的所有元素" />
            <outline text="&lt;b&gt;Iterartor&lt;/b&gt; &lt;b&gt;iterator&lt;/b&gt;() ：返回一个Iterator对象，可以用来遍历集合中的元素. iterator&lt;b&gt; 接口定义了如下方法:&lt;/b&gt;">
              <outline text="hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true" />
              <outline text="next() ：返回下一个元素" />
              <outline text="remove()：从集合中删除上一个有next()方法返回的元素。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;List&lt;/b&gt;: 可以自动扩展的列表. 可存放重复对象。 #面试题">
            <outline text="List接口主要实现类包括：">
              <outline text="ArrayList() : 代表长度可以改变的数组。可对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢。">
                <outline text="ListIterator只应该用来由后向前遍历 ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。" />
              </outline>
              <outline text="LinkedList(): 在实现中采用链表数据结构。插入和删除速度快，随机访问速度慢。">
                <outline text="具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法使得LinkedList可以当作堆栈、队列和双向队列使用。" />
              </outline>
            </outline>
            <outline text="List 的 get(int index) 方法放回集合中由参数index指定的索引位置的对象，下标从“0” 开始。" />
            <outline text="使用 迭代器（Iterator）遍历:">
              <outline text="Iterator it=list.iterator();" />
              <outline text="while(it.hashNext()){">
                <outline text="System.out.println(it.next());" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;Set&lt;/b&gt;: 没有重复的集合 #面试题 ">
            <outline text="set是最简单的一种集合，集合中的对象不存在重复，不按特定的方式排序。" />
            <outline text="set接口主要实现了两个实现类：" />
            <outline text="HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快. ">
              <outline text="存入HashSet的对象必须定义hashCode()。" />
            </outline>
            <outline text="TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。">
              <outline text="保存次序的set, 底层为树结构。" />
            </outline>
            <outline text="LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。">
              <outline text="在使用迭代器遍历Set时，结果会按元素插入的次序显示。" />
            </outline>
            <outline text="set具有与Collection完全一样的接口，没有任何额外的功能，实际上Set就是Collection,只是行为不同: set不保存重复的元素." />
          </outline>
          <outline text="TreeSet, TreeList, Tree** : 自动排序的组数" />
          <outline text="把 Array 转换成 Map">
            <outline text="import java.util.Map;" />
            <outline text="import org.apache.commons.lang.ArrayUtils;" />
            <outline text="public class Main {">
              <outline text="public static void main(String[] args) {">
                <outline text="String[][] countries = { { &quot;United States&quot;, &quot;New York&quot; }, { &quot;United Kingdom&quot;, &quot;London&quot; },">
                  <outline text="{ &quot;Netherland&quot;, &quot;Amsterdam&quot; }, { &quot;Japan&quot;, &quot;Tokyo&quot; }, { &quot;France&quot;, &quot;Paris&quot; } }" />
                </outline>
                <outline text="Map countryCapitals = ArrayUtils.toMap(countries);" />
                <outline text="System.out.println(&quot;Capital of Japan is &quot; + countryCapitals.get(&quot;Japan&quot;));" />
                <outline text="System.out.println(&quot;Capital of France is &quot; + countryCapitals.get(&quot;France&quot;));" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="改变数组的大小">
            <outline text="private static Object resizeArray (Object oldArray, int newSize) {">
              <outline text="int oldSize = java.lang.reflect.Array.getLength(oldArray);" />
              <outline text="Class elementType = oldArray.getClass().getComponentType();" />
              <outline text="Object newArray = java.lang.reflect.Array.newInstance(">
                <outline text="elementType,newSize);" />
              </outline>
              <outline text="int preserveLength = Math.min(oldSize,newSize);" />
              <outline text="if (preserveLength &amp;gt; 0)">
                <outline text="System.arraycopy (oldArray,0,newArray,0,preserveLength);" />
              </outline>
              <outline text="return newArray;" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="媒体">
          <outline text="创建图片的缩略图">
            <outline text="private void createThumbnail(String filename, int thumbWidth, int thumbHeight, int quality, String outFilename)">
              <outline text="throws InterruptedException, FileNotFoundException, IOException {" />
              <outline text="// load image from filename" />
              <outline text="Image image = Toolkit.getDefaultToolkit().getImage(filename);" />
              <outline text="MediaTracker mediaTracker = new MediaTracker(new Container());" />
              <outline text="mediaTracker.addImage(image, 0);" />
              <outline text="mediaTracker.waitForID(0);" />
              <outline text="// use this to test for errors at this point: System.out.println(mediaTracker.isErrorAny());" />
              <outline text="// determine thumbnail size from WIDTH and HEIGHT" />
              <outline text="double thumbRatio = (double)thumbWidth / (double)thumbHeight;" />
              <outline text="int imageWidth = image.getWidth(null);" />
              <outline text="int imageHeight = image.getHeight(null);" />
              <outline text="double imageRatio = (double)imageWidth / (double)imageHeight;" />
              <outline text="if (thumbRatio &amp;lt; imageRatio) {">
                <outline text="thumbHeight = (int)(thumbWidth / imageRatio);" />
              </outline>
              <outline text="} else {">
                <outline text="thumbWidth = (int)(thumbHeight * imageRatio);" />
              </outline>
              <outline text="}" />
              <outline text="// draw original image to thumbnail image object and" />
              <outline text="// scale it to the new size on-the-fly" />
              <outline text="BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB);" />
              <outline text="Graphics2D graphics2D = thumbImage.createGraphics();" />
              <outline text="graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);" />
              <outline text="graphics2D.drawImage(image, 0, 0, thumbWidth, thumbHeight, null);" />
              <outline text="// save thumbnail image to outFilename" />
              <outline text="BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename));" />
              <outline text="JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);" />
              <outline text="JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage);" />
              <outline text="quality = Math.max(0, Math.min(quality, 100));" />
              <outline text="param.setQuality((float)quality / 100.0f, false);" />
              <outline text="encoder.setJPEGEncodeParam(param);" />
              <outline text="encoder.encode(thumbImage);" />
              <outline text="out.close();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="抓屏程序">
            <outline text="import java.awt.Dimension;" />
            <outline text="import java.awt.Rectangle;" />
            <outline text="import java.awt.Robot;" />
            <outline text="import java.awt.Toolkit;" />
            <outline text="import java.awt.image.BufferedImage;" />
            <outline text="import javax.imageio.ImageIO;" />
            <outline text="import java.io.File;" />
            <outline text="public void captureScreen(String fileName) throws Exception {">
              <outline text="Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();" />
              <outline text="Rectangle screenRectangle = new Rectangle(screenSize);" />
              <outline text="Robot robot = new Robot();" />
              <outline text="BufferedImage image = robot.createScreenCapture(screenRectangle);" />
              <outline text="ImageIO.write(image, &quot;png&quot;, new File(fileName));" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="网络">
          <outline text="HTTP 代理设置">
            <outline text="System.getProperties().put(&quot;http.proxyHost&quot;, &quot;someProxyURL&quot;);" />
            <outline text="System.getProperties().put(&quot;http.proxyPort&quot;, &quot;someProxyPort&quot;);" />
            <outline text="System.getProperties().put(&quot;http.proxyUser&quot;, &quot;someUserName&quot;);" />
            <outline text="System.getProperties().put(&quot;http.proxyPassword&quot;, &quot;somePassword&quot;);" />
          </outline>
          <outline text="发送邮件">
            <outline text="import javax.mail.*;" />
            <outline text="import javax.mail.internet.*;" />
            <outline text="import java.util.*;" />
            <outline text="public void postMail(String recipients[ ], String subject, String message , String from) throws MessagingException {">
              <outline text="boolean debug = false;">
                <outline text="//Set the host smtp address" />
                <outline text="Properties props = new Properties();" />
                <outline text="props.put(&quot;mail.smtp.host&quot;, &quot;smtp.example.com&quot;);" />
              </outline>
              <outline text="// create some properties and get the default Session" />
              <outline text="Session session = Session.getDefaultInstance(props, null);" />
              <outline text="session.setDebug(debug);" />
              <outline text="// create a message" />
              <outline text="Message msg = new MimeMessage(session);" />
              <outline text="// set the from and to address" />
              <outline text="InternetAddress addressFrom = new InternetAddress(from);" />
              <outline text="msg.setFrom(addressFrom);" />
              <outline text="InternetAddress[] addressTo = new InternetAddress[recipients.length];" />
              <outline text="for (int i = 0; i &amp;lt; recipients.length; i++) {">
                <outline text="addressTo[i] = new InternetAddress(recipients[i]);" />
              </outline>
              <outline text="}" />
              <outline text="msg.setRecipients(Message.RecipientType.TO, addressTo);" />
              <outline text="// Optional : You can also set your custom headers in the Email if you Want" />
              <outline text="msg.addHeader(&quot;MyHeaderName&quot;, &quot;myHeaderValue&quot;);" />
              <outline text="// Setting the Subject and Content Type" />
              <outline text="msg.setSubject(subject);" />
              <outline text="msg.setContent(message, &quot;text/plain&quot;);" />
              <outline text="Transport.send(msg);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="发送代数据的HTTP 请求">
            <outline text="import java.io.BufferedReader;" />
            <outline text="import java.io.InputStreamReader;" />
            <outline text="import java.net.URL;" />
            <outline text="public class Main {">
              <outline text="public static void main(String[] args) {">
                <outline text="try {">
                  <outline text="URL my_url = new URL(&quot;http://coolshell.cn/&quot;);" />
                  <outline text="BufferedReader br = new BufferedReader(new InputStreamReader(my_url.openStream()));" />
                  <outline text="String strTemp = &quot;&quot;;" />
                  <outline text="while(null != (strTemp = br.readLine())){" />
                  <outline text="System.out.println(strTemp);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="} catch (Exception ex) {">
                <outline text="ex.printStackTrace();" />
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="设计模式">
          <outline text="单例 Singleton示例1  #面试题 ">
            <outline text="public class SimpleSingleton {">
              <outline text="private static SimpleSingleton singleInstance = new SimpleSingleton();" />
              <outline text="//Marking default constructor private" />
              <outline text="//to avoid direct instantiation." />
              <outline text="private SimpleSingleton() {" />
              <outline text="}" />
              <outline text="//Get instance for class SimpleSingleton" />
              <outline text="public static SimpleSingleton getInstance() {">
                <outline text="return singleInstance;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="单例 Singleton示例2  #面试题 ">
            <outline text="public enum SimpleSingleton {">
              <outline text="INSTANCE;" />
              <outline text="public void doSomething() {" />
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="//Call the method from Singleton:" />
            <outline text="SimpleSingleton.INSTANCE.doSomething();" />
          </outline>
        </outline>
        <outline text="Lamada表达式 #面试题 ">
          <outline text="λ表达式本质上是一个匿名方法。比如：">
            <outline text="public int add(int x, int y) {">
              <outline text="return x + y;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="转成λ表达式后是这个样子: (int x, int y) -&amp;gt; x + y;" />
          <outline text="参数类型也可以省略：(x, y) -&amp;gt; x + y; //返回两数之和" />
          <outline text="或者 (x, y) -&amp;gt; { return x + y; }" />
          <outline text="可见λ表达式有三部分组成：参数列表，箭头（-&amp;gt;），以及一个表达式或语句块。" />
          <outline text="如果没有参数, 就省事了:  () -&amp;gt; { System.out.println(&quot;Hello Lambda!&quot;); }" />
          <outline text="如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：">
            <outline text="c -&amp;gt; { return c.size(); }" />
          </outline>
          <outline text="λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。">
            <outline text="Thread gaoDuanDaQiShangDangCi = new Thread( () -&amp;gt; {">
              <outline text="System.out.println(&quot;This is from an anonymous method (lambda exp).&quot;);" />
            </outline>
            <outline text="} );" />
            <outline text="并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。" />
          </outline>
          <outline text="更多高级的内容参见: https://www.jb51.net/article/104903.htm" />
        </outline>
        <outline text="Kotlin">
          <outline text="一个用于多平台应用的静态编程语言。非常年轻。" />
          <outline text="Kotlin完全兼容Java的语言，可以编译成Java字节码，支持在JVM上运行。" />
          <outline text="也可以编译成JavaScript，方便在没有JVM的设备上运行。" />
          <outline text="在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。" />
        </outline>
      </outline>
      <outline text="&lt;b&gt;02-C&amp;amp;C++&lt;/b&gt;">
        <outline text="代码组织方式">
          <outline text="C语言：头文件 .h 和 .c文件. 以文件为单位来组织的." />
          <outline text="C++：头文件也可以写代码." />
          <outline text="冒号（:）的用法 (c++)">
            <outline text="类名后面的冒号是用于定义类的继承关系；" />
            <outline text="构造函数后面的冒号用于成员变量的赋值，常见于const常量。如：">
              <outline text="struct MyStruct{">
                <outline text="MyStruct(): Param(initValue) {…}" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
          <outline text="双冒号(::)的用法 (c++)">
            <outline text="表示“域操作符”。申明一个类成员函数 void func()，则在类外定义它时，要写成void MyClass::func()" />
            <outline text="用于函数前，表示是全局函数。例如 ::flock()" />
            <outline text="表示应用成员函数或变量，等价于.号。">
              <outline text="如：System::Math::Sqrt(), 等价于 System.Math.Sqrt()" />
            </outline>
          </outline>
          <outline text="mian函数(主函数, 入口函数) #面试题 ">
            <outline text="int main( int argc, char *argv[]) {">
              <outline text="return 0;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="预处理  #面试题 ">
            <outline text="防止头文件重复包含。有两种方式：">
              <outline text="常用: # ifndef  ***，# define  ***，# endif /* *** */" />
              <outline text="文件第一行用: # pragma once" />
            </outline>
          </outline>
        </outline>
        <outline text="类和对象">
          <outline text="class, 类定义(C++)">
            <outline text="在C++中，对于类的定义和实现是否要分别在h文件和cpp文件中并没有做严格要求。但一般是要分开的。 " />
            <outline text="// .h文件" />
            <outline text="class MyClass : public SuperClass" />
            <outline text="{">
              <outline text="public:  // 方法常公有">
                <outline text="MyClass();   // 构造函数1，无参数。构造函数没有返回值。" />
                <outline text="MyClass(int param);   // 构造函数2，有参数。" />
                <outline text="~MyClass();   // 析构函数。析构函数没有参数，也没有返回值。" />
                <outline text="int myFunc1();  // 其它对外接口。" />
              </outline>
              <outline text="private: // 属性常私有">
                <outline text="static int staticParam = 0;   // 静态成员属性。后文可看到，这是个访问计数。" />
                <outline text="int myParam1;" />
              </outline>
            </outline>
            <outline text="};" />
            <outline text="// .cpp文件" />
            <outline text="# include &amp;lt;MyClass.h&amp;gt;" />
            <outline text="int MyClass::myParam1;    // 属性要重新引用。这个略奇葩。" />
            <outline text="MyClass::MyClass(): SuperClass() {  // 显示调用父类的构造函数">
              <outline text="myParam1 = 0;" />
              <outline text="staticParam++;" />
            </outline>
            <outline text="}" />
            <outline text="MyClass::MyClass(int param): SuperClass() {  // 显示调用父类的构造函数">
              <outline text="myParam1 = param;" />
              <outline text="staticParam++;" />
            </outline>
            <outline text="}" />
            <outline text="MyClass::~MyClass() {">
              <outline text="staticParam—;" />
              <outline text="if (staticParam &amp;lt; 0) {">
                <outline text="LogE(“MyClass free erro.&quot;);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="int myFunc1() {">
              <outline text="myParam1 *= 2.5;" />
              <outline text="return myParam1;" />
            </outline>
            <outline text="}" />
            <outline text="注意:（1）子类不能访问基类中的私有对象；" />
            <outline text="（2）不要new基类，要new子类。new基类，就和子类无关了。" />
            <outline text="（3）慎用友元." />
          </outline>
          <outline text="struct, 结构定义(C语言)">
            <outline text="struct stuff {">
              <outline text="char job[20];" />
              <outline text="int age;" />
              <outline text="float height;" />
            </outline>
            <outline text="} Qinwei;" />
            <outline text="Qinwei是结构变量. 可以直接使用." />
            <outline text="在其他位置定义变量是, 需要用: struct stuff Qinwei2;" />
            <outline text="使用 &lt;b&gt;typedef&lt;/b&gt; struct stuff{}Qinwei;  这种方式定义, 则定义结构变量时, 直接用 Qinwei Qinwei3;  Qinwei相当于类型别名." />
          </outline>
          <outline text="static 关键字  #面试题">
            <outline text="用于静态量." />
            <outline text="用于定义函数, 即定义私有函数, 只能被本类或本文件访问." />
            <outline text="用于定义全局变量, 即定义私有全局变量, 只能被本类或本文件访问." />
            <outline text="用于定义局部变量, 即定义局部静态变量, 它虽然只能被所在函数访问, 但生命周期是全局的, 会保留上一次的值." />
          </outline>
          <outline text="const 关键字 #面试题">
            <outline text="用于定义常量, 不可被修改." />
            <outline text="用于定义函数参数, 即不能被函数修改. 推荐使用." />
            <outline text="用于定义函数返回值, 即返回值的值不可修改. 很少用." />
            <outline text="用于定义函数, 即函数不可修改类数据成员的值.  推荐使用. (C++)" />
          </outline>
          <outline text="extern 关键字 #面试题">
            <outline text="extern用于定义变量或者函数时, 以标示变量或者函数的定义在别的文件中, 编译时不再检查其有效性. 当然如果实际是无效的, 在链接时还是会报错." />
            <outline text="它还可以用于 链接指定. " />
            <outline text="extern &quot;C&quot; void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去编译." />
            <outline text="因为 C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$. 因为c++支持多态." />
          </outline>
          <outline text="std::make_unique">
            <outline text="C++V11上支持, VS 2015支持." />
            <outline text="make_unique 同 unique_ptr 、auto_ptr 等一样，都是 smart pointer;" />
            <outline text="可以取代new 并且无需 delete pointer，有助于代码管理。" />
            <outline text="make_unique 创建并返回 unique_ptr 至指定类型的对象，这一点从其构造函数能看出来。make_unique相较于unique_ptr 则更加安全。" />
            <outline text="推荐使用." />
          </outline>
          <outline text="explicit 关键字  #面试题 ">
            <outline text="仅用于类的构造函数上。功能是禁止类的隐式类型转换。" />
          </outline>
          <outline text="auto 关键字 #面试题 ">
            <outline text="auto 表示不知道数据的类型，而由编译器来推导。" />
          </outline>
        </outline>
        <outline text="Hello world">
          <outline text="# include &amp;lt;stdio.h&amp;gt;" />
          <outline text="int main( void ) {">
            <outline text="printf(&quot;Hello world!\n&quot;);" />
          </outline>
          <outline text="}" />
          <outline text="编译：cc hello.cpp" />
        </outline>
        <outline text="注释">
          <outline text="// 单行注释" />
          <outline text="/* 多行" />
          <outline text="注释 */" />
        </outline>
        <outline text="Log打印">
          <outline text="打印到文件">
            <outline text="fprintf(fp, “%s %s\t %s\t%s\t%s\n”, __DATA__, __TIME, __FILE__, __LINE__, argv[0]); " />
          </outline>
          <outline text="打印堆栈  --android上不可用">
            <outline text="# include &amp;lt;execinfo.h&amp;gt;" />
            <outline text="void * array[16];" />
            <outline text="int stack_num = backtrace(array, 16);" />
            <outline text="char ** stacktrace = backtrace_symbols(array, stack_num);" />
            <outline text="ALOGE(&quot;stack begin:&quot;);" />
            <outline text="for (int ii=0; ii&amp;lt;stack_num; ++ii) {">
              <outline text="ALOGE(&quot;\t%s&quot;, stacktrace[ii]);" />
            </outline>
            <outline text="}" />
            <outline text="free(stacktrace);" />
          </outline>
          <outline text="打印堆栈  --Android可用">
            <outline text="# include &amp;lt;utils/CallStack.h&amp;gt;" />
            <outline text="新版本(多新不清楚, 先用这个)">
              <outline text="android::CallStack stack(&quot; begin:&quot;);" />
            </outline>
            <outline text="老版本">
              <outline text="android::CallStack stack;" />
              <outline text="stack.update();" />
              <outline text="stack.log(&quot;begin:&quot;);" />
            </outline>
            <outline text="编译文件中加入对 libutils 库的 shared 依赖。" />
            <outline text="编译开关： 为了自带符号表，开关加上 -rdynamic, -g" />
          </outline>
        </outline>
        <outline text="函数（传值、传地址、传引用）">
          <outline text="一般函数: int myFunc(int ii, char * string) {…} " />
          <outline text="变参函数">
            <outline text="void simple_va_fun(int start, …) {">
              <outline text="va_list arg_prt;" />
              <outline text="int nArgValue = start;   // 第一个参数" />
              <outline text="int nArgCount = 0;" />
              <outline text="va_start(arg_ptr, start);" />
              <outline text="do {   // 遍历各个参数">
                <outline text="++nArgCount;" />
                <outline text="printf(“the %d argument is %d”, nArgCount, nArgValue);" />
              </outline>
              <outline text="} while (nArgValue != -1);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="宏定义中使用可变参数">
            <outline text="c99支持 ## _VA_ARGS_ 宏。" />
            <outline text="# define debug(… ) printf (_VA_ARGS_)" />
            <outline text="使用时：debug(“y=%d\n”, y);" />
            <outline text="gcc还支持一种格式，就是：# define dbprint(format, args…) frpintf(stderr, format, ##args) " />
          </outline>
          <outline text="参数传递分为传值、传地址、传引用。 #面试题">
            <outline text="基本数据类型、&lt;b&gt;结构体&lt;/b&gt;默认是传值. " />
            <outline text="数组、字符串、指针、对象默认是传地址。" />
          </outline>
          <outline text="除语义差异外，传值涉及值拷贝，可能有性能问题。" />
          <outline text="c++中提供传引用的方法，推荐使用。 #面试题">
            <outline text="void myFunc(int &amp;amp;param) {…}   // 用&amp;amp;定义" />
            <outline text="函数体中直接使用变量名 param，不需要加什么符号。" />
            <outline text="传参时也直接传，myFunc(myParam) ，不需要加什么符号，所以相对简单。" />
            <outline text="传引用的参数，在退出函数后还可以保持，这个和指针类似。但是和指针不同的是，引用不能做指针运算。" />
          </outline>
        </outline>
        <outline text="整数&amp;amp;布尔量&amp;amp;枚举量">
          <outline text="整数常量">
            <outline text="二进制数： 0b101, 0B01。注意，只有部分编译器支持这种写法。" />
            <outline text="八进制数： 0712（以数字零开始）" />
            <outline text="十进制数：无前缀" />
            <outline text="十六进制：0x123abc， 0X789def" />
          </outline>
          <outline text="整数">
            <outline text="char ii;  // 8位，正负128" />
            <outline text="short ii;   // 16位。 正负 " />
            <outline text="int ii;   // 32位。正负20亿" />
            <outline text="long ii;  // 32位。long跨平台性稍差，不建议使用。" />
            <outline text="long long ii;  // 64位" />
          </outline>
          <outline text="负数和有符号数">
            <outline text="负数在有符号数中用补码表示。补码是绝对值按位取反+1。" />
            <outline text="int和uint运算时，int会先转为uint。" />
          </outline>
          <outline text="&lt;b&gt;位运算&lt;/b&gt; --C语言的特色，而且不想设想的那么简单">
            <outline text="设置整数的bit 3，保证其他位不变">
              <outline text="a |= (1&amp;lt;&amp;lt;3);" />
              <outline text="# define SET_BIT(x,n)    (x | 1U&amp;lt;&amp;lt;(n-1))" />
            </outline>
            <outline text="设置整数的bit 3~bit 7，保持其他位不变">
              <outline text="a |= (0x1f&amp;lt;&amp;lt;3);" />
            </outline>
            <outline text="清除整数的bit 15，保证其他位不变">
              <outline text="a &amp;amp;= ~(1&amp;lt;&amp;lt;15);" />
              <outline text="# define CLEAR_BIT(x,n) (x &amp;amp; ~(1U&amp;lt;&amp;lt;(n-1)))" />
            </outline>
            <outline text="清除整数的bit 15~bit 23，保持其他位不变">
              <outline text="a &amp;amp;= ~(0x1ff&amp;lt;&amp;lt;15);" />
            </outline>
            <outline text="取出整数的bit 3~bit 8">
              <outline text="(a &amp;amp; (0x3f&amp;lt;&amp;lt;3)) &amp;gt;&amp;gt;= 3" />
              <outline text="# define GET_BIT(x,n,m)    (x &amp;amp; ~(~0U&amp;lt;&amp;lt;(m-n+1))&amp;lt;&amp;lt;(n-1)) &amp;gt;&amp;gt;(n-1)" />
            </outline>
            <outline text="给整数的bit 7～bit 17赋值 937，其余位不受影响">
              <outline text="要赋值就需要把要赋值的那几位清零&amp;amp;，然后把需要赋值的数左移到那几位上就可以了。" />
              <outline text="a &amp;amp;= (~(0x7ff&amp;lt;&amp;lt;7));" />
              <outline text="a |= (937&amp;lt;&amp;lt;7);" />
            </outline>
            <outline text="给整数的bit 7～bit 17中的值加17，其余位不受影响">
              <outline text="要加值，就要把那几位的数字取出来，然后把那几位清零&amp;amp;，之后右移，相加，左移，再置1。" />
              <outline text="tmp = a &amp;amp; (0x7ff&amp;lt;&amp;lt;7);" />
              <outline text="a &amp;amp;= (~(0x7ff&amp;lt;&amp;lt;7));" />
              <outline text="tmp &amp;gt;&amp;gt;= 7;" />
              <outline text="tmp += 17;" />
              <outline text="tmp &amp;lt;&amp;lt;= 7;" />
              <outline text="a |= tmp;" />
            </outline>
          </outline>
          <outline text="intptr_t">
            <outline text="C99 标准新增的数据类型." />
            <outline text="intptr_t是一个整数, 其长度总是所在平台的位数，方便用于存放地址。" />
            <outline text="这个纯是为了跨平台." />
            <outline text="不过, Linux内核基本不用这个数据类型." />
          </outline>
          <outline text="布尔量">
            <outline text="c用 char 表示布尔变量。0表示false，非0表示true。" />
            <outline text="c++有bool类型，有true和false两个值。但在逻辑运算中，默认非零为true。" />
          </outline>
          <outline text="枚举量">
            <outline text="enum enumType {">
              <outline text="Monday = 0," />
              <outline text="TuesDay = 1," />
              <outline text="…" />
            </outline>
            <outline text="};" />
            <outline text="enumType WeekDay;" />
            <outline text="enum数据类型被当做int型， 占4个字节。" />
            <outline text="如果想限制为1个字节长度，可用如下方式，但仅在C++11之后可以用。">
              <outline text="typedef enum weekday: unsigned char {" />
              <outline text="SUN, MON, TUE, WED, THU, FRI, SAT" />
              <outline text="} weekday_t;" />
            </outline>
          </outline>
        </outline>
        <outline text="浮点数">
          <outline text="浮点数在内存中按科学计数法来存储。其整数部分始终是一个个位数。" />
          <outline text="float number;  // 32位。小数部分占23位，相当于十进制的6-7位，所以其精度是支持6-7位小数。" />
          <outline text="double complex;  // 128位。小数部分占52位，精度为15-16位小数。" />
        </outline>
        <outline text="常量&amp;amp;全局变量&amp;amp;静态变量">
          <outline text="常量：const int ii = 32;" />
          <outline text="全局变量：在函数外部定义的变量, 可以被其它代码文件调用。">
            <outline text=".data段 保存进程所有的已初始化的全局变量." />
            <outline text=".bss段 保存进程未初始化的全局变量." />
          </outline>
          <outline text="静态全局变量：全局变量加 static. 只能被所在的文件访问, 其它文件不能访问.">
            <outline text="存放位置和全局变量相同." />
          </outline>
          <outline text="静态局部变量: 局部变量(即在函数内部定义) 加 static. ">
            <outline text="如果没有初始化, 会被自动赋值为0. " />
            <outline text="静态局部变量会统一放在 .data 段. " />
            <outline text="全局存在, 但是只能被所在的文件访问, 其它文件不能访问." />
          </outline>
        </outline>
        <outline text="运算符表（优先级由高到底）">
          <outline text="() [] -&amp;gt; .   括号（函数等），数组，两种结构成员访问. 由左向右" />
          <outline text="! ~ ++ -- + - * &amp;amp; (类型) sizeof  取反，按位取反，增量，减量，正负号，间接，取地址，类型转换，求大小. 由右向左">
            <outline text="~： 按位取反" />
          </outline>
          <outline text="/ %  乘，除，取模. 由左向右" />
          <outline text="+ -  加，减. 由左向右" />
          <outline text="&amp;lt;&amp;lt; &amp;gt;&amp;gt;  左移，右移. 由左向右" />
          <outline text="&amp;lt; &amp;lt;= &amp;gt;= &amp;gt;  小于，小于等于，大于等于，大于. 由左向右" />
          <outline text="== !=  等于，不等于. 由左向右" />
          <outline text="&amp;amp;  按位与. 由左向右。两个位都是1才是1，否则都是0." />
          <outline text="^  按位异或. 由左向右" />
          <outline text="|  按位或. 由左向右" />
          <outline text="&amp;amp;&amp;amp;  逻辑与. 由左向右" />
          <outline text="||  逻辑或. 由左向右" />
          <outline text="? :  条件. 由右向左" />
          <outline text="= += -= *= /= &amp;amp;= ^= |= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;=  各种赋值. 由右向左" />
          <outline text=",  逗号（顺序）  由左向右" />
        </outline>
        <outline text="数据的拆箱和装箱" />
        <outline text="指针&amp;amp;引用">
          <outline text="定义指针: int *myPtr = &amp;amp;myInt;" />
          <outline text="使用指针访问值: *myPtr; // 即myInt" />
          <outline text="打印地址: printf(&quot;%p&quot;, myPtr);" />
          <outline text="指针使用前, 务必要判空. if (myPtr != NULL), 或者 if(myPtr) " />
          <outline text="指针的运算: ++、--、+、-">
            <outline text="注意，运算的单位取决于数据的类型，而不是一个字节。如果是数组，一次跳转的距离可能远远超出意料之外。" />
            <outline text="我试过一次跳过4G，当然是bug了。" />
          </outline>
          <outline text="&lt;b&gt;引用（c++）&lt;/b&gt;">
            <outline text="int m;" />
            <outline text="int &amp;amp;n = m;  // n相当于m的别名，对n的任何操作就是对m的操作。" />
            <outline text="引用和指针的区别  #面试题 ">
              <outline text="引用必须在定义的同时被初始化，而且只能初始化为合法的存储单元. 指针没有这个限制." />
              <outline text="引用初始化后，就不能再更改引用关系。指针没有这个限制." />
              <outline text="指针可以跳转, 运算, 引用不可以." />
            </outline>
          </outline>
          <outline text="c++提供的指针强转的序列关键字">
            <outline text="c++中对指针强转做了一些保护. " />
            <outline text="const_cast 的功能是去掉类型的const或者volatile属性. 如:">
              <outline text="const Sa ra;" />
              <outline text="Sa &amp;amp;rb = const_cast&amp;lt;Sa &amp;amp;&amp;gt;(ra);" />
            </outline>
            <outline text="static_cast: 静态类型转换. 用于基类和子类间的转换, 不支持非继承关系的类型之间的转换. 如:">
              <outline text="int n = 8;" />
              <outline text="double d = static_cast&amp;lt;double&amp;gt;(n);" />
            </outline>
            <outline text="dynamic_cast: 动态类型转换. 也是用于基类和子类间的转换, 而且会做转换类型检查, 不安全的会返回null. 所谓安全, 就是指只能从子类转化为基类." />
            <outline text="reinterpret_cast: 无条件强制, 仅重新解释类型, 不做任何二进制的转换. 和C的强制类似, 没有安全保障." />
          </outline>
          <outline text="android 智能指针(sp/wp)">
            <outline text="android定义了两类智能指针, 强指针sp(strong pointer)/弱指针(weak pointer), 相关代码在:" />
            <outline text="/system/core/include/utils/strongpointer.h" />
            <outline text="/system/core/include/utils/RefBase.h" />
            <outline text="/system/core/libutils/RefBase.cpp" />
            <outline text="sp与一般意义上的智能指针概念相同, 通过引用计数来记录有多少个使用者在使用一个对象, 如果所有使用者都放弃了对该对象的引用, 则对象自动销毁." />
            <outline text="wp也指向一个对象, 但wp仅记录对象地址, 不管理对象的生命周期, 所以不能通过该指针访问该对象." />
            <outline text="要用sp/wp来个对象, 那么它需要满足两个条件:">
              <outline text="要是RefBase的子类;" />
              <outline text="要定义虚拟的析构函数, 即 virtual ~myClass();" />
            </outline>
            <outline text="sp的使用">
              <outline text="初始化:sp&amp;lt;myClass&amp;gt;sp = new myClass();" />
              <outline text="调用接口: sp-&amp;gt;myFunction();" />
              <outline text="获取原来的对象: sp.get();" />
              <outline text="指针重新赋值: sp重载了operate=, 重新赋值会自动将原来的引用减一, 新的引用加一." />
              <outline text="手动清理: sp.clear();" />
              <outline text="不用时, 将sp指针改为null;" />
            </outline>
            <outline text="wp的使用">
              <outline text="wp不能直接使用, 用之前要先升级为sp, 即sp = wp.promote();" />
              <outline text="promote()失败表示对象已经销毁. 所以需要检查得到的sp指针是否为空. " />
            </outline>
          </outline>
          <outline text="C++智能指针: std::unique_ptr">
            <outline text="c++标准库提供的智能指针解决方案. 用法是: ">
              <outline text="std::unique_ptr&amp;lt;MyClass&amp;gt; myPtr = new MyClass;" />
            </outline>
          </outline>
        </outline>
        <outline text="对象判空">
          <outline text="if (myObj &amp;lt;&amp;gt; NULL) {...}" />
        </outline>
        <outline text="对象的元属性">
          <outline text="sizeof()" />
          <outline text="typeof()">
            <outline text="typeof 支持的情况不太统一. 它的作用是自动推导表达式的数据类型，以解决泛型编程中有些类型由模板参数决定而难以表示的问题。" />
          </outline>
          <outline text="c++中新增 typeid 关键字, 更强大.">
            <outline text="# include &amp;lt;typeinfo&amp;gt;" />
            <outline text="MyClass myObj;" />
            <outline text="const type_info &amp;amp;myInfo = typeid(myObj);" />
            <outline text="cout &amp;lt;&amp;lt;myInfo.name() &amp;lt;&amp;lt; “|” &amp;lt;&amp;lt; myInfo.raw_name() &amp;lt;&amp;lt; “|” &amp;lt;&amp;lt; myInfo.hash_code() &amp;lt;&amp;lt; endl;" />
            <outline text="输出: class MyClass | .?MyClass@@ | 1035034553" />
          </outline>
        </outline>
        <outline text="For&amp;amp;While">
          <outline text="&lt;b&gt;for&lt;/b&gt; (int ii = 1; ii &amp;lt; limit; ii++) {...}   #面试题 " />
          <outline text="&lt;b&gt;while&lt;/b&gt; (myInt &amp;lt;= 100) {…}  // 先循环一遍再判断 #面试题 " />
          <outline text="&lt;b&gt;do&lt;/b&gt; {…} &lt;b&gt;while&lt;/b&gt; (myInt &amp;lt;= 100)  // 先判断再循环  #面试题 " />
          <outline text="while(1) { }   // 死循环" />
        </outline>
        <outline text="If&amp;amp;Switch">
          <outline text="if (myInt &amp;gt; 0) {...}" />
          <outline text="switch(myInt) {">
            <outline text="case 1:">
              <outline text="…" />
              <outline text="break;" />
            </outline>
            <outline text="case 2:">
              <outline text="…" />
              <outline text="break;" />
            </outline>
            <outline text="default:">
              <outline text="…" />
              <outline text="break;" />
            </outline>
          </outline>
          <outline text="}" />
        </outline>
        <outline text="字符串">
          <outline text="转义符">
            <outline text="\n: 换行" />
            <outline text="\r: 回车" />
            <outline text="\t: Tab符" />
            <outline text="\f: 清屏并换页" />
            <outline text="\\: \本身" />
            <outline text="%%: %本身" />
          </outline>
          <outline text="字符串定义  #面试题 ">
            <outline text="c语言的字符串是一个以’\0’结尾的字符数组. 有两种方式定义:" />
            <outline text="# include &amp;lt;string.h&amp;gt;" />
            <outline text="char myString[] = “Hello world!”;" />
            <outline text="char *myString = “Hello world!”;    // 此时myString指向常量区. 做指针运算的时候要格外小心." />
          </outline>
          <outline text="unicode字符串">
            <outline text="andorid 中, string8.h 是系统提供的utf8字符串类. 还有 string16.h 类." />
            <outline text="代码在: frameworks/native/include/utils/String8.h.   其用法是:" />
            <outline text="String8 myStr1(“Hello android&quot;);" />
            <outline text="String8 myStr2(“ is good! ^_^&quot;);" />
            <outline text="String8 add8 = str1 + str2;   // 用比较自然的方法连接字符串" />
            <outline text="cout&amp;lt;&amp;lt;&quot;name:&quot;&amp;lt;&amp;lt;add8.string()&amp;lt;&amp;lt;endl;  // 通过string()得到它的字符串." />
            <outline text="add8.setTo(“Hello world”);  // 字符串重新定义" />
            <outline text="add8.append(&quot; is good!”);   // 另外一种连接字符串的方式" />
            <outline text="cout&amp;lt;&amp;lt;String8::format(&quot;hello %c&quot;,&quot;world&quot;).string()&amp;lt;&amp;lt;endl;  // 还可以这样." />
          </outline>
          <outline text="字符串取长">
            <outline text="uint strlen(const char *);   长度不包括结束符”\0”." />
            <outline text="sizeof 和 strlen 的区别 #面试题 ">
              <outline text="sizeof 是一个操作符，strlen 是库函数。" />
              <outline text="sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。" />
            </outline>
          </outline>
          <outline text="字符串去空格">
            <outline text="int stringTrim(char * p, char * buf){">
              <outline text="int ret = 0, ncount = 0, begin = 0;" />
              <outline text="int end = strlen(p) - 1;" />
              <outline text="if (p == NULL || buf == NULL) {">
                <outline text="return -1;    // fail" />
              </outline>
              <outline text="}" />
              <outline text="while (isspace(p[begin]) &amp;amp;&amp;amp; p[begin] != '\0'){">
                <outline text="begin++;" />
              </outline>
              <outline text="}" />
              <outline text="while (isspace(p[end]) &amp;amp;&amp;amp; end&amp;gt;0){">
                <outline text="end--;" />
              </outline>
              <outline text="}" />
              <outline text="ncount = end - begin + 1;" />
              <outline text="strncpy_s(buf, ncount + 1, p + i, ncount);" />
              <outline text="buf[ncount] = '\0';" />
              <outline text="return ret;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="字符串拼接">
            <outline text="char *strcat(char *dest, const char *src);   // 返回指向 dest 的指针. " />
          </outline>
          <outline text="字符串截取">
            <outline text="char *strncpy(char *dest, char *src, int n);   // 返回指向 dest 的指针.  " />
            <outline text="注意第三个参数 n 不包括结束符, 所以dest的size一定要不小于n+1." />
            <outline text="如果要实现截取从m开始到n的,可以这样做:" />
            <outline text="strncpy(dest ,str + n , m-n);" />
          </outline>
          <outline text="字符串比较">
            <outline text="int strcmp(const char *s1, const char *s2);" />
            <outline text="返回值为0表示相等, 大于零表示 str1 比较大, 反之 str2 比较大." />
            <outline text="还有一种, strncmp(str1, str2, int n);   // 只比较前n个字符." />
          </outline>
          <outline text="字符串查找">
            <outline text="在字符串str1中定位字符串str2首次出现的位置">
              <outline text="const char * &lt;b&gt;strstr&lt;/b&gt; ( const char * str1, cosnt char *str2);   // 没有找到返回 NULL." />
            </outline>
            <outline text="返回在字符串str1里找到字符串str2里的任意一个字符之前已查找的字符数量">
              <outline text="size_t strcspn ( const char * str1, const char * str2);   // 不是太好理解,  例如:" />
              <outline text="char *str = &quot;Linux was first developed for 386/486-based pcs. “;" />
              <outline text="printf(&quot;%d\n&quot;, strcspn(str, &quot;1234567890&quot;));" />
              <outline text="返回值是:计算到出现数字字符为止, 所以返回&quot;3&quot;出现前的长度(有点像正则表达式)" />
            </outline>
            <outline text="在字符串str1里定位字符串str2里任意一个首次出现的字符: const char * strpbrk (const char * str1, const char * str2);" />
            <outline text="返回字符串str1从开始字符到第一个不在str2中的字符个数: size_t strspn ( const char * str1, const char * str2);" />
            <outline text="在指定内存里查找给定字符: void * memchr ( const void * str, int character, size_t num); // character为要找的字" />
            <outline text="在指定字符串里定位给定字符: char * strchr ( const char * str, int character);" />
            <outline text="在字符串里定位给定字符最后一次出现的位置: const char * strrchr ( const char * str, int character);" />
          </outline>
          <outline text="字符串替换">
            <outline text="char *replacestr(char *strbuf, char *sstr, char *dstr){">
              <outline text="char *p,*p1;" />
              <outline text="int len;" />
              <outline text="if ((strbuf == NULL)||(sstr == NULL)||(dstr == NULL)) return NULL;" />
              <outline text="p = strstr(strbuf, sstr);" />
              <outline text="if (p == NULL) return NULL;  // 不包含子串则直接退出" />
              <outline text="len = strlen(strbuf) + strlen(dstr) - strlen(sstr);" />
              <outline text="p1 = malloc(len);" />
              <outline text="bzero(p1, len);" />
              <outline text="strncpy(p1, strbuf, p - strbuf);" />
              <outline text="strcat(p1, dstr);" />
              <outline text="p += strlen(sstr);" />
              <outline text="strcat(p1, p);" />
              <outline text="return p1;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="字符串切分">
            <outline text="char *strtok(char *str, const char *delim); str为要切分的字符串，delim为分隔符字符串。" />
            <outline text="返回值：从str开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。" />
            <outline text="另外: strtok函数线程不安全，可以使用strtok_r替代。" />
            <outline text="例子:" />
            <outline text="char s[] = &quot;Golden Global View,disk * desk&quot;;" />
            <outline text="const char *d = &quot; ,*&quot;;" />
            <outline text="char *p;" />
            <outline text="p = strtok(s,d);" />
            <outline text="while(p)" />
            <outline text="{">
              <outline text="printf(&quot;%s\n&quot;,p);" />
              <outline text="p=strtok(NULL,d);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="字符串的格式化输出  #面试题 ">
            <outline text="格式化输出:  int &lt;b&gt;snprintf&lt;/b&gt;(char *str, size_t n, char * format [, argument, ...]);  // 将格式化的数据写入字符串." />
            <outline text="其中: str 为要写入的字符串；" />
            <outline text="n 是要写入的字节数。 &lt;b&gt;注意，&lt;/b&gt;由于字符串尾部要放一个 0x0，所以实际上只会拷贝 n-1 个字节。" />
            <outline text="format 为格式化字符串，与printf()函数相同；">
              <outline text="%d              十进制有符号整数" />
              <outline text="%3d             输出3位整型数, 不够3位右对齐." />
              <outline text="%04d          在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位。" />
              <outline text="%ld              输出长整型, 即long整数." />
              <outline text="%lld             输出long long整数." />
              <outline text="%-7d           输出7位整数,左对齐." />
              <outline text="%u              十进制无符号整数" />
              <outline text="%xhh, %XHH      无符号以十六进制表示的整数." />
              <outline text="%0              无符号以八进制表示的整数" />
              <outline text="%f               浮点数" />
              <outline text="%9.2f         输出场宽为9的浮点数, 其中小数位为2, 整数位为6, 小数点占一位, 不够9位右对齐。" />
              <outline text="%lf              输出double浮点数" />
              <outline text="%e              指数形式的浮点数" />
              <outline text="%s              字符串" />
              <outline text="%8s            输出8个字符的字符串, 不够8个字符右对齐。" />
              <outline text="%6.9s         输出一个长度不小于6且不大于9的字符串。若大于9, 则多余内容将被删除。" />
              <outline text="%-10s         输出10个字符, 左对齐." />
              <outline text="%c              单个字符" />
              <outline text="%p              指针的值" />
              <outline text="%g              自动选择合适的表示法" />
            </outline>
            <outline text="argument 为变量。" />
            <outline text="类似函数还有: printf(), sprintf(). " />
            <outline text="返回值：成功返回写字符的总数，其中不包括结尾的null字符；失败返回一个负数。" />
          </outline>
          <outline text="格式化输入">
            <outline text="int sscanf( string str, string format, mixed var1, mixed var2 ... );   // 从字符串输入格式化字符串. 例如:">
              <outline text="int a, b, c;" />
              <outline text="sscanf(&quot;2006:03:18&quot;, &quot;%d:%d:%d&quot;, a, b, c);" />
            </outline>
            <outline text="int scanf( const char *format [,argument]... );    // 从屏幕输入格式化字符串." />
            <outline text="上面这两个函数的关键是参数format具有和正则表达式类似的功能. 其语法结构是:" />
            <outline text="{%[*] [width] [{h | l | I64 | L}]type | ' ' | '\t' | '\n' | 非%符号}" />
            <outline text="亦可用于格式中, (即 %*d 和 %*s) 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)" />
            <outline text="{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。" />
            <outline text="width表示读取宽度。" />
            <outline text="{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。" />
            <outline text="type :这就很多了，就是%s,%d之类。" />
            <outline text="特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值" />
            <outline text="支持集合操作：" />
            <outline text="%[a-z] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)" />
            <outline text="%[aB'] 匹配a、B、'中一员，贪婪性" />
            <outline text="%[^a] 匹配非a的任意字符，贪婪性" />
            <outline text="例1:" />
            <outline text="取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。" />
            <outline text="sscanf(&quot;123456abcdedfBCDEF&quot;, &quot;%[^A-Z]&quot;, buf);" />
            <outline text="printf(&quot;%s\n&quot;, buf);" />
            <outline text="结果为：123456abcdedf" />
            <outline text="例2:" />
            <outline text="给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非'@'的一串内容送到buf中" />
            <outline text="sscanf(&quot;iios/12DDWDFF@122&quot;, &quot;%*[^/]/%[^@]&quot;, buf);" />
            <outline text="printf(&quot;%s\n&quot;, buf);" />
            <outline text="结果为：12DDWDFF" />
          </outline>
        </outline>
        <outline text="对时间的处理">
          <outline text="在c/c++中, 最小的计时单位是1毫秒." />
          <outline text="# include &amp;lt;sys/time.h&amp;gt; " />
          <outline text="获取系统时间">
            <outline text="long long getCurrentTime() {  // 返回微秒数(百万分之秒)">
              <outline text="struct timeval tv;" />
              <outline text="gettimeofday(&amp;amp;tv, NULL);   // gettimeofday()返回1970年1月1日到现在的时间." />
              <outline text="return tv.tv_sec * 1000,000 + tv.tv_usec;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="日历时间的两种格式">
            <outline text="通过tm结构来获得日期和时间，tm结构在time.h中的定义如下：" />
            <outline text="struct tm {">
              <outline text="int tm_sec;     /* 秒 – 取值区间为[0,59] */" />
              <outline text="int tm_min;     /* 分 - 取值区间为[0,59] */" />
              <outline text="int tm_hour;    /* 时 - 取值区间为[0,23] */" />
              <outline text="int tm_mday;    /* 一个月中的日期 - 取值区间为[1,31] */" />
              <outline text="int tm_mon;     /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */" />
              <outline text="int tm_year;    /* 年份，其值等于实际年份减去1900 */" />
              <outline text="int tm_wday;    /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */" />
              <outline text="int tm_yday;    /* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */" />
              <outline text="int tm_isdst;   /* 夏令时标识符，实行夏令时的时候，tm_isdst为正不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负*/" />
            </outline>
            <outline text="};" />
            <outline text="这种时间表示叫分解时间(broken-down time)." />
            <outline text="还有一种日历时间（Calendar Time）, 是通过time_t数据类型来表示的，用time_t表示的时间是从一个时间点（1970年1月1日0时0分0秒）到此时的秒数." />
            <outline text="typedef long time_t;  // 对time_t数据类型的值来说，它所表示的时间不能晚于2038年1月18日19时14分07秒." />
          </outline>
          <outline text="时间格式间的转化">
            <outline text="time_t mktime(struct tm * timeptr);   // 将tm时间转化为time_t时间" />
            <outline text="time_t time(time_t * timer);   // 获取从指定的timer时间到现在的秒数" />
            <outline text="char * asctime(const struct tm * timeptr);  // 将tm时间转为字符串." />
            <outline text="char * ctime(const time_t *timer);    // 将time_t时间转为字符串, 并遵循系统时间格式." />
          </outline>
          <outline text="获取两个时间间的间隔:  double difftime(time_t time1, time_t time0);   // 单位为秒." />
          <outline text="时区处理">
            <outline text="struct tm * localtime(const time_t * timer);   // 将time_t时间转化为当前系统时区下的tm时间" />
            <outline text="struct tm * gmtime(const time_t *timer);   // 将time_t时间转化为世界标准时间下的tm时间" />
          </outline>
          <outline text="自定义时间格式">
            <outline text="使用 strftime（）函数将时间格式化为我们想要的格式. 它的原型如下：" />
            <outline text="size_t strftime(char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);" />
            <outline text="其中 format 支持的格式有好几十种. 此处不再累述." />
          </outline>
        </outline>
        <outline text="数组">
          <outline text="数组的定义和遍历" />
          <outline text="数组的size" />
          <outline text="数组元素的访问" />
          <outline text="数组元素的新增、删除" />
          <outline text="排序" />
          <outline text="不可变数组 Tuple" />
        </outline>
        <outline text="内存管理">
          <outline text="内存模型">
            <outline text="内存空间的逻辑结构">
              <outline text="由低到高分别是:" />
              <outline text="代码段(.text)">
                <outline text="编译的时候由编译器分配的。" />
                <outline text="存放程序代码." />
                <outline text="一般为只读. 某些架构也允许代码段为可写，即允许运行时修改程序。" />
              </outline>
              <outline text="数据段(.data)">
                <outline text="编译的时候由编译器分配的。" />
                <outline text="存放初始化的全局变量和静态变量. " />
                <outline text="分为只读数据段和读写数据段。 字符串常量一般放在只读数据段。" />
              </outline>
              <outline text="BSS段(.bss)">
                <outline text="存放程序中未初始化的全局变量和静态变量, 即默认初始化为0的变量." />
                <outline text="编译的时候由编译器分配的。" />
                <outline text="BSS段在应用程序的二进制映象文件中并不存在, 而是在程序加载时展开到内存的. 因此不占用磁盘空间." />
              </outline>
              <outline text="堆">
                <outline text="程序运行的时候由系统分配的。" />
                <outline text="使用 malloc/free 动态管理的内存段." />
              </outline>
              <outline text="栈">
                <outline text="也叫堆栈. 程序运行的时候由系统分配的。" />
                <outline text="存放程序创建的局部变量, 进入函数时分配, 退出函数时自动释放." />
                <outline text="在linux上用户态进程的默认堆栈大小是8M，可以用ulimit查看和修改。" />
              </outline>
            </outline>
            <outline text="字节序">
              <outline text="x86芯片字节序为低字节在低地址, 高字节在高地址. 即小头." />
              <outline text="arm芯片字节序为高字节在低地址, 低字节在高地址. 即大头." />
            </outline>
            <outline text="读写寄存器">
              <outline text="写一个Long: void WRITE_REGISTER_ULONG(PULONG Register, ULONG Value);" />
              <outline text="其实现是: # define WRITE_REGISTER_ULONG(addr, val) (*(volatile UNIT32)*)(addr)=(val))" />
              <outline text="addr是统一编址的内存地址, 寄存器资源在内存地址的具体映射由硬件定义." />
              <outline text="volatile为关键字, 表示本code不可因为寄存器的优化而忽略, 且要求每次都字节读取. 与硬件和中断打交道的代码, 千万不要忘记 volatile." />
            </outline>
            <outline text="android区分32位/64位的宏: # ifdefined(__LP64__) " />
          </outline>
          <outline text="内存申请">
            <outline text="&lt;b&gt;void *malloc(int num);    // &lt;/b&gt;在堆区分配一块指定大小的内存空间. 不默认初始化." />
            <outline text="&lt;b&gt;void *calloc(int num, int size);    // &lt;/b&gt;在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。" />
            <outline text="&lt;b&gt;void *realloc(void *address, int newsize);   // &lt;/b&gt;重新分配内存，把内存大小扩展到 &lt;b&gt;newsize&lt;/b&gt;。" />
            <outline text="返回值 void * 表示未确定类型的指针。它可以通过类型转换强制转换为任何其它类型的指针。" />
            <outline text="使用分配而来的内存块前, 务必判空." />
          </outline>
          <outline text="内存释放">
            <outline text="&lt;b&gt;void free(void *address);     // &lt;/b&gt;释放 address 所指向的动态分配的内存块." />
          </outline>
          <outline text="以下函数需要包含头文件 string.h." />
          <outline text="内存拷贝">
            <outline text="void *memcpy(void *dest, const void *src, size_t n);" />
            <outline text="void* memmove(void* dst,const void* src,size_t n);   // 与memcpy()在于, 当src和dest所指的内存区域重叠时，memmove仍然可以正确的处理，不过执行效率上会比memcpy略慢。" />
          </outline>
          <outline text="内存清零">
            <outline text="memset(buffer, 0, sizeof(buffer));" />
            <outline text="memset(buffer, 0x, sizeof(buffer));  // 一个字节一个字节的赋值." />
          </outline>
          <outline text="内存比较">
            <outline text="int memcmp(const void* buf1,const void* buf2,unsigned int count);" />
            <outline text="返回值：">
              <outline text="当buf1 == buf2时，返回值=0" />
              <outline text="当buf1&amp;gt;buf2时，返回值&amp;gt;0" />
              <outline text="当buf1&amp;lt;buf2时，返回值&amp;lt;0" />
            </outline>
          </outline>
          <outline text="内存查找">
            <outline text="void* &lt;b&gt;memchr&lt;/b&gt;(const void* buf,int ch,size_t count);" />
            <outline text="从buf所指内存区的前count个字节查找字符ch，当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回null." />
          </outline>
        </outline>
        <outline text="文件系统">
          <outline text="获取系统目录/当前目录/跳转" />
          <outline text="文件夹和文件的的存在性" />
          <outline text="文件夹的新建/删除" />
          <outline text="文件夹的遍历" />
          <outline text="文件的新建/删除" />
          <outline text="文件的读/写" />
          <outline text="获取文件长度" />
          <outline text="文件的改名/修改属性" />
          <outline text="行读" />
          <outline text="行写" />
        </outline>
        <outline text="类的进一步讨论">
          <outline text="虚函数和纯虚函数(C++) #面试题 ">
            <outline text="凡在子类中要重写的函数, 其类定义要加 virtual 关键字. " />
            <outline text="子类也可以不实现虚函数, 此时用父类的实现." />
            <outline text="没有加 virtual 的函数, 子类不可覆盖." />
            <outline text="对于要求每个子类都实现的函数, 父类定义时应定义为&lt;b&gt;纯虚函数&lt;/b&gt;. 定义形式是: virtual myFunc() = 0;" />
            <outline text="如果 new 一个父类, 则纯虚函数就不存在. 所以永远不要 new 一个父类." />
          </outline>
          <outline text="父类如何调用子类的函数?">
            <outline text="不推荐这样做. 实在不行可通过new一个子类来访问. " />
          </outline>
          <outline text="子类不能调用父类的私有函数, 但可调用 protected 函数.  #面试题 " />
          <outline text="友元函数和友元类">
            <outline text="通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。" />
            <outline text="友元函数:友元函数是可以直接访问类的私有成员和受保护成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明. 声明格式是:">
              <outline text="friend 类型 函数名(形式参数);" />
            </outline>
            <outline text="友元函数的声明可以放在类的任何位置, 没有区别. 数量也没有限制." />
            <outline text="友元类 ：友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类的私有成员和受保护成员。" />
            <outline text="申明友元类的语句格式如下：">
              <outline text="friend class 类名;" />
            </outline>
            <outline text="注意: 友元关系不能被继承。父类的友元, 不是子类的友元." />
          </outline>
          <outline text="虚拟继承">
            <outline text="即 SubClass : virtue public MainClass" />
            <outline text="c++ 支持多重继承，因此可能存在难以发现的循环继承问题，使用虚拟继承可解决这个问题。" />
          </outline>
        </outline>
        <outline text="字典 (hash)">
          <outline text="散列算法">
            <outline text="Hash Algorithm，又称哈希算法，杂凑算法，是一种从任意长度的数据中创造小的数字「指纹」的方法。" />
            <outline text="特点有：">
              <outline text="唯一性。" />
              <outline text="标志与文件的每一个字节都相关，而且难以找到逆向规律。" />
            </outline>
            <outline text="冲突">
              <outline text="Hash算法的一个问题是冲突, 即两个数据产生的hash指重复." />
            </outline>
            <outline text="目前流行的 Hash 算法包括 SHA-1 和 SHA-2。MD5已经不建议使用。" />
          </outline>
          <outline text="定义">
            <outline text="android中, KeyedVector.h：定义使用关键字的向量模板KeyedVector. 用字符串key来随机访问数据. " />
          </outline>
          <outline text="size" />
          <outline text="遍历" />
          <outline text="元素的新增/修改/删除" />
          <outline text="排序" />
          <outline text="unordered_map">
            <outline text="这种map不会根据key排序，存储时按key的hash值判断元素是否重复。" />
            <outline text="item-&amp;gt;first, key" />
            <outline text="item-&amp;gt;second, value" />
          </outline>
        </outline>
        <outline text="链表" />
        <outline text="异常处理">
          <outline text="为什么使用空指针会造成data abort？地址0难道不是一个合法的地址吗？">
            <outline text="为了捕捉空指针错误，编译器故意将地址空间的最低部分设为不可使用的，因此任何时候使用地址0（以及极小的地址，比如地址13），都会产生错误。这个故意留的“空洞”一般为几K。" />
          </outline>
        </outline>
        <outline text="UT&amp;amp;Debug">
          <outline text="assert">
            <outline text="原型定义在 assert.h。" />
            <outline text="void assert( int expression );" />
            <outline text="如果 expression 为0， 则先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。" />
            <outline text="版本发布时，可通过在 # include &amp;lt;assert.h&amp;gt; 之前插入 # define NDEBUG 来禁用assert调用。" />
          </outline>
          <outline text="C/C++中的段错误（Segmentation fault） https://www.cnblogs.com/hello--the-world/archive/2012/05/31/2528326.html" />
        </outline>
        <outline text="平台兼容性" />
        <outline text="泛型 (C++)">
          <outline text="C++模板分为函数模板和类模板. " />
          <outline text="函数模板:  template &amp;lt;class 形参1, class 形参2, …&amp;gt; 返回值类型 函数名(参数列表) {…};  例如:">
            <outline text="template &amp;lt;class T&amp;gt; void swap(T&amp;amp; a, T&amp;amp;b){">
              <outline text="T c;" />
              <outline text="c = a;" />
              <outline text="a = b;" />
              <outline text="b = c;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="使用时:">
            <outline text="int a = 0, b = 1;" />
            <outline text="swap(a, b);" />
            <outline text="float c = 0.1, d = 0.2;" />
            <outline text="swap(c, d);" />
          </outline>
          <outline text="类模板: template &amp;lt;class 形参1, class 形参2, …&amp;gt; class 类名 {…}; 例如:" />
          <outline text="template &amp;lt;class T&amp;gt; class A {">
            <outline text="public:" />
            <outline text="A();" />
            <outline text="T add(T a, T b);" />
          </outline>
          <outline text="};" />
          <outline text="template &amp;lt;class T&amp;gt; class A::add(T a, T b) {">
            <outline text="return a+b;" />
          </outline>
          <outline text="}" />
          <outline text="使用时:" />
          <outline text="A&amp;lt;int&amp;gt; a;" />
          <outline text="count &amp;lt;&amp;lt; a.add(2, 3)&amp;lt;&amp;lt;endl;" />
        </outline>
        <outline text="多线程">
          <outline text="启动子线程">
            <outline text="# include &amp;lt;thread&amp;gt;" />
            <outline text="std::thread Reader(ReaderBlockedThread, mSynchronized, &amp;amp;mFw);" />
            <outline text="其中: Reader 为进程名" />
            <outline text="ReaderBlockedThread 为全局函数" />
            <outline text="mFw 为函数参数表" />
            <outline text="Reader.&lt;b&gt;join&lt;/b&gt;();   // join() 会阻塞当前线程, 直到新线程执行完毕后join()才会返回." />
          </outline>
          <outline text="互斥锁">
            <outline text="互斥类: Mutex; 例如:" />
            <outline text="Mutex mLock;" />
            <outline text="使用时:" />
            <outline text="mLock.lock();" />
            <outline text="mLock.unlock();" />
            <outline text="还有一种利用对象的自动析构机制而实现的锁自动释放的形式:" />
            <outline text="{   // 大括号不能少">
              <outline text="AutoMutex _L(mLock);" />
            </outline>
            <outline text="}   // 出大括号时锁自动失败." />
          </outline>
          <outline text="线程锁">
            <outline text="pthread_mutex_lock();" />
            <outline text="pthread_mutex_unlock();" />
          </outline>
        </outline>
        <outline text="其它有意思的话题">
          <outline text="这个宏定义为什么要写成do~while结构？">
            <outline text="# define ErrChk(iserr)\" />
            <outline text="do {\">
              <outline text="if ((iserr) != 0) {\">
                <outline text="ChkErrorFail(__FILE__,__LINE__, # iserr);\" />
              </outline>
              <outline text="}\" />
            </outline>
            <outline text="}while(0)" />
            <outline text="A1：假如不用do-while(0)：" />
            <outline text="# define SOME_MACRO \">
              <outline text="dosomething1(); \" />
              <outline text="dosomething2();" />
            </outline>
            <outline text="if (i&amp;gt;0)">
              <outline text="SOME_MACRO" />
            </outline>
            <outline text="else">
              <outline text="dosomething3();" />
            </outline>
            <outline text="试试看，编译能不能通过？" />
            <outline text="你可能认为可以这样：" />
            <outline text="if (i&amp;gt;0) {">
              <outline text="SOME_MACRO" />
            </outline>
            <outline text="}" />
            <outline text="else">
              <outline text="dosomething3();" />
            </outline>
            <outline text="没错，但如果宏是你定义的，但由别人使用，能保证别人一定会怎么用吗？" />
            <outline text="Q2：可以这样啊" />
            <outline text="# define SOME_MACRO {\">
              <outline text="dosomething1(); \" />
              <outline text="dosomething2();\" />
            </outline>
            <outline text="}" />
            <outline text="A2：你这种写法在例子中是没错。但是，假设某个旧版本中：" />
            <outline text="# define SOME_MACROdosomething()" />
            <outline text="已经有很多应用了，此时你为了增强其功能而升级：" />
            <outline text="# define SOME_MACRO \" />
            <outline text="do { \">
              <outline text="dosomething1(); \" />
              <outline text="dosomething2(); \" />
            </outline>
            <outline text="} while(0)" />
            <outline text="这样的兼容性就很好，但如果采用" />
            <outline text="# define SOME_MACRO \" />
            <outline text="{ \">
              <outline text="dosomething1(); \" />
              <outline text="dosomething2(); \" />
            </outline>
            <outline text="}" />
            <outline text="就不能保证其它的程序能正确编译，如" />
            <outline text="if (i&amp;gt;0)">
              <outline text="SOME_MACRO;     // 注意有分号" />
            </outline>
            <outline text="elses">
              <outline text="dosomething3();" />
            </outline>
            <outline text="说白了，以前的宏定义是单语句，这样的宏定义一般习惯都不会带上分号，当你把宏升级成多语句时，最后也不能带上分号，但{...}表面上没有分号，实际上数据块等同于已经有了分号，所以编译时可能出错。" />
          </outline>
        </outline>
        <outline text="C++ 11">
          <outline text="赋值语句，除了 int ii = 1; 还支持 ii = {1}; ii{1}; 这两种。" />
          <outline text="空指针，nullptr 替代 NULL。" />
          <outline text="lambda 表达式" />
          <outline text="STL, 标准模板库">
            <outline text="命名空间是 std::" />
          </outline>
          <outline text="menu class" />
        </outline>
      </outline>
      <outline text="&lt;b&gt;03-多线程&amp;amp;锁&lt;/b&gt;">
        <outline text="Android线程架构">
          <outline text="当启动一个App的时候，Android系统会启动一个Linux Process，该Process包含一个Thread，称为UI Thread, 即主线程。" />
          <outline text="系统在创建UI线程的时候会初始化一个Looper对象, 以及与其关联的MessageQueue对象;" />
          <outline text="通常一个应用的所有组件都运行在UI Thread中.  " />
          <outline text="通过在Manifest.xml中的代码块(&amp;lt;activity&amp;gt;&amp;lt;service&amp;gt;&amp;lt;provider&amp;gt;&amp;lt;receiver&amp;gt;)中的 android:process 属性可指定其运行在不同的process中。" />
          <outline text="UI Thread中运行着许多重要的逻辑，如系统事件处理，用户输入事件处理，UI绘制，Service，Alarm等. " />
          <outline text="UI线程5秒没有响应, 系统就会报ANR. 所以费时的逻辑应该放在子线程里." />
        </outline>
        <outline text="&lt;b&gt;Android线程的生命周期 #面试题&lt;/b&gt;">
          <outline text="新建状态（New）：new实例化之后进入该状态, jvm为其分配内存，并初始化成员变量;" />
          <outline text="就绪状态（&lt;b&gt;Runnable&lt;/b&gt;）：线程调用start()之后就绪状态. jvm会为其创建方法调用栈和PC计数器, 等待cpu执行. 注意这时线程还没开始运行, 但已获得除CPU之外的所有资源.">
            <outline text="&lt;b&gt;还有一种方式进入就绪态:  yield()：线程把自己暂停, 主动释放CPU资源. 但是, 这里很关键, yield() 只会将线程转为就绪态, 而不是阻塞态. 而且它会强制调用系统调度器重新调度一次。&lt;/b&gt;" />
            <outline text="当某个线程调用 &lt;b&gt;yield&lt;/b&gt;() 暂停后，只要下一次系统调度时, 其优先级与当前运行线程相同或更高时, 就会重新获得执行机会。" />
            <outline text="其它线程调用 notify() / notifyAll() 唤醒本线程. 调用前需要获取对象锁." />
          </outline>
          <outline text="运行状态（Running）：经过系统调度, 线程获得CPU时间，开始执行 run()方法的代码；" />
          <outline text="阻塞状态（&lt;b&gt;Blocked&lt;/b&gt;）：线程由于各种原因进入阻塞状态, 包括：">
            <outline text="&lt;b&gt;join&lt;/b&gt;(), 当前线程阻塞, 进入另外一个线程, 直到后者执行完毕;" />
            <outline text="&lt;b&gt;sleep&lt;/b&gt;(), 线程主动放弃CPU资源。">
              <outline text="通过参数指定睡眠的微秒数." />
              <outline text="注意使用sleep方法时需要捕捉 InterruptedException, 或者抛出该异常。" />
            </outline>
            <outline text="&lt;b&gt;wait&lt;/b&gt;(), 当前线程阻塞, 等待某个通知notify. 调用前需要获取对象锁.">
              <outline text="一般是和 &lt;b&gt;notifyAll&lt;/b&gt;() 成对出现. " />
            </outline>
            <outline text="线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞." />
            <outline text="线程试图获得一个同步锁，但是该锁被其他线程所持有." />
            <outline text="&lt;b&gt;阻塞条件被消除后, 线程会进入就绪态. &lt;/b&gt;" />
          </outline>
          <outline text="死亡状态（Dead）：线程运行完毕或异常退出，可使用 isAlive()获取状态。有三种死亡类型:">
            <outline text="正常终止: 执行完所有工作, 正常结束." />
            <outline text="强制终止: 线程调用 stop() 或 destroy() 结束. LMK即是这种." />
            <outline text="异常终止: 执行过程中发生异常, 或者被系统强制杀死." />
          </outline>
        </outline>
        <outline text="Thread类">
          <outline text="Thread有如下主要函数：">
            <outline text="run(): 线程运行时所执行的代码。" />
            <outline text="start(): 启动线程。" />
            <outline text="&lt;b&gt;sleep&lt;/b&gt;() / sleep(long millis): 线程休眠，进入&lt;b&gt;阻塞&lt;/b&gt;状态，sleep方法不会释放锁（其它线程不会进入synchronized方法体或方法块，不释放锁需要try/catch）" />
            <outline text="&lt;b&gt;yield&lt;/b&gt;(): 线程交出CPU，但是不会阻塞而是重置为&lt;b&gt;就绪&lt;/b&gt;状态，不会释放锁。" />
            <outline text="&lt;b&gt;join&lt;/b&gt;() / join(long millis) / join(long millis, int nanoseconds): 线程插队，执行完join()后, 主线程阻塞, 进入子线程执行; 等子线程执行完后, 再返回主线程join()后一行继续执行." />
            <outline text="&lt;b&gt;wait&lt;/b&gt;(): 进入阻塞状态，释放锁（其它线程可以进入synchronized代码块）" />
            <outline text="interrupt(): 中断线程，注意只能中断阻塞状态的线程" />
            <outline text="getId(): 获取当前线程的id" />
            <outline text="getName() / setName(): 获取和设置线程的name" />
            <outline text="getPriority() / setPriority(): 获取和设置线程的优先级，范围1-10，默认是5" />
            <outline text="setDaemon() / isDaemo(): 设置为守护线程 / 是否是守护线程" />
            <outline text="currentThread(): 静态函数获取当前线程" />
          </outline>
          <outline text="start() 和 run()的区别">
            <outline text="只有调用了start()方法，才会启动新线程，start() 会在新线程中调用 run()。" />
            <outline text="如果只是调用run()方法，那么代码还是在本线程中执行。" />
          </outline>
          <outline text="sleep() 和 wait()的区别">
            <outline text="sleep方法和wait方法都可以用来放弃CPU一定的时间." />
            <outline text="不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器." />
          </outline>
        </outline>
        <outline text="创建子线程的方法">
          <outline text="1. 继承Thread，重写run()方法">
            <outline text="public class MyThread extends Thread{">
              <outline text="@Overrid" />
              <outline text="public void run() {">
                <outline text="super.run();" />
                <outline text="// do something" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="// Thread使用" />
            <outline text="public void goThread(){">
              <outline text="new MyThread().start();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="2. &lt;b&gt;创建&lt;/b&gt;Thread 匿名类，传入&lt;b&gt;Runnable接口，重写其中的run()方法来执行任务. 常见的做法。&lt;/b&gt;">
            <outline text="new Thread(new Runnable() {">
              <outline text="public void run() {...}" />
            </outline>
            <outline text="}).start();" />
          </outline>
        </outline>
        <outline text="Runnable 接口和 Callable 接口的区别 &lt;b&gt;  #面试题&lt;/b&gt;">
          <outline text="Runnable接口中的 run() 方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已;" />
          <outline text="Callable接口中的 call() 方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。" />
          <outline text="多线程执行充满着未知性，某条线程是否执行了？执行了多久？某条线程执行的时候期望的数据是否已经赋值完毕？很难及时知道，能做的只是等待任务执行完毕而已。" />
          <outline text="而 Callable + Future/FutureTask 却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，所以非常有用。" />
        </outline>
        <outline text="&lt;b&gt;Android多线程实现方式  #面试题&lt;/b&gt;">
          <outline text="1. runOnUiThread&lt;b&gt;， 最简单。一般用于刷新界面&lt;/b&gt;">
            <outline text="Android规定只有主线程才可以刷新界面. 那么如果子线程需要刷新界面？" />
            <outline text="把更新ui的代码放在 Runnable对象的 run() 中。" />
            <outline text="子线程需要更新 UI时，把Runnable 对象传给 Activity.&lt;b&gt;runOnUiThread&lt;/b&gt;(Runnable) 即可。">
              <outline text="如果当前线程是UI线程，那么会被立即执行。" />
              <outline text="如果当前线程不是UI线程, 操作是发布事件到UI线程的队列中去。" />
            </outline>
            <outline text="例子：" />
            <outline text="this.runOnUiThread(new Runnable() {   // 在 activity 类中调用">
              <outline text="void run() {">
                <outline text="// Do something …" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="});" />
          </outline>
          <outline text="&lt;b&gt;2. Thread  + Handler + Looper&lt;/b&gt;">
            <outline text="&lt;b&gt;Handler是一个胶水类. 它粘合两个线程, 所以它的代码分为两半。&lt;/b&gt;">
              <outline text="&lt;b&gt;一半在一个线程中发&lt;/b&gt;Message或者Runnable对象；" />
              <outline text="&lt;b&gt;另外一半在另一个线程处理收到的&lt;/b&gt;Message或者Runnable对象&lt;b&gt;. &lt;/b&gt;" />
              <outline text="&lt;b&gt;看Handle代码, 要注意这个关系.&lt;/b&gt;" />
            </outline>
            <outline text="&lt;b&gt;Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。&lt;/b&gt;" />
            <outline text="Handler的同步原理">
              <outline text="使用MessageQueue维护一个消息队列（实际上是链表）。" />
              <outline text="当队列中没有Message时调用nativePollOnce挂起当前线程。" />
              <outline text="当有新的任务时调用nativeWake唤起被挂起的线程，继续循环消息队列。" />
              <outline text="对链表的操作使用synchronized关键字进行了代码块的加锁。" />
            </outline>
            <outline text="在子线程中创建一个Handle对象时，它会自动绑定创建它的线程。这部分是隐含的。" />
            <outline text="在主线程中，可以通过 Thread.mHandler.&lt;b&gt;sendMessage&lt;/b&gt;(msg) 或者 &lt;a href=&quot;http://Thread.mHandler.post&quot;&gt;Thread.mHandler.post&lt;/a&gt;(Runnable) 往子线程的消息队列发送事件，通知子线程某些事情发生。">
              <outline text="sendMessage: 允许把一个包含消息数据的Message对象压入到消息队列中。有:">
                <outline text="sendEmptyMessage(int)   // 发送空消息" />
                <outline text="sendMessage(Message)   // 发送消息" />
                <outline text="sendMessageAtTime(Message,long)   // 发送定时生效的消息" />
                <outline text="sendMessageDelayed(Message,long)    // 指定延时多少毫秒后发送消息" />
              </outline>
              <outline text="post: 把一个Runnable对象入队到消息队列中. 有:">
                <outline text="post(Runnable) " />
                <outline text="postAtTime(Runnable,long)   // 指定时间" />
                <outline text="postDelayed(Runnable,long)   // 延迟post" />
                <outline text="其实1和3都是调用2, post 即定时为now, postDelayed 即定时为 now+指定延时." />
              </outline>
              <outline text="无论是 sendMessage 还是 post, 最终都是sendMessage. 对于后者, 只是把 Runable对象放到message的 Runables属性中而已." />
              <outline text="创建msg对象时， 建议使用 Message.obtain(): 从message池中取一个对象。">
                <outline text="使用池是为了不每次new, 浪费内存." />
              </outline>
            </outline>
            <outline text="&lt;b&gt;子线程在 Handler.handleMessage() 中处理收到的事件。&lt;/b&gt;" />
            <outline text="要做到这件事，需要Looper对象帮忙。looper依赖于线程。">
              <outline text="Looper的目的是保持持有它的线程处于存活状态。" />
              <outline text="一个线程如果不持有Looper，则它的run()方法执行完就销毁了。这种情况不适合接受事件、处理事件的场景。" />
              <outline text="Looper对象有几个要点：">
                <outline text="线程默认没有 Looper；" />
                <outline text="可以创建一个 Looper 并将它绑定到一个线程；" />
                <outline text="每一个线程只能绑定一个 Looper。" />
              </outline>
              <outline text="创建Looper">
                <outline text="调用 Looper.prepare() 即可。" />
                <outline text="创建时会自动创建配套的MessageQueue。这部分是隐含的。" />
                <outline text="调用Looper.&lt;b&gt;loop&lt;/b&gt;()方法启动Looper." />
              </outline>
              <outline text="UI线程的Looper">
                <outline text="UI线程默认会创建Looper对象，相关代码在 ActivityThread.main() 中。" />
                <outline text="所有的view.postDelay()都会走到UI线程的Looper的消息循环体中，Looper配合viewRootImpl 视图树的 handler 将所有的消息追加到主线程消息队列后面。" />
              </outline>
            </outline>
            <outline text="例子：" />
            <outline text="public class CalPrime extends Activity {">
              <outline text="static final String UPPER_NUM = &quot;upper&quot;;" />
              <outline text="EditText etNum;" />
              <outline text="CalThread calThread;" />
              <outline text="// 定义一个线程类" />
              <outline text="class CalThread extends Thread {">
                <outline text="public Handler mHandler;" />
                <outline text="public void &lt;b&gt;run&lt;/b&gt;() {">
                  <outline text="Looper.&lt;b&gt;prepare&lt;/b&gt;();" />
                  <outline text="mHandler = new &lt;b&gt;Handler&lt;/b&gt;() {">
                    <outline text="// 定义处理消息的方法" />
                    <outline text="public void &lt;b&gt;handleMessage&lt;/b&gt;(Message msg) {">
                      <outline text="if(msg.what == 0x123) {">
                        <outline text="int upper = msg.getData().getInt(UPPER_NUM);" />
                        <outline text="List&amp;lt;Integer&amp;gt; nums = new ArrayList&amp;lt;Integer&amp;gt;();" />
                        <outline text="// 计算从2开始、到upper的所有质数" />
                        <outline text="for (int i = 2 ; i &amp;lt;= upper ; i++) {">
                          <outline text="// 用i处于从2开始、到i的平方根的所有数" />
                          <outline text="for (int j = 2 ; j &amp;lt;= Math.sqrt(i) ; j++) {">
                            <outline text="// 如果可以整除，表明这个数不是质数" />
                            <outline text="if(i != 2 &amp;amp;&amp;amp; i % j == 0) {">
                              <outline text="continue outer;" />
                            </outline>
                            <outline text="}" />
                          </outline>
                          <outline text="}" />
                          <outline text="nums.add(i);" />
                        </outline>
                        <outline text="}" />
                        <outline text="// 使用Toast显示统计出来的所有质数" />
                        <outline text="Toast.makeText(CalPrime.this , nums.toString()">
                          <outline text=", Toast.LENGTH_LONG).show();" />
                        </outline>
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="};" />
                  <outline text="Looper.&lt;b&gt;loop&lt;/b&gt;();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
              <outline text="public void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.main);" />
                <outline text="etNum = (EditText)findViewById(R.id.etNum);" />
                <outline text="calThread = new CalThread();" />
                <outline text="// 启动新线程" />
                <outline text="calThread.start();" />
              </outline>
              <outline text="}" />
              <outline text="// 为按钮的点击事件提供事件处理函数" />
              <outline text="public void cal(View source){">
                <outline text="// 创建消息" />
                <outline text="Message msg = Message.obtain();" />
                <outline text="msg.what = 0x123;" />
                <outline text="Bundle bundle = new Bundle();" />
                <outline text="bundle.putInt(UPPER_NUM , Integer.parseInt(etNum.getText().toString()));" />
                <outline text="msg.setData(bundle);" />
                <outline text="// 向新线程中的Handler发送消息" />
                <outline text="calThread.mHandler.&lt;b&gt;sendMessage&lt;/b&gt;(msg);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="&lt;b&gt;Handler的&lt;/b&gt;优缺点: ">
              <outline text="Handler用法简单明了，可以将多个异步任务更新UI的代码放在一起，清晰明了。" />
              <outline text="如果仅处理单个异步任务，代码显得冗余." />
            </outline>
            <outline text="适用范围: 多个异步任务的更新UI." />
            <outline text="Looper.loop为什么不会阻塞掉UI线程？ #面试题">
              <outline text="loop()开启死循环后，会命令MessageQueue通过next()方法取出之前储存的消息，如果有立刻被拿出来执行msg.target.dispatchMessage(msg);" />
              <outline text="如果此时 MessageQueue中已经没有消息了，MessageQueue就会无限期的阻塞下去 &lt;b&gt;nativePollOnce&lt;/b&gt;(ptr, nextPollTimeoutMillis)，同时释放cpu资源，这时候并不会造成UI线程卡顿;" />
              <outline text="直到有新的消息存入队列enqueueMessage(Messagemsg, long when)，唤醒之前阻塞的线程 nativeWake(mPtr)，继续执行next()方法." />
            </outline>
          </outline>
          <outline text="&lt;b&gt;3. HandlerThread: 封装 Handler+Thread&lt;/b&gt;">
            <outline text="&lt;b&gt;HandlerThread&lt;/b&gt;通过继承Thread类和封装Handler类的使用，从而使得创建新线程和与其他线程进行通信变得更加方便易用.">
              <outline text="通过继承Thread类，快速地创建1个带有Looper对象的新工作线程." />
              <outline text="通过封装Handler类，快速创建Handler &amp;amp; 与其他线程进行通信." />
            </outline>
            <outline text="HandlerThread的使用步骤分为5步:">
              <outline text="// step1：创建HandlerThread实例对象" />
              <outline text="// 传入参数 = 线程名字，作用 = 标记该线程">
                <outline text="HandlerThread mHandlerThread = new HandlerThread(&quot;handlerThread&quot;);" />
              </outline>
              <outline text="// step2：启动线程">
                <outline text="mHandlerThread.start();" />
              </outline>
              <outline text="// step3：创建工作线程Handler &amp;amp; 复写handleMessage（）" />
              <outline text="// 关联HandlerThread的Looper对象、实现消息处理操作 &amp;amp; 与其他线程进行通信" />
              <outline text="// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行">
                <outline text="Handler workHandler = new Handler( handlerThread.getLooper() ) {">
                  <outline text="" />
                  <outline text="public boolean handleMessage(Message msg) {">
                    <outline text="...//消息处理" />
                    <outline text="return true;" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="// step4：使用工作线程Handler向工作线程的消息队列发送消息" />
              <outline text="// 在工作线程中，当消息循环时取出对应消息 &amp;amp; 在工作线程执行相关操作">
                <outline text="// a. 定义要发送的消息" />
                <outline text="Message msg = Message.obtain();" />
                <outline text="msg.what = 2; //消息的标识" />
                <outline text="msg.obj = &quot;B&quot;; // 消息的存放" />
                <outline text="// b. 通过Handler发送消息到其绑定的消息队列" />
                <outline text="workHandler.sendMessage(msg);" />
              </outline>
              <outline text="//  step5：结束线程，即停止线程的消息循环">
                <outline text="mHandlerThread.quit();" />
              </outline>
            </outline>
          </outline>
          <outline text="&lt;b&gt;4. &lt;/b&gt;AsyncTask">
            <outline text="AsyncTask是android提供的轻量级的异步类, 可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的状态(常用于实现UI进度更新)，最后反馈执行的结果给UI主线程。" />
            <outline text="AsyncTask通过一个阻塞队列BlockingQuery&amp;lt;Runnable&amp;gt;存储待执行的任务，利用静态线程池THREAD_POOL_EXECUTOR提供一定数量的线程，默认128个。" />
            <outline text="默认采用串行任务执行器，循环取出任务交给THREAD_POOL_EXECUTOR中的线程执行，执行完一个，再执行下一个。" />
            <outline text="不要手动调用onPreExecute()，doInBackground(Params... params)，onProgressUpdate(Progress... values)，onPostExecute(Result result)这几个方法。" />
            <outline text="例子: " />
            <outline text="// &lt;b&gt;自定义AsyncTask&lt;/b&gt;" />
            <outline text="public class MyAsyncTask extends AsyncTask&amp;lt;Integer,Integer,String&amp;gt; {">
              <outline text="private TextView txt;" />
              <outline text="private ProgressBar pgbar;" />
              <outline text="public MyAsyncTask(TextView txt,ProgressBar pgbar) {">
                <outline text="super();" />
                <outline text="this.txt = txt;" />
                <outline text="this.pgbar = pgbar;" />
              </outline>
              <outline text="}" />
              <outline text="// 在调用耗时操作前被调用, 常用于初始化, 比如进度条的显示. 该方法运行在UI线程." />
              <outline text="protected void &lt;b&gt;onPreExecute&lt;/b&gt;() {">
                <outline text="txt.setText(&quot;开始执行异步线程&quot;);" />
              </outline>
              <outline text="}" />
              <outline text="// 在onPreExecute&lt;b&gt;()执行后马上执行. &lt;/b&gt;该方法不运行在UI线程,主要用于异步操作." />
              <outline text="// 可调用 publishProgress()方法实时更新进度, 或者更新UI." />
              <outline text="protected String &lt;b&gt;doInBackground&lt;/b&gt;(Integer... params) {">
                <outline text="DelayOperator dop = new DelayOperator();" />
                <outline text="int i = 0;" />
                <outline text="for (i = 10;i &amp;lt;= 100;i+=10) {">
                  <outline text="dop.delay();" />
                  <outline text="&lt;b&gt;publishProgress&lt;/b&gt;(i);" />
                </outline>
                <outline text="}" />
                <outline text="return  i + params[0].intValue() + &quot;&quot;;" />
              </outline>
              <outline text="}" />
              <outline text="// 在doBackground方法中,每次调用publishProgress方法都会触发该方法" />
              <outline text="// 运行在UI线程中,可对UI控件进行操作" />
              <outline text="protected void &lt;b&gt;onProgressUpdate&lt;/b&gt;(Integer... values) {">
                <outline text="int value = values[0];" />
                <outline text="pgbar.setProgress(value);" />
              </outline>
              <outline text="}" />
              <outline text="// 在&lt;b&gt;doInBackground()执行完后, 该方法会被UI线程调用. 后台的处理结果将通过该方法传递给UI线程.&lt;/b&gt;" />
              <outline text="protected void &lt;b&gt;onPostExecute&lt;/b&gt;(String result) {">
                <outline text="txt.setText(&quot;异步线程执行完毕&quot;);" />
              </outline>
              <outline text="}" />
              <outline text="// 用于在取消执行中的任务时更改UI" />
              <outline text="protected void &lt;b&gt;onCancelled&lt;/b&gt;() {">
                <outline text="txt.setText(&quot;异步线程被终止&quot;);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="// MainActivity.java" />
            <outline text="public class MyActivity extends ActionBarActivity {">
              <outline text="private TextView txttitle;" />
              <outline text="private ProgressBar pgbar;" />
              <outline text="private Button btnupdate;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="txttitle = (TextView)findViewById(R.id.txttitle);" />
                <outline text="pgbar = (ProgressBar)findViewById(R.id.pgbar);" />
                <outline text="btnupdate = (Button)findViewById(R.id.btnupdate);" />
                <outline text="btnupdate.setOnClickListener(new View.OnClickListener() {">
                  <outline text="public void onClick(View v) {">
                    <outline text="MyAsyncTask myTask = new MyAsyncTask(txttitle,pgbar);" />
                    <outline text="myTask.execute(1000);" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="AsyncTask的使用注意事项：">
              <outline text="AsyncTask的类必须在主线程中加载，这一点已经在Android4.1以上版本上自动完成" />
              <outline text="AsyncTask 对象必须在主线程中创建" />
              <outline text="execute方法必须在主线程中调用" />
              <outline text="一个AsyncTask对象只能执行一次，否则会运行报错。" />
            </outline>
            <outline text="优缺点:">
              <outline text="处理单个异步任务时代码简单，而且能获取到异步任务的进度." />
              <outline text="可通过cancel方法取消还没执行完的AsyncTask." />
              <outline text="处理多个异步任务代码显得较多." />
            </outline>
            <outline text="适用范围: 单个异步任务的处理." />
          </outline>
          <outline text="&lt;b&gt;5. ThreadPoolExecutor: 线程池&lt;/b&gt;">
            <outline text="ThreadPoolExecutor提供了一组线程池，可以管理多个线程并行执行。比较适合一组任务的执行。" />
            <outline text="优势: ">
              <outline text="避免频繁地创建和销毁线程，达到线程对象的重用。" />
              <outline text="使用线程池还可以根据项目灵活地控制并发的数目。" />
            </outline>
            <outline text="Executors利用工厂模式对ThreadPoolExecutor进行了封装，使用起来更加方便。">
              <outline text="有4种工厂: ">
                <outline text="Executors.newFixedThreadPool():  创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化。" />
                <outline text="Executors.newCachedThreadPool():  创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制." />
                <outline text="Executors.newScheduledThreadPool(): 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer." />
                <outline text="Executors.newSingleThreadExecutor(): 创建一个单线程化的executor，它只创建唯一的worker线程来执行任务." />
              </outline>
              <outline text="newSingleThreadScheduledExecutor(): 创建一个延迟执行的单线程线程池" />
              <outline text="newWorkingStealingPool(int parallelism): 创建持有足够的线程的线程池来支持给定的并行级别，以充分支持多CPU并行能力。" />
              <outline text="newWorkingStealingPool(): 根据CPU个数设置并行级别。" />
            </outline>
            <outline text="使用线程池的步骤">
              <outline text="调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。" />
              <outline text="创建Runnable实现类或者Callable实现类的实例，作为线程的执行任务。" />
              <outline text="调用ExecutorService对象的 submit() 来提交 Runnable 或者 Callable 实例。" />
              <outline text="当没有任务时，使用shutdown()方法来关闭线程池。" />
              <outline text="public class TestTreadPool{">
                <outline text="public static void main(String[] args)" />
                <outline text="throws Exception{">
                  <outline text="ExecutorService pool = Executors.newFixedThreadPool(6);" />
                  <outline text="Runnable target = ()-&amp;gt;{">
                    <outline text="for(int i=0;i&amp;lt;100;i++) {" />
                    <outline text="System.out.println(Thread.currentThread().getName()">
                      <outline text="+ &quot;的i值为：&quot;+ i);" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="};" />
                  <outline text="// 向线程池中提交两个线程" />
                  <outline text="pool.submit(target);" />
                  <outline text="pool.submit(target);" />
                  <outline text="pool.shutdown();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="适用范围: 批处理任务" />
          </outline>
          <outline text="&lt;b&gt;6. &lt;/b&gt;IntentService">
            <outline text="IntentService继承自Service，是一个经过包装的轻量级的Service，用来接收并处理通过Intent传递的异步请求。客户端通过调用 startService(Intent) 启动一个IntentService，利用一个work线程依次处理顺序过来的请求，处理完成后自动结束Service。" />
            <outline text="优缺点: 它是Service，比起其他线程来说具有更高的优先级，不容易被系统杀死，而能够保证任务的执行。" />
            <outline text="特点: IntentService的优先级比单纯线程要高，所以适合执行一些高优先级的后台任务。" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;锁&lt;/b&gt; #面试题 ">
          <outline text="当有一个线程在对临界资源(内存, 代码块等)进行操作时，其他线程都不可以对这个临界资源进行操作，直到该线程完成操作。" />
          <outline text="线程安全有几个级别:">
            <outline text="1. 可变. 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用。" />
            <outline text="2. 绝对线程安全. 不管运行时环境如何，调用者都不需要额外的同步措施。">
              <outline text="要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的。" />
              <outline text="不过绝对线程安全的类也有，比如说 CopyOnWriteArrayList、CopyOnWriteArraySet。" />
            </outline>
            <outline text="3. 相对线程安全. ">
              <outline text="相对线程安全也就是我们通常意义上所说的线程安全。" />
              <outline text="像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此。" />
              <outline text="如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是 fail-fast 机制。" />
            </outline>
            <outline text="4. 线程非安全. ArrayList、LinkedList、HashMap等都是线程非安全的类。" />
          </outline>
          <outline text="基本上所有的并发模式在解决线程安全问题的问题上，都采用“序列化访问临界资源”的方案，即在同一时刻只能有一个线程访问临界资源（多个线程可能同时访问的数据或资源），也称同步互斥访问。" />
          <outline text="线程安全是以牺牲程序运行效率为代价的，因此在注意线程安全的同时，也要注意不要滥用锁和同步方法，尽量只对那些会改变竞争资源的方法进行同步。" />
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;偏向锁/轻量级锁/重量级锁   #面试题">
            <outline text="偏向锁（Biased Lock ）: 几乎无竞争的条件下使用.">
              <outline text="偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。这是最常见的情况. 因此偏向锁是 &lt;b&gt;Synchronized 的默认状态.&lt;/b&gt;" />
              <outline text="偏向锁是通过对象头实现。">
                <outline text="对象头指Java对象的头信息, 每个对象都有, 占2个字长. " />
                <outline text="第一个字叫Mark Word, 可唯一表示一个对象, 因此可用于做锁." />
                <outline text="第二个字保存类元信息（class metadata）的指针." />
              </outline>
              <outline text="偏向锁的获取方式是将对象头的 MarkWord 部分中， 标记上线程ID， 以表示哪一个线程获得了偏向锁。" />
              <outline text="当同一个线程反复获取同步块时, 不再需要进行加锁和解锁的操作, 效率非常高. " />
              <outline text="这也就要求, 当线程退出同步块时, 并不修改对象头的 MarkWord 字段. 只有在其它线程也访问同步块时再改." />
            </outline>
            <outline text="轻量级锁（ Lightweight Lock）: 轻度竞争的条件下使用.">
              <outline text="在偏向锁的获取过程中， 发现有竞争时，会直接把所升级到轻量级锁上. " />
              <outline text="其他线程会通过&lt;b&gt;自旋&lt;/b&gt;的形式尝试获取锁，不会阻塞，提高性能。" />
            </outline>
            <outline text="重量级锁（Heavyweight Lock）: 重度竞争的情况下使用.">
              <outline text="重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁升级为重量级锁。" />
              <outline text="重量级锁会让他申请的线程进入&lt;b&gt;阻塞&lt;/b&gt;，性能降低。" />
              <outline text="重量级锁依赖于操作系统的互斥量（mutex） 实现，切换到重量级锁开销较大." />
              <outline text="重量级锁是通过对象的Monitor实现，monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;独享锁(互斥锁) / 共享锁(读写锁) #面试题">
            <outline text="独享锁是指该锁一次只能被一个线程所持有. 也叫互斥锁." />
            <outline text="共享锁是指该锁可被多个线程所持有。也叫读写锁." />
            <outline text="&lt;b&gt;Synchronized&lt;/b&gt; 是独享锁。" />
            <outline text="而 Java的 &lt;b&gt;ReentrantLock&lt;/b&gt; 是独享锁。" />
            <outline text="对于Lock的另一个实现类 &lt;b&gt;ReadWriteLock&lt;/b&gt;，其读锁是共享锁，其写锁是独享锁。">
              <outline text="读锁的共享锁可保证并发读是非常高效的." />
              <outline text="写锁是独享锁, 保证读写，写读，写写的过程是互斥的。" />
            </outline>
            <outline text="独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。" />
          </outline>
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;乐观锁 / 悲观锁">
            <outline text="乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。" />
            <outline text="悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语 &lt;b&gt;Synchronized &lt;/b&gt;关键字的实现就是悲观锁。" />
          </outline>
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;公平锁 / 非公平锁">
            <outline text="公平锁是指多个线程按照申请锁的顺序来获取锁。" />
            <outline text="非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。" />
            <outline text="非公平锁的优点在于吞吐量比公平锁大。" />
            <outline text="Java &lt;b&gt;ReetrantLock&lt;/b&gt;，可通过构造函数指定该锁是否是公平锁，默认是非公平锁。" />
            <outline text="&lt;b&gt;Synchronized &lt;/b&gt;也是一种非公平锁。由于其并不像 ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。" />
          </outline>
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;可重入锁">
            <outline text="可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。可重入锁的一个好处是可一定程度避免死锁。" />
            <outline text="对于Java &lt;b&gt;ReetrantLock&lt;/b&gt;而言，从名字就可以看出是一个重入锁。" />
            <outline text="&lt;b&gt;Synchronized&lt;/b&gt; 也是一个可重入锁。" />
          </outline>
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;分段锁">
            <outline text="分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。" />
            <outline text="我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。" />
            <outline text="当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。" />
            <outline text="但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。" />
            <outline text="分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。" />
          </outline>
          <outline text="&lt;b&gt;锁的种类: &lt;/b&gt;自旋锁">
            <outline text="在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用轮询的方式去尝试获取锁." />
            <outline text="这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。" />
            <outline text="自旋锁适用于能很快取到锁的场景下. 这是较常见的情况." />
          </outline>
        </outline>
        <outline text="&lt;b&gt;加锁的方法&lt;/b&gt; #面试题">
          <outline text="&lt;b&gt;synchronized &lt;/b&gt;关键字，修饰代码块. 保证同时刻只有一个线程进入该方法或者代码块. ">
            <outline text="这种最方便, 但是对性能影响也最高. 所以不能到处加 &lt;b&gt;synchronized&lt;/b&gt;." />
            <outline text="&lt;b&gt;原理: synchronized是从偏向锁开始，根据需要逐步升级到轻量级锁, 最后达到重量级锁.&lt;/b&gt;" />
            <outline text="&lt;b&gt;synchronized &lt;/b&gt;有两种形式: " />
            <outline text="第一种是作为前缀定义函数.">
              <outline text="int count = 100;" />
              <outline text="private &lt;b&gt;synchronized &lt;/b&gt;void count() {">
                <outline text="if (count &amp;gt; 0) {">
                  <outline text="Log.e(TAG, Thread.currentThread().getName() + &quot;---&amp;gt;&quot; + count--);" />
                </outline>
                <outline text="} else {">
                  <outline text="isRunning = false;" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="第二种是定义代码块.">
              <outline text="private void count() {">
                <outline text="&lt;b&gt;synchronized &lt;/b&gt;(this) {">
                  <outline text="if (count &amp;gt; 0) {">
                    <outline text="Log.e(TAG, Thread.currentThread().getName() + &quot;---&amp;gt;&quot; + count--);" />
                  </outline>
                  <outline text="} else {">
                    <outline text="isRunning = false;" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
          <outline text="volatile 关键字, 修饰变量">
            <outline text="用volatile来定义变量，可以保证此变量对所有线程的可见性。" />
            <outline text="它告诉虚拟机该变量随时可能更新，因此使用时每次都会重新计算，而不是使用寄存器的值。当一条线程修改了这个值，新值对于其他所有线程来说是立即得知的。" />
            <outline text="volatile会降低性能。" />
            <outline text="Volatile修饰的变量只能保证可见性, 不一定是线程安全的，比如 ii++。" />
          </outline>
          <outline text="重入锁Lock类(ReentrantLock), 实现线程同步">
            <outline text="ReentrantLock 是 java.util.concurrent.Lock的实现类. " />
            <outline text="提供了如下接口:">
              <outline text="lock(): 获得锁" />
              <outline text="unlock(): 释放锁" />
            </outline>
            <outline text="例子:  " />
            <outline text="private void count() {">
              <outline text="private final ReentrantLock lock = new ReentrantLock();  // 创建可重入锁" />
              <outline text="lock.lock();" />
              <outline text="if (count &amp;gt; 0) {">
                <outline text="Log.e(TAG, Thread.currentThread().getName() + &quot;---&amp;gt;&quot; + count--);" />
              </outline>
              <outline text="} else {">
                <outline text="isRunning = false;" />
              </outline>
              <outline text="}" />
              <outline text="lock.unlock();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="ThreadLocal, 管理变量">
            <outline text="如果一个变量使用ThreadLocal进行管理，每一个使用该变量的线程都会获得该变量的副本，副本之间相互独立，所以每个线程都可以修改变量而不会对其它线程造成影响。" />
            <outline text="数据不共享，自然就没有线程安全问题了." />
            <outline text="private static ThreadLocal&amp;lt;Integer&amp;gt; number = new ThreadLocal&amp;lt;Integer&amp;gt;(){">
              <outline text="// 重写方法，设置默认值" />
              <outline text="protected Integer initialValue() {">
                <outline text="return 1;" />
              </outline>
              <outline text="}" />
              <outline text="// 自定义方法设置变量值" />
              <outline text="public void saveNumber(int newNumber){">
                <outline text="number.set(number.get() + newNumber);" />
              </outline>
              <outline text="}" />
              <outline text="// 自定义方法获取变量值" />
              <outline text="public int getNumber(){">
                <outline text="return number.get();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="};" />
          </outline>
          <outline text="Semaphore, 信号量">
            <outline text="信号量维护了一个计数器. 如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。" />
            <outline text="Semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得。" />
          </outline>
        </outline>
        <outline text="死锁问题">
          <outline text="产生死锁的四个必要条件： #面试题">
            <outline text="互斥条件：一个资源每次只能被一个进程使用。" />
            <outline text="请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。" />
            <outline text="不剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。" />
            <outline text="循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。" />
          </outline>
          <outline text="目前处理死锁的方法可归结为4种 #面试题">
            <outline text="预防死锁：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。" />
            <outline text="避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。" />
            <outline text="检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。" />
            <outline text="解除死锁：这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。" />
          </outline>
        </outline>
        <outline text="Java中如何获取到线程dump文件?">
          <outline text="死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：" />
          <outline text="（1）获取到线程的pid，可以通过使用 jps 命令，在Linux环境下还可以使用 ps -ef | grep java" />
          <outline text="（2）打印线程堆栈，可以通过使用 jstack pid命令，在Linux环境下还可以使用kill -3 pid" />
          <outline text="另外提一点，Thread类提供了一个 getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈." />
        </outline>
        <outline text="生产者消费者模型的作用是什么?">
          <outline text="通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。" />
          <outline text="解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。" />
        </outline>
      </outline>
      <outline text="04-Android基础">
        <outline text="Google play 三件套">
          <outline text="google service framework (包名： gsf)" />
          <outline text="google play service (gms)" />
          <outline text="google play store (vending)" />
        </outline>
        <outline text="&lt;b&gt;安卓版本演进&lt;/b&gt;">
          <outline text="&lt;a href=&quot;https://zh.wikipedia.org/wiki/Android%E7%89%88%E6%9C%AC%E5%88%97%E8%A1%A8&quot;&gt;https://zh.wikipedia.org/wiki/Android%E7%89%88%E6%9C%AC%E5%88%97%E8%A1%A8&lt;/a&gt;" />
          <outline text="2003年10月，Andy Rubin团队创办Android公司；" />
          <outline text="2005年8月，谷歌收购Android公司，Andy Rubin担任谷歌工程部副总裁继续负责Android项目." />
          <outline text="&lt;time startYear=&quot;2008&quot; startMonth=&quot;9&quot; startDay=&quot;23&quot;&gt;Tue, Sep 23, 2008&lt;/time&gt;, Android 1.0, Astro">
            <outline text="全球第一台Android设备 &lt;a href=&quot;https://baike.baidu.com/item/HTC%20Dream&quot;&gt;HTC Dream&lt;/a&gt;（G1）就是搭载Android 1.0操作系统." />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/Android%20Market&quot;&gt;Android Market&lt;/a&gt; 可以通过Android Market下载应用程序和获得程序更新；" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8&quot;&gt;网页浏览器&lt;/a&gt;：可以完全还原并且显示&lt;a href=&quot;https://baike.baidu.com/item/HTML&quot;&gt;HTML&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/XHTML&quot;&gt;XHTML&lt;/a&gt;的网页 – 并且可以通过多点触控对网页进行放大缩小。" />
            <outline text="照相机支持：支持照相机和摄像头，但是这个版本没有选项来改变相机的分辨率、白平衡、质量等等。" />
            <outline text="允许将应用程序图标放置到文件夹中，并且可以在主界面显示插件等东西。" />
            <outline text="支持E-mail传输：支持&lt;a href=&quot;https://baike.baidu.com/item/POP3&quot;&gt;POP3&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/IMAP4&quot;&gt;IMAP4&lt;/a&gt;以及&lt;a href=&quot;https://baike.baidu.com/item/SMTP&quot;&gt;SMTP&lt;/a&gt;。" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/Gmail&quot;&gt;Gmail&lt;/a&gt;：通过内置的Gmail应用程序进行Gmail同步。" />
            <outline text="Google联系人：通过People应用程序同步联系人。" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/Google%E6%97%A5%E5%8E%86&quot;&gt;Google日历&lt;/a&gt;：通过日历程序同步日历和日程。" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/Google%E5%9C%B0%E5%9B%BE&quot;&gt;Google地图&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Google%E7%BA%B5%E6%A8%AA&quot;&gt;Google纵横&lt;/a&gt;以及Google街景 可以帮助用户查看地图和地理信息，并且可以通过GPS服务定位地理位置" />
            <outline text="Google同步：一个管理Android设备中Google服务的应用功能。" />
            <outline text="Google搜索：允许用户在手机和网络上进行一致统一的搜索，包括联系人、电话、日历和信息等。" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/Google%20Talk&quot;&gt;Google Talk&lt;/a&gt;：一个聊天工具" />
            <outline text="实时消息、语音频息和短信" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE%E5%99%A8&quot;&gt;多媒体播放器&lt;/a&gt;：负责管理、导入、拷贝和播放多媒体文件，但是不支持蓝牙耳机。" />
            <outline text="通知的信息可以在任务栏显示，并且可以对提示的方式进行设置，包括振动、声音、LED或警告等提示方式。" />
            <outline text="声音识别器可以允许用户通过说话来输入文本、拨打电话，能更好的帮助残疾人士。" />
            <outline text="壁纸功能允许用户设置自己的照片和其他网络图片作为自己的手机主界面的背景。" />
            <outline text="&lt;a href=&quot;https://baike.baidu.com/item/YouTube&quot;&gt;YouTube&lt;/a&gt;内置YouTube在线应用程序。" />
            <outline text="其他应用程序：闹钟，计算器，电话，主界面，图库以及设置。" />
            <outline text="支持Wi-Fi和蓝牙" />
          </outline>
          <outline text="&lt;time startYear=&quot;2009&quot; startMonth=&quot;2&quot; startDay=&quot;2&quot;&gt;Mon, Feb 2, 2009&lt;/time&gt; , Android 1.1, Bender">
            <outline text="Android 1.1 只被预装在 T-Mobile G1 上。" />
            <outline text="用户搜索企业和其他服务时，下方会显示出其他用户搜索时对该搜索信息的评价和留言。" />
            <outline text="加强了电话功能，改进了免提功能。" />
            <outline text="支持对邮件附件的保存和预览功能。" />
            <outline text="增加了长按任意界面弹出多选框的功能。" />
          </outline>
          <outline text="&lt;time startYear=&quot;2009&quot; startMonth=&quot;4&quot; startDay=&quot;17&quot;&gt;Fri, Apr 17, 2009&lt;/time&gt; , Android 1.5, Cupcake">
            <outline text="拍摄/播放视频，并支持上传到&lt;a href=&quot;https://baike.baidu.com/item/Youtube&quot;&gt;Youtube&lt;/a&gt;。" />
            <outline text="支持立体声蓝牙耳机，同时改善自动配对性能。" />
            <outline text="最新的采用&lt;a href=&quot;https://baike.baidu.com/item/WebKit&quot;&gt;WebKit&lt;/a&gt;技术的浏览器，支持复制/粘贴和页面中搜索。" />
            <outline text="GPS性能大大提高" />
            <outline text="提供屏幕虚拟键盘" />
            <outline text="主屏幕增加音乐播放器和相框widgets" />
            <outline text="应用程序自动随着手机旋转" />
            <outline text="短信、Gmail、日历，浏览器的用户界面大幅改进，如Gmail可以批量删除邮件。" />
            <outline text="相机启动速度加快，拍摄图片可以直接上传到&lt;a href=&quot;https://baike.baidu.com/item/Picasa&quot;&gt;Picasa&lt;/a&gt;。" />
            <outline text="来电照片显示" />
          </outline>
          <outline text="&lt;time startYear=&quot;2009&quot; startMonth=&quot;9&quot; startDay=&quot;15&quot;&gt;Tue, Sep 15, 2009&lt;/time&gt; , Android 1.6, Donut">
            <outline text="该版本基于Linux 2.6.29内核。" />
            <outline text="重新设计的Android Market" />
            <outline text="手势支持" />
            <outline text="支持&lt;a href=&quot;https://baike.baidu.com/item/CDMA&quot;&gt;CDMA&lt;/a&gt;网络" />
            <outline text="文本转语音系统（Text-to-Speech）" />
            <outline text="快速搜索框" />
            <outline text="全新的拍照界面" />
            <outline text="查看应用程序耗电" />
            <outline text="支持&lt;a href=&quot;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%A7%81%E4%BA%BA%E7%BD%91%E7%BB%9C&quot;&gt;虚拟私人网络&lt;/a&gt;（VPN）" />
            <outline text="支持更多的屏幕分辨率" />
            <outline text="支持OpenCore2媒体引擎" />
            <outline text="新增面向视觉或听觉困难人群的易用性插件" />
          </outline>
          <outline text="Android 2.0/2.1, Eclair">
            <outline text="优化硬件速度" />
            <outline text="“Car Home”程序" />
            <outline text="支持更多的屏幕分辨率" />
            <outline text="改良的用户界面" />
            <outline text="新的浏览器的用户界面和支持&lt;a href=&quot;https://baike.baidu.com/item/HTML5&quot;&gt;HTML5&lt;/a&gt;" />
            <outline text="新的联系人名单" />
            <outline text="更好的白色/黑色背景比率" />
            <outline text="改进&lt;a href=&quot;https://baike.baidu.com/item/Google%20Maps&quot;&gt;Google Maps&lt;/a&gt; 3.1.2" />
            <outline text="支持Microsoft Exchange" />
            <outline text="支持内置相机闪光灯" />
            <outline text="支持数码变焦" />
            <outline text="改进的虚拟键盘" />
            <outline text="支持蓝牙2.1" />
            <outline text="支持动态桌面的设计" />
          </outline>
          <outline text="&lt;time startYear=&quot;2010&quot; startMonth=&quot;5&quot; startDay=&quot;20&quot;&gt;Thu, May 20, 2010&lt;/time&gt; , Android 2.2, Froyo">
            <outline text="该版本基于Linux 2.6.32内核。">
              <outline text="部分标称为2.2的固件仍然在使用2.6.29的核心。这种固件可以实现大部分2.2的功能（比如Flash），但性能上与Google官方发布的2.6.32内核有一定性能差距。" />
            </outline>
            <outline text="支持将软件安装至扩展内存" />
            <outline text="集成Adobe Flash 10.1支持" />
            <outline text="加强软件即时编译的速度" />
            <outline text="新增软件启动&quot;快速&quot;至电话和浏览器" />
            <outline text="USB分享器和WiFi热点功能" />
            <outline text="支持在浏览器上传档案" />
            <outline text="更新Market中的批量和自动更新" />
            <outline text="增加对Microsoft Exchange的支持（安全政策，auto-discovery，GAL look-up）" />
            <outline text="集成&lt;a href=&quot;https://baike.baidu.com/item/Chrome&quot;&gt;Chrome&lt;/a&gt;的V8 JavaScript引擎到浏览器" />
            <outline text="加强快速搜索小工具" />
            <outline text="更多软件能透过Market更新，类似2.0/2.1中的Map更新" />
            <outline text="速度和性能优化" />
          </outline>
          <outline text="&lt;time startYear=&quot;2010&quot; startMonth=&quot;12&quot; startDay=&quot;6&quot;&gt;Mon, Dec 6, 2010&lt;/time&gt; , Android 2.3, Gingerbread">
            <outline text="该版本基于Linux 2.6.35内核。" />
            <outline text="修补UI" />
            <outline text="支持更大的屏幕尺寸和分辨率（&lt;a href=&quot;https://baike.baidu.com/item/WXGA&quot;&gt;WXGA&lt;/a&gt;及更高）" />
            <outline text="系统级复制粘贴" />
            <outline text="重新设计的多点触摸屏幕键盘" />
            <outline text="原生支持多个镜头（用于视频通话等）和更多传感器（陀螺仪、气压计等）" />
            <outline text="电话簿集成Internet Call功能" />
            <outline text="支持&lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%91%E5%9C%BA%E9%80%9A%E4%BF%A1&quot;&gt;近场通信&lt;/a&gt;（NFC）" />
            <outline text="强化电源、应用程序管理功能" />
            <outline text="新增下载管理员" />
            <outline text="优化游戏开发支持" />
            <outline text="多媒体音效强化" />
            <outline text="从&lt;a href=&quot;https://baike.baidu.com/item/YAFFS&quot;&gt;YAFFS&lt;/a&gt;转换到&lt;a href=&quot;https://baike.baidu.com/item/ext4&quot;&gt;ext4&lt;/a&gt;文件系统" />
            <outline text="开放了屏幕截图功能" />
            <outline text="对黑色及白色的还原更加真实" />
            <outline text="屏幕截图功能（电源键+Home）在2.3.4 才有实现出来（2011 Xperia: 长按Power键，再点击“截图”）" />
            <outline text="&lt;time startYear=&quot;2011&quot; startMonth=&quot;7&quot; startDay=&quot;25&quot;&gt;Mon, Jul 25, 2011&lt;/time&gt;, Android 2.3.5更新包发布，如下改进： ">
              <outline text="提升了Nexus S 4G的性能，包括其他性能的提升。" />
              <outline text="修复了存在于&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%89%E6%98%9FGalaxy%20S&quot;&gt;三星Galaxy S&lt;/a&gt;中存在的蓝牙Bug。" />
              <outline text="升级了内置的Gmail应用程序" />
              <outline text="增强了滚动列表时产生的阴影动画" />
              <outline text="增强了内置的相机功能" />
              <outline text="改善了电池耗电量，增加续航时间。" />
            </outline>
          </outline>
          <outline text="&lt;time startYear=&quot;2011&quot; startMonth=&quot;2&quot; startDay=&quot;24&quot;&gt;Thu, Feb 24, 2011&lt;/time&gt; , Android 3.0, Honeycomb">
            <outline text="仅供平板电脑使用" />
            <outline text="Google eBooks上提供数百万本书" />
            <outline text="支持平板电脑大屏幕、高分辨率" />
            <outline text="新版Gmail" />
            <outline text="Google Talk视讯功能" />
            <outline text="3D加速处理" />
            <outline text="网页版Market（Web store）详细分类显示，依个人Android分别设定安装应用程序。" />
            <outline text="新的短消息通知功能" />
            <outline text="专为平板电脑设计的用户界面（重新设计的通知列与系统列）" />
            <outline text="加强多任务处理的界面" />
            <outline text="重新设计适用大屏幕的键盘及复制粘贴功能" />
            <outline text="多个标签的浏览器以及私密浏览模式" />
            <outline text="快速切换各种功能的相机" />
            <outline text="增强的图库与快速滚动的联系人界面" />
            <outline text="更有效率的Email界面" />
            <outline text="支持多核心处理器" />
            <outline text="&lt;time startYear=&quot;2011&quot; startMonth=&quot;5&quot; startDay=&quot;10&quot;&gt;Tue, May 10, 2011&lt;/time&gt;, Android 3.1 发布。主要更新如下： ">
              <outline text="用户界面的改进" />
              <outline text="连接USB配件" />
              <outline text="扩大最近的应用程序列表" />
              <outline text="可调整大小的主屏幕小部件" />
              <outline text="支持外部键盘和鼠标等设备" />
              <outline text="支持操纵杆和游戏控制器" />
              <outline text="FLAC音频播放支持" />
              <outline text="高性能的WiFi锁，维护高性能WiFi连接设备屏幕关闭时。" />
              <outline text="支持HTTP代理为每个连接的WiFi接入点" />
            </outline>
            <outline text="&lt;time startYear=&quot;2011&quot; startMonth=&quot;7&quot; startDay=&quot;15&quot;&gt;Fri, Jul 15, 2011&lt;/time&gt;, Android 3.2发布。全球第一台使用该版本操作系统的设备是中国 &lt;a href=&quot;https://baike.baidu.com/item/%E5%8D%8E%E4%B8%BA&quot;&gt;华为&lt;/a&gt;公司制造生产的&lt;a href=&quot;https://baike.baidu.com/item/MediaPad&quot;&gt;MediaPad&lt;/a&gt;平板电脑。主要更新如下： ">
              <outline text="改进的硬件支持，包括为更广泛的芯片，并且进行优化。" />
              <outline text="增强应用程序访问SD卡上文件的能力，提供同步功能。" />
              <outline text="增加应用程序兼容性功能，用户可以通过使用兼容性功能适配更多应用程序。" />
              <outline text="新的显示支持功能，为开发人员提供更多的显示外观在不同的Android设备的控制。" />
            </outline>
            <outline text="&lt;time startYear=&quot;2011&quot; startMonth=&quot;9&quot; startDay=&quot;20&quot;&gt;Tue, Sep 20, 2011&lt;/time&gt;, Android 3.2.1 发布，包含以下更新： ">
              <outline text="修复存在的Bug和安全性问题，增强系统稳定性和WiFi的性能" />
              <outline text="升级自带的&lt;a href=&quot;https://baike.baidu.com/item/Android%20Market&quot;&gt;Android Market&lt;/a&gt;" />
              <outline text="升级自带的Google Books" />
              <outline text="提升浏览器对&lt;a href=&quot;https://baike.baidu.com/item/Adobe%20Flash&quot;&gt;Adobe Flash&lt;/a&gt;的支持" />
              <outline text="增强对简体中文、繁体中文的手写功能" />
            </outline>
          </outline>
          <outline text="&lt;time startYear=&quot;2011&quot; startMonth=&quot;10&quot; startDay=&quot;19&quot;&gt;Wed, Oct 19, 2011&lt;/time&gt; , Android 4.0, Ice Cream Sandwich">
            <outline text="统一了手机和平板电脑使用的系统，应用会自动根据设备选择最佳显示方式。" />
            <outline text="提升硬件的性能以及系统的优化，提升系统流畅度。" />
            <outline text="支持在系统中使用虚拟按键，该功能可以取代物理按键。" />
            <outline text="界面以新的标签页形式展示，并且将应用程序和其他内容的图标分类。" />
            <outline text="更方便地在主界面创建文件夹，并且使用“一拖”、“一放”的操作方式。" />
            <outline text="一个定制的启动器" />
            <outline text="改进的可视化语音邮件的能力，加快或减慢语音邮件。" />
            <outline text="在日历中也可以使用多点触控，进行缩放和拖拽操作。" />
            <outline text="Gmail离线搜索，两行预览，和新的任务栏。" />
            <outline text="与其他第三方微博、博客类应用程序的无缝连接，实时更新的内容会被展示在主界面上。" />
            <outline text="Gmail支持缩放操作，支持左拉、右拉进行查看。" />
            <outline text="增加截图功能（可以同时按住电源键和音量向下键进行截图操作）。" />
            <outline text="改进虚拟键盘可以产生的误操作" />
            <outline text="在锁屏状态下也可以对用户设置的某些应用程序进行操作" />
            <outline text="改进的复制、粘贴功能" />
            <outline text="更好的语音集成，实时录音，文本听写等语音功能。" />
            <outline text="脸部识别进行锁屏，可以通过脸部识别进行锁屏。" />
            <outline text="新标签页模式的网页浏览器，支持最大同时打开16个标签页。" />
            <outline text="自动同步用户手机中的网页书签，可以在桌面版Chrome和其他Android设备中进行同步。" />
            <outline text="全新的现代化&lt;a href=&quot;https://baike.baidu.com/item/Roboto&quot;&gt;Roboto&lt;/a&gt;字体" />
            <outline text="内置流量监控功能，用户可以对流量进行设置，超出设置流量时，手机会自动关闭上网功能，并且可以随时查看已使用和未使用的流量，并且以报表的形式展现出来以帮助用户了解使用情况。" />
            <outline text="能够随时关闭正在使用的应用程序" />
            <outline text="提升自带的相机功能" />
            <outline text="内置图片处理软件" />
            <outline text="新的图库软件" />
            <outline text="与其他第三方应用程序进行无缝衔接，用户可以在任何界面看到自己需要的消息和图像。" />
            <outline text="新的启动画面，主画面右下角类似Tray的图标，内有多个程序可运行。" />
            <outline text="Google Search Bar会设置在最上方" />
            <outline text="Apps/Widgets会类似Honeycomb模样" />
            <outline text="增加支持硬件加速的功能" />
            <outline text="Wi-Fi直连功能" />
            <outline text="支持&lt;a href=&quot;https://baike.baidu.com/item/1080p&quot;&gt;1080p&lt;/a&gt;视频播放和录制" />
          </outline>
          <outline text="&lt;time startYear=&quot;2012&quot; startMonth=&quot;6&quot; startDay=&quot;28&quot;&gt;Thu, Jun 28, 2012&lt;/time&gt; , Android 4.1/4.2/4.3, Jelly Bean">
            <outline text="“黄油”性能（Project Butter），意思是可以让Jelly Bean的体验像“黄油般顺滑”（锁定提升用户页面的速度与流畅性）。" />
            <outline text="“&lt;a href=&quot;https://baike.baidu.com/item/Google%20Now&quot;&gt;Google Now&lt;/a&gt;”可在Google日历内加入活动举办时间、地点，系统就会在判断当地路况后，提前在“适当的出门时间给予通知”，协助用户在准时时间抵达。" />
            <outline text="新增脱机语音输入" />
            <outline text="通知中心显示更多消息" />
            <outline text="更多的平板优化（主要针对小尺寸平板）" />
            <outline text="强化Voice Search语音搜索，与S Voice类近，相当于Apple Siri。" />
            <outline text="Google Play 增加电视视频与电影的购买" />
            <outline text="提升反应速度" />
            <outline text="强化默认键盘" />
            <outline text="大幅改变用户界面设计" />
            <outline text="更多的Google云集成" />
            <outline text="恶意软件的保护措施，强化&lt;a href=&quot;https://baike.baidu.com/item/ASLR&quot;&gt;ASLR&lt;/a&gt;" />
            <outline text="Google Play 采用智能升级，更新应用只会下载有改变的部分以节约时间、流量、电量，平均只需下载原APK文件的三分之一。" />
            <outline text="不会内置Flash Player，并且&lt;a href=&quot;https://baike.baidu.com/item/Adobe&quot;&gt;Adobe&lt;/a&gt;声明停止开发，但可自行安装APK。" />
            <outline text="&lt;time startYear=&quot;2012&quot; startMonth=&quot;11&quot; startDay=&quot;23&quot;&gt;Fri, Nov 23, 2012&lt;/time&gt; , Android 4.2发布:">
              <outline text="PhotoSphere 360°全景拍摄" />
              <outline text="手势输入键盘" />
              <outline text="改进锁屏：支持Widget，可于屏幕锁定界面直接打开相机功能。" />
              <outline text="Daydream屏幕保护程序功能" />
              <outline text="可直接进行操作的状态通知列功能" />
              <outline text="支持多重账户（仅适用于平板电脑）" />
              <outline text="&lt;a href=&quot;https://baike.baidu.com/item/Miracast&quot;&gt;Miracast&lt;/a&gt;无线显示分享功能" />
              <outline text="连点三次可放大整个显示页及两指旋转和缩放" />
              <outline text="增加为盲人用户设计的语音输出及手势模式导航功能" />
              <outline text="内置时钟新增世界时钟，秒表和定时器" />
              <outline text="Google Now新增以Gmail登录信息作为数据源" />
              <outline text="Google Now新增航班追踪功能、酒店、餐厅预订，与音乐和电影推荐功能。" />
              <outline text="Gmail邮件可缩放显示" />
            </outline>
            <outline text="&lt;time startYear=&quot;2013&quot; startMonth=&quot;2&quot; startDay=&quot;11&quot;&gt;Mon, Feb 11, 2013&lt;/time&gt; , Android 4.2.2发布:">
              <outline text="改善蓝牙A2DP流问题" />
              <outline text="Google Play在下载内容时会显示剩余的时间" />
              <outline text="在快速设置中长按WiFi和蓝牙图标可切换开关" />
              <outline text="当设备电量低于95%并开始无线充电时会发出提示音" />
              <outline text="在USB Debug加入白名单功能" />
              <outline text="优化电池耗电量，增加续航时间。" />
            </outline>
            <outline text="&lt;time startYear=&quot;2013&quot; startMonth=&quot;7&quot; startDay=&quot;24&quot;&gt;Wed, Jul 24, 2013&lt;/time&gt; , Android 4.3发布:">
              <outline text="支持多用户登录，支持一台终端设备上有多个登录帐号。" />
              <outline text="“蓝牙低功耗”功能，开启蓝牙后，耗电量相比之前大幅降低。" />
              <outline text="支持更多缓冲器对象" />
              <outline text="新版&lt;a href=&quot;https://baike.baidu.com/item/OpenGL%20ES&quot;&gt;OpenGL ES&lt;/a&gt; 3.0渲染语言，支持32 位整数和浮点数据类型以及操作。" />
              <outline text="增加多个纹理的支持，包括浮点纹理、深度纹理、顶点纹理等等。" />
              <outline text="多重渲染目标（Multiple Render Targets），让GPU一次性渲染多个纹理。" />
              <outline text="多重采样抗锯齿（MSAA Render To Texture），让3D物体的边缘不出现毛刺，可提升图像效果。" />
              <outline text="使用统一的纹理压缩格式ETC" />
              <outline text="增加TRIM指令，使得内置存储（Internal Storage）不会越用越慢。" />
              <outline text="新增App Opt功能（默认隐藏），允许用户强行解除已安装应用的特定权限。" />
            </outline>
          </outline>
          <outline text="&lt;time startYear=&quot;2013&quot; startMonth=&quot;9&quot; startDay=&quot;3&quot;&gt;Tue, Sep 3, 2013&lt;/time&gt; , Android 4.4, KitKat">
            <outline text="支持语音打开Google Now (在主画面说出“OK Google”)" />
            <outline text="在阅读电子书、玩游戏、看电影时支持全屏模式（Immersive Mode）" />
            <outline text="优化存储器使用，在多任务处理时有更佳工作的表现。" />
            <outline text="新的电话通信功能" />
            <outline text="旧有的SMS应用程序集成至新版本的Hangouts应用程序" />
            <outline text="Emoji Keyboard 集成至Google本地的键盘" />
            <outline text="支持Google Cloud Print服务，让用户可以利用户中或办公室中连接至Cloud Print的打印机，印出文件。" />
            <outline text="支持第三方Office应用程序直接打开及存储用户在Google Drive内的文件，实时同步更新文件。" />
            <outline text="支持低电耗音乐播放" />
            <outline text="全新的原生计步器" />
            <outline text="全新的NFC付费集成" />
            <outline text="全新的非Java虚拟机运行环境ART（Android Runtime）" />
            <outline text="支持Message Access Profile（MAP）" />
            <outline text="支持Chromecast及新的Chrome功能" />
            <outline text="支持隐闭字幕" />
          </outline>
          <outline text="&lt;time startYear=&quot;2014&quot; startMonth=&quot;6&quot; startDay=&quot;25&quot;&gt;Wed, Jun 25, 2014&lt;/time&gt; , Android 5.0, Lollipop">
            <outline text="采用全新Material Design界面" />
            <outline text="支持64位处理器" />
            <outline text="全面由Dalvik转用ART(Android Runtime)编译，性能可提升四倍" />
            <outline text="改良的通知界面及新增优先模式" />
            <outline text="预载省电及充电预测功能" />
            <outline text="新增自动内容加密功能" />
            <outline text="新增多人设备分享功能，可在其他设备登录自己账号，并获取用户的联系人、日历等Google云数据" />
            <outline text="强化网络及传输连接性，包括Wi-Fi、蓝牙及NFC" />
            <outline text="强化多媒体功能，例如支持RAW格式拍摄" />
            <outline text="强化“OK Google”功能" />
            <outline text="改善Android TV的支持" />
            <outline text="提供低视力的设置，以协助色弱人士" />
            <outline text="改善Google Now功能 [2]" />
          </outline>
          <outline text="&lt;time startYear=&quot;2015&quot; startMonth=&quot;5&quot; startDay=&quot;28&quot;&gt;Thu, May 28, 2015&lt;/time&gt; , Android 6.0, Marshmallow">
            <outline text="应用权限管理" />
            <outline text="SD卡可能和内置存储“合并”" />
            <outline text="Android Pay" />
            <outline text="原生指纹识别认证" />
            <outline text="自动应用数据备份" />
            <outline text="App Links（尽量减少诸如“你想要使用什么来打开这个？”的提醒）" />
            <outline text="打盹和应用待机功能" />
            <outline text="多窗口（隐藏技能，未来不确定）" />
            <outline text="主题支持（隐藏技能，未来不确定）" />
            <outline text="Dark主题（已经被移除，未来不确定）" />
            <outline text="可定制的Quick Toggles和其他UI调整" />
            <outline text="可视化的语音邮件支持" />
            <outline text="重新设计的时钟插件和音乐识别插件" />
            <outline text="在设置中新出现的全新“Memory”选项条目（早期版本出现，不过后来被隐藏）" />
            <outline text="在完成截图之后可以通过通知中心直接删除截图" />
            <outline text="Google Now Launcher支持横屏模式" />
            <outline text="带滚动条和垂直滚动条支持的全新应用和窗口小部件抽屉" />
            <outline text="内置的文件管理器能够获得功能方面的明显升级" />
            <outline text="支持原生点击唤醒功能" />
            <outline text="可以选择“heads up”或者“peeking” 通知" />
            <outline text="原生4K输出支持" />
            <outline text="严格的APK安装文件验证" />
            <outline text="支持MIDI" />
            <outline text="USB Type-C端口支持" />
            <outline text="全新的启动动画" />
            <outline text="引入“语音交互”API在应用中提供更好的语音支持" />
            <outline text="可通过语音命令切换到省电模式" />
            <outline text="可以通过蓝牙键盘快捷方式来撤销和重做文本" />
            <outline text="在联系人应用中能够对已经添加的联系人进行合并、删除或者分享功能。" />
            <outline text="会有针对文本选择的浮动工具栏出现，以便于更快的选择文本" />
            <outline text="默认应用的UI" />
            <outline text="允许通过分享菜单直接分享给联系人好友" />
            <outline text="更细化的应用程序信息" />
            <outline text="原生蓝牙手写笔支持" />
            <outline text="分屏键盘" />
            <outline text="移动的收音机" />
            <outline text="Mobile Radio Active服务电池续航BUG将会被修复" />
            <outline text="除重复来电之外优化勿扰模式" />
            <outline text="蓝牙扫描来改善定位精准度" />
            <outline text="原生Flashlight API" />
            <outline text="更容易访问控制多个声音空控制（ 铃声、多媒体和闹钟）" />
            <outline text="更平滑的声音滑块" />
          </outline>
          <outline text="&lt;time startYear=&quot;2016&quot; startMonth=&quot;5&quot; startDay=&quot;18&quot;&gt;Wed, May 18, 2016&lt;/time&gt; , Android 7.0, Nougat">
            <outline text="内核版本：4.4.1" />
            <outline text="支持多视窗模式" />
            <outline text="加入应用在 Android Wear 上的 RemoteInput notification API" />
            <outline text="强化Doze 的省电功能" />
            <outline text="加入暗色主题" />
            <outline text="强化Smart Lock 功能" />
            <outline text="加入 Tile API ，允许应用程序开发者在“快速设置”中添加瓷块。" />
            <outline text="Recent App 加入全部清除" />
            <outline text="加入新版 Emoji" />
            <outline text="支持 Vulkan" />
            <outline text="更新App Folder" />
          </outline>
          <outline text="&lt;time startYear=&quot;2017&quot; startMonth=&quot;8&quot; startDay=&quot;21&quot;&gt;Mon, Aug 21, 2017&lt;/time&gt; , Android 8.0, Oreo">
            <outline text="内核版本：4.9" />
            <outline text="强化与用户交互之性能" />
            <outline text="提高电池使用寿命" />
            <outline text="通知列表" />
            <outline text="应用图标的通知" />
            <outline text="子母画面" />
            <outline text="支持 Google Assistant 的智能选字工具" />
            <outline text="背景 App 的运行限制" />
            <outline text="自适应图标" />
            <outline text="改进的 MediaRecorder API" />
            <outline text="Project Treble模块化架构" />
            <outline text="多种商务功能" />
          </outline>
          <outline text="&lt;time startYear=&quot;2018&quot; startMonth=&quot;3&quot; startDay=&quot;7&quot;&gt;Wed, Mar 7, 2018&lt;/time&gt; , Android 9.0, Pie">
            <outline text="内核版本：4.14" />
            <outline text="为快速设置菜单设计的新用户界面" />
            <outline text="时钟移动到通知栏的左侧" />
            <outline text="屏幕下方的dock加入半透明背景" />
            <outline text="取消省电模式的橙色条" />
            <outline text="电源选项中加入截屏按钮" />
            <outline text="锁定（Lockdown）功能，开启后将禁用生物识别" />
            <outline text="图标加入更多圆角" />
            <outline text="在应用之间切换，或在应用内部菜单间切换时，使用新的动画" />
            <outline text="通知更加丰富，能够显示会话的更完整内容，以及类似Google开发的Reply的智能回复" />
            <outline text="经过重新设计的音量滑块" />
            <outline text="可在息屏上显示电量" />
            <outline text="可能重新加入的NFC解锁功能" />
            <outline text="实验性功能（一般情况下隐藏在Feature Flag功能表中），例如重新设计的“关于手机”页面，以及驾驶时自动启用蓝牙功能等。" />
            <outline text="支持高效率图像文件格式" />
            <outline text="全新的手势操作界面，不带多任务键（仍可以使用旧版操作方式）" />
            <outline text="重新设计的任务管理器界面，具有Google搜索栏" />
            <outline text="令用户可在仪表盘得知自己在应用中已停留多久的“数位健康”功能" />
            <outline text="将设备正面朝下放置可进入请勿打扰模式，只允许紧急通知" />
            <outline text="优化用户最常用的应用以大幅省电的自适应省电功能" />
            <outline text="基于个人偏好设置的自动亮度功能" />
            <outline text="“Wind down”功能：允许用户设定一个休息时间，到时系统界面会变灰以防止夜间进一步长时间使用。" />
          </outline>
          <outline text="&lt;time startYear=&quot;2019&quot; startMonth=&quot;9&quot; startDay=&quot;3&quot;&gt;Tue, Sep 3, 2019&lt;/time&gt; , Android 10.0, Q">
            <outline text="Linux内核版本：5.0" />
            <outline text="此版本Android是各Android版本中，首次不用甜品来命名。" />
            <outline text="对折叠式智能手机的原生支持。" />
            <outline text="允许用户控制应用程序何时有权查所在位置。" />
            <outline text="新增控制应用程序在后台时的照片、视频和音乐文件的访问权限。" />
            <outline text="支持屏幕录影功能。" />
            <outline text="增加对后台应用程序自动唤醒到前台的限制。" />
            <outline text="隐私改进：限制对IMEI码的读取。" />
            <outline text="更快捷的分享方式，允许直接与联系人共享内容。" />
            <outline text="新增浮动设置面板（Floating settings panel），允许直接从应用程序中更改系统设置。" />
            <outline text="照片的动态景深格式，允许在拍照后更改景深模糊程度。" />
            <outline text="支持AV1视频编解码器、HDR10+视频格式和Opus音频编解码器。" />
            <outline text="加入原生MIDI API，允许其与音乐控制器互换。" />
            <outline text="为应用程序中的生物识别技术提供更好的支持。" />
            <outline text="新增53个中立性别的Emoji。" />
            <outline text="“Bubbles”气泡通知界面。Bubbles通过在其他应用程序中快速访问App内的功能来帮助多任务处理，并且用于发送消息，正在进行的任务以及到达时间或电话等更新，并且可以提供对笔记、翻译或任务的快速访问。" />
            <outline text="新的手势操作设计。新的方案增加了向任一方向拉动导航按钮、在应用程序之间切换的功能。" />
            <outline text="类似iOS 12前的3D Touch的深度按压功能。" />
            <outline text="以纯文本形式显示Wi-Fi密码。" />
            <outline text="屏幕智能睡眠功能，使用手机时不会关闭屏幕。" />
            <outline text="可选择黑屏／近黑屏显示模式，包括短信显示。" />
            <outline text="加入全新导航手势（向上滑动），类似于“iPhone X”的底部长条导航。" />
            <outline text="Product Sans字体被运用的更广（仅限Pixel设备）" />
          </outline>
          <outline text="&lt;time startYear=&quot;2020&quot; startMonth=&quot;9&quot; startDay=&quot;8&quot;&gt;Tue, Sep 8, 2020&lt;/time&gt; , Android 11.0, R">
            <outline text="原生内置屏幕录影" />
            <outline text="更新屏幕截图后的动作" />
            <outline text="深色主题的日程表" />
            <outline text="通信程序如WhatsApp、Telegram的泡泡" />
            <outline text="新的电源清单" />
            <outline text="自定义“画中画”视频画面的大小" />
            <outline text="更新语音操控" />
            <outline text="更新权限管理">
              <outline text="用户可授予应用程序一次性权限" />
              <outline text="“Zombie权限”：当长时间没有使用应用程序时，权限会被重置" />
            </outline>
            <outline text="更新通知功能">
              <outline text="通知栏新增通信程序“对话”组别" />
              <outline text="通知栏新增媒体播放的独立区域" />
              <outline text="录影时暂停通知" />
            </outline>
          </outline>
        </outline>
        <outline text="Android生态环境  @Today " />
        <outline text="android开源许可证情况">
          <outline text="linux kerenl：GPL；" />
          <outline text="各种运行时函数库，比如bionic：BSD；" />
          <outline text="Dalvik虚拟机及java类库：Apache。">
            <outline text="社区对android选择ASL的分析:" />
            <outline text="ASL和BSD鼓励开源软件的商业性使用，使软件公司愿意对开源软件投资，因为这些公司可以从中获利。" />
            <outline text="就手机厂商而言，他们才是受android许可证影响最大的开发者，因为他们是手机平台主要的发布渠道。" />
            <outline text="apache允许手机厂商对平台进行改造，使得android变得他们的独家平台一样。" />
          </outline>
        </outline>
        <outline text="Android是怎么完成区隔的？">
          <outline text="Android的做法是，通过bionic libc替代glibc，确保“keep GPL out of user_space”，这句话来自2008年google IO大会一篇著名ppt的原文。" />
          <outline text="但是，这种做法引起了一些疑问:">
            <outline text="使用glibc. 使用系统调用，本来就没有开源义务。所以这个理由基本不成立。" />
            <outline text="bionic libc拷贝内核头文件，并去掉其中的GPL申明。">
              <outline text="这一点引起的争议很大。" />
              <outline text="google的辩解是这些是代码自动抓取的，以保证数据结构的统一。" />
              <outline text="这明显是借口，因为glibc不需要这么做。" />
            </outline>
          </outline>
          <outline text="关键在哪里？HAL层。">
            <outline text="google通过HAL层来缓解业界对GPL的恐惧。" />
            <outline text="在android中，HAL本质上是用户空间的驱动。" />
            <outline text="目的是规避GPL。" />
            <outline text="硬件厂商可以把自己的产权相关代码放在HAL层，就可以二进制发布。" />
            <outline text="HAL层细节, 驱动的主要业务逻辑剥离出来放在用户空间的主驱动模块中，内核的驱动是个“影子”驱动，只有透传控制命令和数据的功能。" />
          </outline>
          <outline text="这条显而易见的路，为什么要等到google来才走得通？">
            <outline text="关键还是在bionic libc。" />
            <outline text="google通过bionic暴露更多的接口，包括原来在内核空间才能使用的接口。" />
            <outline text="其目的是为了让设备驱动能够充分的利用内核和硬件资源。 " />
          </outline>
          <outline text="bionic libc是android的后门.">
            <outline text="借这个后门，隔离了GPL，架空了linux." />
            <outline text="推动无数硬件厂商为它写驱动，提供器件。" />
          </outline>
        </outline>
        <outline text="Android版本列表">
          <outline text="Android 5.0/5.1 - Lollipop（Android L）- API 21/22" />
          <outline text="Android 6.0 - Marshmallow（Android M）- API 23" />
          <outline text="Android 7.0/7.1 -Nougat（Android N） - API 24/25" />
          <outline text="Android 8.0/8.1 -Oreo（Android O） - API 26/27" />
          <outline text="Android 9.0 -Pie （Android P） - API 28" />
          <outline text="Android 10.0 -（未知）（Android Q）" />
        </outline>
        <outline text="Android代码的量级">
          <outline text="for android 4.0，use sloccount" />
          <outline text="ansi C 15908K（其中kernel 9728K）" />
          <outline text="xml：5880K" />
          <outline text="C++：5860K" />
          <outline text="java：3217K" />
          <outline text="ASM：619K" />
        </outline>
        <outline text="Android架构分层">
          <outline text="Application(应用程序层) , 即应用软件，也包括系统内置的一组应用程序，使用的是Java语言." />
          <outline text="Application Framework(应用程序框架层) 无论系统内置或者我们自己编写的App，都需要使用到这层，比如我们想弄来电黑名单，自动挂断电话，我们就需要用到电话管理(TelephonyManager) 通过该层我们就可以很轻松的实现挂断操作，而不需要关心底层实现." />
          <outline text="Android Runtime(Android运行时) ">
            <outline text="Android核心库集" />
            <outline text="Dalvik虚拟机: 针对移动设备定制的Java虚拟机，它的特点:不需要很快的CPU计算速度和大量的内存空间;而每个App都单独地运行在单独的Dalvik虚拟机内每个app对于一条Dalvik进程." />
          </outline>
          <outline text="Libraries(库): 一组C/C++库，为平台的不同组件所使用，比如媒体框架." />
          <outline text="Linux内核. 即底层驱动的部分，一些系统服务，比如安全性，内存管理以及进程管理等." />
        </outline>
        <outline text="Android工程的目录结构">
          <outline text="Makefile" />
          <outline text="abi">
            <outline text="applicationbinary interface，应用程序二进制接口" />
            <outline text="生成 libgabi++.so相关库文件" />
          </outline>
          <outline text="art  **">
            <outline text="google在4.4后加入用来代替Dalvik的运行时" />
          </outline>
          <outline text="bionic  **">
            <outline text="Android的C library，即C库文件。" />
            <outline text="libm（library math）" />
            <outline text="libc（library c）：在 glibc 的基础上做了裁剪与修改的，为了规避GNU GPL等商业行为的约束" />
            <outline text="libstdc++（library standard C++）：并非完整版，只做了简单支持" />
            <outline text="linker：装载链接相关库" />
          </outline>
          <outline text="bootable">
            <outline text="启动引导相关代码。" />
            <outline text="仅 recovery。" />
          </outline>
          <outline text="build">
            <outline text="存放系统编译规则及generic等基础开发配置包" />
          </outline>
          <outline text="cts">
            <outline text="Android兼容性测试套件标准" />
          </outline>
          <outline text="dalvik **">
            <outline text="dalvik JAVA虚拟机" />
          </outline>
          <outline text="developers">
            <outline text="开发者用，存放几个例子" />
          </outline>
          <outline text="development">
            <outline text="开发者需要的一些例程及工具" />
          </outline>
          <outline text="device">
            <outline text="设备相关代码，这是各厂商需要配置和修改的代码。" />
            <outline text="文件很多。" />
            <outline text="不太重要。" />
          </outline>
          <outline text="external">
            <outline text="android使用的一些开源的模块。" />
            <outline text="比如大家比较熟悉的如glide、junit、okhttp、sqlite 等。" />
          </outline>
          <outline text="frameworks  ***">
            <outline text="核心框架,  Java及C++语言" />
            <outline text="Android support 包， 包括 com.android.support:support-v4、v7 等都位于 frameworks/support 文件夹下" />
            <outline text="webview 就位于 frameworks/webview 文件夹下" />
            <outline text="各种 Service，比如ActivityManagerService、SystemService、WindowManagerService、InputManagerService等就位于 frameworks/base 文件夹下" />
            <outline text="keystore、opengl 等也位于 frameworks/base 文件夹下" />
          </outline>
          <outline text="hardware  **">
            <outline text="HAL层。" />
            <outline text="仅部分愿意开源的厂家的代码。" />
          </outline>
          <outline text="kernel  **">
            <outline text="驱动内核相关代码" />
          </outline>
          <outline text="libcore  **">
            <outline text="核心库相关" />
          </outline>
          <outline text="libnativehelper  **">
            <outline text="JNI用到的库" />
          </outline>
          <outline text="ndk">
            <outline text="ndk相关" />
          </outline>
          <outline text="packages">
            <outline text="应用程序包" />
            <outline text="蓝牙、浏览器、相机、邮件、音乐、NFC 等都位于 packages/apps 下面" />
            <outline text="MediaProvider、DownloadProvider、MmsProvider等都位于 packages/providers 下" />
            <outline text="壁纸相关位于 packages/wallpapers 下" />
          </outline>
          <outline text="pdk">
            <outline text="google用来减少碎片化的东西" />
          </outline>
          <outline text="prebuilt">
            <outline text="x86和arm架构下预编译的一些资源" />
          </outline>
          <outline text="sdk">
            <outline text="sdk及模拟器" />
          </outline>
          <outline text="system  **">
            <outline text="底层文件系统库、应用及组件. " />
            <outline text="C语言" />
            <outline text="Treble 架构在这里。" />
          </outline>
          <outline text="toolchain">
            <outline text="工具链" />
          </outline>
          <outline text="tools">
            <outline text="工具类。包含 fat32lib 与 gradle。" />
          </outline>
          <outline text="vendor">
            <outline text="厂商定制代码" />
          </outline>
        </outline>
        <outline text="应用架构指南">
          <outline text="https://developer.android.google.cn/jetpack/docs/guide" />
          <outline text="android建议应用不给用户提供退出菜单。" />
        </outline>
        <outline text="Android 官方UI设计手册： &lt;a href=&quot;https://www.shuzhiduo.com/A/q4zVW01WJK/&quot;&gt;https://www.shuzhiduo.com/A/q4zVW01WJK/&lt;/a&gt; 翻译版" />
        <outline text="定时器">
          <outline text="SystemClock.elapsedRealtime()：获得系统开机到现在经历的毫秒数。" />
        </outline>
        <outline text="Android Support Library包">
          <outline text="Android Support v4">
            <outline text="这个包是为了照顾1.6及更高版本而设计的。" />
            <outline text="目前使用最广泛。" />
          </outline>
          <outline text="Android Support v7">
            <outline text="这个包是为了考虑照顾2.1及以上版本而设计的，但不包含更低，故如果不考虑1.6,我们可以采用再加上这个包，" />
            <outline text="另外，v7是要依赖v4这个包的，即两个得同时被包含。" />
          </outline>
          <outline text="Android Support v13">
            <outline text="这个包的设计是为了android 3.2及更高版本的。" />
            <outline text="一般我们都不常用，平板开发中能用到。" />
          </outline>
        </outline>
        <outline text="APP项目文件夹的组成">
          <outline text="src：存放项目的源代码。" />
          <outline text="res：存放项目需要的资源文件，比如字符串，布局，皮肤等，这里面每个资源的索引都保存在R.java类中。">
            <outline text="drawable：存放图片资源，每添加一个图片资源，R.drawble类中对应添加一个图片索引。不同的drawable文件夹存放不同分辨率的图片。" />
            <outline text="layout：存放界面的布局，每一个布局文件对应R.layout里面的布局索引，索引名称与布局文件名称一致。">
              <outline text="布局中文件每个控件的id也会被添加到R.id类中去。其中在为控件指定id时有两种方式，一种是@id/btn ，另外一种是@+id/btn ，前一种是R.id类中已经有了这个id定义，后一种是新增一个btn的id索引。" />
              <outline text="Layout目录一般有多个, 适配不同的分辨率, 比如:">
                <outline text="-mdpi: 中等分辨率. 目前已经很少见了." />
                <outline text="-hdpi: 高分辨率" />
                <outline text="-xhdpi: 超高分辨率" />
                <outline text="-xxhdpi: 超超高分辨率" />
                <outline text="-480x320: 适配480x320的屏幕" />
                <outline text="-w820dp: w代表平板设备，820dp代表屏幕宽度" />
                <outline text="-v11: 11这样代表在API(11)，即android 3.0后才会用到的." />
              </outline>
            </outline>
            <outline text="values：里面存放xml资源文件，有如下数据:">
              <outline text="demens.xml：定义尺寸资源" />
              <outline text="string.xml：定义字符串资源" />
              <outline text="styles.xml：定义样式资源" />
              <outline text="colors.xml：定义颜色资源" />
              <outline text="arrays.xml：定义数组资源" />
              <outline text="attrs.xml：自定义控件时用的较多，自定义控件的属性！" />
              <outline text="theme主题文件，和styles很相似，但是会对整个应用中的Actvitiy或指定Activity起作用，一般是改变窗口外观的！可在Java代码中通过setTheme使用，或者在Androidmanifest.xml中为&amp;lt;application...&amp;gt;添加theme的属性！" />
            </outline>
            <outline text="animator：存放属性动画的XML文件" />
            <outline text="anim：存放补间动画的XML文件" />
            <outline text="raw:  用于存放各种原生资源(音频，视频，一些XML文件等)，我们可以通过openRawResource(int id)来获得资源的二进制流！其实和Assets差不多，不过这里面的资源会在R文件那里生成一个资源id." />
          </outline>
          <outline text="assets：assets文件夹里面都存放原始的文件格式，不会在R.java中生成一个ID. 在代码中通过AssetManager来进行访问。比如需要在代码中访问加载一个html文件，或者一个txt文档，那么就需要把html文件和txt文档保存到assets文件下。" />
          <outline text="gen：编译时自动生成的，其中最关键的是 R.java 的静态类，它里面包括很多静态类（内部类），每个静态类中的静态成员名称都对应res文件夹中的一个资源名称，保存着该资源的索引，方便在代码中进行获取资源。包括如下: ">
            <outline text="id：保存布局文件中控件id，" />
            <outline text="layout：保存布局文件的索引，" />
            <outline text="string：保存字符串资源的索引。" />
            <outline text="array类: 保存数组的资源索引;" />
            <outline text="drawable：保存图片索引，" />
          </outline>
          <outline text="bin：存放编译后的apk和资源文件。" />
          <outline text="R.java文件：由aapt工具根据App中的资源文件自动生成, 可以理解为资源字典。" />
        </outline>
        <outline text="项目文件夹中各种资源的使用">
          <outline text="使用布局文件">
            <outline text="在Activity的onCreate方法中，调用布局文件，渲染界面。">
              <outline text="setContentView(R.layout.activity_main);   // 实现界面的渲染" />
            </outline>
            <outline text="获取布局文件中的控件">
              <outline text="TextView myView=(TextView) this.findViewById(R.id.textView1);" />
            </outline>
          </outline>
          <outline text="获取values文件夹下的各种资源">
            <outline text="访问字符串资源">
              <outline text="String sstr=this.getResources().getString(R.string.app_name);//获取app名称" />
            </outline>
            <outline text="访问数组资源">
              <outline text="int []myarray=this.getResources().getIntArray(R.array.my_array);" />
            </outline>
          </outline>
          <outline text="获取assets文件夹下的资源">
            <outline text="在assets文件中保存一个html页面，我们需要在代码利用WebView控件加载这个html页面.">
              <outline text="myWebView.loadUrl(&quot;file:///android_asset/myblog.html&quot;);  //注意获取文件的路径格式" />
            </outline>
          </outline>
        </outline>
        <outline text="Andorid 开源库列表">
          <outline text="Android（常用）主流UI开源库整理： https://blog.csdn.net/changalbert/article/details/61424193" />
          <outline text="Android 开源项目分类汇总： https://github.com/Trinea/android-open-project" />
          <outline text="图像处理：opencv" />
          <outline text="人脸图像处理：dlib" />
          <outline text="组件间通讯： EventBus" />
          <outline text="菜单：FAB，android-floating-action-button">
            <outline text="https://github.com/futuresimple/android-floating-action-button" />
          </outline>
          <outline text="水平移动导航条：ViewPage" />
          <outline text="图片预览： PhotoView">
            <outline text="https://github.com/chrisbanes/PhotoView" />
          </outline>
          <outline text="图片加载库：Glide">
            <outline text="google推荐。" />
          </outline>
          <outline text="互联网访问套件：okhttp" />
          <outline text="网络框架： Volley">
            <outline text="Get，Post网络请求及网络图像的高效率" />
          </outline>
          <outline text="网络框架：Async">
            <outline text="解析成json" />
            <outline text="持久化cookies存储" />
          </outline>
          <outline text="网络下载框架：ion">
            <outline text="支持异步获取和处理JSON，支持Android文件下载，支持安全链接和代理。" />
          </outline>
          <outline text="抽屉菜单： SlidingMenu" />
          <outline text="视频播放： Vitamio" />
          <outline text="ORM框架：greenDAO" />
          <outline text="ORM框架：OrmLite" />
          <outline text="ORM框架：AndrORM" />
          <outline text="Json数据解析：FastJason" />
          <outline text="统计图表： mpChart" />
          <outline text="音视频解码库: VLC" />
          <outline text="音频处理: Webrtc, Superpowered,  Juce" />
        </outline>
      </outline>
      <outline text="05-工具链 ">
        <outline text="Android代码下载  **">
          <outline text="国内可用的镜像：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" />
          <outline text="下载Repo： 启动Cygwin,然后cd /bin,切到bin目录执行">
            <outline text="curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &amp;gt; ~/bin/repo , 下载repo到bin目录." />
            <outline text="chmod a+x ~/bin/repo , 赋予它可执行的权限." />
            <outline text="修改repo文件:">
              <outline text="REPO_URL = 'https://gerrit.googlesource.com/git-repo'  替换为" />
              <outline text="REPO_URL = 'https://gerrit-google.tuna.tsinghua.edu.cn/git-repo'" />
            </outline>
          </outline>
          <outline text="repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest" />
          <outline text="repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r14 --repo-url=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/" />
          <outline text="repo sync" />
          <outline text="repo 常见异常">
            <outline text="fatal: the remote end hung up unexpectedly" />
            <outline text="fatal: early EOF" />
            <outline text="解决方法: ~/.gitconfig  加入如下语句:">
              <outline text="[http]">
                <outline text="postBuffer = 524288000" />
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="Windows上安装cygwin">
          <outline text="下载 Cygwin ,然后就是一路的下一步。第一次安装, 要选 install from internet。" />
          <outline text="使用镜像：">
            <outline text="http://mirrors.aliyun.com" />
            <outline text="http://www.cygwin.cn" />
          </outline>
          <outline text="安装过程中报错“Unable to get setup from &amp;lt;http://mirrors.aliyun.com/&amp;gt;”">
            <outline text="通过命令行： cygwin-x86_64.exe -X 启动安装" />
          </outline>
          <outline text="选择需要下载安装的组件包。需要选择分类视图。然后选择下面几个库:">
            <outline text="Net -&amp;gt; curl" />
            <outline text="Devel -&amp;gt; git, git-completion, git-gui, gitk" />
            <outline text="Libs -&amp;gt; libreadline7, libiconv2" />
            <outline text="Editors -&amp;gt; vim" />
            <outline text="Python -&amp;gt; python" />
            <outline text="如果要gcc编译，则安装 binutils，gcc，gcc-mingw，gdb" />
          </outline>
        </outline>
        <outline text="Mac上的特殊设置">
          <outline text="https://blog.csdn.net/u012455213/article/details/54647010" />
          <outline text="https://www.zhihu.com/question/19759722  搜 nothing chen" />
          <outline text="分区一定要是大小写敏感的文件系统. 通过磁盘工具检查. 如果不是, 则要创建.">
            <outline text="hdiutil create -type SPARSE -fs 'Case-sensitive Journaled HFS+' -size 60g ~/android.dmg    // android.dmg 为自定义文件名." />
            <outline text="加载分区: hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android" />
            <outline text="调整分区大小: hdiutil resize -size &amp;lt;new-size-you-want&amp;gt;g ~/android.dmg.sparseimage" />
          </outline>
          <outline text="修改文件打开数量上限">
            <outline text="mac默认是1024, Android编译时可能超过. 需要修改:">
              <outline text="~/.bash_profile 中添加内容：" />
              <outline text="ulimit -S -n 1024" />
            </outline>
          </outline>
          <outline text="安装 Gradle">
            <outline text="brew install gradle (前提: 要先安装xCode)" />
            <outline text="安装位置: /usr/local/Cellar/gradle/2.2.1" />
            <outline text="check安装是否成功: gradle -version" />
            <outline text="写入环境变量:">
              <outline text="vim ~/.bash_profile" />
              <outline text="GRADLE_HOME=/usr/local/Cellar/gradle/2.2.1" />
              <outline text="export GRADLE_HOME" />
              <outline text="export PATH=$PATH:$GRADLE_HOME/bin" />
            </outline>
          </outline>
        </outline>
        <outline text="android看代码环境">
          <outline text="IEDA 和 AS 的方法一样." />
          <outline text="1. 修改MacOS sdk 版本">
            <outline text="/build/soong/cc/config/x86_darwin_host.go" />
            <outline text="darwinSupportedSdkVersions 中添加 &quot;10.15&quot;" />
          </outline>
          <outline text="2. 生成idegen.jar">
            <outline text="工程根目录下执行:" />
            <outline text="source build/envsetup.sh">
              <outline text="执行结果: 无任何返回值." />
            </outline>
            <outline text="mmm development/tools/idegen">
              <outline text="执行结果: #### build completed successfully (10:35 (mm:ss)) ####" />
            </outline>
            <outline text="development/tools/idegen/idegen.sh">
              <outline text="执行结果: Traversed tree: 143730ms" />
            </outline>
            <outline text="此时会在根目录生成两个文件：android.ipr 和 android.iml" />
          </outline>
          <outline text="3. IDEA 中打开">
            <outline text="FIle - New - Module from Existing Sourese, 打开刚生成的 android.iml." />
          </outline>
          <outline text="4. 裁剪工程大小" />
          <outline text="5. 更换fwk codepath">
            <outline text="默认情况下, fwk代码会指到jar包中去, 但是既然我们有fwk的源代码, 这显然不是我们想要的." />
            <outline text="" />
          </outline>
          <outline text="问题: Mac默认分区不区分大小">
            <outline text="报错：You are building on a case-insensitive filesystem.">
              <outline text="Please move your source tree to a case-sensitive filesystem." />
            </outline>
            <outline text="解决方法: 创建一个区分大小写的分区">
              <outline text="打开磁盘工具, 文件 - 新建映像 - 空白映像, 弹出如下界面;" />
              <outline text="填写信息，格式选择区分大小写格式，点击存储，" />
              <outline text="然后会在你的位置文件夹内生成一个Android.dmg文件，" />
              <outline text="双击即可安装，然后将Android源码考入即可操作。" />
            </outline>
          </outline>
        </outline>
        <outline text="android编译环境-windows">
          <outline text="Windows下使用Docker编译Android系统源代码: https://blog.csdn.net/loongembedded/article/details/88714960" />
        </outline>
        <outline text="android编译环境-Mac  ***">
          <outline text="更新java sdk到 8u45 或更高版本:">
            <outline text="检查java sdk版本号: /usr/libexec/java_home -V" />
          </outline>
          <outline text="下载对应设备的vendor代码">
            <outline text="官方驱动: &lt;a href=&quot;https://developers.google.com/android/drivers&quot;&gt;https://developers.google.com/android/drivers&lt;/a&gt;" />
            <outline text="要编译 AOSP 的 master 分支，请使用二进制文件预览。" />
            <outline text="Pixel 2 XL: &lt;a href=&quot;https://developers.google.com/android/blobs-preview#taimen6428072&quot;&gt;https://developers.google.com/android/blobs-preview#taimen6428072&lt;/a&gt;" />
            <outline text="解压缩下载的文件, 会得到一个sh文件. 拷贝到aosp的根目录." />
            <outline text="命令行窗口输入  sh &lt;a href=&quot;http://xxx.sh&quot;&gt;xxx.sh&lt;/a&gt; 运行sh文件. " />
            <outline text="需要阅读用户协议. 输入999跳到最后一行, 然后输入 &quot;I ACCEPT&quot; 即可。" />
            <outline text="sh运行完成之后aosp的根目录会生成一个vendor文件夹." />
          </outline>
          <outline text="清理上一次的编译文件: make clobber" />
          <outline text="配置参数: source build/&lt;a href=&quot;http://envsetup.sh&quot;&gt;envsetup.sh&lt;/a&gt;" />
          <outline text="选择目标设备: lunch">
            <outline text="我选择: aosp_taimen-userdebug" />
            <outline text="也可以: aosp_blueline-userdebug" />
            <outline text="版本类型有:">
              <outline text="user: 权限受限；适用于生产环境" />
              <outline text="userdebug: 与“user”类似，但具有 root 权限和可调试性；是进行调试时的首选编译类型" />
              <outline text="eng: 具有额外调试工具的开发配置" />
            </outline>
          </outline>
          <outline text="全编译: make -j7" />
          <outline text="编译指定模块: mmm packages/apps/Settings" />
          <outline text="编译log: ./out/error.log" />
          <outline text="编译问题:">
            <outline text="module &quot;libscudo&quot; variant &quot;darwin_x86_64_static&quot;: depends on disabled module &quot;bionic_libc_platform_headers&quot;">
              <outline text="external/scudo/Android.bp" />
              <outline text="bionic/libc/Android.bp" />
            </outline>
            <outline text="too many open files">
              <outline text="launchctl limit: 查看文件打开数量限制 (默认值为256)" />
              <outline text="sudo launchctl limit maxfiles 2048 unlimited:  修改数量限制" />
            </outline>
          </outline>
        </outline>
        <outline text="关键仓的基本信息">
          <outline text="模块名，仓名，目录，二进制包名" />
          <outline text="framework, frameworks/base , frameworks/base, /system/framework/framework.jar" />
          <outline text="framework-res, frameworks/base , frameworks/base/core/res, /system/framework/framework-res.jar" />
          <outline text="services, frameworks/base , frameworks/base/service, /system/framework/services.jar" />
          <outline text="libinputflinger, frameworks/native, frameworks/native/services/inputflinger, /system/lib64/libinputflinger.so" />
        </outline>
        <outline text="编译命令">
          <outline text="新增jar包时android.mk文件中的修改">
            <outline text="Local_static_java_libraries:=">
              <outline text="android_support_v4\" />
              <outline text="Netpad_system" />
            </outline>
            <outline text="Local_prebuilt_static_java_libraries:=">
              <outline text="libs/function_SDK.jar" />
            </outline>
          </outline>
          <outline text="kernel 中加特性宏">
            <outline text="android\kernel\arch\arm\configs\defconfig ， CONFIG_HUAWEI_FEATURE_OEMINFO=y" />
            <outline text="android\kernel\arch\arm\mach-msm\Kconfig" />
          </outline>
          <outline text="只编译 kernel的命令: make bootimage" />
          <outline text="编译带root权限的kernel: make bootimage -eng" />
          <outline text="内核模块添加类">
            <outline text="在该模块的Makefile中，在末尾添加一行：obj-y += rmt_server.o" />
          </outline>
          <outline text="新增一个自启动的内核进程">
            <outline text="修改 system\core\rootdir\init.rc，在最后面加一行，即：service rmt_server /system/bin/rmt_server" />
            <outline text="init.rc 会编译到boot.img中。" />
          </outline>
          <outline text="更新frameworks api后, 需调用 updata-api 命令刷新api。" />
        </outline>
        <outline text="编译系统: bp文件的语法">
          <outline text="Android 7用ninja系统替代make来管理编译。 其配置文件叫 Android.bp。" />
          <outline text="Android的编译处理流程是: 用blueprint和soong来解析bp文件，将其转换为ninja文件。">
            <outline text="Android还支持 mk文件, 使用 kati 将mk文件转化为 ninja文件." />
            <outline text="最终用 ninja文件来管理编译过程." />
          </outline>
          <outline text="blueprint和soong是go语言写的. 代码在 build 目录下。" />
          <outline text="Android.bp 格式如下:">
            <outline text="java_library {">
              <outline text="name: &quot;services&quot;,    // 模块名" />
              <outline text="dex_preopt: {">
                <outline text="app_image: true," />
                <outline text="profile: &quot;art-profile&quot;," />
              </outline>
              <outline text="}," />
              <outline text="srcs: [    // 指定源代码文件">
                <outline text="&quot;java/**/*.java&quot;," />
              </outline>
              <outline text="]," />
              <outline text="static_libs: [   // 依赖的静态库">
                <outline text="&quot;services.core&quot;," />
                <outline text="&quot;services.accessibility&quot;," />
              </outline>
              <outline text="]," />
              <outline text="libs: [    // 依赖的动态库">
                <outline text="&quot;android.hidl.manager-V1.0-java&quot;," />
                <outline text="&quot;miuisdk&quot;," />
                <outline text="&quot;miuisystemsdk&quot;" />
              </outline>
              <outline text="]," />
            </outline>
            <outline text="}" />
            <outline text="cc_library_shared {   // 输出文件">
              <outline text="name: &quot;libandroid_servers&quot;," />
              <outline text="defaults: [&quot;libservices.core-libs&quot;]," />
              <outline text="whole_static_libs: [&quot;libservices.core&quot;]," />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="处理编译错误">
          <outline text="go到 编译error.log 的末尾，搜 error:  " />
        </outline>
        <outline text="第三方刷机包">
          <outline text="设备型号: Pixel2 xl 的手机" />
          <outline text="官方刷机工具包: &lt;a href=&quot;https://dl.google.com/android/repository/platform-tools-latest-darwin.zip&quot;&gt;https://dl.google.com/android/repository/platform-tools-latest-darwin.zip&lt;/a&gt;" />
          <outline text="官方刷机包下载: &lt;a href=&quot;https://developers.google.com/android/images#taimen&quot;&gt;https://developers.google.com/android/images#taimen&lt;/a&gt;" />
          <outline text="打开adb: 在“设置”中，点按关于手机，然后点按版本号七 (7) 次, 进入开发人员选项.">
            <outline text="打开 USB 调试." />
          </outline>
          <outline text="进入fastboot模式: adb reboot bootloader" />
          <outline text="强制进fastboot模式: Pixel XL:按住音量调低键，然后按住电源键。" />
          <outline text="引导加载程序解锁: fastboot flashing lock">
            <outline text="然后, fastboot flashing unlock_critical" />
            <outline text="注意: 在 Motorola Xoom 上重新锁定引导加载程序会清空用户数据" />
          </outline>
          <outline text="刷机: fastboot flashall -w">
            <outline text="-w 选项会清除设备上的 /data 分区；该选项在您第一次刷写特定设备时非常有用." />
          </outline>
        </outline>
        <outline text="AVD： (android virtual machine):安卓虚拟设备,就是安卓的模拟器 --性能差，基本不可用" />
        <outline text="ADT： (android development tools)安卓开发工具" />
        <outline text="DDMS：(dalvik debug monitor service)安卓调试工具" />
        <outline text="adb：安卓调试桥, 在sdk的platform-tools目录下." />
      </outline>
      <outline text="&lt;b&gt;06-ADB&lt;/b&gt;">
        <outline text="刷机: fastboot">
          <outline text="重启到bootloader，即刷机模式：adb reboot bootloader" />
          <outline text="重启到EDL模式(快速刷机): adb reboot edl" />
          <outline text="在fastboot 中也可以进 EDL: fastboot oem edl" />
          <outline text="下载一个分区： fastboot flash boot boot.img" />
          <outline text="重启到recovery，即恢复模式：adb reboot recovery" />
        </outline>
        <outline text="导出已安装应用的apk文件">
          <outline text="找包名： adb shell pm list package" />
          <outline text="找apk安装路径： adb shell pm path + 包名" />
          <outline text="adb pull 即可。" />
          <outline text="Google play商店的包名是： com.android.vending " />
        </outline>
        <outline text="ADB连接管理">
          <outline text="等待设备连接上: adb wait-for-device  --用于脚本，***" />
          <outline text="查看连接中的设备：adb devices.  返回设备ID可用于其它命令." />
          <outline text="指定设备安装: adb  -s [设备ID] install ..." />
          <outline text="获取设备序列号：adb get-serialno" />
          <outline text="获取设备状态: adb get-state ">
            <outline text="设备的状态有 3 钟，device , offline , unknown" />
            <outline text="device：设备正常连接" />
            <outline text="offline：连接出现异常，设备无响应" />
            <outline text="unknown：没有连接设备" />
          </outline>
          <outline text="终止adb服务进程：adb kill-server" />
          <outline text="重启adb服务进程：adb start-server" />
          <outline text="查看ADB帮助：adb help" />
          <outline text="重启机器：adb reboot" />
          <outline text="将宿主机上的某个端口重定向到设备的某个端口:  db forward tcp:1314 tcp:8888" />
          <outline text="WiFi连接 ADB(方法1)">
            <outline text="手机、PC处于相同的网络下，手机 root ，安装应用 adbWireless ，启动应用后点击界面中间的按钮" />
            <outline text="运行 adb connect 192.168.1.102 , 即可通过无线的方式连接手机，缺点是速度比较慢" />
          </outline>
          <outline text="WiFi链接 ADB(方法2)">
            <outline text="usb连接接手机, 输入命令: adb tcpip 5555">
              <outline text="restarting in TCP mode port: 5555" />
            </outline>
            <outline text="拔掉手机, 输入命令: adb connect 192.168.0.44:5555  (手机IP地址)">
              <outline text="connected to 192.168.11.117:5555" />
            </outline>
          </outline>
        </outline>
        <outline text="常见ADB命令">
          <outline text="加view边框： adb shell setprop debug.layout true    ****" />
          <outline text="Monkey：adb shell monkey -v -p &amp;lt;apk&amp;gt; 50000   ***" />
          <outline text="截图：  adb shell screencap -p /sdcard/DCIM/1.JPG     ***" />
          <outline text="屏幕录制:  adb shell screenrecord sdcard/record.mp4" />
          <outline text="发送文本内容(不能发中文):  adb shell input text test123456" />
        </outline>
        <outline text="&lt;b&gt;模拟按键&lt;/b&gt;">
          <outline text="&lt;b&gt;模拟按键事件&lt;/b&gt;:  adb shell input keyevent KEYCODE_HOME">
            <outline text="事件在 KeyEvent.java 中定义." />
            <outline text="比如： public static final int KEYCODE_HOME = 3;" />
          </outline>
          <outline text="模拟触摸事件:  adb shell input tap 500 500" />
          <outline text="模拟滑动事件:  adb shell input swipe 900 500 100 500" />
          <outline text="模拟长按事件: adb shell input swipe 500 500 501 501 2000" />
        </outline>
        <outline text="prop项">
          <outline text="修改prop项（重启不失效）： pull 到本地，用写字板修改，然后再push回去，改权限644，最后重启。" />
          <outline text="获取prop值:  adb shell getprop ro.build.version.sdk" />
          <outline text="设置prop项： adb shell setprop ***=0/1/true/false">
            <outline text="重启后失效" />
          </outline>
        </outline>
        <outline text="屏幕管理">
          <outline text="关闭屏幕（模拟power）： adb shell input keyevent 26" />
          <outline text="获取屏幕状态:  adb shell dumpsys display | findstr DisplayDeviceInfo.  返回:">
            <outline text="DisplayDeviceInfo{&quot;内置屏幕&quot;: 1080 x 1920, 55.0 fps, density 480, 464.949 x 468.923 dpi..." />
          </outline>
          <outline text="获取屏幕分辨率:  adb shell wm size">
            <outline text="Physical size: 1080x1920" />
          </outline>
          <outline text="获取屏幕像素密度: adb shell wm density" />
          <outline text="获取亮度是否为自动获取: adb shell settings get system screen_brightness_mode" />
          <outline text="获取当前亮度值: adb shell settings get system screen_brightness" />
          <outline text="更改亮度值（亮度值在0—255之间）: adb shell settings put system screen_brightness 150" />
          <outline text="获取屏幕休眠时间: adb shell settings get system screen_off_timeout" />
          <outline text="更改休眠时间，10分钟: adb shell settings put system screen_off_timeout 600000" />
        </outline>
        <outline text="网络管理">
          <outline text="获取wifi状态: adb shell dumpsys wifi. 可以获取到当前连接的wifi名、搜索到的wifi列表、wifi强度等" />
          <outline text="获取MAC地址：adb shell cat /sys/class/net/wlan0/address" />
          <outline text="查看wifi密码：adb shell cat /data/misc/wifi/*.conf" />
          <outline text="获取设备名称：adb shell cat /system/build.prop" />
        </outline>
        <outline text="充电管理">
          <outline text="获取设备电池状态: adb shell dumpsys battery / batterystats. 返回:">
            <outline text="Current Battery Service state:" />
            <outline text="AC powered: false" />
            <outline text="USB powered: true" />
            <outline text="Wireless powered: false" />
            <outline text="status: 2   # 电池状态" />
            <outline text="health: 2" />
            <outline text="present: true" />
            <outline text="level: 34  # 电量" />
            <outline text="scale: 100" />
            <outline text="voltage: 3848" />
            <outline text="current now: -427943" />
            <outline text="temperature: 280   # 电池温度" />
            <outline text="technology: Li-ion" />
          </outline>
          <outline text="获取电源管理状态: adb shell dumpsys power. 返回:">
            <outline text="可以获取到是否处于锁屏状态：mWakefulness=Asleep或者mScreenOn=false" />
            <outline text="亮度值：mScreenBrightness=255" />
            <outline text="屏幕休眠时间：Screen off timeout: 60000 ms" />
            <outline text="屏幕分辨率：mDisplayWidth=1440，mDisplayHeight=2560" />
          </outline>
          <outline text="关闭充电功能： adb shell dumpsys battery unplug" />
          <outline text="设置电量： adb shell dumpsys battery set level 19" />
          <outline text="恢复充电功能： adb shell dumpsys battery reset" />
        </outline>
        <outline text="安全管理">
          <outline text="获取账号状态: adb shell dumpsys account" />
          <outline text="查看SELinux状态： adb shell getenforce" />
          <outline text="设置SELinux状态： adb shell setenforce 0/1">
            <outline text="0 表示关闭" />
            <outline text="1 表示打开" />
          </outline>
        </outline>
        <outline text="内存管理">
          <outline text="查看设备cpu和内存占用情况：adb shell top" />
          <outline text="查看占用内存前6的app：adb shell top -m 6" />
          <outline text="刷新一次内存信息，然后返回：adb shell top -n 1" />
          <outline text="查询各进程内存使用情况：adb shell procrank" />
          <outline text="查看当前内存占用：adb shell cat /proc/meminfo" />
          <outline text="查看IO内存分区：adb shell cat /proc/iomem" />
        </outline>
        <outline text="分区和文件管理">
          <outline text="将system分区重新挂载为可读写分区：adb remount" />
          <outline text="从本地复制文件到设备：adb push &amp;lt;local&amp;gt; &amp;lt;remote&amp;gt;" />
          <outline text="从设备复制文件到本地：adb pull &amp;lt;remote&amp;gt;  &amp;lt;local&amp;gt;" />
          <outline text="查看文件内容：adb shell cat &amp;lt;file&amp;gt;" />
        </outline>
        <outline text="进程管理">
          <outline text="查看进程列表：adb shell ps" />
          <outline text="获取指定进程号： adb shell &quot;ps | grep camera&quot;" />
          <outline text="查看指定进程状态：adb shell ps -x [PID]" />
          <outline text="杀死一个进程：adb shell kill [pid]" />
          <outline text="获取线程数的上限: adb shell cat /proc/sys/kernel/threads_max">
            <outline text="FindX 是 57798" />
          </outline>
          <outline text="获取同时打开文件数上限: adb shell cat /proc/sys/fs/file_max">
            <outline text="FindX 是732094" />
          </outline>
          <outline text="关闭 java 虚拟机: adb shell stop" />
          <outline text="打开 java 虚拟机: adb shell start" />
        </outline>
        <outline text="APK管理">
          <outline text="安装APK：adb install &amp;lt;apkfile&amp;gt;" />
          <outline text="Q版本上安装APK：adb install -t &amp;lt;apkfile&amp;gt;" />
          <outline text="重新安装apk(保留数据和缓存)：adb install -r &amp;lt;apkfile&amp;gt;" />
          <outline text="安装apk到sd卡：adb install -s &amp;lt;apkfile&amp;gt;" />
          <outline text="卸载APK：adb uninstall &amp;lt;package&amp;gt;" />
          <outline text="卸载app但保留数据和缓存文件：adb uninstall -k &amp;lt;package&amp;gt;" />
          <outline text="获取apk的packagename 和 classname:  aapt d badging &amp;lt;apkfile&amp;gt;" />
          <outline text="列出安装在设备上的应用:  adb shell pm list package" />
          <outline text="列出系统应用: adb shell pm list package -s" />
          <outline text="列出第三方应用:  adb shell pm list package -3" />
          <outline text="列出应用包名及对应的apk名及存放位置: adb shell pm list package -f" />
          <outline text="列出应用包名及其安装来源:   adb shell pm list package -f -3 -i zhihu">
            <outline text="返回: package:/data/app/com.zhihu.android-1.apk=com.zhihu.android  installer=com.xiaomi.market" />
          </outline>
          <outline text="列出对应包名的 .apk 位置: adb shell pm path com.tencent.mobileqq" />
          <outline text="列出指定应用的 dump 信息: adb shell pm dump com.tencent.mobileqq" />
          <outline text="安装应用(apk 文件在Android 设备中): pm install" />
          <outline text="清除应用数据:  pm clear" />
          <outline text="设置和获取应用安装位置: pm get-install-location">
            <outline text="[0/auto]：默认为自动" />
            <outline text="[1/internal]：默认为安装在手机内部" />
            <outline text="[2/external]：默认安装在外部存储" />
          </outline>
        </outline>
        <outline text="Activity和service管理">
          <outline text="启动应用：adb shell am start -n &amp;lt;package_name&amp;gt;/.&amp;lt;activity_class_name&amp;gt;" />
          <outline text="启动一个 Activity: adb shell am start -n com.android.camera/.Camera" />
          <outline text="先停止再启动:  adb shell am start -S com.android.camera/.Camera" />
          <outline text="等待应用完成启动: adb shell am start -W com.android.camera/.Camera" />
          <outline text="结束应用: am force-stop com.android.camera/.Camera" />
          <outline text="获取当前界面的控件信息: adb shell uiautomator dump. 返回: ">
            <outline text="UI hierchary dumped to: /storage/emulated/legacy/window_dump.xml" />
          </outline>
          <outline text="列举所有services：adb shell service list" />
          <outline text="启动一个服务: am startservice" />
          <outline text="发送一个广播: am broadcast" />
          <outline text="监控 crash 与 ANR:  am monitor " />
        </outline>
        <outline text="settings 命令">
          <outline text="setings 命令的key值在 android.provider.Settings 中定义。" />
          <outline text="获取、修改wifi状态（wifi_on）、飞行模式（airlpane_mode_on）等，这里也是appium中 getNetworkConnection获得设备网络状态的方法。" />
          <outline text="获取通过网络获取时间的状态: adb shell settings get global auto_time. 返回:">
            <outline text="1为允许、0为不允许" />
          </outline>
          <outline text="更改通过网络获取时间的状态，从1改为0: adb shell settings put global auto_time 0" />
        </outline>
        <outline text="输入法和本地化">
          <outline text="列出输入法: adb shell ime list -s, 返回:">
            <outline text="com.google.android.inputmethod.pinyin/.PinyinIME" />
            <outline text="com.baidu.input_mi/.ImeService" />
          </outline>
          <outline text="获取系统默认输入法: adb shell settings get secure default_input_method, 返回:">
            <outline text="com.sohu.inputmethod.sogouoem/.SogouIME  默认搜狗输入法" />
          </outline>
          <outline text="选择输入法:  adb shell ime set com.baidu.input_mi/.ImeService" />
          <outline text="默认为Appium使用中文输入时安装的输入法">
            <outline text="adb shell settings get secure default_input_method io.appium.android.ime/.UnicodeIME" />
          </outline>
          <outline text="put命令更改默认输入法（将io.appium.android.ime/.UnicodeIME改为com.sohu.inputmethod.sogouoem/.SogouIME）">
            <outline text="adb shell settings put secure default_input_method com.sohu.inputmethod.sogouoem/.SogouIME" />
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;07-Debug&lt;/b&gt;">
        <outline text="&lt;b&gt;dumpsys&lt;/b&gt;">
          <outline text="&lt;b&gt;窗口列表: adb shell dumpsys window. Log内容说明: &lt;/b&gt;">
            <outline text="lastanr: 最后一次anr。如果有。" />
            <outline text="policy： 系统Window策略。很多。">
              <outline text="LockScreen: 锁屏相关" />
            </outline>
            <outline text="animator: 动画栈">
              <outline text="所有动画是单独于window管理的。" />
            </outline>
            <outline text="sessions： 刷新任务列表" />
            <outline text="displays: 内容很多">
              <outline text="屏幕分辨率" />
              <outline text="task及其包含的activityRecord 列表" />
              <outline text="display属性" />
              <outline text="横竖屏属性" />
            </outline>
            <outline text="windows: window 栈">
              <outline text="dumpsys window windows | grep windows: 返回当前window栈。" />
            </outline>
          </outline>
          <outline text="Input 设备信息: adb shell dumpsys input" />
          <outline text="进程列表: adb shell dumpsys activity processes" />
          <outline text="获取Activity信息: adb shell dumpsys activity activities">
            <outline text="获取当前界面的Activity信息：adb shell dumpsys activity top" />
            <outline text="要获取当前界面的Activity：adb shell dumpsys activity top | findstr ACTIVITY" />
          </outline>
          <outline text="打印当前系统所有service信息: adb shell dumpsys activity services">
            <outline text="打印指定服务的信息: adb shell dumpsys service ***(指定服务名)" />
            <outline text="列出当前运行的服务： adb shell dumpsys | findstr DUMP" />
          </outline>
          <outline text="Provider列表: adb shell dumpsys activity providers" />
          <outline text="获取package状态: adb shell dumpsys package, 可指定包名" />
          <outline text="获取通知列表: adb shell dumpsys notification. 返回值是:">
            <outline text="NotificationRecord(0x44217920: pkg=com.sohu.newsclient useron=0x7f0201b5 / com.tencent.news:drawable/icon" />
            <outline text="pri=0 score=0" />
            <outline text="contentIntent=PendingIntent{4294d748: PendingIntentRecord{44088e90 com.tencent.news startActivity}}" />
            <outline text="deleteIntent=null" />
            <outline text="tickerText=null" />
            <outline text="contentView=android.widget.RemoteViews@441fc810" />
            <outline text="defaults=0x00000001 flags=0x00000010" />
            <outline text="sound=null" />
            <outline text="vibrate=null" />
            <outline text="led=0x00000000 onMs=0 offMs=0" />
            <outline text="extras={">
              <outline text="android.title=农业部:中国超级稻亩产超1吨" />
              <outline text="android.subText=null" />
              <outline text="android.showChronometer=false" />
              <outline text="android.icon=2130837941" />
              <outline text="android.text=农业部今日通报称,经专家测产,袁隆平领衔培育的中国“超级稻”亩产过千公斤,创造1026.7公斤新纪录。详情&amp;gt;&amp;gt;" />
              <outline text="android.progress=0" />
              <outline text="android.progressMax=0" />
              <outline text="android.showWhen=true" />
              <outline text="android.infoText=null" />
              <outline text="android.progressIndeterminate=false" />
              <outline text="android.scoreModified=false" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="获取广播: adb shell dumpsys activity broadcasts" />
          <outline text="获取intents消息: adb shell dumpsys activity intents" />
          <outline text="提醒列表: adb shell dumpsys alarm" />
          <outline text="获取内存状态:  adb shell dumpsys meminfo">
            <outline text="要获取具体应用的内存信息，可加上包名:  adb shell dumpsys meminfo PACKAGE_NAME" />
          </outline>
          <outline text="查看camera属性和状态: adb shell dumpsys media.camera">
            <outline text="注意 stream[0], [1]" />
          </outline>
          <outline text="获取位置状态: adb shell dumpsys location" />
          <outline text="获取电话状态: adb shell dumpsys telephony.registry. 返回:">
            <outline text="mCallState值为0，表示待机状态、1表示来电未接听状态、2表示电话占线状态" />
            <outline text="mCallForwarding=false   # 是否启用呼叫转移" />
            <outline text="mDataConnectionState=2 #0：无数据连接 1：正在创建数据连接 2：已连接" />
            <outline text="mDataConnectionPossible=true   # 是否有数据连接" />
            <outline text="mDataConnectionApn=   # APN名称" />
          </outline>
          <outline text="获取CPU信息:  adb shell dumpsys cpuinfo" />
        </outline>
        <outline text="&lt;b&gt;Android有几种Log?  @iPanorama &lt;/b&gt;">
          <outline text="Android log系统框图  @iChart " />
          <outline text="模板">
            <outline text="1. log名称:" />
            <outline text="2. log层次:" />
            <outline text="3. 常用于解决哪类问题:" />
            <outline text="4. 是否依赖特定平台:" />
            <outline text="5. 抓取方法:" />
            <outline text="6. log文件名:" />
            <outline text="7. 查看工具:" />
            <outline text="8. log内容:" />
            <outline text="9. 核心log是什么，一般的分析方法是什么:" />
            <outline text="10. log打印的原理:" />
          </outline>
          <outline text="&lt;b&gt;logcat&lt;/b&gt;">
            <outline text="1. log名称: logcat" />
            <outline text="2. log层次: 包括4种log, 应用log, fwk log, 射频通话log (暂不关注)" />
            <outline text="3. 常用于解决哪类问题: 分析应用和fwk层的所有问题." />
            <outline text="4. 是否依赖特定平台: 原生, 不依赖." />
            <outline text="5. 抓取方法">
              <outline text="抓app+fwk log: adb logcat *** .  参数如下:" />
              <outline text="&lt;b&gt;-b main&lt;/b&gt;">
                <outline text="默认, 主程序log. " />
                <outline text="一般用户空间log将写入设备节点 /dev/log/main，包括 System.out.print 及 System.erro.print 等." />
              </outline>
              <outline text="-b system">
                <outline text="fwk层log信息和debugging." />
                <outline text="为了防止mian缓存区溢出, 而从其中分离出来." />
              </outline>
              <outline text="-b radio">
                <outline text="射频通话相关信息." />
                <outline text="tag 为&quot;HTC_RIL&quot; &quot;RILJ&quot; &quot;RILC&quot; &quot;RILD&quot; &quot;RIL&quot; &quot;AT&quot; &quot;GSM&quot; &quot;STK&quot;的log信息将写入此节点." />
              </outline>
              <outline text="&lt;b&gt;-c: 清除log缓存&lt;/b&gt;" />
              <outline text="-v: 指定Log前缀格式, 包括:">
                <outline text="brief: 默认" />
                <outline text="process: 只有PID." />
                <outline text="tag: 只有优先级和PID" />
                <outline text="time: 有日期时间, 优先级, 标签和PID" />
                <outline text="threadtime: 仅time + thread id" />
                <outline text="raw: 不显示前缀" />
              </outline>
              <outline text="-d: 打印当前log后退出." />
              <outline text="-g: 打印缓冲区大小" />
              <outline text="&lt;b&gt;过滤关键字&lt;/b&gt;: adb logcat | find &quot;***&quot;">
                <outline text="过滤多个关键字: findstr 后用空格分开." />
              </outline>
              <outline text="logcat 遇到 read: unexpected EOF!. 解决办法是:">
                <outline text="adb logcat -G 2m" />
              </outline>
            </outline>
            <outline text="6. log文件名:  自定义" />
            <outline text="7. 查看工具: 普通文本编辑器即可. 比如 Sublime, notepad++" />
            <outline text="8. log内容: ">
              <outline text="•Logcat是一行一行的, 单条log不能跨行(其实也可以, 但是一般不建议这么做). " />
              <outline text="每行log包括如下6个部分:">
                <outline text="Tag" />
                <outline text="时间戳" />
                <outline text="PID, 进程ID" />
                <outline text="TID, 线程ID" />
                <outline text="log level" />
                <outline text="log信息(代码中写入)" />
              </outline>
            </outline>
            <outline text="9. 核心log是什么，一般的分析方法是什么: 无特定方法, 一行行的看就完了." />
            <outline text="10. log打印的原理:">
              <outline text="App通过导入android.util.Log包来引入Log类，然后通过log方法写不同优先级的相关信息到log。" />
              <outline text="代码在: frameworks/base/core/java/android/util/Log.java" />
              <outline text="主要方法有：">
                <outline text="Log.v();" />
                <outline text="Log.d();" />
                <outline text="Log.i();" />
                <outline text="Log.w();" />
                <outline text="Log.e();" />
                <outline text="Log.a();" />
                <outline text="分别对应log级别：Assert，ERROR，WARN，INFO，DEBUG，VERBOSE。" />
                <outline text="VERBOSE除了开发期间，是不应该被编译进APP的，DEBUG应该编译但在runtime被忽略，ERROR，WARN和INFO logs则一直被保留。" />
              </outline>
              <outline text="jni层: frameworks/base/core/jni/android_util_Log.cpp, 关键函数是 android_util_Log_println_native()" />
              <outline text="Native层: system/core/logcat/logcat.cpp. " />
              <outline text="Native层打印log的方法:">
                <outline text="包含system/core/include/cutils/log.h" />
                <outline text="在模块Android.mk中添加：LOCAL_SHARED_LIBRARIES := liblog libcutils" />
                <outline text="打印接口是: " />
                <outline text="ALOGV" />
                <outline text="ALOGD" />
                <outline text="ALOGI" />
                <outline text="ALOGW" />
                <outline text="ALOGE" />
              </outline>
              <outline text="logd 服务: 在开机过程中被init进程启动. ">
                <outline text="代码在 system/core/logd" />
                <outline text="system\core\logd\CommandListener.cpp" />
                <outline text="system\core\logd\LogBuffer.cpp" />
              </outline>
              <outline text="底层: logging的kernel driver部分被称作”logger”">
                <outline text="代码在 kernel/drivers/staging/android/logger.c" />
                <outline text="生成4个设备节点:">
                  <outline text="/dev/log/main" />
                  <outline text="/dev/log/events" />
                  <outline text="/dev/log/radio" />
                  <outline text="/dev/log/system" />
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="&lt;b&gt;logcat -b &lt;/b&gt;events">
            <outline text="系统事件log." />
            <outline text="Event logs是在 android.util.EventLog.class 中创建二进制log信息。Log条目由二进制tag代码和二进制参数构成。" />
            <outline text="Event logs 文件存储在system/etc/event-log-tags中，通过cat system/etc/event-log-tags能查看其信息。" />
          </outline>
          <outline text="kernel log">
            <outline text="1. log名称: kernel log" />
            <outline text="2. log层次: kernel" />
            <outline text="3. 常用于解决哪类问题: 底层所有问题." />
            <outline text="4. 是否依赖特定平台: 不依赖" />
            <outline text="5. 抓取方法">
              <outline text="adb shell cat /proc/kmsg；kernel日志,每cat一次会清零" />
              <outline text="adb dmesg -n 8，配置打印级别, 8是所有都打。" />
              <outline text="adb shell dmesg: ernel日志,开机信息.(通过var/log/demsg)" />
            </outline>
            <outline text="6. log文件名: 自定义" />
            <outline text="7. 查看工具: 普通文本编辑器即可. 比如 Sublime, notepad++" />
            <outline text="8. log内容: ">
              <outline text="较简单: 2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5]" />
              <outline text="分别是 进程ID, 线程ID, 级别, Log内容" />
            </outline>
            <outline text="9. 核心log是什么，一般的分析方法是什么: 无" />
            <outline text="10. log打印的原理:">
              <outline text="使用 printk()函数 进行Log输出。" />
              <outline text="日志级别">
                <outline text="kernel log日志级别在 include/linux/kern_levels.h 定义. 字符串表示为一个尖括号中的整数，0-7，值越小优先级越高。" />
                <outline text="优先级小于 console_loglevel 这个整数变量的消息才会打印。" />
                <outline text="获取当前日志级别: cat /system/sys/kernel/printk, 有4个数字，第一个表示当前日志级别。" />
                <outline text="刷新系统日志级别: echo 8 &amp;gt; /system/sys/kernel/printk" />
              </outline>
              <outline text="换行符，log行尾一定要加换行符。否则不会输出到控制台。" />
              <outline text="如果系统运行了 klogd 和 syslogd，则所有内核消息都会被追加到 /var/log/messages 中。" />
              <outline text="Log buffer 大小是写在代码中的，这个宏:LOG_BUF_SHIFT，所在文件为 /kernel/init/Kconfig。" />
              <outline text="打印速度: printk_ratelimit()." />
              <outline text="打印主次设备号: print_dev_t(), format_dev_t()." />
              <outline text="例子:">
                <outline text="printk(KERN_ALERT &quot;This is the log printed by printk in linux kernel space.&quot;);" />
                <outline text="printk(KERN_ERR &quot;%s: Invalid parameter\n&quot;, __func__);" />
              </outline>
              <outline text="" />
            </outline>
          </outline>
          <outline text="binder log">
            <outline text="和应用层相关的binder问题主要有两类:">
              <outline text="主线程被Binder 对端block导致anr;" />
              <outline text="Binder被占满, 导致主线程无法启动binder引起异常." />
            </outline>
            <outline text="&lt;b&gt;binder_sample&lt;/b&gt;: binder通讯过程超过门限(默认500毫秒)时打印:">
              <outline text="binder_sample: [android.app.IActivityManager,13,940,com.starbucks.cn,100]" />
              <outline text="其中:">
                <outline text="android.app.IActivityManager: 被调用方" />
                <outline text="13: 方法的序号" />
                <outline text="940: delay的时长(单位: 毫秒)" />
                <outline text="com.starbucks.cn: 调用方" />
                <outline text="100: 被卡住的百分比." />
              </outline>
              <outline text="相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()" />
            </outline>
            <outline text="binder thread: binder线程池耗尽, 且持续时间超过门限时打印">
              <outline text="binder thread pool (16 threads) starved for 100 ms" />
              <outline text="含义是: 线程池已满的持续长达100ms" />
              <outline text="还有一个binder资源耗尽的log , binder_alloc_buf, no vma" />
            </outline>
            <outline text="BINDER FAILED TRANSACTION LOG">
              <outline text="获取该log:读取文件/proc/binder/failed_transaction_log" />
            </outline>
            <outline text="BINDER TRANSACTION LOG">
              <outline text="获取该log:读取文件/proc/binder/transaction_log" />
            </outline>
            <outline text="BINDER TRANSACTIONS">
              <outline text="获取该log:读取文件/proc/binder/transactions" />
            </outline>
            <outline text="BINDER STATS">
              <outline text="获取该log:读取文件/proc/binder/stats" />
            </outline>
            <outline text="BINDER PROCESS STATE">
              <outline text="获取该log:读取文件/proc/binder/proc/*" />
              <outline text="bind相关的一些状态" />
            </outline>
          </outline>
          <outline text="bugreport">
            <outline text="抓取 bugreport: adb bugreport &amp;gt; bugreport.log" />
            <outline text="log中包含有dmesg，dumpstate和dumpsys: ">
              <outline text="dmesg: kernel log" />
              <outline text="dumpstate: 系统状态信息，里面比较全" />
              <outline text="dumpsys: 系统所有进程Process的基本属性." />
            </outline>
          </outline>
          <outline text="systrace" />
          <outline text="hprof" />
          <outline text="anr" />
          <outline text="traces" />
          <outline text="tombstones" />
          <outline text="traceView" />
          <outline text="过度绘制" />
          <outline text="tcpdump">
            <outline text="TCP/IP协议相关的log" />
            <outline text="adb shell tcpdump -s 10000 -w /sdcard/capture.pcap" />
          </outline>
        </outline>
        <outline text="显示相关知识参见 &lt;a href=&quot;https://workflowy.com/#/56a8ba6ce429&quot;&gt;https://workflowy.com/#/56a8ba6ce429&lt;/a&gt;" />
        <outline text="&lt;b&gt;硬件基本速度指标 @iP&lt;/b&gt;anorama #经验总结 ">
          <outline text="执行一条指令：1 指令周期" />
          <outline text="从L1 cache中获取一个字：2 指令周期" />
          <outline text="从内存中读一个字：10 指令周期" />
          <outline text="从磁盘连续位置取一个字：200 指令周期" />
          <outline text="从磁盘任意位置取一个字：8000,000 指令周期" />
          <outline text="双通道DDR4内存: 30GB/s" />
          <outline text="PCIe SSD：3600MB/s" />
          <outline text="SATA SSD：600MB/s" />
          <outline text="机械硬盘：200MB/s" />
          <outline text="SD卡：读写速度差异大，主流大约是读100MB/s, 写30MB/s." />
          <outline text="Nor FLASH 和 Nand FLASH 的速度对比">
            <outline text="以美光（Micron）的NAND和NOR对比, 速度数据如下:" />
            <outline text="读: Nor: 41MB/s;   Nand: 37MB/s (基本差不多)" />
            <outline text="写: Nor: 0.178MB/s;   Nand: 5MB/s (&lt;b&gt;Nand 快了28倍&lt;/b&gt;)" />
            <outline text="擦一个块的时间: Nor: 750ms;   Nand: 2ms (&lt;b&gt;Nand 快了375倍&lt;/b&gt;)" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;性能问题优化经验  #经验总结 #面试题&lt;/b&gt;">
          <outline text="性能问题, 首先要找到参照物. 和谁对比慢? 参照物的合理性在哪里?" />
          <outline text="其次, 要找对目标. 性能问题没有尽头, 不可能无限优化下去. 比如: 华为应用启动速度目标：500ms，从点击图标到 activity ouResume的时间。" />
          <outline text="基本做法是: 主流程砍几刀, 分别打点, 找出最耗时的操作, 确认哪些步骤水分最大，谁在等待、在等谁. 继续这个动作, 逐步深入." />
          <outline text="首先, 去掉非必要的步骤；" />
          <outline text="合并步骤，批量处理；" />
          <outline text="预处理；预读. &lt;b&gt;用户感知的动作&lt;/b&gt;, 要提前准备数据, 必要时可读入无效数据, 冗余数据." />
          <outline text="按需处理。&lt;b&gt;用户无感知的动作&lt;/b&gt;放在后面处理. 延迟读, 延迟写。" />
          <outline text="大流程搞成多线程的, 串行改并行, 往往有奇效." />
          <outline text="buffer管理: ">
            <outline text="双buffer，或多buffer ，保证并发；" />
            <outline text="更大的 buffer.">
              <outline text="经验: 读写buffer 超过 64K 就价值不大了; 复杂计算buffer超过一帧就价值不大了." />
            </outline>
          </outline>
          <outline text="同一个处理, 底层和应用都可以做, 那就放在底层做. " />
          <outline text="&lt;b&gt;界面刷新速度优化&lt;/b&gt;">
            <outline text="setAlpha() 要特别小心. 因为如果界面上有多个Alpha值, 绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作. " />
            <outline text="减少页面 layout布局层级." />
            <outline text="减少过度绘制.   --参见: &lt;a href=&quot;https://workflowy.com/#/5d3ed8a3ec39&quot;&gt;https://workflowy.com/#/5d3ed8a3ec39&lt;/a&gt;" />
          </outline>
          <outline text="&lt;b&gt;拍照速度优化&lt;/b&gt;">
            <outline text="拍照性能优化看5个点: 拍照开始的回调, 缩略图回帧的回调, 拍照回帧, 后期处理的回调, 保存文件的回调." />
            <outline text="拍照性能优化: 先显示后处理, 在缩略图没有存储时候提前显示缩略图. 给用户快的感觉." />
          </outline>
        </outline>
        <outline text="性能问题工具">
          <outline text="&lt;b&gt;android过度绘制 (overdraw)&lt;/b&gt;">
            <outline text="过度绘制指屏幕的某个像素在同一帧的时间内会绘制多次. 这是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用." />
            <outline text="android系统设计思路就是递归, 无论是底层, 还是上层, 都喜欢用递归来解决问题. 好处是用很小的投入就能推动了庞大的系统; 坏处是层次太多, 太多无效调用, 系统低效臃肿." />
            <outline text="造成过度绘制的原因:    #面试题 #经验总结 ">
              <outline text="布局存在重叠的部分;" />
              <outline text="存在非必须的重叠背景;" />
              <outline text="不可见的UI元素也在刷新界面." />
            </outline>
            <outline text="&lt;b&gt;如何解决过度绘制?  #经验总结 &lt;/b&gt;">
              <outline text="总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?" />
              <outline text="1. 合理选择控件容器">
                <outline text="表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。" />
                <outline text="LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。" />
                <outline text="从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。" />
              </outline>
              <outline text="2. 去掉window的默认背景">
                <outline text="使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。" />
                <outline text="去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);" />
                <outline text="或者在theme中添加 android:windowbackground=&quot;null&quot;" />
              </outline>
              <outline text="3. 去掉其他不必要的背景">
                <outline text="有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。" />
                <outline text="如果采用的是 selector的背景，将normal状态的color设置为“@android:color/transparent&quot;,也同样可以解决问题。" />
              </outline>
              <outline text="4. ClipRect &amp;amp; QuickReject">
                <outline text="为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化." />
                <outline text="可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。" />
                <outline text="这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。" />
              </outline>
              <outline text="5. 使用ViewStub">
                <outline text="ViewStub是个什么东西？一句话总结：高效占位符。" />
                <outline text="我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。" />
                <outline text="这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。" />
                <outline text="推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。" />
                <outline text="想加载布局时，可以使用下面其中一种方法：" />
                <outline text="((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);" />
                <outline text="View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();" />
              </outline>
              <outline text="6. 使用Merge标签">
                <outline text="有两种情况下我们可以使用Merge标签来做容器控件。" />
                <outline text="第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。" />
                <outline text="另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。" />
                <outline text="Merge只能作为XML布局的根标签使用，当Inflate以&amp;lt;merge /&amp;gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。" />
              </outline>
              <outline text="7. 善用draw9patch">
                <outline text="你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。" />
                <outline text="优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。" />
              </outline>
              <outline text="8. 慎用Alpha">
                <outline text="对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。" />
                <outline text="如果一定做Alpha转化的话，可以采用缓存的方式。">
                  <outline text="view.setLayerType(LAYER_TYPE_HARDWARE);" />
                  <outline text="doSmoeThing();" />
                  <outline text="view.setLayerType(LAYER_TYPE_NONE);" />
                </outline>
                <outline text="通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。" />
              </outline>
              <outline text="9. 避免“OverDesign”">
                <outline text="开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难&quot;，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。" />
              </outline>
            </outline>
            <outline text="检查方法: ">
              <outline text="开发人员选项中有&quot;调试GPU过度绘制&quot;, 打开它, 然后在应用界面上会显示各种颜色, 其中:" />
              <outline text="没有颜色: 仅绘制1次." />
              <outline text="蓝色: 绘制2次 (可接受)" />
              <outline text="绿: 绘制3次" />
              <outline text="浅红: 绘制4次. 小块也可接受" />
              <outline text="深红: 绘制5次或以上. 这种需要修复." />
            </outline>
          </outline>
          <outline text="&lt;b&gt;systrace: 分析性能问题  --异常强大的工具 #经验总结 #面试题&lt;/b&gt;">
            <outline text="systrace负责收集Android关键子系统（如surfaceflinger、wms等Framework模块、服务，View系统等）的运行信息。" />
            <outline text="systrace模块由3部分组成：">
              <outline text="内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。" />
              <outline text="数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。" />
              <outline text="数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 " />
              <outline text="从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace." />
            </outline>
            <outline text="抓取方法：">
              <outline text="AS 进入Tools &amp;gt; Android &amp;gt; Monitor 抓取。" />
              <outline text="或者使用 monitor.bat , 选择线程。" />
              <outline text="选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。" />
              <outline text="然后复现问题，抓对应的 systrace." />
              <outline text="设置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件），比如32M。" />
            </outline>
            <outline text="分析方法：">
              <outline text="chrome中打开 chrome://tracing,  把文件拖进去" />
              <outline text="找对应的线程" />
              <outline text="遍历快捷键:">
                <outline text="w: 放大" />
                <outline text="s: 缩小" />
                <outline text="a: 后退" />
                <outline text="d: 前进" />
                <outline text="方向键: 四处遍历" />
                <outline text="f: 直接放大当前" />
                <outline text="m: 高亮当前" />
                <outline text="v: 高亮整个 vsync" />
                <outline text="0(数字): 恢复到最初状态" />
              </outline>
              <outline text="卡顿看 UIThread , 每个&quot;F&quot;都是一帧, 绿色表示不卡, 其它颜色表示卡." />
            </outline>
            <outline text="界面刷新一般包括如下几个步骤：">
              <outline text="SurfaceFlinger中的 EventThread 唤醒了应用程序UI线程，表明现在是渲染新帧的时候了。" />
              <outline text="应用程序使用CPU和GPU资源在UI线程，RenderThread 和 hwuiTasks 中渲染帧。这部分占UI的大部分。" />
              <outline text="应用程序通过binder将绘制好的帧发送到SurfaceFlinger并进入睡眠状态。" />
              <outline text="SurfaceFlinger中的第二个EventThread 负责唤醒SurfaceFlinger来触发组合和显示输出。" />
              <outline text="如果SurfaceFlinger确定没有任何工作要完成，它将返回睡眠状态。" />
              <outline text="SurfaceFlinger通过HWC / HWC2或GL处理组合。 HWC / HWC2组合更快，更低的功耗，但会受到SOC的限制。这一步通常需要4-6ms，但是可以与步骤2重叠，因为Android应用程序总是三重缓冲。 （虽然应用程序总是三重缓冲，但在SurfaceFlinger中只能有一个待处理帧，因此和双重缓存差不多。）" />
              <outline text="SurfaceFlinger通过驱动程序调度最终输出，并返回睡眠状态，等待EventThread唤醒。" />
            </outline>
            <outline text="systrace 加点">
              <outline text="代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();" />
              <outline text="必须成对出现, 且在同一个线程." />
              <outline text="在 release 版本中也生效." />
            </outline>
          </outline>
          <outline text="traceView">
            <outline text="使用工具 traceView 观察CPU的执行情况, 找出耗时操作." />
            <outline text="选择: call stack show" />
            <outline text="打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧." />
          </outline>
          <outline text="oprofile： linux性能监控工具">
            <outline text="特点是小巧，对运行影响小。android有一个简化的实现。" />
            <outline text="oprofile使用方法:">
              <outline text="先打开宏：CONFIG_OPROFILE=Y，编译系统生成boot.img，下载到手机侧。" />
              <outline text="用adb使能功能：opcontrol 等工具，抓取手机数据；" />
              <outline text="然后将/data/oprofile/ 目录下的数据pull 回pc ；" />
              <outline text="使用PC工具:opimport、opreport等进行分析。" />
            </outline>
            <outline text="代码位置: ">
              <outline text="手机侧：/external/oprofile，负责收集数据；" />
              <outline text="pc-linux侧，/prebuild/linux_x86/oprofile，负责分析数据。" />
            </outline>
          </outline>
        </outline>
        <outline text="CPU提频">
          <outline text="提频也叫CPU boost。" />
          <outline text="CPU分大小核，一般情况下，应用线程会跑在小核上。" />
          <outline text="如果性能不够，可以将线程提频，即强制让它运行到大核上。" />
          <outline text="是否提频，在systrace中搜 hypnus" />
        </outline>
        <outline text="应用ANR问题">
          <outline text="Android ANR问题（一）-基本分析方法 https://www.jianshu.com/p/082045769443 --还可以" />
          <outline text="ANR：Application Not Responding" />
          <outline text="ANR出现的原因  #面试题">
            <outline text="主线程频繁进行耗时的操作：如数据库读写" />
            <outline text="多线程操作的死锁，主线程被block；">
              <outline text="关键字：waiting to lock" />
            </outline>
            <outline text="主线程被Binder server block；">
              <outline text="在 traces.txt 文件中确认，client端的main线程卡在 BinderPorxy.transactNative；" />
              <outline text="通过binderinfo 文件查找 server端的进程号。" />
              <outline text="然后再在traces.txt 文件中确认server端在干什么， 常见的情况是卡在 Android.os.MessageQueue.nativePollOnce, 即事件处理卡住了，这种一般需要驱动继续排查。" />
              <outline text="还有一种情况是server端进程出现WatchDog导致ANR." />
            </outline>
            <outline text="service binder的连接达到上线无法和和System Server通信" />
            <outline text="系统资源已耗尽（CPU、IO、内存）" />
          </outline>
          <outline text="获取ANR日志: Trace文件">
            <outline text="旧版本系统(&amp;lt;=8.0)">
              <outline text="adb pull data/anr/traces.txt" />
            </outline>
            <outline text="新版本系统(&amp;gt;=9.0)">
              <outline text="一次anr一个log文件" />
              <outline text="/data/anr/目录中有多个 anr_XXX文件" />
            </outline>
            <outline text="设置ANR路径文件的位置：">
              <outline text="读取: getprop dalvik.vm.stack -trace -file" />
              <outline text="配置: setprop dalvik.vm.stack -trace -file /tmp/stack-traces.txt" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;Trace文件分析过程   参见: &lt;a href=&quot;https://workflowy.com/#/28c7c7faaf64&quot;&gt;https://workflowy.com/#/28c7c7faaf64&lt;/a&gt;&lt;/b&gt;" />
          <outline text="Log中的ANR reason（仅供参考）">
            <outline text="无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up." />
            <outline text="窗口暂停: Waiting because the [targetType] window is paused." />
            <outline text="窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed." />
            <outline text="窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed." />
            <outline text="窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度]." />
            <outline text="按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度]." />
            <outline text="非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长]." />
            <outline text="其中：" />
            <outline text="targetType: 取值为”focused”或者”touched”" />
            <outline text="Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE”" />
          </outline>
          <outline text="系统定义的超时时间">
            <outline text="用户输入5S">
              <outline text="logKey：Input event dispatching timed out" />
            </outline>
            <outline text="广播：前台10S，后台60S">
              <outline text="logKey：Timeout of broadcast BroadcastRecord" />
            </outline>
            <outline text="服务：前台20S，后台200S">
              <outline text="logKey：Timeout executing service" />
            </outline>
            <outline text="ContentProvider：10S">
              <outline text="logKey：timeout publishing content providers" />
            </outline>
          </outline>
          <outline text="服务启动时ANR 的原因">
            <outline text="Service创建之前会延迟发送一个消息，而这个消息就是ANR的起源；" />
            <outline text="Service创建完毕，在规定的时间之内执行完毕onCreate()方法就移除这个消息，就不会产生ANR了；" />
            <outline text="在规定的时间之内没有完成onCreate()的调用，消息被执行，ANR发生。" />
          </outline>
          <outline text="写anr log的代码在 ActivityManagerService.dumpStackTraces()" />
        </outline>
        <outline text="稳定性问题">
          <outline text="https://www.jianshu.com/p/18f16aba79dd  --好文章" />
          <outline text="Android卡顿分析中常见的log: https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html  --比较全面" />
          <outline text="traces.txt 文件  --定位ANR问题">
            <outline text="watchdog发现系统30秒不响应, 就会打印 traces.txt ." />
            <outline text="超过一分钟不响应则会打印类似如下的log, 名字如 races_SystemServer_WDT_${time}.txt  的文件,并重启 system_server." />
            <outline text="traces.txt 保存系统crash 时的堆栈信息。其中：">
              <outline text="ANR in 表明发生 anr 的模块." />
              <outline text="PID 是进程号。" />
              <outline text="Reason: *** 表示直接原因. 有时候有用, 有时候没用. " />
              <outline text="Load: 5.15 / 3.68 / 3.38, 表明, 5分钟，10分钟，15分钟内的平均负载分别为：5.15 , 3.68 , 3.38" />
              <outline text="CPU usage from 602ms to -6091ms ago: .   后面一堆数据, cpu从602毫秒到6091毫秒之间的各进程的CPU使用情况。" />
              <outline text="以上是系统概况信息, 一般价值不大, 真正定位原因还要看anr时的堆栈." />
            </outline>
            <outline text="堆栈分析方法：">
              <outline text="搜 Dalvik Threads 可直接定位到堆栈区." />
              <outline text="一般看 main 线程，即前台window所在的应用的主线程。" />
              <outline text="错误类型包括:">
                <outline text="Blocked in handler on foreground thread (android.fg)" />
                <outline text="Blocked in handler on main thread (main)" />
                <outline text="Blocked in handler on display thread (android.display)" />
                <outline text="Blocked in handler on ActivityManager (ActivityManager)" />
              </outline>
              <outline text="找对应的binder进程的堆栈. 比如 主线程id是8277,  则搜 Binder:8277_" />
            </outline>
          </outline>
          <outline text="tombstone   --定位死机问题">
            <outline text="当系统 crash 的时候，会保存一个 tombstone 文件到 /data/tombstones目录下。" />
            <outline text="它包含了发生问题的进程ID信息：">
              <outline text="I/DEBUG   (  241): pid: 244, tid: 244, name: mediaserver  &amp;gt;&amp;gt;&amp;gt; /system/bin/mediaserver &amp;lt;&amp;lt;&amp;lt;" />
              <outline text="当 tid == pid 时，问题发生在父进程，反之问题发生在子进程。" />
            </outline>
            <outline text="以及错误类型：">
              <outline text="F/libc    (  244): Fatal signal 11 (SIGSEGV), code 1, fault addr 0xdeadbaad in tid 244 (mediaserver)" />
              <outline text="说明出现进程 Crash 的原因是因为程序产生了段错误的信号，访问了非法的内存空间，而访问的非法地址是 0xdeadbaad。" />
            </outline>
            <outline text="系统支持的错误类型有：">
              <outline text="SIGSEGV	Invalid memory reference." />
              <outline text="SIGBUS	Access to an undefined portion of a memory object." />
              <outline text="SIGFPE	Arithmetic operation error, like divide by zero." />
              <outline text="SIGILL	Illegal instruction, like execute garbage or a privileged instruction" />
              <outline text="SIGSYS	Bad system call." />
              <outline text="SIGXCPU	CPU time limit exceeded." />
              <outline text="SIGXFSZ	File size limit exceeded." />
              <outline text="错误类型定义在prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.8/sysroot/usr/include/bits/signum.h" />
            </outline>
            <outline text="分析方法">
              <outline text="主要关注 backtrace 下面的内容。它保存了发生 crash 时的堆栈。" />
            </outline>
          </outline>
          <outline text="c代码堆栈信息只有内存地址, 没有函数名和行号, 需要一些工具转.">
            <outline text="addr2line">
              <outline text="addr2line 是把内存地址转化为代码行的工具。需要符号表。" />
              <outline text="用法如下：" />
              <outline text="如果想找这行错误：#08 pc 0013b3d5 /system/lib/&lt;a href=&quot;http://libskia.so&quot;&gt;libskia.so&lt;/a&gt; (SkPNGImageDecoder::onDecodeSubset(SkBitmap*, SkIRect const&amp;amp;)+604)" />
              <outline text="先在符号表目录查找：&lt;a href=&quot;http://libskia.so&quot;&gt;libskia.so&lt;/a&gt;。 比如在 ./symbols/system/lib/ 下。" />
              <outline text="./bin/x86_64-linux-addr2line -e ./symbols/system/lib/&lt;a href=&quot;http://libskia.so&quot;&gt;libskia.so&lt;/a&gt; 0013b3d5" />
              <outline text="输出大致为： android/external/skia/src/images/SkImageDecoder_libpng.cpp:907" />
            </outline>
            <outline text="addr2line 的增强版： &lt;a href=&quot;http://stack.py&quot;&gt;stack.py&lt;/a&gt;">
              <outline text="stack.py 能够把backtrace堆栈一次性对应到代码，也是利用addr2line。" />
              <outline text="命令： python stack.py --symbols-dir=[符号变目录] [tombstone文件]" />
            </outline>
            <outline text="ndk-stack">
              <outline text="Android NDK 自从版本 r6开始, 提供了一个工具 ndk-stack。这个工具能自动分析 tombstone 文件, 能将崩溃时的调用内存地址和 c++ 代码一行一行对应起来。" />
              <outline text="命令： ndk-stack -sym &amp;lt;path&amp;gt; [-dump &amp;lt;path&amp;gt;]">
                <outline text="dump 参数即 dump 下来的 log 文本文件." />
                <outline text="sym 参数即符号表。就是android项目目录下，编译成功之后，obj目录下的文件（android系统源码o 中带有符号信息的文件）。" />
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="底层死机原因">
          <outline text="Preftch Abort：程序指针跑飞；" />
          <outline text="Data Abort：内存指针跑飞；（最常见）" />
          <outline text="Div by Zero：发生除零错误；" />
          <outline text="Unknown sig：某个task收到未定义的信号；" />
          <outline text="Error Fatal：代码进入error FATAL分支（可能是assert）" />
        </outline>
        <outline text="内存泄漏  --参见 &lt;a href=&quot;https://workflowy.com/#/2ec2e50f9992&quot;&gt;https://workflowy.com/#/2ec2e50f9992&lt;/a&gt;" />
        <outline text="功耗问题  --参见 &lt;a href=&quot;https://workflowy.com/#/a5573305b407&quot;&gt;https://&lt;/a&gt;&lt;a href=&quot;https://workflowy.com/#/a5573305b407&quot;&gt;workflowy&lt;/a&gt;&lt;a href=&quot;https://workflowy.com/#/a5573305b407&quot;&gt;.com/#/a5573305b407&lt;/a&gt;" />
        <outline text="Monkey" />
        <outline text="CTS" />
        <outline text="分析问题的首选方法  #经验总结 ">
          <outline text="三现原则。log也算现场。" />
          <outline text="利用dailybuild版本，将问题分而治之。" />
          <outline text="花3-5分钟时间考虑思路，并写在纸上. 然后尽快开始做。" />
          <outline text="配环境是难点，三个办法：">
            <outline text="平时准备好；" />
            <outline text="找现成的环境用；" />
            <outline text="基本环境出问题, 不要自己琢磨, 直接找高手搞定. 不要把时间浪费在非关键问题上.">
              <outline text="这意味着平时要维护一个高手的名单, 并和他们处好关系." />
            </outline>
          </outline>
          <outline text="加快闭环">
            <outline text="code → compiler → install → test" />
            <outline text="如果在定位问题，请保证每个小时出一次版本。" />
            <outline text="我的经验是，一个较复杂的问题的定位，至少需要3个以上的测试版本，而写完一大段代码（300行以上）后进行功能验证，一般需要4-6个版本才能搞定（平均每个版本能解决两三个个bug）。" />
          </outline>
          <outline text="USB 相关问题，首选是Bus Hound；" />
          <outline text="硬件问题：把线连出来，上示波器。要会用示波器。" />
          <outline text="用trace 跟无问题，不跟才有，一般和踢狗相关。" />
          <outline text="性能问题，先要流程分解成3-6个阶段，然后通过log 打印等方式得出各阶段的时耗，找到突破点。" />
          <outline text="功耗问题，逐个器件拔。" />
          <outline text="迅速缩小焦点：">
            <outline text="FFA上有吗? 有, 就是高通的问题. 没有,则是我们的修改引入的." />
            <outline text="新版本有吗? 没有, 则已经解决." />
            <outline text="老版本有吗? 没有, 则是最近修改引入的. 有, 则是固有问题." />
            <outline text="新单板有吗? 没有, 则已经解决. (软件版本一致的情况下)" />
            <outline text="老单板有吗? 没有, 则为硬件修改引入. (软件版本一致的情况下)" />
            <outline text="第三方应用有吗? 有, 说明是底层问题. 没有, 说明是应用的问题. (非绝对)" />
          </outline>
          <outline text="时刻关注自己是在哪个层面上考虑问题：">
            <outline text="是cpu层次（包括cpu、硬件寄存器、dma）" />
            <outline text="是外设级别（要考虑时序、电源）" />
            <outline text="还是task级别（sig、队列、task切换、堆栈、中断等）" />
          </outline>
        </outline>
        <outline text="张建春的定位技巧  #经验总结 ">
          <outline text="多看 MODEM SOFTWARE INTERFACE .pdf，学会对arm硬件寄存器的直接操作。" />
          <outline text="下发“FALSH读”的指令：D.S SD:0X60000304 %LE %LONG 1；D.S SD:0X60000100 %LE %LONG 0x2。0X60000304  即 page read指令。" />
          <outline text="设置读地址：D.S SD:0X60000300 %LE %LONG 0x0279c00；" />
          <outline text="查看FALSH读写状态：0X60000308；" />
          <outline text="查看ECC 纠错的位数：0X6000030C。0表示无错误；超过4个字节就无法正确纠正。" />
        </outline>
      </outline>
      <outline text="&lt;b&gt;08-Log关键字&lt;/b&gt;">
        <outline text="官方的Log注释">
          <outline text="原生代码中其实有大量的关键log的文档. 这类文档叫 event.logtags." />
          <outline text="其数据格式是: event|1|5" />
          <outline text="event表示含义;" />
          <outline text="第一个数字表示数据类型, 包括: ">
            <outline text="1: int" />
            <outline text="2: long" />
            <outline text="3: string" />
            <outline text="4: list" />
            <outline text="5: float" />
          </outline>
          <outline text="第二个数字表示数据属性, 包括: ">
            <outline text="1: Number of objects" />
            <outline text="2: Number of bytes" />
            <outline text="3: Number of milliseconds" />
            <outline text="4: Number of allocations" />
            <outline text="5: Id" />
            <outline text="6: Percent" />
            <outline text="s: Number of seconds (monotonic time)" />
          </outline>
        </outline>
        <outline text="定位应用线程ID, 过滤其Log">
          <outline text="adb logcat -c" />
          <outline text="adb logcat | find &quot;Start proc&quot;" />
          <outline text="adb logcat | find &quot;***&quot; &amp;gt; 1.log" />
        </outline>
        <outline text="&lt;b&gt;Input&lt;/b&gt;">
          <outline text="常规： Inputreader|inputdispatcher|eventhub|inputmanager_dispatch|InputTransport|PhoneWindowManager" />
          <outline text="View 处理触摸事件： processMotionEvent ">
            <outline text="Input log开关不打开时，这个打印也有，所以方便。" />
          </outline>
          <outline text="input rawdata： Input event">
            <outline text="其中，device即设备ID" />
            <outline text="Type, 事件类型.">
              <outline text="0是EV_Syn，因为一个事件要保上报多次，所以需要同步事件来确认整个世界上报完毕。" />
              <outline text="1是EV_key，键盘" />
              <outline text="2是EV_rel，即触摸事件。" />
            </outline>
            <outline text="code即各种键值，key_***, syn_***等等。" />
            <outline text="value指具体指，比如触摸事件的坐标等。x, y轴是分开上报的。" />
          </outline>
          <outline text="触摸事件上报： notifyMotion">
            <outline text="下面这些枚举字段的含义在 input.h 中定义。" />
            <outline text="eventTime, 事件上报时间" />
            <outline text="downTime, down事件时间。">
              <outline text="注意，所有非down的事件，它的downTime不等于自己的eventTime，而是等于上一次的eventTime。" />
              <outline text="凡是不满足这个条件的，都是非法事件，会被过滤掉。" />
            </outline>
            <outline text="deviceId： 设备id。即hal层input设备id。">
              <outline text="R版本上，注入的事件统一设置为-1。" />
            </outline>
            <outline text="source，设备类型">
              <outline text="触屏： 0x1002" />
              <outline text="键盘： 0x101" />
              <outline text="鼠标： 0x2002" />
              <outline text="手写笔： 0x4002" />
            </outline>
            <outline text="policyFlags： 即wms窗口策略。 重要">
              <outline text="1, 保持系统唤醒" />
              <outline text="2, 是虚拟按键" />
              <outline text="4, 是特殊功能修饰健（Ctrl、shift 之类）" />
              <outline text="8, " />
              <outline text="0x100 0000，注入的事件" />
              <outline text="0x200 0000，可信的" />
              <outline text="0x400 0000， 过滤的" />
              <outline text="0x800 0000， 禁用自动重复事件。" />
              <outline text="0x4000 0000，事件要传递到应用层，即 PASS_TO_USER." />
            </outline>
            <outline text="action: 事件类型。重要。">
              <outline text="0： down" />
              <outline text="1： up" />
              <outline text="2： move" />
              <outline text="3： cancel" />
              <outline text="4： outside" />
              <outline text="7： hover move" />
              <outline text="9： hover enter" />
              <outline text="10： hover exit" />
              <outline text="11： button press" />
              <outline text="12： button release" />
            </outline>
            <outline text="actionButton： 按键类型，比如左键、中键、右键之类。" />
            <outline text="flags： 对于触摸事件：标记点位发生在屏幕边界，分上下左右。不常用。" />
            <outline text="Precision: 分x、y轴, 屏幕密度，一般是1。" />
          </outline>
          <outline text="按键事件上报： notifyKey">
            <outline text="各字段含义和 notifyMotion 相同的，不累述。" />
            <outline text="flags： 对于按键事件，这个字段重要多了。">
              <outline text="2，软键盘产生的事件。" />
              <outline text="8, 事件来自系统，不可被应用屏蔽。" />
            </outline>
            <outline text="keyCode: 键值">
              <outline text="在 Keycodes.h 定义。" />
              <outline text="24, 0x18, 音量上" />
              <outline text="25, 0x19, 音量下" />
              <outline text="26, 0x1a, power键" />
            </outline>
            <outline text="scanCode: 硬件键值。底层上报的键值是这个。">
              <outline text="在 InputEventLabels.h 和 KeyEvent.java 中定义。" />
              <outline text="116, 0x74, power键" />
              <outline text="115, 0x73, 音量上" />
              <outline text="114, 0x72, 音量下" />
            </outline>
            <outline text="metaState: 仅用于键盘，标识 Ctrl、ALT等按键的状态。 参见 ameta_none" />
          </outline>
          <outline text="触摸屏报点： Pointer">
            <outline text="id：点的序号，从0开始，一些input事件有多个点。" />
            <outline text="toolType： 触摸工具类型。">
              <outline text="1, 手指" />
              <outline text="2, 手写笔" />
              <outline text="3, 鼠标" />
              <outline text="4, 橡皮擦 ？" />
              <outline text="5, 手掌 ？" />
            </outline>
            <outline text="x, y： 点坐标" />
            <outline text="pressure: 按下压力值。用于按压屏或者手写笔。" />
            <outline text="size： 触摸区域的大小（近似值）。0到1之间。" />
            <outline text="touchMajor, tohchMinor, 触摸区域的长轴和短轴（单位为像素）" />
            <outline text="toolMajor, toolMinor, 触摸根工具的长轴和短轴 （单位为像素）" />
            <outline text="这4个值一般一样。" />
            <outline text="orientation: 屏幕方向，0表示竖屏。" />
          </outline>
          <outline text="channel 发送事件的流程">
            <outline text="enqueueDispatchCycle" />
            <outline text="prepareDispatchCycle" />
            <outline text="startDispatchCycle" />
            <outline text="publishMotionEvent" />
            <outline text="finishDispatchCycle" />
            <outline text="sendFinishedSignal" />
            <outline text="receiveFinishedSignal " />
          </outline>
          <outline text="" />
          <outline text="取得焦点窗口： Focus entered window" />
          <outline text="事件cancel： InputDispatcher: cancel">
            <outline text="各字段含义和 notify Motion相同。" />
          </outline>
          <outline text="事件cancel的原因：cancellation events">
            <outline text="其中，channel, cancel,发生的channel" />
            <outline text="synthesized，被cancel的事件的数量" />
            <outline text="mode，cancel模式">
              <outline text="1, 点事件" />
              <outline text="2, 非点时间" />
              <outline text="3, callback事件" />
            </outline>
          </outline>
          <outline text="事件被跳过： skipping inconsistent motion event" />
          <outline text="事件删除： Dropping">
            <outline text="第二个关键字是删除原因" />
          </outline>
          <outline text="事件过滤： filter|shouldInterceptEventLocked " />
          <outline text="事件冲突： Conflicting pointer actions" />
          <outline text="事件注入： injectInputEvent|should inject" />
          <outline text="事件拦截： interceptKeyBeforeQueueing|interceptKeyBeforeDispatching" />
          <outline text="" />
          <outline text="设备识别： Device added|New device|Input event">
            <outline text="其中，id 后面用得比较多。" />
            <outline text="classes 为设备类型，为掩码量。" />
          </outline>
          <outline text="光标显示： unfade|fade|cursor" />
          <outline text="横竖屏切换： Device reconfigured. 重要。">
            <outline text="其中，size： 屏幕坐标" />
            <outline text="orientation： 0表示竖屏, 1表示横屏。" />
            <outline text="mode： 设备模式，参见 DeviceMode." />
          </outline>
        </outline>
        <outline text="Sensor">
          <outline text="hal层上报数据：sensors-hal|ap_sensors" />
          <outline text="服务： SensorManager|SensorService" />
          <outline text="接近光： proximity" />
          <outline text="加速度： accelerometer" />
        </outline>
        <outline text="Activity / 进程">
          <outline text="应用启动： Start proc|New app record|am_proc_start|am_pre_boot" />
          <outline text="activity启动： am_create_task|am_create_activity|am_restart_activity|am_on_create_called|am_on_start_called|am_on_restart_called|am_relaunch_resume_activity|am_relaunch_activity" />
          <outline text="Activity task 回到栈顶, 显示在屏幕上： am_task_to_front" />
          <outline text="Activity 显示到界面上：am_resume_activity|am_on_resume_called|Displayed" />
          <outline text="activity绘制时间： am_activity_fully_drawn_time|am_activity_launch_time" />
          <outline text="已经存在的activity接受新的intent: am_new_intent">
            <outline text="数据结构: (User|1|5),(Token|1|5),(Task ID|1|5),(Component Name|3),(Action|3),(MIME Type|3),(URI|3),(Flags|1|5)" />
          </outline>
          <outline text="activity结束： am_finish_activity|am_destroy_activity|am_stop_activity|am_on_stop_called|am_on_destroy_called">
            <outline text="am_destroy_activity 有reasen字段." />
          </outline>
          <outline text="activity从栈中被移除： am_remove_task">
            <outline text="数据是两个整数，前者是task id，后者是stack id。" />
          </outline>
          <outline text="启动activity耗时: am _activity_launch_time (很有用)" />
          <outline text="Application 线程绑定到工作队列: am_proc_bound" />
          <outline text="Stack focus: am_focused_stack">
            <outline text="数据: (User|1|5), (Display Id|1|5), (Focused Stack Id|1|5), (Last Focused Stack Id|1|5), (Reason|3)" />
          </outline>
          <outline text="The activity's onTopResumedActivityChanged(true) has been called: am_on_top_resumed_gained_called" />
          <outline text="The activity's onTopResumedActivityChanged(false) has been called:  am_on_top_resumed_lost_called" />
          <outline text="An activity been add into stopping list: am_add_to_stopping" />
          <outline text="回调onActivityResult: am_on_activity_result_called" />
          <outline text="暂停activity: am_pause_activity|am_on_paused_called|am_set_resumed_activity" />
          <outline text="activity启动异常: am_proc_bad|am_process_start_timeout|am_failed_to_pause" />
          <outline text="activity恢复正常: am_proc_good" />
          <outline text="attach进程失败(找不到pid)： am_drop_process" />
          <outline text="Task 被压缩: am_compact">
            <outline text="数据: (Pid|1|5),(Process Name|3),(Action|3),(BeforeRssTotal|2|2),(BeforeRssFile|2|2),(BeforeRssAnon|2|2),(BeforeRssSwap|2|2),(DeltaRssTotal|2|2),(DeltaRssFile|2|2),(DeltaRssAnon|2|2),(DeltaRssSwap|2|2),(Time|2|3),(LastAction|1|2),(LastActionTimestamp|2|3),(setAdj|1|2),(procState|1|2),(BeforeZRAMFree|2|2),(DeltaZRAMFree|2|2)" />
          </outline>
          <outline text="进程踢狗: tickle (authority|3)" />
          <outline text="Note when any processes of a uid have started running: am_uid_running" />
          <outline text="Note when all processes of a uid have stopped: am_uid_stopped" />
          <outline text="Note when the state of a uid has become active: am_uid_active" />
          <outline text="Note when the state of a uid has become idle (background check enforced): am_uid_idle" />
          <outline text="Note when a service is being forcibly stopped because its app went idle: am_stop_idle_service" />
          <outline text="处理事件： handleMessage, what" />
          <outline text="Usb对话框： showMtpDialog : mode" />
        </outline>
        <outline text="Window / View">
          <outline text="移除task stack： wm_stack_removed" />
          <outline text="创建task stack： wm_stack_created">
            <outline text="Stack id" />
          </outline>
          <outline text="移除task： wm_task_removed">
            <outline text="Reason: 移除原因" />
          </outline>
          <outline text="将window移动到top 或 bottom： wm_task_moved">
            <outline text="Totop: 1表示top，0表示bottom" />
            <outline text="index： target position的值。" />
          </outline>
          <outline text="创建window task： wm_task_created">
            <outline text="StackId: 指activity task ID" />
          </outline>
          <outline text="横竖屏切换： orientation ">
            <outline text="0, 竖屏； 1, 横屏" />
          </outline>
          <outline text="Out of memory for surfaces: wm_no_surface_memory (Window|3),(PID|1|5),(Operation|3)" />
          <outline text="Task created: wm_task_created (TaskId|1|5),(StackId|1|5)" />
          <outline text="Task moved to top (1) or bottom (0): wm_task_moved (TaskId|1|5),(ToTop|1),(Index|1)" />
          <outline text="Task removed with source explanation: wm_task_removed (TaskId|1|5),(Reason|3)" />
          <outline text="Stack created: wm_stack_created (StackId|1|5)" />
          <outline text="Home stack moved to top (1) or bottom (0): wm_home_stack_moved (ToTop|1)" />
          <outline text="Stack removed: wm_stack_removed (StackId|1|5)" />
          <outline text="bootanim finished: wm_boot_animation_done (time|2|3)" />
          <outline text="窗口大小： Rect" />
          <outline text="焦点窗口切换： Set focused app to" />
        </outline>
        <outline text="系统">
          <outline text="音量调节： volume_changed| VOLUME_CHANGED_ACTION" />
          <outline text="开机动画播放完成： wm_boot_animation_done" />
          <outline text="允许安装未知来源的应用： unknown_sources_enabled">
            <outline text="1为允许" />
          </outline>
          <outline text="恢复出厂设置">
            <outline text="重置统计： rescue_note" />
            <outline text="重置等级： rescue_level" />
            <outline text="重置成功： rescue_success" />
            <outline text="重置失败： rescue_failure" />
          </outline>
          <outline text="watchdog" />
          <outline text="存储分区统计： storage_state">
            <outline text="数据： uuid, old state, new state, 可用空间，总空间" />
          </outline>
          <outline text="系统重启： beginning of main|beginning of system " />
          <outline text="底层模块启动: boot_progress_start (time|2|3)" />
          <outline text="ZygoteInit 启动各模块: boot_progress_preload_start (time|2|3)" />
          <outline text="ZygoteInit 启动结束: boot_progress_preload_end (time|2|3)" />
          <outline text="启动Dalvik: dvm_lock_sample">
            <outline text="数据格式:  (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6)" />
          </outline>
          <outline text="启动ART: art_hidden_api_access">
            <outline text="(access_method|1),(flags|1),(class|3),(member|3),(type_signature|3)" />
          </outline>
          <outline text="ams就绪： boot_progress_ams_ready (数字是毫秒数)">
            <outline text="ActivityManagerService.systemReady() starts" />
          </outline>
          <outline text="SystemServer 启动: boot_progress_system_run" />
          <outline text="SystemServer 启动: system_server_start">
            <outline text="数据: (start_count|1), (uptime|2|3), (elapse_time|2|3)" />
          </outline>
          <outline text="系统进入桌面： system now ready" />
          <outline text="写系统文件: commit_sys_config_file (name|3),(time|2|3)" />
          <outline text="配置改变: configuration_changed" />
          <outline text="切换用户： am_switch_user|am_user_state_changed" />
          <outline text="账户: sync">
            <outline text="格式: (id|3), (event|1|5), (source|1|5), (account|1|5), account是账号名的hash值." />
          </outline>
        </outline>
        <outline text="内存 / 性能">
          <outline text="内存信息： am_meminfo">
            <outline text="数据：(Cached|2|2), (Free|2|2), (Zram|2|2), (Kernel|2|2), (Native|2|2)" />
          </outline>
          <outline text="pss信息： am_pss">
            <outline text="数据： (Pid|1|5), (UID|1|5), (Process Name|3), (Pss|2|2), (Uss|2|2), (SwapPss|2|2), (Rss|2|2), (StatType|1|5), " />
            <outline text="(ProcState|1|5), ">
              <outline text="进程状态，参见 ActivityManager.h. 其中2表示前台进程。" />
            </outline>
            <outline text="(TimeToCollect|2|2)" />
          </outline>
          <outline text="垃圾回收： Starting a blocking GC Alloc|GC freed|am_low_memory" />
          <outline text="强制垃圾回收: force_gc (reason|3)" />
          <outline text="低内存杀进程: killinfo">
            <outline text="(Pid|1|5), (Uid|1|5), (OomAdj|1), (MinOomAdj|1), (TaskSize|1), (enum kill_reasons|1|5), (MemFree|1), " />
            <outline text="(Cached|1), (SwapCached|1), (Buffers|1), (Shmem|1), (Unevictable|1), (SwapTotal|1), (SwapFree|1), " />
            <outline text="(ActiveAnon|1), (InactiveAnon|1), (ActiveFile|1), (InactiveFile|1), (SReclaimable|1), (SUnreclaim|1), " />
            <outline text="(KernelStack|1), (PageTables|1), (IonHeap|1), (IonHeapPool|1), (CmaFree|1), (MsSinceEvent|1), " />
            <outline text="(MsSincePrevWakeup|1), (WakeupsSinceEvent|1), (SkippedWakeups|1)" />
          </outline>
          <outline text="CPU占用率: cpu">
            <outline text="(total|1|6),(user|1|6),(system|1|6),(iowait|1|6),(irq|1|6),(softirq|1|6)" />
          </outline>
          <outline text="CPU占用率： CPU usage" />
          <outline text="丢帧： Choreographer: Skipped" />
          <outline text="Log溢出： identical" />
        </outline>
        <outline text="亮灭屏 / 唤醒睡眠 / 屏幕亮度">
          <outline text="亮灭屏原因： power_screen_state">
            <outline text="1. offOrOn: 0, 灭；1，亮" />
            <outline text="2. because: 亮灭屏原因">
              <outline text="参见 PowerManager.java， 300行。" />
              <outline text="亮屏">
                <outline text="0, 其它原因" />
                <outline text="1, 按键" />
                <outline text="2, 应用" />
                <outline text="3, 设备插入" />
                <outline text="4, 手势" />
              </outline>
              <outline text="灭屏">
                <outline text="0, 应用请求" />
                <outline text="2, 屏幕超时" />
                <outline text="4, power键" />
              </outline>
            </outline>
          </outline>
          <outline text="亮灭屏： onScreenChanged|PowerManagetService" />
          <outline text="屏幕亮灭: screen_toggled (screen_state|1|5)">
            <outline text="0 for screen off" />
            <outline text="1 for screen on" />
            <outline text="2表示已锁屏。" />
          </outline>
          <outline text="亮灭屏广播： power_screen_broadcast_send|power_screen_broadcast_done">
            <outline text="wakelockCount: 发送广播的数量" />
          </outline>
          <outline text="屏幕亮度变化： Brightness" />
          <outline text="屏幕亮度变化： auto_brightness_adj">
            <outline text="其中, old_lux: 旧的环境光度" />
            <outline text="old_brightness： 旧的屏幕亮度" />
            <outline text="new_lux：新的环境光度" />
            <outline text="new_brightness： 新的屏幕亮度" />
          </outline>
          <outline text="ams点亮屏幕（开机过程）： boot_progress_enable_screen (数字是毫秒数)">
            <outline text="ActivityManagerService calls enableScreenAfterBoot()." />
          </outline>
          <outline text="灭屏时被清空的应用持有唤醒数量： power_sleep_requested" />
        </outline>
        <outline text="功耗 / 充电 / 电池">
          <outline text="功耗service： PowerManagetService" />
          <outline text="过滤power: intercept_power (action|3),(mPowerKeyHandled|1),(mPowerKeyPressCounter|1)" />
          <outline text="电池电量： battery_level">
            <outline text="数据格式： 电量，电压，温度" />
          </outline>
          <outline text="充电状态： battery_status">
            <outline text="第一个参数： 2，充电；3，放电；4，未充电；5，充满电。" />
            <outline text="第二个参数：2，电池正常；3，过热；4，电池损坏；5，电压过高；6，未知故障；7，电池过冷。" />
            <outline text="第三个参数：1，放电；0，充电" />
            <outline text="第四个参数：1，AC直充；2，USB充电；4，无线充电" />
            <outline text="第五个参数：电池类型，li-ion，锂电池。" />
          </outline>
          <outline text="放电状态： battery_discharge">
            <outline text="放电时长，最低电流，最高电量" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;稳定性&lt;/b&gt;">
          <outline text="Watchdog">
            <outline text="watchdog (Service|3)" />
            <outline text="watchdog_proc_pss (Process|3),(Pid|1|5),(Pss|1|2)" />
            <outline text="watchdog_soft_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2),(Skip|3)" />
            <outline text="watchdog_hard_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2)" />
            <outline text="watchdog_pss_stats (EmptyPss|1|2),(EmptyCount|1|1),(BackgroundPss|1|2),(BackgroundCount|1|1),(ServicePss|1|2),(ServiceCount|1|1),(VisiblePss|1|2),(VisibleCount|1|1),(ForegroundPss|1|2),(ForegroundCount|1|1),(NoPssCount|1|1)" />
            <outline text="watchdog_proc_stats (DeathsInOne|1|1),(DeathsInTwo|1|1),(DeathsInThree|1|1),(DeathsInFour|1|1),(DeathsInFive|1|1)" />
            <outline text="watchdog_scheduled_reboot (Now|2|1),(Interval|1|3),(StartTime|1|3),(Window|1|3),(Skip|3)" />
            <outline text="watchdog_meminfo (MemFree|1|2),(Buffers|1|2),(Cached|1|2),(Active|1|2),(Inactive|1|2),(AnonPages|1|2),(Mapped|1|2),(Slab|1|2),(SReclaimable|1|2),(SUnreclaim|1|2),(PageTables|1|2)" />
            <outline text="watchdog_vmstat (runtime|2|3),(pgfree|1|1),(pgactivate|1|1),(pgdeactivate|1|1),(pgfault|1|1),(pgmajfault|1|1)" />
            <outline text="watchdog_requested_reboot (NoWait|1|1),(ScheduleInterval|1|3),(RecheckInterval|1|3),(StartTime|1|3),(Window|1|3),(MinScreenOff|1|3),(MinNextAlarm|1|3)" />
          </outline>
          <outline text="crash开始： beginning of crash" />
          <outline text="一级crash： crash|fatal|backtrace|died|goodbye|shutting down vm|Androidruntime|am_crash|service crashed|java.lang.runtimeexception|exit zygote|Killing|Death received|am_proc_died" />
          <outline text="应用crash: am_crash">
            <outline text="数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Exception|3), (Message|3), (File|3), (Line|1|5)" />
          </outline>
          <outline text="activity被kill: am_kill">
            <outline text="数据: (User|1|5), (PID|1|5), (Process Name|3), (OomAdj|1|5), (Reason|3)" />
          </outline>
          <outline text="二级crash：Err|fail|unexpected|system.err|java.lang|Systrace" />
          <outline text="卡死冻屏: held by|blocked|caused by|locked|waiting on|locked" />
          <outline text="ANR： ANR in|Input event dispatching timed out" />
          <outline text="activity ANR: am_anr">
            <outline text="数据: (User|1|5), (pid|1|5), (Package Name|3), (Flags|1|5), (reason|3)" />
          </outline>
          <outline text="am_wtf: ">
            <outline text="数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Tag|3), (Message|3)" />
          </outline>
          <outline text="进程短时间crash多次： am_process_crashed_too_much" />
        </outline>
        <outline text="安全">
          <outline text="Selinux 权限检验失败">
            <outline text="denied {execute/read/write} for " />
            <outline text="其中校验目标即 comm字段。" />
          </outline>
          <outline text="security_adb_shell_interactive" />
          <outline text="security_adb_shell_command               (command|3)" />
          <outline text="security_adb_sync_recv                   (path|3)" />
          <outline text="security_adb_sync_send                   (path|3)" />
          <outline text="security_app_process_start               (process|3),(start_time|2|3),(uid|1),(pid|1),(seinfo|3),(sha256|3)" />
          <outline text="security_keyguard_dismissed" />
          <outline text="security_keyguard_dismiss_auth_attempt   (success|1),(method_strength|1)" />
          <outline text="security_keyguard_secured" />
          <outline text="security_os_startup                      (boot_state|3),(verity_mode|3)" />
          <outline text="security_os_shutdown" />
          <outline text="security_logging_started" />
          <outline text="security_logging_stopped" />
          <outline text="security_media_mounted                   (path|3),(label|3)" />
          <outline text="security_media_unmounted                 (path|3),(label|3)" />
          <outline text="security_log_buffer_size_critical" />
          <outline text="security_password_expiration_set         (package|3),(admin_user|1),(target_user|1),(timeout|2|3)" />
          <outline text="security_password_complexity_set         (package|3),(admin_user|1),(target_user|1),(length|1),(quality|1),(num_letters|1),(num_non_letters|1),(num_numeric|1),(num_uppercase|1),(num_lowercase|1),(num_symbols|1)" />
          <outline text="security_password_history_length_set     (package|3),(admin_user|1),(target_user|1),(length|1)" />
          <outline text="security_max_screen_lock_timeout_set     (package|3),(admin_user|1),(target_user|1),(timeout|2|3)" />
          <outline text="security_max_password_attempts_set       (package|3),(admin_user|1),(target_user|1),(num_failures|1)" />
          <outline text="security_keyguard_disabled_features_set  (package|3),(admin_user|1),(target_user|1),(features|1)" />
          <outline text="security_remote_lock                     (package|3),(admin_user|1),(target_user|1)" />
          <outline text="security_wipe_failed                     (package|3),(admin_user|1)" />
          <outline text="security_key_generated                   (success|1),(key_id|3),(uid|1)" />
          <outline text="security_key_imported                    (success|1),(key_id|3),(uid|1)" />
          <outline text="security_key_destroyed                   (success|1),(key_id|3),(uid|1)" />
          <outline text="security_user_restriction_added          (package|3),(admin_user|1),(restriction|3)" />
          <outline text="security_user_restriction_removed        (package|3),(admin_user|1),(restriction|3)" />
          <outline text="security_cert_authority_installed        (success|1),(subject|3)" />
          <outline text="security_cert_authority_removed          (success|1),(subject|3)" />
          <outline text="security_crypto_self_test_completed      (success|1)" />
          <outline text="security_key_integrity_violation         (key_id|3),(uid|1)" />
          <outline text="security_cert_validation_failure         (reason|3)" />
        </outline>
        <outline text="Service">
          <outline text="创建： am_create_service" />
          <outline text="销毁： am_destroy_service" />
          <outline text="启动： startService" />
          <outline text="Service多次crash： am_service_crashed_too_much">
            <outline text="" />
          </outline>
          <outline text="绑定, 解绑：  bindService|unbindService" />
          <outline text="统计绑定了多少个客户端： total connections for service" />
          <outline text="重启： am_schedule_service_restart" />
          <outline text="访问统计: service_manager_stats (call_count|1), (total_time|1|3), (duration|1|3)" />
          <outline text="响应迟缓: service_manager_slow (time|1|3), (service|3)" />
          <outline text="服务空闲而关闭： am_stop_idle_service" />
        </outline>
        <outline text="Binder / 广播 / 通知">
          <outline text="通知被取消： notification_cancel" />
          <outline text="通知被点击： notification_action_clicked" />
          <outline text="通知栏被点击： notification_clicked" />
          <outline text="通知栏扩展或收缩： notification_expansion" />
          <outline text="新通知显示状态改变： notification_visibility_changed">
            <outline text="新的显示状态，旧的显示状态" />
          </outline>
          <outline text="显示信息栏： notification_panel_revealed" />
          <outline text="隐藏信息栏： notification_panel_hidden" />
          <outline text="模块全部通知取消： notification_cancel_all">
            <outline text="数据： cancel原因，监听者" />
          </outline>
          <outline text="通知取消： notification_cancel">
            <outline text="数据： cancel原因，监听者" />
          </outline>
          <outline text="通知： notification_enqueue">
            <outline text="数据： uid, pid, 包名，id, tag, userid, notificatin, status(0=post, 1=update, 2=ignored)" />
          </outline>
          <outline text="binder溢出： binder_alloc_buf, no vma" />
          <outline text="binder超时: audioserver_binder_timeout (command|3)" />
          <outline text="接收广播： received broadcast|onReceive， 太多，请直接搜广播名" />
          <outline text="忽略特定广播： am_broadcast_discard_filter|am_broadcast_discard_app">
            <outline text="数据： (User|1|5),(Broadcast|1|5),(Action|3),(Receiver Number|1|1),(BroadcastFilter|1|5) / (App|3)" />
            <outline text="原因可能是: timeout/ANR/crash." />
          </outline>
        </outline>
        <outline text="Provider / SQL">
          <outline text="数据库更新： onSharedPreferenceChanged" />
          <outline text="provider没有准备好： am_provider_lost_process" />
          <outline text="数据库操作: db_sample">
            <outline text="数据格式: (db|3),(sql|3),(time|1|3),(blocking_package|3),(sample_percent|1|6)" />
            <outline text="db：数据库的文件名" />
            <outline text="sql：已执行的查询（无查询参数）" />
            <outline text="time：cpu时间毫秒（不是墙上时间），包括锁定获取" />
            <outline text="blocking_package：如果在主线程上，则为程序包名称，否则为“”" />
            <outline text="sample_percent：记录此查询的可能性百分比" />
          </outline>
          <outline text="数据库更新: ***_upgrade_receiver (time|2|3)" />
          <outline text="sqlite_mem_alarm_current (current|1|2)" />
          <outline text="sqlite_mem_alarm_max (max|1|2)" />
          <outline text="sqlite_mem_alarm_alloc_attempt (attempts|1|4)" />
          <outline text="sqlite_mem_released (Memory released|1|2)" />
          <outline text="sqlite_db_corrupt (Database file corrupt|3)" />
        </outline>
        <outline text="PackageManagerService">
          <outline text="Package Manager starts: boot_progress_pms_start (time|2|3)" />
          <outline text="Package Manager .apk scan starts: boot_progress_pms_system_scan_start (time|2|3)" />
          <outline text="Package Manager .apk scan starts: boot_progress_pms_data_scan_start (time|2|3)" />
          <outline text="Package Manager .apk scan ends: boot_progress_pms_scan_end (time|2|3)" />
          <outline text="Package Manager ready: boot_progress_pms_ready (time|2|3)" />
          <outline text="check activity_launch_time for Home app: Value of &quot;unknown sources&quot; setting at app install time:  unknown_sources_enabled (value|1)" />
          <outline text="Package Manager critical info: pm_critical_info (msg|3)" />
          <outline text="Disk usage stats for verifying quota correctness: pm_package_stats ">
            <outline text="数据: (manual_time|2|3),(quota_time|2|3),(manual_data|2|2),(quota_data|2|2),(manual_cache|2|2),(quota_cache|2|2)" />
          </outline>
        </outline>
        <outline text="WiFi / 网络">
          <outline text="网络流量统计： netstats_mobile_sample">
            <outline text="字段太多，网上补充" />
          </outline>
          <outline text="Wifi 流量统计： netstats_wifi_sample">
            <outline text="字段太多，网上补充" />
          </outline>
          <outline text="wifi状态改变: wifi_state_changed (wifi_state|3)" />
          <outline text="事件分发: wifi_event_handled (wifi_event|1|5)">
            <outline text="[15 - 0] HSM event (as defined in WifiStateTracker.java)" />
          </outline>
          <outline text="Supplicant状态改变: wifi_supplicant_state_changed (supplicant_state|1|5)">
            <outline text="[8 - 0] Supplicant state (as defined in SupplicantState.java)" />
          </outline>
        </outline>
        <outline text="Location">
          <outline text="定位成功, 上报位置数据: location_controller" />
        </outline>
        <outline text="应用">
          <outline text="GMS拒绝注册: gms_unknown" />
          <outline text="联系人数量和查询时间: contacts_aggregation (aggregation time|2|3), (count|1|1)">
            <outline text="查询阶段 count为负，合并阶段 count为正." />
          </outline>
          <outline text="菜单项被选中: menu_item_selected">
            <outline text="数据格式: (Menu type where 0 is options and 1 is context|1|5), (Menu item title|3)" />
          </outline>
          <outline text="菜单打开: menu_opened">
            <outline text="数据格式: (Menu type where 0 is options and 1 is context|1|5)" />
          </outline>
          <outline text="锁屏类型: lock_screen_type (type|3)" />
          <outline text="" />
        </outline>
        <outline text="Web / HTTP / WebView">
          <outline text="NTP成功: ntp_success (server|3),(rtt|2),(offset|2)" />
          <outline text="NTP失败: ntp_failure (server|3),(msg|3)" />
          <outline text="http_stats (useragent|3),(response|2|3),(processing|2|3),(tx|1|2),(rx|1|2)" />
          <outline text="viewroot_layout (Layout time|1|3)" />
          <outline text="view_build_drawing_cache (View created drawing cache|1|5)" />
          <outline text="view_use_drawing_cache (View drawn using bitmap cache|1|5)" />
          <outline text="browser_zoom_level_change (start level|1|5),(end level|1|5),(time|2|3)" />
          <outline text="viewroot_draw (Draw time|1|3)" />
          <outline text="browser_double_tap_duration (duration|1|3),(time|2|3)" />
          <outline text="browser_snap_center" />
          <outline text="exp_det_attempt_to_call_object_getclass (app_signature|3)" />
        </outline>
        <outline text="LibC异常">
          <outline text="bionic_event_memcpy_buffer_overflow (uid|1)" />
          <outline text="bionic_event_strcat_buffer_overflow (uid|1)" />
          <outline text="bionic_event_memmov_buffer_overflow (uid|1)" />
          <outline text="bionic_event_strncat_buffer_overflow (uid|1)" />
          <outline text="bionic_event_strncpy_buffer_overflow (uid|1)" />
          <outline text="bionic_event_memset_buffer_overflow (uid|1)" />
          <outline text="bionic_event_strcpy_buffer_overflow (uid|1)" />
          <outline text="bionic_event_strcat_integer_overflow (uid|1)" />
          <outline text="bionic_event_strncat_integer_overflow (uid|1)" />
          <outline text="bionic_event_resolver_old_response (uid|1)" />
          <outline text="bionic_event_resolver_wrong_server (uid|1)" />
          <outline text="bionic_event_resolver_wrong_query (uid|1)" />
          <outline text="exp_det_cert_pin_failure (certs|4)" />
        </outline>
        <outline text="systemui">
          <outline text="sysui_view_visibility (category|1|5),(visible|1|6)" />
          <outline text="sysui_action (category|1|5),(pkg|3)" />
          <outline text="sysui_multi_action (content|4)" />
          <outline text="sysui_count (name|3),(increment|1)" />
          <outline text="sysui_histogram (name|3),(bucket|1)" />
        </outline>
        <outline text="时区">
          <outline text="时区： timezone" />
          <outline text="timezone_check_trigger_received (token_bytes|3)" />
          <outline text="timezone_check_read_from_data_app (token_bytes|3)" />
          <outline text="timezone_check_request_uninstall (token_bytes|3)" />
          <outline text="timezone_check_request_install (token_bytes|3)" />
          <outline text="timezone_check_request_nothing (token_bytes|3), (success|1)" />
        </outline>
      </outline>
      <outline text="&lt;b&gt;10-Activity&lt;/b&gt;">
        <outline text="&lt;b&gt;Application类&lt;/b&gt;">
          <outline text="一个虚拟机线程中只会有一个Application对象, 该对象的生命周期和线程相同." />
          <outline text="Application的实质是一个Context, 它继承ContextWrapper。" />
          <outline text="由于在Context中可以通过 getApplicationContext()获取到 Application对象，或者是通过Activity.getApplication()、Service.getApplication()获取到Application(都是同一个对象)，所以可以在Application保存全局的数据，供所有的Activity或者是Service使用。" />
        </outline>
        <outline text="Activity生命周期 #面试题 ">
          <outline text="Activity生命周期图, 要看图.  @iChart " />
          <outline text="&lt;b&gt;onCreate &lt;/b&gt;: Activity被创建时被回调，是生命周期第一个调用的方法，我们在创建Activity时一般会重写该方法做一些初始化的操作，如通过 setContentView 设置界面布局的资源，初始化所需要的组件信息等。" />
          <outline text="&lt;b&gt;onStart &lt;/b&gt;: Activity正在启动时回调，此时Activity已处于可见状态，但是还没有在前台显示，因此无法与用户进行交互。" />
          <outline text="&lt;b&gt;onResume &lt;/b&gt;: 当此方法回调时，则说明Activity已在前台可见，可与用户交互了, 即activity处于 Active/Running形态.">
            <outline text="onResume与onStart的相同点是两者都表示Activity可见；" />
            <outline text="不同点是onStart时Activity还在后台无法与用户交互，而onResume则表示已显示在前台，可与用户交互。" />
            <outline text="当Activity停止后（ onPause 方法和 onStop方法被调用），重新回到前台时也会调用onResume方法." />
            <outline text="可以在onResume方法中初始化一些资源，比如重新初始化在 onPause 或者 onStop 方法中释放的资源。" />
          </outline>
          <outline text="&lt;b&gt;onPause &lt;/b&gt;: Activity被切换到后台或停止的时候回调, 此时activity进入 Paused形态. 一般情况下 onStop方法接下来会马上被回调。">
            <outline text="在onPause中我们可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示. &lt;b&gt;因为旧activity的 onPause方法执行完成后，新Activity的onResume方法才会被执行。&lt;/b&gt;" />
            <outline text="onPause()和onStop()的区别是：前者是旧Activity还可见的状态；后者是旧Activity已经不可见。" />
            <outline text="AlertDialog 和 PopWindow 不会触发onPause()和onStop()." />
            <outline text="有一种极端情况是onPause方法执行后马上执行了onResume方法，一般是用户操作使当前Activity退居后台后又迅速切回来，此时onResume方法就会被回调。" />
          </outline>
          <outline text="&lt;b&gt;onStop &lt;/b&gt;: 一般在onPause执行完成时回调，表示Activity即将停止进入Stopped形态，此时Activity不可见，仅在后台运行。在onStop方法可以做一些资源释放的操作（不能太耗时）。" />
          <outline text="&lt;b&gt;onRestart &lt;/b&gt;: 表示Activity正在重新启动，当Activity由&lt;b&gt;onStop&lt;/b&gt;() 状态切换回前台时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。" />
          <outline text="&lt;b&gt;onDestroy &lt;/b&gt;: 此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做最终的资源释放。" />
          <outline text="总结下: ">
            <outline text="Activity第一启动的时候执行: onCreate() -&amp;gt; onStart() -&amp;gt; onResume(). " />
            <outline text="如果再有启动同一Activity的时候, 执行: onNewIntent() -&amp;gt; onResart() -&amp;gt; onStart() -&amp;gt; onResume()." />
            <outline text="如果android系统由于内存不足把已存在Activity释放掉了，那么再次调用的时候会重新启动Activity, 即执行: onCreate() -&amp;gt; onStart() -&amp;gt; onResume()。" />
          </outline>
        </outline>
        <outline text="横竖屏切换 #面试题">
          <outline text="横竖屏切换的时候会销毁当前的Activity然后重新创建一个. " />
          <outline text="横竖屏切换时会走这个生命周期：onPause -&amp;gt; onStop -&amp;gt; onDestory -&amp;gt; onCreate -&amp;gt; onStart -&amp;gt; onResume" />
          <outline text="准备两套不同的布局，Android会自己根据横竖屏加载不同布局. 创建两个布局文件夹：">
            <outline text="layout-land: 横屏" />
            <outline text="layout-port: 竖屏" />
          </outline>
          <outline text="在onCreate()方法中判断横竖屏">
            <outline text="if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE){">
              <outline text="setContentView(R.layout.横屏);" />
            </outline>
            <outline text="} else if (this.getResources().getConfiguration().orientation ==Configuration.ORIENTATION_PORTRAIT) {">
              <outline text="setContentView(R.layout.竖屏);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="" />
        </outline>
        <outline text="禁止屏幕横竖屏自动切换">
          <outline text="在AndroidManifest.xml中为Act添加一个属性： android:screenOrientation, 值域是:" />
          <outline text="unspecified: 默认值.由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向。" />
          <outline text="landscape: 横屏显示（宽比高要长）" />
          <outline text="portrait: 竖屏显示(高比宽要长)" />
          <outline text="user: 用户当前首选的方向" />
          <outline text="behind: 和Activity堆栈中前面那个Activity的方向一致." />
          <outline text="sensor: 有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。" />
          <outline text="nosensor: 忽略物理感应器，这样就不会随着用户旋转设备而更改了（&quot;unspecified&quot;设置除外）。" />
        </outline>
        <outline text="系统给我们提供的常见的Activity">
          <outline text="拨打电话">
            <outline text="// 给移动客服10086拨打电话" />
            <outline text="Uri uri = Uri.parse(&quot;tel:10086&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_DIAL, uri);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="发送短信">
            <outline text="// 给10086发送内容为“Hello”的短信" />
            <outline text="Uri uri = Uri.parse(&quot;smsto:10086&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_SENDTO, uri);" />
            <outline text="intent.putExtra(&quot;sms_body&quot;, &quot;Hello&quot;);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="发送彩信（相当于发送带附件的短信）">
            <outline text="Intent intent = new Intent(Intent.ACTION_SEND);" />
            <outline text="intent.putExtra(&quot;sms_body&quot;, &quot;Hello&quot;);" />
            <outline text="Uri uri = Uri.parse(&quot;content://media/external/images/media/23&quot;);" />
            <outline text="intent.putExtra(Intent.EXTRA_STREAM, uri);" />
            <outline text="intent.setType(&quot;image/png&quot;);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="打开浏览器">
            <outline text="Uri uri = Uri.parse(&quot;http://www.baidu.com&quot;);" />
            <outline text="Intent intent  = new Intent(Intent.ACTION_VIEW, uri);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="发送电子邮件(阉割了Google服务的没戏)">
            <outline text="Uri uri = Uri.parse(&quot;mailto:someone@domain.com&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_SENDTO, uri);" />
            <outline text="startActivity(intent);" />
            <outline text="// 给someone@domain.com发邮件发送内容为“Hello”的邮件" />
            <outline text="Intent intent = new Intent(Intent.ACTION_SEND);" />
            <outline text="intent.putExtra(Intent.EXTRA_EMAIL, &quot;someone@domain.com&quot;);" />
            <outline text="intent.putExtra(Intent.EXTRA_SUBJECT, &quot;Subject&quot;);" />
            <outline text="intent.putExtra(Intent.EXTRA_TEXT, &quot;Hello&quot;);" />
            <outline text="intent.setType(&quot;text/plain&quot;);" />
            <outline text="startActivity(intent);" />
            <outline text="// 给多人发邮件" />
            <outline text="Intent intent=new Intent(Intent.ACTION_SEND);" />
            <outline text="String[] tos = {&quot;1@abc.com&quot;, &quot;2@abc.com&quot;}; // 收件人" />
            <outline text="String[] ccs = {&quot;3@abc.com&quot;, &quot;4@abc.com&quot;}; // 抄送" />
            <outline text="String[] bccs = {&quot;5@abc.com&quot;, &quot;6@abc.com&quot;}; // 密送" />
            <outline text="intent.putExtra(Intent.EXTRA_EMAIL, tos);" />
            <outline text="intent.putExtra(Intent.EXTRA_CC, ccs);" />
            <outline text="intent.putExtra(Intent.EXTRA_BCC, bccs);" />
            <outline text="intent.putExtra(Intent.EXTRA_SUBJECT, &quot;Subject&quot;);" />
            <outline text="intent.putExtra(Intent.EXTRA_TEXT, &quot;Hello&quot;);" />
            <outline text="intent.setType(&quot;message/rfc822&quot;);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="显示地图">
            <outline text="// 打开Google地图中国北京位置（北纬39.9，东经116.3）" />
            <outline text="Uri uri = Uri.parse(&quot;geo:39.9,116.3&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_VIEW, uri);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="路径规划">
            <outline text="// 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4）" />
            <outline text="Uri uri = Uri.parse(&quot;http://maps.google.com/maps?f=d&amp;amp;saddr=39.9 116.3&amp;amp;daddr=31.2 121.4&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_VIEW, uri);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="多媒体播放">
            <outline text="Intent intent = new Intent(Intent.ACTION_VIEW);" />
            <outline text="Uri uri = Uri.parse(&quot;file:///sdcard/foo.mp3&quot;);" />
            <outline text="intent.setDataAndType(uri, &quot;audio/mp3&quot;);" />
            <outline text="startActivity(intent);" />
            <outline text="// 获取SD卡下所有音频文件,然后播放第一首=-=" />
            <outline text="Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, &quot;1&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_VIEW, uri);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="打开摄像头拍照">
            <outline text="// 打开拍照程序" />
            <outline text="Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);" />
            <outline text="startActivityForResult(intent, 0);" />
            <outline text="// 取出照片数据" />
            <outline text="Bundle extras = intent.getExtras();" />
            <outline text="Bitmap bitmap = (Bitmap) extras.get(&quot;data&quot;);" />
          </outline>
          <outline text="调用系统相机应用程序，并存储拍下来的照片">
            <outline text="Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);" />
            <outline text="time = Calendar.getInstance().getTimeInMillis();" />
            <outline text="intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment" />
            <outline text=".getExternalStorageDirectory().getAbsolutePath()+&quot;/tucue&quot;, time + &quot;.jpg&quot;)));" />
            <outline text="startActivityForResult(intent, ACTIVITY_GET_CAMERA_IMAGE);" />
          </outline>
          <outline text="获取并剪切图片">
            <outline text="// 获取并剪切图片" />
            <outline text="Intent intent = new Intent(Intent.ACTION_GET_CONTENT);" />
            <outline text="intent.setType(&quot;image/*&quot;);" />
            <outline text="intent.putExtra(&quot;crop&quot;, &quot;true&quot;); // 开启剪切" />
            <outline text="intent.putExtra(&quot;aspectX&quot;, 1); // 剪切的宽高比为1：2" />
            <outline text="intent.putExtra(&quot;aspectY&quot;, 2);" />
            <outline text="intent.putExtra(&quot;outputX&quot;, 20); // 保存图片的宽和高" />
            <outline text="intent.putExtra(&quot;outputY&quot;, 40);" />
            <outline text="intent.putExtra(&quot;output&quot;, Uri.fromFile(new File(&quot;/mnt/sdcard/temp&quot;))); // 保存路径" />
            <outline text="intent.putExtra(&quot;outputFormat&quot;, &quot;JPEG&quot;);// 返回格式" />
            <outline text="startActivityForResult(intent, 0);" />
            <outline text="// 剪切特定图片" />
            <outline text="Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);" />
            <outline text="intent.setClassName(&quot;com.android.camera&quot;, &quot;com.android.camera.CropImage&quot;);" />
            <outline text="intent.setData(Uri.fromFile(new File(&quot;/mnt/sdcard/temp&quot;)));" />
            <outline text="intent.putExtra(&quot;outputX&quot;, 1); // 剪切的宽高比为1：2" />
            <outline text="intent.putExtra(&quot;outputY&quot;, 2);" />
            <outline text="intent.putExtra(&quot;aspectX&quot;, 20); // 保存图片的宽和高" />
            <outline text="intent.putExtra(&quot;aspectY&quot;, 40);" />
            <outline text="intent.putExtra(&quot;scale&quot;, true);" />
            <outline text="intent.putExtra(&quot;noFaceDetection&quot;, true);" />
            <outline text="intent.putExtra(&quot;output&quot;, Uri.parse(&quot;file:///mnt/sdcard/temp&quot;));" />
            <outline text="startActivityForResult(intent, 0);" />
          </outline>
          <outline text="打开Google Market">
            <outline text="// 打开Google Market直接进入该程序的详细页面" />
            <outline text="Uri uri = Uri.parse(&quot;market://details?id=&quot; + &quot;com.demo.app&quot;);" />
            <outline text="Intent intent = new Intent(Intent.ACTION_VIEW, uri);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="进入手机设置界面">
            <outline text="// 进入无线网络设置界面（其它可以举一反三）" />
            <outline text="Intent intent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);" />
            <outline text="startActivityForResult(intent, 0);" />
          </outline>
          <outline text="安装apk">
            <outline text="Uri installUri = Uri.fromParts(&quot;package&quot;, &quot;xxx&quot;, null);" />
            <outline text="returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);" />
          </outline>
          <outline text="卸载apk">
            <outline text="Uri uri = Uri.fromParts(&quot;package&quot;, strPackageName, null);" />
            <outline text="Intent it = new Intent(Intent.ACTION_DELETE, uri);" />
            <outline text="startActivity(it);" />
          </outline>
          <outline text="发送附件">
            <outline text="Intent it = new Intent(Intent.ACTION_SEND);" />
            <outline text="it.putExtra(Intent.EXTRA_SUBJECT, &quot;The email subject text&quot;);" />
            <outline text="it.putExtra(Intent.EXTRA_STREAM, &quot;file:///sdcard/eoe.mp3&quot;);" />
            <outline text="sendIntent.setType(&quot;audio/mp3&quot;);" />
            <outline text="startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;));" />
          </outline>
          <outline text="进入联系人页面">
            <outline text="Intent intent = new Intent();" />
            <outline text="intent.setAction(Intent.ACTION_VIEW);" />
            <outline text="intent.setData(People.CONTENT_URI);" />
            <outline text="startActivity(intent);" />
          </outline>
          <outline text="查看指定联系人">
            <outline text="Uri personUri = ContentUris.withAppendedId(People.CONTENT_URI, info.id);  //info.id联系人ID" />
            <outline text="Intent intent = new Intent();" />
            <outline text="intent.setAction(Intent.ACTION_VIEW);" />
            <outline text="intent.setData(personUri);" />
            <outline text="startActivity(intent);" />
          </outline>
        </outline>
        <outline text="Activity间的数据传递 #面试题 ">
          <outline text="&lt;b&gt;Intent &lt;/b&gt;it = new Intent(MyActivity.this, MyActivity2.class);" />
          <outline text="&lt;b&gt;Bundle &lt;/b&gt;bd = new Bundle();   // // 新建Bundle对象,并把数据写入" />
          <outline text="bd.putCharSequence(&quot;user&quot;,name);" />
          <outline text="bd.putCharSequence(&quot;sex&quot;,sex);" />
          <outline text="it.&lt;b&gt;putExtras&lt;/b&gt;(bd);  // 将数据包Bundle绑定到Intent上" />
          <outline text="startActivity(it);   // 启动第二个activity" />
          <outline text="finish();   // 关闭第一个Activity" />
        </outline>
        <outline text="一次性关闭所有Activity">
          <outline text="public class ActivityCollector {">
            <outline text="// 用一个list集合来存储所有Activity" />
            <outline text="public static LinkedList&amp;lt;Activity&amp;gt; activities = new LinkedList&amp;lt;Activity&amp;gt;();" />
            <outline text="public static void addActivity(Activity activity) {">
              <outline text="activities.add(activity);" />
            </outline>
            <outline text="}" />
            <outline text="public static void removeActivity(Activity activity) {">
              <outline text="activities.remove(activity);" />
            </outline>
            <outline text="}" />
            <outline text="public static void finishAll() {">
              <outline text="for(Activity activity:activities) {">
                <outline text="if(!activity.isFinishing()) {">
                  <outline text="activity.finish();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="假如app中所有的activity 都继承自 BaseActivity.  在它的 onCreate() 中调用 ActivityCollector.addActivity(this);  在 onDestory() 中调用 ActivityCollector.removeActivity()." />
          <outline text="然后在任何地方调用 ActivityCollector.finishAll() 即可关闭所有的activity." />
        </outline>
        <outline text="完全退出App">
          <outline text="上面是关闭所有的activity, 但是app并没有退出, 因为还有service. " />
          <outline text="下面是完全退出app的代码:" />
          <outline text="public void AppExit(Context context) {">
            <outline text="try {">
              <outline text="ActivityCollector.finishAll();" />
              <outline text="ActivityManager activityMgr = (ActivityManager) context">
                <outline text=".getSystemService(Context.ACTIVITY_SERVICE);" />
              </outline>
              <outline text="activityMgr.killBackgroundProcesses(context.getPackageName());" />
              <outline text="System.exit(0);" />
            </outline>
            <outline text="} catch (Exception ignored) {}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="为Activity设置过场动画">
          <outline text="过场动画就是切换到另外的Activity时加上一些切换动画，比如淡入淡出，放大缩小，左右互推等." />
          <outline text="" />
          <outline text="通过style进行配置，这个是全局的哦，就是所有的Activity都会加载这个动画." />
          <outline text="(1) 在style.xml中自定义style：" />
          <outline text="&amp;lt;!-- 默认Activity跳转动画 --&amp;gt;" />
          <outline text="&amp;lt;style name=&quot;default_animation&quot; mce_bogus=&quot;1&quot; parent=&quot;@android:style/Animation.Activity&quot;&amp;gt;">
            <outline text="&amp;lt;item name=&quot;android:activityOpenEnterAnimation&quot;&amp;gt;@anim/default_anim_in&amp;lt;/item&amp;gt;" />
            <outline text="&amp;lt;item name=&quot;android:activityOpenExitAnimation&quot;&amp;gt;@anim/anim_stay&amp;lt;/item&amp;gt;" />
            <outline text="&amp;lt;item name=&quot;android:activityCloseEnterAnimation&quot;&amp;gt;@anim/anim_stay&amp;lt;/item&amp;gt;" />
            <outline text="&amp;lt;item name=&quot;android:activityCloseExitAnimation&quot;&amp;gt;@anim/default_anim_out&amp;lt;/item&amp;gt;" />
          </outline>
          <outline text="&amp;lt;/style&amp;gt;" />
          <outline text="4个item分别代表:" />
          <outline text="Activity A跳转到Activity B时Activity B进入动画;" />
          <outline text="Activity A跳转到Activity B时Activity A退出动画;" />
          <outline text="Activity B返回Activity A时Activity A的进入动画" />
          <outline text="Activity B返回Activity A时ActivityB的退出动画" />
          <outline text="&lt;b&gt;(2) 然后修改下AppTheme:&lt;/b&gt;&amp;lt;style name=&quot;AppTheme&quot; mce_bogus=&quot;1&quot; parent=&quot;@android:style/Theme.Light&quot;&amp;gt;">
            <outline text="&amp;lt;item name=&quot;android:windowAnimationStyle&quot;&amp;gt;@style/default_animation&amp;lt;/item&amp;gt;" />
            <outline text="&amp;lt;item name=&quot;android:windowNoTitle&quot;&amp;gt;true&amp;lt;/item&amp;gt;" />
          </outline>
          <outline text="&amp;lt;/style&amp;gt;" />
          <outline text="&lt;b&gt;(3) 最后在appliction设置下：&lt;/b&gt;" />
          <outline text="&amp;lt;application">
            <outline text="android:icon=&quot;@drawable/logo&quot;" />
            <outline text="android:label=&quot;@string/app_name&quot;" />
            <outline text="android:theme=&quot;@style/AppTheme&quot; &amp;gt;" />
          </outline>
        </outline>
        <outline text="设置Activity全屏">
          <outline text="1. 代码隐藏ActionBar">
            <outline text="在Activity的onCreate方法中调用getActionBar.hide();即可" />
          </outline>
          <outline text="2. 通过requestWindowFeature设置">
            <outline text="requestWindowFeature(Window.FEATURE_NO_TITLE);  // 需要在setContentView ()之前调用. " />
            <outline text="把 requestWindowFeature(Window.FEATURE_NO_TITLE); 放在super.onCreate(savedInstanceState);前面就可以隐藏ActionBar而不报错。" />
          </outline>
          <outline text="3. 通过AndroidManifest.xml的theme">
            <outline text="在需要全屏的Activity的标签内设置 theme = @android:style/Theme.NoTitleBar.FullScreen" />
          </outline>
        </outline>
        <outline text="定义对话框风格的Activity">
          <outline text="Activity一般是占满全屏的， 而Dialog则是占据部分屏幕的." />
          <outline text="直接设置下Activity的theme: android:theme=&quot;@android:style/Theme.Dialog&quot; 即可." />
          <outline text="// 然后再设置左上角小图标" />
          <outline text="requestWindowFeature(Window.FEATURE_LEFT_ICON);" />
          <outline text="setContentView(R.layout.main);" />
          <outline text="getWindow().setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, android.R.drawable.ic_lion_icon);" />
          <outline text="// 设置文字:" />
          <outline text="setTitle(R.string.actdialog_title);  //XML代码中设置:android:label=&quot;@string/activity_dialog&quot;" />
        </outline>
        <outline text="开源中国客户端Activity管理类 --还在哪里?">
          <outline text="package net.oschina.app;" />
          <outline text="import java.util.Stack;" />
          <outline text="import android.app.Activity;" />
          <outline text="import android.app.ActivityManager;" />
          <outline text="import android.content.Context;" />
          <outline text="public class AppManager {">
            <outline text="private static Stack&amp;lt;Activity&amp;gt; activityStack;" />
            <outline text="private static AppManager instance;" />
            <outline text="private AppManager(){}" />
            <outline text="/* 单一实例 */" />
            <outline text="public static AppManager getAppManager(){">
              <outline text="if(instance==null){">
                <outline text="instance=new AppManager();" />
              </outline>
              <outline text="}" />
              <outline text="return instance;" />
            </outline>
            <outline text="}" />
            <outline text="/**">
              <outline text="添加Activity到堆栈" />
              <outline text="*/" />
            </outline>
            <outline text="public void addActivity(Activity activity){">
              <outline text="if(activityStack==null){">
                <outline text="activityStack=new Stack&amp;lt;Activity&amp;gt;();" />
              </outline>
              <outline text="}" />
              <outline text="activityStack.add(activity);" />
            </outline>
            <outline text="}" />
            <outline text="/* 获取当前Activity（堆栈中最后一个压入的） */" />
            <outline text="public Activity currentActivity(){">
              <outline text="Activity activity=activityStack.lastElement();" />
              <outline text="return activity;" />
            </outline>
            <outline text="}" />
            <outline text="/* 结束当前Activity（堆栈中最后一个压入的） */" />
            <outline text="public void finishActivity(){">
              <outline text="Activity activity=activityStack.lastElement();" />
              <outline text="finishActivity(activity);" />
            </outline>
            <outline text="}" />
            <outline text="/**">
              <outline text="结束指定的Activity" />
              <outline text="*/" />
            </outline>
            <outline text="public void finishActivity(Activity activity){">
              <outline text="if(activity!=null){">
                <outline text="activityStack.remove(activity);" />
                <outline text="activity.finish();" />
                <outline text="activity=null;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="/* 结束指定类名的Activity */" />
            <outline text="public void finishActivity(Class&amp;lt;?&amp;gt; cls){">
              <outline text="for (Activity activity : activityStack) {">
                <outline text="if(activity.getClass().equals(cls) ){">
                  <outline text="finishActivity(activity);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="/* 结束所有Activity */" />
            <outline text="public void finishAllActivity(){">
              <outline text="for (int i = 0, size = activityStack.size(); i &amp;lt; size; i++){">
                <outline text="if (null != activityStack.get(i)){">
                  <outline text="activityStack.get(i).finish();" />
                </outline>
                <outline text="}" />
                <outline text="activityStack.clear();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="/* 退出应用程序 */" />
            <outline text="public void AppExit(Context context) {">
              <outline text="try {">
                <outline text="finishAllActivity();" />
                <outline text="ActivityManager activityMgr= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);" />
                <outline text="activityMgr.restartPackage(context.getPackageName());" />
                <outline text="System.exit(0);" />
              </outline>
              <outline text="} catch (Exception e) {    }" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
      </outline>
      <outline text="11-View">
        <outline text="https://www.runoob.com/w3cnote/android-tutorial-intro.html" />
        <outline text="Android的图形界面都是由 View和 ViewGroup以及他们的子类构成的.">
          <outline text="View：所有可视化控件的父类,提供组件描绘和时间处理方法." />
          <outline text="ViewGroup：View类的子类，可以拥有子控件,可以看作是容器." />
        </outline>
        <outline text="View的可见性">
          <outline text="View.VISIBLE: 0, 可见." />
          <outline text="View.INCISIBLE: 4, 不可见. 占用layout空间, 不重新绘制." />
          <outline text="View,GONE: 8, 不可见. 不再占用layout空间, 会重新绘制." />
        </outline>
        <outline text="查看当前窗口的Layout">
          <outline text="AS/IDEA: Tools - Layout Inspector" />
          <outline text="AS monitor: &quot;Open Perspective&quot; - &quot;Hierarchy View&quot; - &quot;Tree View&quot;" />
        </outline>
        <outline text="&lt;b&gt;7种布局&lt;/b&gt;">
          <outline text="LinearLayout: 线性布局">
            <outline text="weight(权重)属性，等比例划分, 非常强大." />
            <outline text="缺点: 当界面比较复杂的时候，需要嵌套多层的 LinearLayout,这样就会降低UI Render的效率(渲染速度),而且如果是 listview或者 GridView上的 item,效率会更低." />
          </outline>
          <outline text="RelativeLayout: 相对布局  --推荐用这个">
            <outline text="优点: 很复杂的界面, 也可以一层搞定." />
            <outline text="根据父容器定位" />
            <outline text="根据兄弟组件定位" />
            <outline text="margin与padding的区别">
              <outline text="margin代表的是偏移,比如 marginleft = &quot;5dp&quot;表示组件离容器左边缘偏移5dp; " />
              <outline text="padding代表的则是填充,而填充的对象针对的是组件中的元素,比如为 TextView 设置paddingleft = &quot;5dp&quot;, 是在组件里的元素的左边填充5dp的空间." />
              <outline text="margin针对的是容器中的组件，而padding针对的是组件中的元素." />
            </outline>
          </outline>
          <outline text="TableLayout: 表格布局">
            <outline text="如果我们直接往 TableLayout 中添加组件的话,那么这个组件将占满一行." />
            <outline text="如果我们想一行上有多个组件的话,就要添加一个 TableRow 的容器,把组件都丢到里面." />
            <outline text="tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定." />
            <outline text="tablerow的 layout_width 属性, 默认是 fill_parent 的, 设置成其他的值也不会生效. 但是layout_height默认是wrapten-content的,我们却可以自己设置大小." />
          </outline>
          <outline text="FrameLayout: 帧布局">
            <outline text="这个布局直接在屏幕上开辟出一块空白的区域,当我们往里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式." />
          </outline>
          <outline text="AbsoluteLayout: 绝对布局  --不要使用这个" />
          <outline text="GridLayout: 网格布局">
            <outline text="GridLayout 相当于 TableLayout的升级版, 较之后者更好用. 比如: ">
              <outline text="可以自己设置布局中组件的排列方式" />
              <outline text="可以自定义网格布局有多少行,多少列" />
              <outline text="可以直接设置组件位于某行某列" />
              <outline text="可以设置组件横跨几行或者几列" />
            </outline>
            <outline text="GridLayout是4.0新增的, 低版本sdk如何使用 GridLayout?">
              <outline text="只需要导入v7包的gridlayout包即可! v7包一般在sdk下的:sdk\extras\android\support\v7\gridlayout目录下." />
              <outline text="用的时候,标签却是这样写的:  &amp;lt;android.support.v7.widget.GridLayout&amp;gt;" />
            </outline>
          </outline>
          <outline text="ConstraintLayout: 约束布局">
            <outline text="它是Android Studio 2.2中主要的新增功能之一。" />
            <outline text="它适合使用可视化的方式来编写界面，而不适合xml方式来编写。" />
            <outline text="它还可以有效地解决布局嵌套过多的问题。" />
            <outline text="为了使用ConstraintLayout，需要在 app/build.gradle 中添加ConstraintLayout的依赖">
              <outline text="dependencies {">
                <outline text="compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4'" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="邮件点击 layout文件，可以把现在的布局改成ConstraintLayout。" />
            <outline text="然后就可以拖控件，安排位置，修改属性了。" />
          </outline>
        </outline>
        <outline text="TextView(文本框)">
          <outline text="&lt;b&gt;id：&lt;/b&gt;为TextView设置一个组件id，根据id，我们可以在Java代码中通过findViewById()的方法获取到该对象，然后进行相关属性的设置，又或者使用RelativeLayout时，参考组件用的也是id！" />
          <outline text="&lt;b&gt;layout_width：&lt;/b&gt;组件的宽度，一般写：**wrap_content**或者**match_parent(fill_parent)**，前者是控件显示的内容多大，控件就多大，而后者会填满该控件所在的父容器；当然也可以设置成特定的大小，比如我这里为了显示效果，设置成了200dp。" />
          <outline text="&lt;b&gt;layout_height：&lt;/b&gt;组件的宽度，内容同上。" />
          <outline text="&lt;b&gt;gravity：&lt;/b&gt;设置控件中内容的对齐方向，TextView中是文字，ImageView中是图片等等。" />
          <outline text="&lt;b&gt;text：&lt;/b&gt;设置显示的文本内容，一般我们是把字符串写到string.xml文件中，然后通过@String/xxx取得对应的字符串内容的." />
          <outline text="&lt;b&gt;textColor：&lt;/b&gt;设置字体颜色，同上，通过 colors.xml资源来引用，别直接这样写！" />
          <outline text="&lt;b&gt;textStyle：&lt;/b&gt;设置字体风格，三个可选值：normal(无效果)，bold(加粗)，italic(斜体)" />
          <outline text="&lt;b&gt;textSize：&lt;/b&gt;字体大小，单位一般是用sp" />
          <outline text="&lt;b&gt;background：&lt;/b&gt;控件的背景颜色，可以理解为填充整个控件的颜色，可以是图片." />
          <outline text="&amp;lt;solid android:color = &quot;xxx&quot;&amp;gt; 这个是设置背景颜色的" />
          <outline text="&amp;lt;stroke android:width = &quot;xdp&quot; android:color=&quot;xxx&quot;&amp;gt; 这个是设置边框的粗细,以及边框颜色的" />
          <outline text="&amp;lt;padding androidLbottom = &quot;xdp&quot;...&amp;gt; 这个是设置边距的" />
          <outline text="&amp;lt;corners android:topLeftRadius=&quot;10px&quot;...&amp;gt; 这个是设置圆角的" />
          <outline text="&amp;lt;gradient&amp;gt; 这个是设置渐变色的,可选属性有: ">
            <outline text="startColor:起始颜色" />
            <outline text="endColor:结束颜色" />
            <outline text="centerColor:中间颜色" />
            <outline text="angle:方向角度,等于0时,从左到右,然后逆时针方向转,当 angle = 90度时从下往上" />
            <outline text="type:设置渐变的类型" />
          </outline>
          <outline text="&amp;lt;corners   // 设置四个圆角的半径">
            <outline text="android:bottomLeftRadius=&quot;10px&quot;" />
            <outline text="android:bottomRightRadius=&quot;10px&quot;" />
            <outline text="android:topLeftRadius=&quot;10px&quot;" />
            <outline text="android:topRightRadius=&quot;10px&quot; /&amp;gt;" />
          </outline>
          <outline text="监听EditText的内容变化">
            <outline text="public class DelEditText extends EditText {">
              <outline text="public DelEditText(Context context, AttributeSet attrs) {">
                <outline text="&lt;b&gt;addTextChangedListener&lt;/b&gt;(new TextWatcher() {">
                  <outline text="public void beforeTextChanged(CharSequence s, int start, int count, int after) {" />
                  <outline text="}" />
                  <outline text="public void onTextChanged(CharSequence s, int start, int before, int count) {" />
                  <outline text="}" />
                  <outline text="public void afterTextChanged(Editable editable) {">
                    <outline text="setDrawable();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="密码输入框的可见和不可见">
            <outline text="private EditText edit_pawd  = (EditText) findViewById(R.id.edit_pawd);" />
            <outline text="edit_pawd.setTransformationMethod(HideReturnsTransformationMethod.getInstance());   // 不可见" />
            <outline text="edit_pawd.setTransformationMethod(PasswordTransformationMethod.getInstance());   // 可见" />
          </outline>
        </outline>
        <outline text="EditText(输入框)">
          <outline text="EditText可以接受用户输入." />
          <outline text="android:hint=&quot;默认提示文本&quot;" />
          <outline text="android:textColorHint=&quot;#95A1AA&quot;  // 设置提示文本的颜色" />
          <outline text="android:selectAllOnFocus=&quot;true&quot;   // 获得焦点后全选组件内所有文本内容" />
          <outline text="android:inputType=&quot;phone&quot;    // 限制 EditText输入类型. 类型相当多, " />
          <outline text="android:maxLines=&quot;3&quot;   // 设置最大的行数" />
          <outline text="android:windowSoftInputMode    // Activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题. 这个属性可影响两件事:">
            <outline text="当有焦点产生时，软键盘是隐藏还是显示" />
            <outline text="是否减少活动主窗口大小以便腾出空间放软键盘. " />
            <outline text="相关属性较多, 可以同时设多个, 如下:" />
            <outline text="stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置" />
            <outline text="stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示" />
            <outline text="stateHidden：用户选择activity时，软键盘总是被隐藏" />
            <outline text="stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的" />
            <outline text="stateVisible：软键盘通常是可见的" />
            <outline text="stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态" />
            <outline text="adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示" />
            <outline text="adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间" />
            <outline text="adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分" />
          </outline>
          <outline text="监听EditText的内容变化">
            <outline text="文本内容 变化的监听器则是：TextWatcher，我们可以调用EditText.addTextChangedListener(mTextWatcher); 为EditText设置内容变化监听！" />
            <outline text="TextWatcher，需实现三个方法：" />
            <outline text="public void beforeTextChanged(CharSequence s, int start,int count, int after);  // 内容变化前" />
            <outline text="public void onTextChanged(CharSequence s, int start, int before, int count);  // 内容变化中" />
            <outline text="public void afterTextChanged(Editable s);  // 内容变化后" />
            <outline text="例子:" />
            <outline text="public class DelEditText extends EditText {">
              <outline text="private Drawable imgClear;" />
              <outline text="private Context mContext;" />
              <outline text="public DelEditText(Context context, AttributeSet attrs) {">
                <outline text="super(context, attrs);" />
                <outline text="this.mContext = context;" />
                <outline text="init();" />
              </outline>
              <outline text="}" />
              <outline text="private void init() {">
                <outline text="imgClear = mContext.getResources().getDrawable(R.drawable.delete_gray);" />
                <outline text="addTextChangedListener(new TextWatcher() {">
                  <outline text="public void beforeTextChanged(CharSequence s, int start, int count, int after) {" />
                  <outline text="}" />
                  <outline text="public void onTextChanged(CharSequence s, int start, int before, int count) {" />
                  <outline text="}" />
                  <outline text="public void afterTextChanged(Editable editable) {">
                    <outline text="setDrawable();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
              <outline text="//绘制删除图片" />
              <outline text="private void setDrawable(){">
                <outline text="if (length() &amp;lt; 1)">
                  <outline text="setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);" />
                </outline>
                <outline text="else">
                  <outline text="setCompoundDrawablesWithIntrinsicBounds(null, null, imgClear, null);" />
                </outline>
              </outline>
              <outline text="}" />
              <outline text="//当触摸范围在右侧时，触发删除方法，隐藏叉叉" />
              <outline text="public boolean onTouchEvent(MotionEvent event) {">
                <outline text="if(imgClear != null &amp;amp;&amp;amp; event.getAction() == MotionEvent.ACTION_UP)" />
                <outline text="{">
                  <outline text="int eventX = (int) event.getRawX();" />
                  <outline text="int eventY = (int) event.getRawY();" />
                  <outline text="Rect rect = new Rect();" />
                  <outline text="getGlobalVisibleRect(rect);" />
                  <outline text="rect.left = rect.right - 100;" />
                  <outline text="if (rect.contains(eventX, eventY))">
                    <outline text="setText(&quot;&quot;);" />
                  </outline>
                </outline>
                <outline text="}" />
                <outline text="return super.onTouchEvent(event);" />
              </outline>
              <outline text="}" />
              <outline text="protected void finalize() throws Throwable {">
                <outline text="super.finalize();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="实现EditText的密码可见与不可见">
            <outline text="例子:" />
            <outline text="public class MainActivity extends AppCompatActivity {">
              <outline text="private EditText edit_pawd;" />
              <outline text="private Button btnChange;" />
              <outline text="private boolean flag = false;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="edit_pawd = (EditText) findViewById(R.id.edit_pawd);" />
                <outline text="btnChange = (Button) findViewById(R.id.btnChange);" />
                <outline text="edit_pawd.setHorizontallyScrolling(true);    //设置EditText不换行" />
                <outline text="btnChange.setOnClickListener(new View.OnClickListener() {">
                  <outline text="public void onClick(View view) {">
                    <outline text="if(flag == true){">
                      <outline text="edit_pawd.setTransformationMethod(HideReturnsTransformationMethod.getInstance());" />
                      <outline text="flag = false;" />
                      <outline text="btnChange.setText(&quot;密码不可见&quot;);" />
                    </outline>
                    <outline text="} else {">
                      <outline text="edit_pawd.setTransformationMethod(PasswordTransformationMethod.getInstance());" />
                      <outline text="flag = true;" />
                      <outline text="btnChange.setText(&quot;密码可见&quot;);" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="Button(按钮)与ImageButton(图像按钮)">
          <outline text="Button是TextView的子类，所以TextView上很多属性也可以应用到Button 上." />
          <outline text="StateListDrawable是Drawable资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点 &amp;lt; selector &amp;gt;，我们只需要将Button的background属性设置为该drawable资源即可轻松实现，按下 按钮时不同的按钮颜色或背景." />
          <outline text="drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~" />
          <outline text="state_focused:是否获得焦点" />
          <outline text="state_window_focused:是否获得窗口焦点" />
          <outline text="state_enabled:控件是否可用" />
          <outline text="state_checkable:控件可否被勾选, eg:checkbox" />
          <outline text="state_checked:控件是否被勾选" />
          <outline text="state_selected:控件是否被选择,针对有滚轮的情况" />
          <outline text="state_pressed:控件是否被按下" />
          <outline text="state_active:控件是否处于活动状态,eg:slidingTab" />
          <outline text="state_single:控件包含多个子控件时,确定是否只显示一个子控件" />
          <outline text="state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态" />
          <outline text="state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态" />
          <outline text="state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态" />
        </outline>
        <outline text="ImageView(图像视图)">
          <outline text="ImageView有两个可以设置图片的属性，分别是：src和 background">
            <outline text="background通常指的都是背景,而src指的是内容" />
            <outline text="当使用src填入图片时,是按照图片大小直接填充,并不会进行拉伸" />
            <outline text="而使用 background填入图片,则是会根据 ImageView给定的宽度来进行拉伸" />
          </outline>
          <outline text="src + background 可以实现融入效果.">
            <outline text="找一张透明的png图片 + 设置一个黑色的背景" />
            <outline text="&amp;lt;ImageView">
              <outline text="android:layout_width=&quot;150dp&quot;" />
              <outline text="android:layout_height=&quot;wrap_content&quot;" />
              <outline text="android:src=&quot;@drawable/pig&quot;" />
              <outline text="android:background=&quot;#6699FF&quot; /&amp;gt;" />
            </outline>
          </outline>
          <outline text="Java代码中设置 blackground和 src属性">
            <outline text="前景(对应src属性): setImageDrawable( );" />
            <outline text="背景(对应background属性): setBackgroundDrawable( );" />
          </outline>
          <outline text="adjustViewBounds设置缩放是否保存原图长宽比">
            <outline text="ImageView为我们提供了adjustViewBounds属性，用于设置缩放时是否保持原图长宽比！ 单独设置不起作用，需要配合maxWidth和maxHeight属性一起使用！而后面这两个属性 也是需要adjustViewBounds为true才会生效的~" />
            <outline text="android:maxHeight:设置ImageView的最大高度" />
            <outline text="android:maxWidth:设置ImageView的最大宽度" />
          </outline>
          <outline text="scaleType设置缩放类型">
            <outline text="android:scaleType用于设置显示的图片如何缩放或者移动以适应ImageView的大小 Java代码中可以通过imageView.setScaleType(ImageView.ScaleType.CENTER);来设置~ 可选值如下：" />
            <outline text="fitXY:对图像的横向与纵向进行独立缩放,使得该图片完全适应ImageView,但是图片的横纵比可能会发生改变" />
            <outline text="fitStart:保持纵横比缩放图片,知道较长的边与Image的编程相等,缩放完成后将图片放在ImageView的左上角" />
            <outline text="fitCenter:同上,缩放后放于中间;" />
            <outline text="fitEnd:同上,缩放后放于右下角;" />
            <outline text="center:保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。" />
            <outline text="centerCrop:保持横纵比缩放图片,知道完全覆盖ImageView,可能会出现图片的显示不完全" />
            <outline text="centerInside:保持横纵比缩放图片,直到ImageView能够完全地显示图片" />
            <outline text="matrix:默认值，不改变原图的大小，从ImageView的左上角开始绘制原图， 原图超过ImageView的部分作裁剪处理" />
          </outline>
        </outline>
        <outline text="RadioButton(单选按钮)&amp;amp;Checkbox(复选框)">
          <outline text="&amp;lt;RadioGroup">
            <outline text="android:id=&quot;@+id/radioGroup&quot;" />
            <outline text="android:layout_width=&quot;wrap_content&quot;" />
            <outline text="android:layout_height=&quot;wrap_content&quot;" />
            <outline text="android:orientation=&quot;horizontal&quot;&amp;gt;" />
            <outline text="&amp;lt;RadioButton">
              <outline text="android:id=&quot;@+id/btnMan&quot;" />
              <outline text="android:layout_width=&quot;wrap_content&quot;" />
              <outline text="android:layout_height=&quot;wrap_content&quot;" />
              <outline text="android:text=&quot;男&quot;" />
              <outline text="android:checked=&quot;true&quot;/&amp;gt;" />
            </outline>
            <outline text="&amp;lt;RadioButton">
              <outline text="android:id=&quot;@+id/btnWoman&quot;" />
              <outline text="android:layout_width=&quot;wrap_content&quot;" />
              <outline text="android:layout_height=&quot;wrap_content&quot;" />
              <outline text="android:text=&quot;女&quot;/&amp;gt;" />
            </outline>
          </outline>
          <outline text="&amp;lt;/RadioGroup&amp;gt;" />
          <outline text="获得选中的值：">
            <outline text="第一种是为RadioButton设置一个事件监听器setOnCheckChangeListener">
              <outline text="RadioGroup radgroup = (RadioGroup) findViewById(R.id.radioGroup);" />
              <outline text="radgroup.setOnCheckedChangeListener(new OnCheckedChangeListener() {">
                <outline text="public void onCheckedChanged(RadioGroup group, int checkedId) {">
                  <outline text="RadioButton radbtn = (RadioButton) findViewById(checkedId);" />
                  <outline text="Toast.makeText(getApplicationContext(), &quot;按钮组值发生改变,你选了&quot; + radbtn.getText(), Toast.LENGTH_LONG).show();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="});" />
            </outline>
            <outline text="第二种方法是通过单击其他按钮获取选中单选按钮的值">
              <outline text="RadioButton rd = (RadioButton) radgroup.getChildAt(i);" />
            </outline>
            <outline text="改变文字与选择框的相对位置">
              <outline text="1. android:button=&quot;@null&quot;" />
              <outline text="2. android:drawableTop=&quot;@android:drawable/btn_radio&quot;" />
            </outline>
            <outline text="修改文字与选择框的距离">
              <outline text="1. 在XML代码中控制： 使用android:paddingXxx = &quot;xxx&quot; 来控制距离" />
              <outline text="2. 在Java代码中，稍微好一点，动态计算paddingLeft." />
            </outline>
          </outline>
        </outline>
        <outline text="开关按钮ToggleButton和开关Switch">
          <outline text="ToggleButton(开关按钮) 有如下属性:" />
          <outline text="android:disabledAlpha：设置按钮在禁用时的透明度" />
          <outline text="android:textOff：按钮没有被选中时显示的文字" />
          <outline text="android:textOn：按钮被选中时显示的文字 另外，除了这个我们还可以自己写个selector，然后设置下Background属性即可~" />
          <outline text="Switch(开关)" />
          <outline text="android:showText：设置on/off的时候是否显示文字,boolean" />
          <outline text="android:splitTrack：是否设置一个间隙，让滑块与底部图片分隔,boolean" />
          <outline text="android:switchMinWidth：设置开关的最小宽度" />
          <outline text="android:switchPadding：设置滑块内文字的间隔" />
          <outline text="android:switchTextAppearance：设置开关的文字外观，暂时没发现有什么用..." />
          <outline text="android:textOff：按钮没有被选中时显示的文字" />
          <outline text="android:textOn：按钮被选中时显示的文字" />
          <outline text="android:textStyle：文字风格，粗体，斜体写划线那些" />
          <outline text="android:track：底部的图片" />
          <outline text="android:thumb：滑块的图片" />
          <outline text="android:typeface：设置字体，默认支持这三种:sans, serif, monospace" />
          <outline text="还可以使用 其他字体文件(*.ttf)，首先要将字体文件保存在 assets/fonts/目录下，然后在 Java代码中设置：">
            <outline text="Typeface typeFace =Typeface.createFromAsset(getAssets(),&quot;fonts/HandmadeTypewriter.ttf&quot;); textView.setTypeface(typeFace);" />
          </outline>
        </outline>
        <outline text="ProgressBar(进度条)">
          <outline text="ProgressBar继承与 View类，直接子类有 AbsSeekBar和 ContentLoadingProgressBar， 其中 AbsSeekBar的子类有 SeekBar和 RatingBar" />
          <outline text="android:max：进度条的最大值" />
          <outline text="android:progress：进度条已完成进度值" />
          <outline text="android:progressDrawable：设置轨道对应的Drawable对象" />
          <outline text="android:indeterminate：如果设置成true，则进度条不精确显示进度" />
          <outline text="android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象" />
          <outline text="android:indeterminateDuration：设置不精确显示进度的持续时间" />
          <outline text="android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置" />
        </outline>
        <outline text="SeekBar(拖动条)">
          <outline text="android:max=&quot;100&quot; //滑动条的最大值" />
          <outline text="android:progress=&quot;60&quot; //滑动条的当前值" />
          <outline text="android:secondaryProgress=&quot;70&quot; //二级滑动条的进度" />
          <outline text="android:thumb = &quot;@mipmap/sb_icon&quot; //滑块的drawable" />
          <outline text="SeekBar的事件，SeekBar.OnSeekBarChangeListener 我们只需重写三个对应的方法：">
            <outline text="onProgressChanged：进度发生改变时会触发" />
            <outline text="onStartTrackingTouch：按住SeekBar时会触发" />
            <outline text="onStopTrackingTouch：放开SeekBar时触发" />
          </outline>
        </outline>
        <outline text="RatingBar(星级评分条)">
          <outline text="android:isIndicator：是否用作指示，用户无法更改，默认false" />
          <outline text="android:numStars：显示多少个星星，必须为整数" />
          <outline text="android:rating：默认评分值，必须为浮点数" />
          <outline text="android:stepSize： 评分每次增加的值，必须为浮点数" />
          <outline text="除了上面这些，还有两种样式供我们选择咧，但是不建议使用，因为这两种样式都好丑... 他们分别是：" />
          <outline text="style=&quot;?android:attr/ratingBarStyleSmall&quot;" />
          <outline text="style=&quot;?android:attr/ratingBarStyleIndicator&quot;" />
          <outline text="——事件处理： 只需为RatingBar设置OnRatingBarChangeListener事件，然后重写下onRatingChanged()方法即可！" />
        </outline>
        <outline text="ScrollView(滚动条)">
          <outline text="ScrollView(滚动条)，应该叫它竖直滚动条，对应的另外一个水平方向上的滚动条：HorizontalScrollView." />
          <outline text="滚动到底部">
            <outline text="利用ScrollView给我们提供的:fullScroll()方法：" />
            <outline text="scrollView.fullScroll(ScrollView.FOCUS_DOWN);滚动到底部" />
            <outline text="scrollView.fullScroll(ScrollView.FOCUS_UP);滚动到顶部" />
            <outline text="另外用这玩意的时候要小心异步的玩意，就是addView后，有可能还没有显示完， 如果这个时候直接调用该方法的话，可能会无效，这就需要自己写handler来更新了~" />
          </outline>
          <outline text="设置滚动的滑块图片">
            <outline text="垂直方向滑块：android:scrollbarThumbVertical" />
            <outline text="水平方向滑块：android:scrollbarThumbHorizontal" />
          </outline>
          <outline text="隐藏滑块">
            <outline text="方法有两种： 1.android:scrollbars=&quot;none&quot;" />
            <outline text="2.Java代码设置：scrollview.setVerticalScrollBarEnabled(false);" />
          </outline>
          <outline text="设置滚动速度">
            <outline text="没有可以直接设置的方法，需要继承ScrollView，然后重写一个 public void fling (int velocityY)的方法：" />
            <outline text="public void fling(int velocityY) {">
              <outline text="super.fling(velocityY / 2);    //速度变为原来的一半" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="Date &amp;amp; Time组件(时间相关)">
          <outline text="&lt;b&gt;显示时间的控件有：TextClock，AnalogClock，Chronometer.  &lt;/b&gt;" />
          <outline text="TextClock(文本时钟)">
            <outline text="TextClock提供的 is24HourModeEnabled()方法来查看系统是否在使用24进制时间显示" />
            <outline text="android:format12Hour, 设置12时制的格式" />
            <outline text="android:format24Hour, 设置24时制的格式" />
            <outline text="android:timeZone, 设置时区" />
          </outline>
          <outline text="AnalogClock(模拟时钟)">
            <outline text="android:dial=&quot;@mipmap/ic_c_bg&quot;   // 背景" />
            <outline text="android:hand_hour=&quot;@mipmap/zhen_shi&quot;   // 时针" />
            <outline text="android:hand_minute=&quot;@mipmap/zhen_fen  // 分针" />
          </outline>
          <outline text="Chronometer(计时器)" />
          <outline text="&lt;b&gt;选择时间的控件有: DatePicker(日期选择器)，TimePicker(时间选择器)，CalendarView(日期视图).&lt;/b&gt;" />
          <outline text="DatePicker(日期选择器)">
            <outline text="android:calendarTextColor ： 日历列表的文本的颜色" />
            <outline text="android:calendarViewShown：是否显示日历视图" />
            <outline text="android:datePickerMode：组件外观，可选值:spinner，calendar 前者效果如下，默认效果" />
            <outline text="android:dayOfWeekBackground：顶部星期几的背景颜色" />
            <outline text="android:dayOfWeekTextAppearance：顶部星期几的文字颜色" />
            <outline text="android:endYear：去年(内容)比如2010" />
            <outline text="android:firstDayOfWeek：设置日历列表以星期几开头" />
            <outline text="android:headerBackground：整个头部的背景颜色" />
            <outline text="android:headerDayOfMonthTextAppearance：头部日期字体的颜色" />
            <outline text="android:headerMonthTextAppearance：头部月份的字体颜色" />
            <outline text="android:headerYearTextAppearance：头部年的字体颜色" />
            <outline text="android:maxDate：最大日期显示在这个日历视图mm / dd / yyyy格式" />
            <outline text="android:minDate：最小日期显示在这个日历视图mm / dd / yyyy格式" />
            <outline text="android:spinnersShown：是否显示spinner" />
            <outline text="android:startYear：设置第一年(内容)，比如19940年" />
            <outline text="android:yearListItemTextAppearance：列表的文本出现在列表中。" />
            <outline text="android:yearListSelectorColor：年列表选择的颜色" />
            <outline text="DatePicker的事件： DatePicker.OnDateChangedListener" />
          </outline>
          <outline text="TimePicker(时间选择器)">
            <outline text="官方提供的属性只有一个： android:timePickerMode：组件外观，同样可选值为: spinner和 clock(默认) 前者是旧版本的TimePicker" />
            <outline text="对应的监听事件是：TimePicker.OnTimeChangedListener" />
          </outline>
          <outline text="CalendarView(日期视图)">
            <outline text="android:firstDayOfWeek：设置一个星期的第一天" />
            <outline text="android:maxDate ：最大的日期显示在这个日历视图mm / dd / yyyy格式" />
            <outline text="android:minDate：最小的日期显示在这个日历视图mm / dd / yyyy格式" />
            <outline text="android:weekDayTextAppearance：工作日的文本出现在日历标题缩写" />
            <outline text="对应的日期改变事件是：CalendarView.OnDateChangeListener" />
          </outline>
        </outline>
        <outline text="Adapter: 复杂控件的数据更新一般放在单独类中完成, 后者叫 Adapter.">
          <outline text="Adapter即MVC模型中的C. 家族很大, 明星成员有: " />
          <outline text="BaseAdapter：抽象类，实际开发中我们会继承这个类并且重写相关方法，用得最多的一个Adapter！" />
          <outline text="&lt;b&gt;ArrayAdapter&lt;/b&gt;：支持泛型操作，最简单的一个Adapter，只能展现一行行文字." />
          <outline text="SimpleAdapter：同样具有良好扩展性的一个Adapter，可以自定义多种效果." />
          <outline text="SimpleCursorAdapter：用于显示简单文本类型的listView，一般在数据库那里会用到，不过有点过时， 不推荐使用." />
          <outline text="ArrayAdapter的例子:">
            <outline text="// 要显示的数据" />
            <outline text="String[] strs = {&quot;基神&quot;,&quot;B神&quot;,&quot;翔神&quot;,&quot;曹神&quot;,&quot;J神&quot;};" />
            <outline text="// 创建ArrayAdapter" />
            <outline text="ArrayAdapter&amp;lt;String&amp;gt; adapter = new ArrayAdapter&amp;lt;String&amp;gt;">
              <outline text="(this, android.R.layout.simple_expandable_list_item_1, strs);" />
            </outline>
            <outline text="// 获取ListView对象，通过调用 setAdapter方法为 ListView设置Adapter设置适配器" />
            <outline text="ListView list_test = (ListView) findViewById(R.id.list_test);" />
            <outline text="list_test.setAdapter(adapter);" />
          </outline>
          <outline text="ArrayAdapter的第二个参数负责定义界面风格, 其值域是:">
            <outline text="simple_list_item_1 : 单独一行的文本框" />
            <outline text="simple_list_item_2 : 两个文本框组成" />
            <outline text="simple_list_item_checked : 每项都是由一个已选中的列表项" />
            <outline text="simple_list_item_multiple_choice : 都带有一个复选框" />
            <outline text="simple_list_item_single_choice : 都带有一个单选钮" />
          </outline>
          <outline text="simpleAdapter的例子" />
        </outline>
        <outline text="&lt;b&gt;ListView: 需搭配Adapter使用的UI控件&lt;/b&gt;">
          <outline text="ListView 适用于搭复杂界面的框架, 所以最好按MVC模型进行组织. 其中关键是controller, 一般采用 adapter模型. " />
          <outline text="例子:">
            <outline text="// 要显示的数据. " />
            <outline text="String[] strs = {&quot;基神&quot;,&quot;B神&quot;,&quot;翔神&quot;,&quot;曹神&quot;,&quot;J神&quot;};" />
            <outline text="// 创建 ArrayAdapter" />
            <outline text="ArrayAdapter&amp;lt;String&amp;gt; &lt;b&gt;adapter &lt;/b&gt;= new ArrayAdapter&amp;lt;String&amp;gt;(this, android.R.layout.simple_expandable_list_item_1, strs);" />
            <outline text="// 获取ListView对象，通过调用setAdapter方法为ListView设置Adapter设置适配器" />
            <outline text="ListView list_test = (ListView) findViewById(R.id.list_test);" />
            <outline text="list_test.setAdapter(&lt;b&gt;adapter&lt;/b&gt;);" />
          </outline>
          <outline text="对于数组资源, 创建 ArrayAdapter 是用: ">
            <outline text="ArrayAdapter&amp;lt;CharSequence&amp;gt; adapter = ArrayAdapter.&lt;b&gt;createFromResource&lt;/b&gt;(this, R.array.myarray, android.R.layout.simple_list_item_multiple_choice);" />
          </outline>
          <outline text="还有一个简写的方式, 在 ListView 的layout中使用:  android:entries=&quot;@array/myarray&quot;; 直接引用数组资源." />
          <outline text="其它属性">
            <outline text="footerDividersEnabled：是否在footerView(表尾)前绘制一个分隔条,默认为true" />
            <outline text="headerDividersEnabled:是否在headerView(表头)前绘制一个分隔条,默认为true" />
            <outline text="divider:设置分隔条,可以用颜色分割,也可以用drawable资源分割" />
            <outline text="dividerHeight:设置分隔条的高度" />
            <outline text="addHeaderView(View v)：添加headView(表头),括号中的参数是一个View对象, 使用这个方法必须在listview.setAdapter前面，否则会报错。" />
            <outline text="addFooterView(View v)：添加footerView(表尾)，括号中的参数是一个View对象" />
            <outline text="addHeaderView(headView, null, false)：和前面的区别：设置Header是否可以被选中" />
            <outline text="addFooterView(View,view,false)：同上" />
            <outline text="想让列表显示你列表的最下面的话，将 stackFromBottom 属性设置为true即可." />
            <outline text="设置点击颜色 cacheColorHint">
              <outline text="如果你为ListView设置了一个图片作为Background的话，当你拖动或者点击listView空白位置会发现 item都变成黑色了，这是时候我们可以通过这个cacheColorHint将颜色设置为透明: # 00000000" />
            </outline>
            <outline text="隐藏滑动条: android:scrollbars=&quot;none&quot; 或者 setVerticalScrollBarEnabled(true);" />
          </outline>
          <outline text="上面的例子直接使用 ArrayAdapter作 adapter, 这种太简单, 常见的是重载 BaseAdapter. 如下:">
            <outline text="// 先编写下表头与表尾的布局：">
              <outline text="&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;" />
              <outline text="&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
                <outline text="android:layout_width=&quot;match_parent&quot;" />
                <outline text="android:layout_height=&quot;match_parent&quot;" />
                <outline text="android:orientation=&quot;vertical&quot;" />
                <outline text="android:gravity=&quot;center&quot;&amp;gt;" />
                <outline text="&amp;lt;TextView">
                  <outline text="android:layout_width=&quot;match_parent&quot;" />
                  <outline text="android:layout_height=&quot;48dp&quot;" />
                  <outline text="android:textSize=&quot;18sp&quot;" />
                  <outline text="android:text=&quot;表头&quot;" />
                  <outline text="android:gravity=&quot;center&quot;" />
                  <outline text="android:background=&quot;#43BBEB&quot;" />
                  <outline text="android:textColor=&quot;#FFFFFF&quot;/&amp;gt;" />
                </outline>
              </outline>
              <outline text="&amp;lt;/LinearLayout&amp;gt;" />
            </outline>
            <outline text="// 表尾除了text字段不同外, 其它都一样." />
            <outline text="" />
            <outline text="// 自定义 BaseAdapter" />
            <outline text="public class AnimalAdapter extends BaseAdapter {">
              <outline text="private LinkedList&amp;lt;Animal&amp;gt; mData;" />
              <outline text="private Context mContext;" />
              <outline text="// Animal 是个数据类库, 这里不再累述." />
              <outline text="public AnimalAdapter(LinkedList&amp;lt;Animal&amp;gt; mData, Context mContext) {">
                <outline text="this.mData = mData;" />
                <outline text="this.mContext = mContext;" />
              </outline>
              <outline text="}" />
              <outline text="// 关键函数. 返回表格有多少列." />
              <outline text="public int getCount() {">
                <outline text="return mData.size();" />
              </outline>
              <outline text="}" />
              <outline text="public Object getItem(int position) {">
                <outline text="return null;" />
              </outline>
              <outline text="}" />
              <outline text="public long getItemId(int position) {">
                <outline text="return position;" />
              </outline>
              <outline text="}" />
              <outline text="// 关键函数. 返回每一列的view, 界面上有多少列就会调用多少次 getView." />
              <outline text="public View getView(int position, View convertView, ViewGroup parent) {">
                <outline text="ViewHolder holder = null;" />
                <outline text="if(convertView == null){">
                  <outline text="convertView = LayoutInflater.from(mContext).inflate(R.layout.item_list_animal,parent,false);" />
                  <outline text="&lt;b&gt;holder = new ViewHolder();&lt;/b&gt;" />
                  <outline text="holder.img_icon = (ImageView) convertView.findViewById(R.id.img_icon);" />
                  <outline text="holder.txt_aName = (TextView) convertView.findViewById(R.id.txt_aName);" />
                  <outline text="holder.txt_aSpeak = (TextView) convertView.findViewById(R.id.txt_aSpeak);" />
                  <outline text="convertView.setTag(holder);   //将Holder存储到convertView中" />
                </outline>
                <outline text="}else{">
                  <outline text="holder = (ViewHolder) convertView.getTag();" />
                </outline>
                <outline text="}" />
                <outline text="holder.img_icon.setBackgroundResource(mData.get(position).getaIcon());" />
                <outline text="holder.txt_aName.setText(mData.get(position).getaName());" />
                <outline text="holder.txt_aSpeak.setText(mData.get(position).getaSpeak());" />
                <outline text="return convertView;" />
              </outline>
              <outline text="}" />
              <outline text="// 数据类" />
              <outline text="static class ViewHolder{">
                <outline text="ImageView img_icon;" />
                <outline text="TextView txt_aName;" />
                <outline text="TextView txt_aSpeak;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="" />
            <outline text="// 主函数:" />
            <outline text="public class MainActivity extends AppCompatActivity implements AdapterView.OnItemClickListener{">
              <outline text="private List&amp;lt;Animal&amp;gt; mData = null;" />
              <outline text="private Context mContext;" />
              <outline text="private AnimalAdapter &lt;b&gt;mAdapter &lt;/b&gt;= null;" />
              <outline text="private ListView list_animal;" />
              <outline text="private LinearLayout ly_content;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="mContext = MainActivity.this;" />
                <outline text="list_animal = (ListView) findViewById(R.id.list_animal);" />
                <outline text="// 动态加载顶部View和底部View" />
                <outline text="final LayoutInflater inflater = LayoutInflater.from(this);" />
                <outline text="View headView = inflater.inflate(R.layout.view_header, null, false);" />
                <outline text="View footView = inflater.inflate(R.layout.view_footer, null, false);" />
                <outline text="mData = new LinkedList&amp;lt;Animal&amp;gt;();" />
                <outline text="mData.add(new Animal(&quot;狗说&quot;, &quot;你是狗么?&quot;, R.mipmap.ic_icon_dog));" />
                <outline text="mData.add(new Animal(&quot;牛说&quot;, &quot;你是牛么?&quot;, R.mipmap.ic_icon_cow));" />
                <outline text="&lt;b&gt;mAdapter &lt;/b&gt;= new AnimalAdapter((LinkedList&amp;lt;Animal&amp;gt;) mData, mContext);" />
                <outline text="// 添加表头和表尾需要写在setAdapter方法调用之前！！！" />
                <outline text="list_animal.addHeaderView(headView);" />
                <outline text="list_animal.addFooterView(footView);" />
                <outline text="list_animal.&lt;b&gt;setAdapter&lt;/b&gt;(&lt;b&gt;mAdapter&lt;/b&gt;);" />
                <outline text="list_animal.&lt;b&gt;setOnItemClickListener&lt;/b&gt;(this);" />
              </outline>
              <outline text="}" />
              <outline text="public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {">
                <outline text="// 添加表头表尾后，positon是从表头开始算的，表头是0, 第一个数据是1." />
                <outline text="Toast.makeText(mContext,&quot;你点击了第&quot; + position + &quot;项&quot;,Toast.LENGTH_SHORT).show();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="ViewHolder重用组件">
            <outline text="之前说过, ListView上有多少个列就会调多少次 getView(). 但是findViewById不一样需要调用多次. 可以自己定义一个ViewHolder类来对这一部分进行性能优化." />
            <outline text="具体做法参见例子中的 &lt;b&gt;holder = new ViewHolder(); &lt;/b&gt;这几行代码." />
          </outline>
          <outline text="ListView的数据更新">
            <outline text="在BaseAdapter中加一个接口">
              <outline text="public void add(Data data) {">
                <outline text="if (mData == null) {">
                  <outline text="mData = new LinkedList&amp;lt;&amp;gt;();" />
                </outline>
                <outline text="}" />
                <outline text="mData.add(data);" />
                <outline text="// notifyDataSetChanged()方法会判断是否需要重新渲染，如果当前item没有必要重新渲染 是不会重新渲染的，如果某个Item的状态发生改变，都会导致View的重绘，而重绘的并不是 所有的Item，而是View状态发生变化的那个Item." />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="然后在数据更新处调用即可. Adapter.add();" />
            <outline text="删除也是如此.">
              <outline text="public void remove(Data data) {">
                <outline text="if(mData != null) {">
                  <outline text="mData.remove(data);" />
                </outline>
                <outline text="}" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
              <outline text="public void remove(int position) {">
                <outline text="if(mData != null) {">
                  <outline text="mData.remove(position);" />
                </outline>
                <outline text="}" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
          <outline text="ListView的焦点问题">
            <outline text="如果往ListView的Item中添加了Button，CheckBox，EditText 等控件的话，就需要考虑ListView的焦点问题. 因为这些控件点击不了，触发不了onItemClick 和 onItemLongClick." />
            <outline text="解决办法是在 item根节点设置 android:descendantFocusability=&quot;blocksDescendants&quot;" />
            <outline text="该属性的值域是：">
              <outline text="beforeDescendants： ViewGroup会优先其子类控件而获取到焦点" />
              <outline text="afterDescendants： ViewGroup只有当其子类控件不需要获取焦点时才获取焦点" />
              <outline text="blocksDescendants： ViewGroup会覆盖子类控件而直接获得焦点" />
            </outline>
          </outline>
          <outline text="ListView之 checkbox 错位问题 #面试题">
            <outline text="作为ListView经典问题之一，如果你尝试过自定义ListView的item，在上面带有一个checkbox的话，那么当 item数超过了一页的话，就会出现错位问题." />
            <outline text="问题产生的原因是ListView当前屏的item都是缓存到 convertView中去的. 当滚出屏幕，这时候 ConvertView不为空，所以新的一项会复用这个ConvertView, 这个地方产生了问题. " />
            <outline text="第一个解决方式就是，不重用这个ConvertView，或者 说每次getView都将这个ConvertView设置为null. 如果Item数目巨大的话， 这种方法的性能比较差. " />
            <outline text="第二个方法是, 找个地方保存当前Item CheckBox的状态，初始化的时候进行判断，设置是否选中.">
              <outline text="放在哪里合适? 当然是 ViewHolder 类中了. 增加一个 CheckBox 成员." />
              <outline text="增加checkbox监听器:">
                <outline text="viewHolder.cbxStatus.setOnCheckedChangeListener(this);" />
              </outline>
              <outline text="在checkbox状态变化时保存状态" />
              <outline text="public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {">
                <outline text="int index = (int)buttonView.getTag();" />
                <outline text="if (isChecked)">
                  <outline text="mData.get(index).setCheckStatus(true);" />
                </outline>
                <outline text="else">
                  <outline text="mData.get(index).setCheckStatus(false);" />
                </outline>
              </outline>
              <outline text="}" />
              <outline text="使用该值">
                <outline text="viewHolder.cbxStatus.setChecked(mData.get(position).getcheckStatus());" />
              </outline>
            </outline>
          </outline>
          <outline text="优化ListView的性能  #面试题 #经验总结 ">
            <outline text="在adapter中的getView方法中尽量少使用逻辑;" />
            <outline text="尽最大可能避免GC;">
              <outline text="在 getView()方法 中不要创建非常多的对象。" />
            </outline>
            <outline text="滑动的时候不载入图片;" />
            <outline text="将 ListView 的 scrollingCache 和 animateCache 设置为 false;" />
            <outline text="item的布局层级越少越好;">
              <outline text="当滑动ListView的时候，会导致大量的測量与绘制。所以我们应该将一些不必要的布局嵌套关系去掉, 降低item布局深度." />
            </outline>
            <outline text="使用ViewHolder.">
              <outline text="ViewHolder 可以大大提高 ListView 的性能." />
            </outline>
          </outline>
        </outline>
        <outline text="构建一个可复用的自定义BaseAdapter">
          <outline text="在上面ListView的Adapter基础上, 做几次进化." />
          <outline text="第一步, 将Item实体类设置成泛型. 这样任何数据都可以复用这个Adapter.">
            <outline text="public class MyAdapter&amp;lt;T&amp;gt; extends BaseAdapter {">
              <outline text="private Context mContext;" />
              <outline text="private LinkedList&amp;lt;T&amp;gt; mData;" />
              <outline text="public MyAdapter() {" />
              <outline text="}" />
              <outline text="public MyAdapter(LinkedList&amp;lt;T&amp;gt; mData, Context mContext) {">
                <outline text="this.mData = mData;" />
                <outline text="this.mContext = mContext;" />
              </outline>
              <outline text="}" />
              <outline text="public int getCount() {">
                <outline text="return mData.size();" />
              </outline>
              <outline text="}" />
              <outline text="public Object getItem(int position) {">
                <outline text="return null;" />
              </outline>
              <outline text="}" />
              <outline text="public long getItemId(int position) {">
                <outline text="return position;" />
              </outline>
              <outline text="}" />
              <outline text="public View getView(int position, View convertView, ViewGroup parent) {">
                <outline text="ViewHolder holder = null;" />
                <outline text="if (convertView == null) {">
                  <outline text="convertView = LayoutInflater.from(mContext).inflate(R.layout.item_list, parent, false);" />
                  <outline text="holder = new ViewHolder();" />
                  <outline text="holder.img_icon = (ImageView) convertView.findViewById(R.id.img_icon);" />
                  <outline text="holder.txt_content = (TextView) convertView.findViewById(R.id.txt_content);" />
                  <outline text="convertView.setTag(holder);" />
                </outline>
                <outline text="} else {">
                  <outline text="holder = (ViewHolder) convertView.getTag();" />
                </outline>
                <outline text="}" />
                <outline text="holder.img_icon.setImageResource(mData.get(position).getImgId());" />
                <outline text="holder.txt_content.setText(mData.get(position).getContent());" />
                <outline text="return convertView;" />
              </outline>
              <outline text="}" />
              <outline text="//添加一个元素" />
              <outline text="public void add(T data) {">
                <outline text="if (mData == null) {">
                  <outline text="mData = new LinkedList&amp;lt;&amp;gt;();" />
                </outline>
                <outline text="}" />
                <outline text="mData.add(data);" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
              <outline text="//往特定位置，添加一个元素" />
              <outline text="public void add(int position,T data){">
                <outline text="if (mData == null) {">
                  <outline text="mData = new LinkedList&amp;lt;&amp;gt;();" />
                </outline>
                <outline text="}" />
                <outline text="mData.add(position, data);" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
              <outline text="public void remove(T data) {">
                <outline text="if(mData != null) {">
                  <outline text="mData.remove(data);" />
                </outline>
                <outline text="}" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
              <outline text="public void remove(int position) {">
                <outline text="if(mData != null) {">
                  <outline text="mData.remove(position);" />
                </outline>
                <outline text="}" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
              <outline text="public void clear() {">
                <outline text="if(mData != null) {">
                  <outline text="mData.clear();" />
                </outline>
                <outline text="}" />
                <outline text="notifyDataSetChanged();" />
              </outline>
              <outline text="}" />
              <outline text="private class ViewHolder {">
                <outline text="ImageView img_icon;" />
                <outline text="TextView txt_content;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="第二步, ViewHolder类的升级改造">
            <outline text="目标: 将getView()方法大部分的逻辑写到ViewHolder类里. 这样 getView() 就不需要了解各个Item的界面表现了. " />
            <outline text="ViewHolder要做的事：">
              <outline text="定义一个查找控件的方法，我们的思路是通过暴露公共的方法，调用方法时传递过来控件id，以及设置的内容." />
              <outline text="将convertView复用部分搬到这里，那就需要传递一个context对象了，我们把需要获取 的部分都写到构造方法中！" />
              <outline text="写一堆设置方法(public)，比如设置文字大小颜色，图片背景等！" />
            </outline>
            <outline text="代码如下:" />
            <outline text="public static class ViewHolder {">
              <outline text="private SparseArray&amp;lt;View&amp;gt; mViews;    // 存储ListView 的 item中的View" />
              <outline text="private View item;                  // 存放convertView" />
              <outline text="private int position;                // 游标" />
              <outline text="private Context context;        // Context上下文" />
              <outline text="// 构造方法，完成相关初始化" />
              <outline text="private ViewHolder(Context context, ViewGroup parent, int layoutRes) {">
                <outline text="mViews = new SparseArray&amp;lt;&amp;gt;();" />
                <outline text="this.context = context;" />
                <outline text="View convertView = LayoutInflater.from(context).inflate(layoutRes, parent,false);" />
                <outline text="convertView.setTag(this);" />
                <outline text="item = convertView;" />
              </outline>
              <outline text="}" />
              <outline text="" />
              <outline text="// 绑定ViewHolder与Item" />
              <outline text="public static ViewHolder bind(Context context, View convertView, ViewGroup parent,">
                <outline text="int layoutRes, int position) {" />
                <outline text="ViewHolder holder;" />
                <outline text="if(convertView == null) {">
                  <outline text="holder = new ViewHolder(context, parent, layoutRes);" />
                </outline>
                <outline text="} else {">
                  <outline text="holder = (ViewHolder) convertView.getTag();" />
                  <outline text="holder.item = convertView;" />
                </outline>
                <outline text="}" />
                <outline text="holder.position = position;" />
                <outline text="return holder;" />
              </outline>
              <outline text="}" />
              <outline text="" />
              <outline text="// 根据id获取集合中保存的控件" />
              <outline text="public &amp;lt;T extends View&amp;gt; T getView(int id) {">
                <outline text="T t = (T) mViews.get(id);" />
                <outline text="if(t == null) {">
                  <outline text="t = (T) item.findViewById(id);" />
                  <outline text="mViews.put(id, t);" />
                </outline>
                <outline text="}" />
                <outline text="return t;" />
              </outline>
              <outline text="}" />
              <outline text="" />
              <outline text="// 获取当前条目" />
              <outline text="public View getItemView() {">
                <outline text="return item;" />
              </outline>
              <outline text="}" />
              <outline text="// 获取条目位置" />
              <outline text="public int getItemPosition() {">
                <outline text="return position;" />
              </outline>
              <outline text="}" />
              <outline text="// 设置文字" />
              <outline text="public ViewHolder setText(int id, CharSequence text) {">
                <outline text="View view = getView(id);" />
                <outline text="if(view instanceof TextView) {">
                  <outline text="((TextView) view).setText(text);" />
                </outline>
                <outline text="}" />
                <outline text="return this;" />
              </outline>
              <outline text="}" />
              <outline text="// 设置图片" />
              <outline text="public ViewHolder setImageResource(int id, int drawableRes) {">
                <outline text="View view = getView(id);" />
                <outline text="if(view instanceof ImageView) {">
                  <outline text="((ImageView) view).setImageResource(drawableRes);" />
                </outline>
                <outline text="} else {">
                  <outline text="view.setBackgroundResource(drawableRes);" />
                </outline>
                <outline text="}" />
                <outline text="return this;" />
              </outline>
              <outline text="}" />
              <outline text="// 设置点击监听" />
              <outline text="public ViewHolder setOnClickListener(int id, View.OnClickListener listener) {">
                <outline text="getView(id).setOnClickListener(listener);" />
                <outline text="return this;" />
              </outline>
              <outline text="}" />
              <outline text="// 设置可见性" />
              <outline text="public ViewHolder setVisibility(int id, int visible) {">
                <outline text="getView(id).setVisibility(visible);" />
                <outline text="return this;" />
              </outline>
              <outline text="}" />
              <outline text="ImageView img_icon;" />
              <outline text="TextView txt_content;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="第三步, 定义一个抽象方法，完成ViewHolder与Data数据集的绑定">
            <outline text="public abstract void bindView(ViewHolder holder, T obj);" />
            <outline text="我们创建新的BaseAdapter的时候，实现这个方法就好." />
          </outline>
          <outline text="第四步, 修改getView()部分的内容">
            <outline text="public View getView(int position, View convertView, ViewGroup parent) {">
              <outline text="ViewHolder holder = ViewHolder.bind(parent.getContext(), convertView, parent, mLayoutRes, position);" />
              <outline text="bindView(holder,getItem(position));" />
              <outline text="return holder.getItemView();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="第四步, 怎么使用?">
            <outline text="//Adapter初始化" />
            <outline text="myAdapter1 = new MyAdapter&amp;lt;App&amp;gt;((ArrayList)mData1, R.layout.item_one) {">
              <outline text="public void bindView(ViewHolder holder, App obj) {">
                <outline text="holder.setImageResource(R.id.img_icon, obj.getaIcon());" />
                <outline text="holder.setText(R.id.txt_aname, obj.getaName());" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="};" />
            <outline text="ListView list_app = (ListView) findViewById(R.id.list_app);" />
            <outline text="list_app.setAdapter(myAdapter1);" />
          </outline>
        </outline>
        <outline text="ListView的多布局">
          <outline text="同一个ListView中有多种布局风格叫ListView的多布局. 比如聊天窗口, 你说的和别人说的显示风格认定是不一样的. " />
          <outline text="重写getViewTypeCount()方法iew返回 总共多少个类别">
            <outline text="public int getViewTypeCount() {">
              <outline text="return 2;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="重写getItemViewType()方法对应View是哪个类别. 关键接口">
            <outline text="public int getItemViewType(int position) {">
              <outline text="if (mData.get(position) instanceof App) {">
                <outline text="return TYPE_APP;" />
              </outline>
              <outline text="} else if (mData.get(position) instanceof Book) {">
                <outline text="return TYPE_BOOK;" />
              </outline>
              <outline text="} else {">
                <outline text="return super.getItemViewType(position);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="在getView那里调用getItemViewType获得对应类别，再加载对应的View">
            <outline text="代码较长. 不贴了." />
          </outline>
        </outline>
        <outline text="GridView(网格视图)">
          <outline text="GridView和ListView一样是AbsListView的子类. 和ListView很类似, 主要的不同是支持多列显示." />
          <outline text="一些属性">
            <outline text="android:columnWidth：设置列的宽度" />
            <outline text="android:gravity：组件对其方式" />
            <outline text="android:horizontalSpacing：水平方向每个单元格的间距" />
            <outline text="android:verticalSpacing：垂直方向每个单元格的间距" />
            <outline text="android:numColumns：设置列数. 数字." />
            <outline text="android:stretchMode：设置拉伸模式. 值域:">
              <outline text="none：不拉伸;" />
              <outline text="spacingWidth：拉伸元素间的间隔空隙;" />
              <outline text="columnWidth：仅仅拉伸表格元素自身;" />
              <outline text="spacingWidthUniform：既拉元素间距又拉伸他们之间的间隔空袭." />
            </outline>
          </outline>
          <outline text="例子:" />
          <outline text="public class MainActivity extends AppCompatActivity {">
            <outline text="private Context mContext;" />
            <outline text="private GridView grid_photo;" />
            <outline text="private BaseAdapter mAdapter = null;" />
            <outline text="private ArrayList&amp;lt;Icon&amp;gt; mData = null;" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="mContext = MainActivity.this;" />
              <outline text="grid_photo = (GridView) findViewById(R.id.grid_photo);" />
              <outline text="mData = new ArrayList&amp;lt;Icon&amp;gt;();" />
              <outline text="mData.add(new Icon(R.mipmap.iv_icon_1, &quot;图标1&quot;));" />
              <outline text="mData.add(new Icon(R.mipmap.iv_icon_2, &quot;图标2&quot;));" />
              <outline text="mAdapter = new MyAdapter&amp;lt;Icon&amp;gt;(mData, R.layout.item_grid_icon) {">
                <outline text="public void bindView(ViewHolder holder, Icon obj) {">
                  <outline text="holder.setImageResource(R.id.img_icon, obj.getiId());" />
                  <outline text="holder.setText(R.id.txt_icon, obj.getiName());" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="};" />
              <outline text="grid_photo.setAdapter(mAdapter);" />
              <outline text="grid_photo.setOnItemClickListener(new AdapterView.OnItemClickListener() {">
                <outline text="public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {">
                  <outline text="Toast.makeText(mContext, &quot;你点击了~&quot; + position + &quot;~项&quot;, Toast.LENGTH_SHORT).show();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="});" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="Spinner(列表选项框)">
          <outline text="功能: 当我们的app需要用户输入数据时，除了让用户自己打字以外，还有一种方便的设计: 列出一组选项让用户从中挑选." />
          <outline text="相关属性">
            <outline text="android:dropDownHorizontalOffset：设置列表框的水平偏移距离" />
            <outline text="android:dropDownVerticalOffset：设置列表框的水平竖直距离" />
            <outline text="android:dropDownSelector：列表框被选中时的背景" />
            <outline text="android:dropDownWidth：设置下拉列表框的宽度" />
            <outline text="android:gravity：设置里面组件的对其方式" />
            <outline text="android:popupBackground：设置列表框的背景" />
            <outline text="android:prompt：设置对话框模式的列表框的提示信息(标题)，只能够引用string.xml 中的资源id,而不能直接写字符串" />
            <outline text="android:spinnerMode：列表框的模式. 值域:">
              <outline text="dropdown：下拉菜单风格的窗口(默认)" />
              <outline text="dialog：对话框风格的窗口" />
            </outline>
            <outline text="可选属性：android:entries：使用数组资源设置下拉列表框的列表项目" />
          </outline>
          <outline text="Spinner会默认选中第一个值，请把默认值放在这里, 方便用户选择. " />
          <outline text="代码: 第一步, 在layout文件中加入控件定义:">
            <outline text="&amp;lt;Spinner">
              <outline text="android:id=&quot;@+id/spin_one&quot;" />
              <outline text="android:layout_width=&quot;100dp&quot;" />
              <outline text="android:layout_height=&quot;64dp&quot;" />
              <outline text="android:entries=&quot;@array/data&quot;" />
              <outline text="android:prompt=&quot;@string/spin_title&quot;" />
              <outline text="android:spinnerMode=&quot;dialog&quot; /&amp;gt;" />
            </outline>
          </outline>
          <outline text="第二步, 使用:" />
          <outline text="public class MainActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener {">
            <outline text="private Spinner spin_one;" />
            <outline text="private Spinner spin_two;" />
            <outline text="private Context mContext;" />
            <outline text="// 判断是否为刚进去时触发onItemSelected的标志" />
            <outline text="private boolean one_selected = false;" />
            <outline text="private boolean two_selected = false;" />
            <outline text="private ArrayList&amp;lt;Hero&amp;gt; mData = null;" />
            <outline text="private BaseAdapter myAdadpter = null;" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="mContext = MainActivity.this;" />
              <outline text="mData = new ArrayList&amp;lt;Hero&amp;gt;();" />
              <outline text="bindViews();" />
            </outline>
            <outline text="}" />
            <outline text="private void bindViews() {">
              <outline text="spin_one = (Spinner) findViewById(R.id.spin_one);" />
              <outline text="spin_two = (Spinner) findViewById(R.id.spin_two);" />
              <outline text="mData.add(new Hero(R.mipmap.iv_lol_icon1,&quot;迅捷斥候：提莫（Teemo）&quot;));" />
              <outline text="mData.add(new Hero(R.mipmap.iv_lol_icon2,&quot;诺克萨斯之手：德莱厄斯（Darius）&quot;));" />
              <outline text="myAdadpter = new MyAdapter&amp;lt;Hero&amp;gt;(mData,R.layout.item_spin_hero) {">
                <outline text="public void bindView(ViewHolder holder, Hero obj) {">
                  <outline text="holder.setImageResource(R.id.img_icon,obj.gethIcon());" />
                  <outline text="holder.setText(R.id.txt_name, obj.gethName());" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="};" />
              <outline text="spin_two.setAdapter(myAdadpter);" />
              <outline text="spin_one.setOnItemSelectedListener(this);" />
              <outline text="spin_two.setOnItemSelectedListener(this);" />
            </outline>
            <outline text="}" />
            <outline text="public void onItemSelected(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {">
              <outline text="switch (parent.getId()){">
                <outline text="case R.id.spin_one:">
                  <outline text="if(one_selected){">
                    <outline text="Toast.makeText(mContext,&quot;您的分段是~：&quot; + parent.getItemAtPosition(position).toString(),">
                      <outline text="Toast.LENGTH_SHORT).show();" />
                    </outline>
                  </outline>
                  <outline text="}else one_selected = true;" />
                  <outline text="break;" />
                </outline>
                <outline text="case R.id.spin_two:">
                  <outline text="if(two_selected){">
                    <outline text="TextView txt_name = (TextView) view.findViewById(R.id.txt_name);" />
                    <outline text="Toast.makeText(mContext,&quot;您选择的英雄是~：&quot; + txt_name.getText().toString(),">
                      <outline text="Toast.LENGTH_SHORT).show();" />
                    </outline>
                  </outline>
                  <outline text="}else two_selected = true;" />
                  <outline text="break;" />
                </outline>
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="public void onNothingSelected(AdapterView&amp;lt;?&amp;gt; parent) {" />
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="AutoCompleteTextView(自动完成文本框)">
          <outline text="属性">
            <outline text="android:completionHint：设置下拉菜单中的提示标题. 比如 &quot;请输入搜索内容&quot;. 如果觉得丑可以设置一个View." />
            <outline text="android:completionHintView：定义提示视图中显示下拉菜单." />
            <outline text="android:completionThreshold：指定至少输入多少个字符才会显示提示. 1表示输入1个就提示." />
            <outline text="android:dropDownAnchor：设置下拉菜单的定位&quot;锚点&quot;组件，如果没有指定改属性， 将使用该TextView作为定位&quot;锚点&quot;组件" />
            <outline text="android:dropDownHeight：设置下拉菜单的高度" />
            <outline text="android:dropDownWidth：设置下拉菜单的宽度" />
            <outline text="android:dropDownHorizontalOffset：指定下拉菜单与文本之间的水平间距" />
            <outline text="android:dropDownVerticalOffset：指定下拉菜单与文本之间的竖直间距" />
            <outline text="android:dropDownSelector：设置下拉菜单点击效果" />
            <outline text="android:popupBackground：设置下拉菜单的背景" />
          </outline>
        </outline>
        <outline text="ExpandableListView(可折叠列表)">
          <outline text="属性:">
            <outline text="android:childDivider：指定各组内子类表项之间的分隔条，图片不会完全显示， 分离子列表项的是一条直线" />
            <outline text="android:childIndicator：显示在子列表旁边的Drawable对象，可以是一个图像" />
            <outline text="android:childIndicatorEnd：子列表项指示符的结束约束位置" />
            <outline text="android:childIndicatorLeft：子列表项指示符的左边约束位置" />
            <outline text="android:childIndicatorRight：子列表项指示符的右边约束位置" />
            <outline text="android:childIndicatorStart：子列表项指示符的开始约束位置" />
            <outline text="android:groupIndicator：显示在组列表旁边的Drawable对象，可以是一个图像" />
            <outline text="android:indicatorEnd：组列表项指示器的结束约束位置" />
            <outline text="android:indicatorLeft：组列表项指示器的左边约束位置" />
            <outline text="android:indicatorRight：组列表项指示器的右边约束位置" />
            <outline text="android:indicatorStart：组列表项指示器的开始约束位置" />
          </outline>
          <outline text="核心是重写BaseExpandableListAdpter，其实和之前写的普通的BaseAdapter是类似的， 但是BaseExpandableListAdpter则分成了两部分：组和子列表." />
        </outline>
        <outline text="ViewFlipper(翻转视图)">
          <outline text="是一个多页面管理控件，且支持自动播放. 多用于应用的引导页, 或者用于图片轮播." />
          <outline text="和ViewPager不同，ViewPager是一页页的，而ViewFlipper则是一层层的." />
          <outline text="属性">
            <outline text="setInAnimation：设置View进入屏幕时使用的动画" />
            <outline text="setOutAnimation：设置View退出屏幕时使用的动画" />
            <outline text="showNext：调用该方法来显示ViewFlipper里的下一个View" />
            <outline text="showPrevious：调用该方法来显示ViewFlipper的上一个View" />
            <outline text="setFilpInterval：设置View之间切换的时间间隔" />
            <outline text="setFlipping：使用上面设置的时间间隔来开始切换所有的View，切换会循环进行" />
            <outline text="stopFlipping：停止View切换" />
          </outline>
          <outline text="例子">
            <outline text="// 布局中这么定义." />
            <outline text="&amp;lt;ViewFlipper">
              <outline text="android:id=&quot;@+id/vflp_help&quot;" />
              <outline text="android:layout_width=&quot;match_parent&quot;" />
              <outline text="android:layout_height=&quot;match_parent&quot;" />
              <outline text="android:inAnimation=&quot;@anim/right_in&quot;" />
              <outline text="android:outAnimation=&quot;@anim/right_out&quot;" />
              <outline text="// 每隔3000ms切换一次." />
              <outline text="android:flipInterval=&quot;3000&quot;&amp;gt;" />
              <outline text="&amp;lt;include layout=&quot;@layout/page_help_one&quot; /&amp;gt;" />
              <outline text="&amp;lt;include layout=&quot;@layout/page_help_two&quot; /&amp;gt;" />
              <outline text="&amp;lt;include layout=&quot;@layout/page_help_three&quot; /&amp;gt;" />
              <outline text="&amp;lt;include layout=&quot;@layout/page_help_four&quot; /&amp;gt;" />
            </outline>
            <outline text="&amp;lt;/ViewFlipper&amp;gt;" />
            <outline text="// 代码中调用 &lt;b&gt;startFlipping() 即尅是播放.&lt;/b&gt;" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="vflp_help = (ViewFlipper) findViewById(R.id.vflp_help);" />
              <outline text="vflp_help.&lt;b&gt;startFlipping&lt;/b&gt;();" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="Toast(吐司)">
          <outline text="直接调用Toast类的makeText()方法创建:">
            <outline text="比如点击一个按钮，然后弹出Toast，" />
            <outline text="用法： Toast.makeText(MainActivity.this, &quot;提示内容&quot;, Toast.LENGTH_LONG).show();" />
            <outline text="其中第3个参数是显示时间，只有 LONG 和 SHORT 两种." />
          </outline>
          <outline text="如果需要对Toast窗口做更多定制, 则要这么做:">
            <outline text="private void midToast(String str, int showTime) {">
              <outline text="Toast toast = Toast.makeText(mContext, str, showTime);" />
              <outline text="toast.setGravity(Gravity.CENTER_HORIZONTAL|Gravity.BOTTOM , 0, 0);  //设置显示位置" />
              <outline text="LinearLayout layout = (LinearLayout) toast.getView();" />
              <outline text="layout.setBackgroundColor(Color.BLUE);" />
              <outline text="ImageView image = new ImageView(this);" />
              <outline text="image.setImageResource(R.mipmap.ic_icon_qitao);" />
              <outline text="layout.addView(image, 0);" />
              <outline text="TextView v = (TextView) toast.getView().findViewById(android.R.id.message);" />
              <outline text="v.setTextColor(Color.YELLOW);     //设置字体颜色" />
              <outline text="toast.show();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="一个常见的效果: 圆角. 在布局文件中加入">
            <outline text="&amp;lt;!-- 设置四个圆角的半径 --&amp;gt;" />
            <outline text="&amp;lt;corners">
              <outline text="android:bottomLeftRadius=&quot;50px&quot;" />
              <outline text="android:bottomRightRadius=&quot;50px&quot;" />
              <outline text="android:topLeftRadius=&quot;50px&quot;" />
              <outline text="android:topRightRadius=&quot;50px&quot; /&amp;gt;" />
            </outline>
          </outline>
        </outline>
        <outline text="&lt;b&gt;Notification(状态栏通知)&lt;/b&gt;">
          <outline text="Notification，是一种具有全局效果的通知，可以在系统的通知栏中显示。" />
          <outline text="当 APP 向系统发出通知时，它将先以图标的形式显示在通知栏中。用户可以下拉通知栏查看通知的详细信息。" />
          <outline text="通知栏和抽屉式通知栏均是由系统控制，用户可以随时查看。" />
          <outline text="Notification 的基本操作：有创建、更新、取消这三种。" />
          <outline text="涉及到3个类：">
            <outline text="Notification.Builer : 使用建造者模式构建 Notification 对象。">
              <outline text="仅支持 Android 4.1及之后的版本，为了解决兼容性问题， Google 在 Android Support v4 中加入了 NotificationCompat.Builder 类。" />
              <outline text="但是请注意，对于某些在 Android 4.1 之后才特性，使用NotificationCompat.Builder也不可用。" />
            </outline>
            <outline text="Notification : 通知对应类，保存通知相关的数据。NotificationManager 向系统发送通知时会用到。" />
            <outline text="NotificationManager : NotificationManager 是通知管理类，它是一个系统服务。调用 NotificationManager 的 notify() 方法可以向系统发送通知。" />
          </outline>
          <outline text="属性">
            <outline text="Notification.Builder mBuilder = new Notification.Builder(this);" />
            <outline text="后再调用下述的相关的方法进行设置：(官方API文档：Notification.Builder) 常用的方法如下：" />
            <outline text="&lt;b&gt;setContentTitle&lt;/b&gt;(CharSequence)：标题（&lt;b&gt;必须&lt;/b&gt;）" />
            <outline text="&lt;b&gt;setSmallIcon&lt;/b&gt;(int)：右下角的小图标（&lt;b&gt;必须&lt;/b&gt;）">
              <outline text="在接收到通知的时候顶部也会显示这个小图标。" />
              <outline text="当大小图标都设置了的时, smallIcon 显示在通知的右下角, largeIcon 显示在左侧。" />
              <outline text="当只设置 setSmallIcon() 时, smallIcon 显示在左侧。" />
            </outline>
            <outline text="&lt;b&gt;setContentText&lt;/b&gt;(CharSequence)：通知内容（&lt;b&gt;必须&lt;/b&gt;）" />
            <outline text="setLargeIcon(Bitmap)：设置左边的大图标（可选，以下都可选）" />
            <outline text="setSubText(CharSequence)：内容下面一小行的文字" />
            <outline text="setTicker(CharSequence)：设置收到通知时在顶部显示的文字信息" />
            <outline text="&lt;b&gt;setWhen&lt;/b&gt;(long)：设置通知时间，一般设置的是收到通知时的System.currentTimeMillis()" />
            <outline text="setAutoCancel(boolean)：用户点击Notification点击面板后是否让通知取消(默认不取消)" />
            <outline text="setDefaults(int)：向通知添加声音、闪灯和振动效果的最简单、 使用默认（defaults）属性，可以组合多个属性，">
              <outline text="Notification.DEFAULT_VIBRATE(添加默认震动提醒)；" />
              <outline text="Notification.DEFAULT_SOUND(添加默认声音提醒)；" />
              <outline text="Notification.DEFAULT_LIGHTS(添加默认三色灯提醒)" />
              <outline text="Notification.DEFAULT_ALL(添加默认以上3种全部提醒)" />
            </outline>
            <outline text="setVibrate(long[])：设置振动方式，比如：">
              <outline text="setVibrate(new long[] {0,300,500,700});延迟0ms，然后振动300ms，在延迟500ms， 接着再振动700ms，关于Vibrate用法后面会讲解。" />
            </outline>
            <outline text="setLights(int argb, int onMs, int offMs)：设置三色灯，参数依次是：灯光颜色， 亮持续时间，暗的时间，不是所有颜色都可以，这跟设备有关，有些手机还不带三色灯； 另外，还需要为Notification设置flags为Notification.FLAG_SHOW_LIGHTS才支持三色灯提醒！" />
            <outline text="setSound(Uri)：设置接收到通知时的铃声，可以用系统的，也可以自己设置，例子如下:" />
            <outline text="setDefaults(Notification.DEFAULT_SOUND)  // 获取默认铃声" />
            <outline text="setSound(Uri.parse(&quot;file:///sdcard/xx/xx.mp3&quot;))  // 获取自定义铃声" />
            <outline text="setSound(Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, &quot;5&quot;)) //获取Android多媒体库内的铃声" />
            <outline text="setOngoing(boolean)：设置为ture，表示它为一个正在进行的通知。他们通常是用来表示 一个后台任务,用户积极参与(如播放音乐)或以某种方式正在等待,因此占用设备(如一个文件下载, 同步操作,主动网络连接)" />
            <outline text="setProgress(int,int,boolean)：设置带进度条的通知 参数依次为：进度条最大数值，当前进度，进度是否不确定 如果为确定的进度条：调用setProgress(max, progress, false)来设置通知， 在更新进度的时候在此发起通知更新progress，并且在下载完成后要移除进度条 ，通过调用setProgress(0, 0, false)既可。如果为不确定（持续活动）的进度条， 这是在处理进度无法准确获知时显示活动正在持续，所以调用setProgress(0, 0, true) ，操作结束时，调用setProgress(0, 0, false)并更新通知以移除指示条" />
            <outline text="setContentIntent(PendingIntent)：PendingIntent。">
              <outline text="PendingIntent 是一种特殊的 Intent ，字面意思可以解释为延迟的 Intent ，用于在某个事件结束后执行特定的 Action 。" />
              <outline text="PendingIntent可以设置执行次数， 主要用于远程服务通信、闹铃、通知、启动器、短信中。" />
              <outline text="比如这里通过 Pending启动Activity：getActivity(Context, int, Intent, int)，当然还可以启动Service或者Broadcast。" />
              <outline text="注意： PendingIntent 是 AMS 管理并持有的对象。即便创建该 PendingIntent对象的进程被杀死了，这个PendingItent对象在其他进程中还是可用的。" />
              <outline text="PendingIntent的位标识符(第四个参数)：">
                <outline text="FLAG_ONE_SHOT 表示返回的PendingIntent仅能执行一次，执行完后自动取消" />
                <outline text="FLAG_NO_CREATE 表示如果描述的PendingIntent不存在，并不创建相应的PendingIntent，而是返回NULL" />
                <outline text="FLAG_CANCEL_CURRENT 表示相应的PendingIntent已经存在，则取消前者，然后创建新的PendingIntent， 这个有利于数据保持为最新的，可以用于即时通信的通信场景" />
                <outline text="FLAG_UPDATE_CURRENT 表示更新的 PendingIntent.  " />
              </outline>
            </outline>
            <outline text="setPriority(int)：设置优先级. 值域包括:">
              <outline text="MAX	重要而紧急的通知，通知用户这个事件是时间上紧迫的或者需要立即处理的。" />
              <outline text="HIGH	高优先级用于重要的通信内容，例如短消息或者聊天，这些都是对用户来说比较有兴趣的。" />
              <outline text="DEFAULT	默认优先级用于没有特殊优先级分类的通知。" />
              <outline text="LOW	低优先级可以通知用户但又不是很紧急的事件。" />
              <outline text="MIN	     用于后台消息 (例如天气或者位置信息)。最低优先级通知将只在状态栏显示图标，只有用户下拉通知抽屉才能看到内容。" />
            </outline>
          </outline>
          <outline text="Notification的基本使用流程">
            <outline text="Step 1. 获得NotificationManager对象： NotificationManager mNManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);" />
            <outline text="Step 2. 创建一个通知栏的Builder构造类： Notification.Builder mBuilder = new Notification.Builder(this);" />
            <outline text="Step 3. 对Builder进行相关的设置，比如标题，内容，图标，动作等！" />
            <outline text="Step 4.调用Builder的build()方法为notification赋值" />
            <outline text="Step 5.调用NotificationManager的notify()方法发送通知！" />
            <outline text="PS:另外我们还可以调用NotificationManager的cancel()方法取消通知" />
          </outline>
          <outline text="简单例子：" />
          <outline text="private void sendNotification() {">
            <outline text="//  1. 获取NotificationManager实例" />
            <outline text="NotificationManager notifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);" />
            <outline text="// 2. 实例化NotificationCompat.Builde并设置相关属性" />
            <outline text="NotificationCompat.Builder builder = new NotificationCompat.Builder(this)">
              <outline text="// 设置小图标" />
              <outline text=".setSmallIcon(R.mipmap.icon_fab_repair)" />
              <outline text="// 设置通知标题" />
              <outline text=".setContentTitle(&quot;最简单的Notification&quot;)" />
              <outline text="// 设置通知内容" />
              <outline text=".setContentText(&quot;只有小图标、标题、内容&quot;)" />
              <outline text="// 设置通知时间，默认为系统发出通知的时间，通常不用设置" />
              <outline text="//.setWhen(System.currentTimeMillis());" />
            </outline>
            <outline text="// 3. 通过builder.build()方法生成Notification对象,并发送通知,id=1" />
            <outline text="notifyManager.notify(1, builder.build());" />
          </outline>
          <outline text="}" />
          <outline text="如果需要用户交互，则应该给 Notification 设置一个 Action。">
            <outline text="例子：" />
            <outline text="// 发送一个点击跳转到MainActivity的消息" />
            <outline text="Intent mainIntent = new Intent(this, MainActivity.class);" />
            <outline text="PendingIntent mainPendingIntent = PendingIntent.getActivity(this, 0, mainIntent, PendingIntent.FLAG_UPDATE_CURRENT);" />
            <outline text="然后在 new NotificationCompat.Builder() 中setContentIntent(mainPendingIntent);" />
          </outline>
          <outline text="复杂例子：" />
          <outline text="public class MainActivity extends AppCompatActivity implements View.OnClickListener {">
            <outline text="private Context mContext;" />
            <outline text="private NotificationManager mNManager;" />
            <outline text="private Notification notify1;" />
            <outline text="Bitmap LargeBitmap = null;" />
            <outline text="private static final int NOTIFYID_1 = 1;" />
            <outline text="private Button btn_show_normal;" />
            <outline text="private Button btn_close_normal;" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="mContext = MainActivity.this;" />
              <outline text="// 创建大图标的Bitmap" />
              <outline text="LargeBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.iv_lc_icon);" />
              <outline text="mNManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);" />
              <outline text="bindView();" />
            </outline>
            <outline text="}" />
            <outline text="private void bindView() {">
              <outline text="btn_show_normal = (Button) findViewById(R.id.btn_show_normal);" />
              <outline text="btn_close_normal = (Button) findViewById(R.id.btn_close_normal);" />
              <outline text="btn_show_normal.setOnClickListener(this);" />
              <outline text="btn_close_normal.setOnClickListener(this);" />
            </outline>
            <outline text="}" />
            <outline text="public void onClick(View v) {">
              <outline text="switch (v.getId()) {">
                <outline text="case R.id.btn_show_normal:">
                  <outline text="// 定义一个PendingIntent点击Notification后启动一个Activity" />
                  <outline text="Intent it = new Intent(mContext, OtherActivity.class);" />
                  <outline text="PendingIntent pit = PendingIntent.getActivity(mContext, 0, it, 0);" />
                  <outline text="//设置图片,通知标题,发送时间,提示方式等属性" />
                  <outline text="Notification.Builder mBuilder = new Notification.Builder(this);" />
                  <outline text="mBuilder.setContentTitle(&quot;叶良辰&quot;) ">
                    <outline text=".setContentText(&quot;我有一百种方法让你呆不下去~&quot;)  " />
                    <outline text=".setSubText(&quot;——记住我叫叶良辰&quot;) " />
                    <outline text=".setTicker(&quot;收到叶良辰发送过来的信息~&quot;) " />
                    <outline text=".setWhen(System.currentTimeMillis()) " />
                    <outline text=".setSmallIcon(R.mipmap.ic_lol_icon) " />
                    <outline text=".setLargeIcon(LargeBitmap) " />
                    <outline text=".setDefaults(Notification.DEFAULT_LIGHTS | Notification.DEFAULT_VIBRATE)" />
                    <outline text=".setSound(Uri.parse(&quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.biaobiao)) " />
                    <outline text=".setAutoCancel(true) " />
                    <outline text=".setContentIntent(pit);" />
                  </outline>
                  <outline text="notify1 = mBuilder.build();" />
                  <outline text="mNManager.notify(NOTIFYID_1, notify1);" />
                  <outline text="break;" />
                </outline>
                <outline text="case R.id.btn_close_normal:">
                  <outline text="// 除了可以根据ID来取消Notification外,还可以调用cancelAll();关闭该应用产生的所有通知" />
                  <outline text="mNManager.cancel(NOTIFYID_1);" />
                  <outline text="break;" />
                </outline>
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="AlertDialog(对话框)">
          <outline text="AlertDialog是其他 Dialog的的父类, 包括ProgressDialog，TimePickerDialog等." />
          <outline text="不像Toast和Notification，AlertDialog并不能直接new出来.  AlertDialog的构造方法是protected的." />
          <outline text="如果要创建AlertDialog的话，需要使用到该类中的一个静态内部类：public static class Builder，然后来调用AlertDialog 里的相关方法来对AlertDialog进行定制，最后调用show()方法来显示我们的AlertDialog对话框." />
          <outline text="基本使用流程">
            <outline text="Step 1：创建AlertDialog.Builder对象；" />
            <outline text="Step 2：调用setIcon()设置图标，setTitle()或setCustomTitle()设置标题；" />
            <outline text="Step 3：设置对话框的内容：setMessage()还有其他方法来指定显示的内容；" />
            <outline text="Step 4：调用setPositive/Negative/NeutralButton()设置：确定，取消，中立按钮；" />
            <outline text="Step 5：调用create()方法创建这个对象，再调用show()方法将对话框显示出来；" />
          </outline>
          <outline text="例子: 点击后弹出对话框.">
            <outline text="public void onClick(View v) {">
              <outline text="switch (v.getId()) {">
                <outline text="//普通对话框" />
                <outline text="case R.id.btn_dialog_one:">
                  <outline text="alert = null;" />
                  <outline text="builder = new AlertDialog.Builder(mContext);" />
                  <outline text="alert = builder.setIcon(R.mipmap.ic_icon_fish)">
                    <outline text=".setTitle(&quot;系统提示：&quot;)" />
                    <outline text=".setMessage(&quot;这是一个最普通的AlertDialog,\n带有三个按钮，分别是取消，中立和确定&quot;)" />
                    <outline text=".setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which) {">
                        <outline text="Toast.makeText(mContext, &quot;你点击了取消按钮~&quot;, Toast.LENGTH_SHORT).show();" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="})" />
                    <outline text=".setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which) {">
                        <outline text="Toast.makeText(mContext, &quot;你点击了确定按钮~&quot;, Toast.LENGTH_SHORT).show();" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="})" />
                    <outline text=".setNeutralButton(&quot;中立&quot;, new DialogInterface.OnClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which) {">
                        <outline text="Toast.makeText(mContext, &quot;你点击了中立按钮~&quot;, Toast.LENGTH_SHORT).show();" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}).create();             //创建AlertDialog对象" />
                  </outline>
                  <outline text="alert.show();                    //显示对话框" />
                  <outline text="break;" />
                </outline>
                <outline text="//普通列表对话框" />
                <outline text="case R.id.btn_dialog_two:">
                  <outline text="final String[] lesson = new String[]{&quot;语文&quot;, &quot;数学&quot;, &quot;英语&quot;, &quot;化学&quot;, &quot;生物&quot;, &quot;物理&quot;, &quot;体育&quot;};" />
                  <outline text="alert = null;" />
                  <outline text="builder = new AlertDialog.Builder(mContext);" />
                  <outline text="alert = builder.setIcon(R.mipmap.ic_icon_fish)">
                    <outline text=".setTitle(&quot;选择你喜欢的课程&quot;)" />
                    <outline text=".setItems(lesson, new DialogInterface.OnClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which) {">
                        <outline text="Toast.makeText(getApplicationContext(), &quot;你选择了&quot; + lesson[which], Toast.LENGTH_SHORT).show();" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}).create();" />
                  </outline>
                  <outline text="alert.show();" />
                  <outline text="break;" />
                </outline>
                <outline text="//单选列表对话框" />
                <outline text="case R.id.btn_dialog_three:">
                  <outline text="final String[] fruits = new String[]{&quot;苹果&quot;, &quot;雪梨&quot;, &quot;香蕉&quot;, &quot;葡萄&quot;, &quot;西瓜&quot;};" />
                  <outline text="alert = null;" />
                  <outline text="builder = new AlertDialog.Builder(mContext);" />
                  <outline text="alert = builder.setIcon(R.mipmap.ic_icon_fish)">
                    <outline text=".setTitle(&quot;选择你喜欢的水果，只能选一个哦~&quot;)" />
                    <outline text=".setSingleChoiceItems(fruits, 0, new DialogInterface.OnClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which) {">
                        <outline text="Toast.makeText(getApplicationContext(), &quot;你选择了&quot; + fruits[which], Toast.LENGTH_SHORT).show();" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}).create();" />
                  </outline>
                  <outline text="alert.show();" />
                  <outline text="break;" />
                </outline>
                <outline text="//多选列表对话框" />
                <outline text="case R.id.btn_dialog_four:">
                  <outline text="final String[] menu = new String[]{&quot;水煮豆腐&quot;, &quot;萝卜牛腩&quot;, &quot;酱油鸡&quot;, &quot;胡椒猪肚鸡&quot;};" />
                  <outline text="//定义一个用来记录个列表项状态的boolean数组" />
                  <outline text="checkItems = new boolean[]{false, false, false, false};" />
                  <outline text="alert = null;" />
                  <outline text="builder = new AlertDialog.Builder(mContext);" />
                  <outline text="alert = builder.setIcon(R.mipmap.ic_icon_fish)">
                    <outline text=".setMultiChoiceItems(menu, checkItems, new DialogInterface.OnMultiChoiceClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which, boolean isChecked) {">
                        <outline text="checkItems[which] = isChecked;" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="})" />
                    <outline text=".setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {">
                      <outline text="public void onClick(DialogInterface dialog, int which) {">
                        <outline text="String result = &quot;&quot;;" />
                        <outline text="for (int i = 0; i &amp;lt; checkItems.length; i++) {">
                          <outline text="if (checkItems[i])">
                            <outline text="result += menu[i] + &quot; &quot;;" />
                          </outline>
                        </outline>
                        <outline text="}" />
                        <outline text="Toast.makeText(getApplicationContext(), &quot;客官你点了:&quot; + result, Toast.LENGTH_SHORT).show();" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="})" />
                    <outline text=".create();" />
                  </outline>
                  <outline text="alert.show();" />
                  <outline text="break;" />
                </outline>
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="ProgressDialog(进度条对话框)">
          <outline text="创建进度条对话框的方式有两种：">
            <outline text="直接调用ProgressDialog提供的静态方法show()显示" />
            <outline text="创建ProgressDialog,再设置对话框的参数,最后show()出来" />
          </outline>
          <outline text="例子:">
            <outline text="public class MainActivity extends AppCompatActivity implements View.OnClickListener{">
              <outline text="private Button btn_one;" />
              <outline text="private Button btn_two;" />
              <outline text="private Button btn_three;" />
              <outline text="private ProgressDialog pd1 = null;" />
              <outline text="private ProgressDialog pd2 = null;" />
              <outline text="private final static int MAXVALUE = 100;" />
              <outline text="private int progressStart = 0;" />
              <outline text="private int add = 0;" />
              <outline text="private Context mContext = null;" />
              <outline text="//定义一个用于更新进度的Handler,因为只能由主线程更新界面,所以要用Handler传递信息" />
              <outline text="final Handler hand = new Handler()" />
              <outline text="{">
                <outline text="public void handleMessage(Message msg) {">
                  <outline text="//这里的话如果接受到信息码是123" />
                  <outline text="if(msg.what == 123)" />
                  <outline text="{">
                    <outline text="//设置进度条的当前值" />
                    <outline text="pd2.setProgress(progressStart);" />
                  </outline>
                  <outline text="}" />
                  <outline text="//如果当前大于或等于进度条的最大值,调用dismiss()方法关闭对话框" />
                  <outline text="if(progressStart &amp;gt;= MAXVALUE)" />
                  <outline text="{">
                    <outline text="pd2.dismiss();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="};" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="mContext = MainActivity.this;" />
                <outline text="bindViews();" />
              </outline>
              <outline text="}" />
              <outline text="private void bindViews() {">
                <outline text="btn_one = (Button) findViewById(R.id.btn_one);" />
                <outline text="btn_two = (Button) findViewById(R.id.btn_two);" />
                <outline text="btn_three = (Button) findViewById(R.id.btn_three);" />
                <outline text="btn_one.setOnClickListener(this);" />
                <outline text="btn_two.setOnClickListener(this);" />
                <outline text="btn_three.setOnClickListener(this);" />
              </outline>
              <outline text="}" />
              <outline text="public void onClick(View v) {">
                <outline text="switch (v.getId()){">
                  <outline text="case R.id.btn_one:">
                    <outline text="//这里的话参数依次为,上下文,标题,内容,是否显示进度,是否可以用取消按钮关闭" />
                    <outline text="ProgressDialog.show(MainActivity.this, &quot;资源加载中&quot;, &quot;资源加载中,请稍后...&quot;,false,true);" />
                    <outline text="break;" />
                  </outline>
                  <outline text="case R.id.btn_two:">
                    <outline text="pd1 = new ProgressDialog(mContext);" />
                    <outline text="//依次设置标题,内容,是否用取消按钮关闭,是否显示进度" />
                    <outline text="pd1.setTitle(&quot;软件更新中&quot;);" />
                    <outline text="pd1.setMessage(&quot;软件正在更新中,请稍后...&quot;);" />
                    <outline text="pd1.setCancelable(true);" />
                    <outline text="//这里是设置进度条的风格,HORIZONTAL是水平进度条,SPINNER是圆形进度条" />
                    <outline text="pd1.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);" />
                    <outline text="pd1.setIndeterminate(true);" />
                    <outline text="//调用show()方法将ProgressDialog显示出来" />
                    <outline text="pd1.show();" />
                    <outline text="break;" />
                  </outline>
                  <outline text="case R.id.btn_three:">
                    <outline text="//初始化属性" />
                    <outline text="progressStart = 0;" />
                    <outline text="add = 0;" />
                    <outline text="//依次设置一些属性" />
                    <outline text="pd2 = new ProgressDialog(MainActivity.this);" />
                    <outline text="pd2.setMax(MAXVALUE);" />
                    <outline text="pd2.setTitle(&quot;文件读取中&quot;);" />
                    <outline text="pd2.setMessage(&quot;文件加载中,请稍后...&quot;);" />
                    <outline text="//这里设置为不可以通过按取消按钮关闭进度条" />
                    <outline text="pd2.setCancelable(false);" />
                    <outline text="pd2.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);" />
                    <outline text="//这里设置的是是否显示进度,设为false才是显示的哦！" />
                    <outline text="pd2.setIndeterminate(false);" />
                    <outline text="pd2.show();" />
                    <outline text="//这里的话新建一个线程,重写run()方法," />
                    <outline text="new Thread()" />
                    <outline text="{">
                      <outline text="public void run()" />
                      <outline text="{">
                        <outline text="while(progressStart &amp;lt; MAXVALUE)" />
                        <outline text="{">
                          <outline text="//这里的算法是决定进度条变化的,可以按需要写" />
                          <outline text="progressStart = 2 * usetime() ;" />
                          <outline text="//把信息码发送给handle让更新界面" />
                          <outline text="hand.sendEmptyMessage(123);" />
                        </outline>
                        <outline text="}" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}.start();" />
                    <outline text="break;" />
                  </outline>
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
              <outline text="//这里设置一个耗时的方法:" />
              <outline text="private int usetime() {">
                <outline text="add++;" />
                <outline text="try{">
                  <outline text="Thread.sleep(100);" />
                </outline>
                <outline text="}catch (InterruptedException e) {">
                  <outline text="e.printStackTrace();" />
                </outline>
                <outline text="}" />
                <outline text="return add;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="DatePickerDialog(日期选择对话框)与TimePickerDialog(时间选择对话框)">
          <outline text="直接上例子" />
          <outline text="public class MainActivity extends AppCompatActivity implements View.OnClickListener{">
            <outline text="private Button btn_date;" />
            <outline text="private Button btn_time;" />
            <outline text="private String result = &quot;&quot;;" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="bindViews();" />
            </outline>
            <outline text="}" />
            <outline text="private void bindViews() {">
              <outline text="btn_date = (Button) findViewById(R.id.btn_date);" />
              <outline text="btn_time = (Button) findViewById(R.id.btn_time);" />
              <outline text="btn_date.setOnClickListener(this);" />
              <outline text="btn_time.setOnClickListener(this);" />
            </outline>
            <outline text="}" />
            <outline text="public void onClick(View v) {">
              <outline text="result = &quot;&quot;;" />
              <outline text="switch (v.getId()){">
                <outline text="case R.id.btn_date:">
                  <outline text="Calendar cale1 = Calendar.getInstance();" />
                  <outline text="new DatePickerDialog(MainActivity.this,new DatePickerDialog.OnDateSetListener() {">
                    <outline text="public void onDateSet(DatePicker view, int year, int monthOfYear,">
                      <outline text="int dayOfMonth) {" />
                      <outline text="//这里获取到的月份需要加上1哦~" />
                      <outline text="result += &quot;你选择的是&quot;+year+&quot;年&quot;+(monthOfYear+1)+&quot;月&quot;+dayOfMonth+&quot;日&quot;;" />
                      <outline text="Toast.makeText(getApplicationContext(), result, Toast.LENGTH_SHORT).show();" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="}">
                    <outline text=",cale1.get(Calendar.YEAR)">
                      <outline text=",cale1.get(Calendar.MONTH)" />
                      <outline text=",cale1.get(Calendar.DAY_OF_MONTH)).show();" />
                    </outline>
                  </outline>
                  <outline text="break;" />
                </outline>
                <outline text="case R.id.btn_time:">
                  <outline text="Calendar cale2 = Calendar.getInstance();" />
                  <outline text="new TimePickerDialog(MainActivity.this, new TimePickerDialog.OnTimeSetListener() {">
                    <outline text="public void onTimeSet(TimePicker view, int hourOfDay, int minute) {">
                      <outline text="result = &quot;&quot;;" />
                      <outline text="result += &quot;您选择的时间是:&quot;+hourOfDay+&quot;时&quot;+minute+&quot;分&quot;;" />
                      <outline text="Toast.makeText(getApplicationContext(), result, Toast.LENGTH_SHORT).show();" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="}, cale2.get(Calendar.HOUR_OF_DAY), cale2.get(Calendar.MINUTE), true).show();" />
                  <outline text="break;" />
                </outline>
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="PopupWindow(悬浮框)">
          <outline text="也是弹出框. 但和AlertDialog对话框不同的是，它的位置可以是随意的." />
          <outline text="另外AlertDialog是非堵塞线程的，而PopupWindow则是堵塞线程的. 即它是模式窗口." />
          <outline text="常用的构造方法">
            <outline text="public PopupWindow (Context context)" />
            <outline text="public PopupWindow(View contentView, int width, int height)" />
            <outline text="public PopupWindow(View contentView)" />
            <outline text="public PopupWindow(View contentView, int width, int height, boolean focusable)" />
          </outline>
          <outline text="属性">
            <outline text="setContentView(View contentView)：设置PopupWindow显示的View" />
            <outline text="getContentView()：获得PopupWindow显示的View" />
            <outline text="showAsDropDown(View anchor)：相对某个控件的位置（正左下方），无偏移" />
            <outline text="showAsDropDown(View anchor, int xoff, int yoff)：相对某个控件的位置，有偏移" />
            <outline text="showAtLocation(View parent, int gravity, int x, int y)： 相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 PS:parent这个参数只要是activity中的view就可以了！" />
            <outline text="setWidth/setHeight：设置宽高，也可以在构造方法那里指定好宽高， 除了可以写具体的值，还可以用WRAP_CONTENT或MATCH_PARENT， popupWindow的width和height属性直接和第一层View相对应。" />
            <outline text="setFocusable(true)：设置焦点，PopupWindow弹出后，所有的触屏和物理按键都由PopupWindows 处理。其他任何事件的响应都必须发生在PopupWindow消失之后，（home 等系统层面的事件除外）。 比如这样一个PopupWindow出现的时候，按back键首先是让PopupWindow消失，第二次按才是退出 activity，准确的说是想退出activity你得首先让PopupWindow消失，因为不并是任何情况下按back PopupWindow都会消失，必须在PopupWindow设置了背景的情况下 。" />
            <outline text="setAnimationStyle(int)：设置动画效果" />
          </outline>
          <outline text="例子:">
            <outline text="public class MainActivity extends AppCompatActivity {">
              <outline text="private Button btn_show;" />
              <outline text="private Context mContext;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="mContext = MainActivity.this;" />
                <outline text="btn_show = (Button) findViewById(R.id.btn_show);" />
                <outline text="btn_show.setOnClickListener(new View.OnClickListener() {">
                  <outline text="public void onClick(View v) {">
                    <outline text="initPopWindow(v);" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
              <outline text="private void initPopWindow(View v) {">
                <outline text="View view = LayoutInflater.from(mContext).inflate(R.layout.item_popup, null, false);" />
                <outline text="Button btn_xixi = (Button) view.findViewById(R.id.btn_xixi);" />
                <outline text="Button btn_hehe = (Button) view.findViewById(R.id.btn_hehe);" />
                <outline text="//1.构造一个PopupWindow，参数依次是加载的View，宽高" />
                <outline text="final PopupWindow popWindow = new PopupWindow(view,">
                  <outline text="ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true);" />
                </outline>
                <outline text="popWindow.setAnimationStyle(R.anim.anim_pop);  //设置加载动画" />
                <outline text="//这些为了点击非PopupWindow区域，PopupWindow会消失的，如果没有下面的" />
                <outline text="//代码的话，你会发现，当你把PopupWindow显示出来了，无论你按多少次后退键" />
                <outline text="//PopupWindow并不会关闭，而且退不出程序，加上下述代码可以解决这个问题" />
                <outline text="popWindow.setTouchable(true);" />
                <outline text="popWindow.setTouchInterceptor(new View.OnTouchListener() {">
                  <outline text="public boolean onTouch(View v, MotionEvent event) {">
                    <outline text="return false;" />
                    <outline text="// 这里如果返回true的话，touch事件将被拦截" />
                    <outline text="// 拦截后 PopupWindow的onTouchEvent不被调用，这样点击外部区域无法dismiss" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
                <outline text="popWindow.setBackgroundDrawable(new ColorDrawable(0x00000000));    //要为popWindow设置一个背景才有效" />
                <outline text="//设置popupWindow显示的位置，参数依次是参照View，x轴的偏移量，y轴的偏移量" />
                <outline text="popWindow.showAsDropDown(v, 50, 0);" />
                <outline text="//设置popupWindow里的按钮的事件" />
                <outline text="btn_xixi.setOnClickListener(new View.OnClickListener() {">
                  <outline text="public void onClick(View v) {">
                    <outline text="Toast.makeText(MainActivity.this, &quot;你点击了嘻嘻~&quot;, Toast.LENGTH_SHORT).show();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
                <outline text="btn_hehe.setOnClickListener(new View.OnClickListener() {">
                  <outline text="public void onClick(View v) {">
                    <outline text="Toast.makeText(MainActivity.this, &quot;你点击了呵呵~&quot;, Toast.LENGTH_SHORT).show();" />
                    <outline text="popWindow.dismiss();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="菜单(Menu)">
          <outline text="Android中的菜单有如下几种：">
            <outline text="OptionMenu：选项菜单，android中最常见的菜单，通过Menu键来调用" />
            <outline text="SubMenu：子菜单，android中点击子菜单将弹出一个显示子菜单项的悬浮框， 子菜单不支持嵌套，即不能包括其他子菜单" />
            <outline text="ContextMenu：上下文菜单，通过长按某个视图组件后出现的菜单，该组件需注册上下文菜单." />
          </outline>
          <outline text="OptionMenu(选项菜单)">
            <outline text="产生选项菜单只需要实现如下2个接口:">
              <outline text="public boolean onCreateOptionsMenu(Menu menu)：调用OptionMenu，在这里完成菜单初始化" />
              <outline text="public boolean onOptionsItemSelected(MenuItem item)：菜单项被选中时触发，这里完成事件处理" />
            </outline>
            <outline text="其它接口还有3个:">
              <outline text="public void onOptionsMenuClosed(Menu menu)：菜单关闭会调用该方法" />
              <outline text="public boolean onPrepareOptionsMenu(Menu menu)：选项菜单显示前会调用该方法， 可在这里进行菜单的调整(动态加载菜单列表)" />
              <outline text="public boolean onMenuOpened(int featureId, Menu menu)：选项菜单打开以后会调用这个方法" />
            </outline>
            <outline text="例子:">
              <outline text="public class MainActivity extends AppCompatActivity {">
                <outline text="//1.定义不同颜色的菜单项的标识:" />
                <outline text="final private int RED = 110;" />
                <outline text="final private int GREEN = 111;" />
                <outline text="final private int BLUE = 112;" />
                <outline text="final private int YELLOW = 113;" />
                <outline text="final private int GRAY= 114;" />
                <outline text="final private int CYAN= 115;" />
                <outline text="final private int BLACK= 116;" />
                <outline text="private TextView tv_test;" />
                <outline text="protected void onCreate(Bundle savedInstanceState) {">
                  <outline text="super.onCreate(savedInstanceState);" />
                  <outline text="setContentView(R.layout.activity_main);" />
                  <outline text="tv_test = (TextView) findViewById(R.id.tv_test);" />
                </outline>
                <outline text="}" />
                <outline text="public boolean onCreateOptionsMenu(Menu menu) {">
                  <outline text="// Inflate the menu; this adds items to the action bar if it is present." />
                  <outline text="menu.add(1,RED,4,&quot;红色&quot;);" />
                  <outline text="menu.add(1,GREEN,2,&quot;绿色&quot;);" />
                  <outline text="menu.add(1,BLUE,3,&quot;蓝色&quot;);" />
                  <outline text="menu.add(1,YELLOW,1,&quot;黄色&quot;);" />
                  <outline text="menu.add(1,GRAY,5,&quot;灰色&quot;);" />
                  <outline text="menu.add(1,CYAN,6,&quot;蓝绿色&quot;);" />
                  <outline text="menu.add(1,BLACK,7,&quot;黑色&quot;);" />
                  <outline text="return true;" />
                </outline>
                <outline text="}" />
                <outline text="public boolean onOptionsItemSelected(MenuItem item) {">
                  <outline text="// Handle action bar item clicks here. The action bar will" />
                  <outline text="// automatically handle clicks on the Home/Up button, so long" />
                  <outline text="// as you specify a parent activity in AndroidManifest.xml." />
                  <outline text="int id = item.getItemId();" />
                  <outline text="switch (id){">
                    <outline text="case RED:">
                      <outline text="tv_test.setTextColor(Color.RED);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case GREEN:">
                      <outline text="tv_test.setTextColor(Color.GREEN);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case BLUE:">
                      <outline text="tv_test.setTextColor(Color.BLUE);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case YELLOW:">
                      <outline text="tv_test.setTextColor(Color.YELLOW);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case GRAY:">
                      <outline text="tv_test.setTextColor(Color.GRAY);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case CYAN:">
                      <outline text="tv_test.setTextColor(Color.CYAN);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case BLACK:">
                      <outline text="tv_test.setTextColor(Color.BLACK);" />
                      <outline text="break;" />
                    </outline>
                  </outline>
                  <outline text="}" />
                  <outline text="return super.onOptionsItemSelected(item);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
          <outline text="ContextMenu(上下文菜单)">
            <outline text="基本流程">
              <outline text="Step 1：重写onCreateContextMenu()方法" />
              <outline text="Step 2：为view组件注册上下文菜单，使用registerForContextMenu()方法,参数是View" />
              <outline text="Step 3：重写onContextItemSelected()方法为菜单项指定事件监听器" />
            </outline>
            <outline text="例子">
              <outline text="// 布局文件" />
              <outline text="&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;" />
              <outline text="&amp;lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;">
                <outline text="&amp;lt;!-- 定义一组单选按钮 --&amp;gt;" />
                <outline text="&amp;lt;!-- checkableBehavior的可选值由三个：single设置为单选，all为多选，none为普通选项 --&amp;gt;" />
                <outline text="&amp;lt;group android:checkableBehavior=&quot;none&quot;&amp;gt;">
                  <outline text="&amp;lt;item android:id=&quot;@+id/blue&quot; android:title=&quot;@string/font_blue&quot;/&amp;gt;" />
                  <outline text="&amp;lt;item android:id=&quot;@+id/green&quot; android:title=&quot;@string/font_green&quot;/&amp;gt;" />
                  <outline text="&amp;lt;item android:id=&quot;@+id/red&quot; android:title=&quot;@string/font_red&quot;/&amp;gt;" />
                </outline>
                <outline text="&amp;lt;/group&amp;gt;" />
              </outline>
              <outline text="&amp;lt;/menu&amp;gt;" />
              <outline text="// 代码" />
              <outline text="private TextView tv_context;" />
              <outline text="tv_context = (TextView) findViewById(R.id.tv_context);">
                <outline text="registerForContextMenu(tv_context);" />
                <outline text="//重写与ContextMenu相关方法" />
                <outline text="//重写上下文菜单的创建方法" />
                <outline text="public void onCreateContextMenu(ContextMenu menu, View v,">
                  <outline text="ContextMenu.ContextMenuInfo menuInfo) {" />
                  <outline text="MenuInflater inflator = new MenuInflater(this);" />
                  <outline text="inflator.inflate(R.menu.menu_context, menu);" />
                  <outline text="super.onCreateContextMenu(menu, v, menuInfo);" />
                </outline>
                <outline text="}" />
                <outline text="//上下文菜单被点击是触发该方法" />
                <outline text="public boolean onContextItemSelected(MenuItem item) {">
                  <outline text="switch (item.getItemId()) {">
                    <outline text="case R.id.blue:">
                      <outline text="tv_context.setTextColor(Color.BLUE);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case R.id.green:">
                      <outline text="tv_context.setTextColor(Color.GREEN);" />
                      <outline text="break;" />
                    </outline>
                    <outline text="case R.id.red:">
                      <outline text="tv_context.setTextColor(Color.RED);" />
                      <outline text="break;" />
                    </outline>
                  </outline>
                  <outline text="}" />
                  <outline text="return true;" />
                </outline>
                <outline text="}" />
              </outline>
            </outline>
          </outline>
          <outline text="SubMenu(子菜单)">
            <outline text="public void onCreateContextMenu(ContextMenu menu, View v,">
              <outline text="ContextMenu.ContextMenuInfo menuInfo) {">
                <outline text="//子菜单部分：" />
                <outline text="MenuInflater inflator = new MenuInflater(this);" />
                <outline text="inflator.inflate(R.menu.menu_sub, menu);" />
                <outline text="super.onCreateContextMenu(menu, v, menuInfo);" />
              </outline>
            </outline>
            <outline text="}" />
            <outline text="public boolean onContextItemSelected(MenuItem item) {">
              <outline text="switch (item.getItemId()) {">
                <outline text="case R.id.one:">
                  <outline text="Toast.makeText(MainActivity.this,&quot;你点击了子菜单一&quot;,Toast.LENGTH_SHORT).show();">
                    <outline text="break;" />
                  </outline>
                  <outline text="case R.id.two:">
                    <outline text="item.setCheckable(true);" />
                    <outline text="Toast.makeText(MainActivity.this,&quot;你点击了子菜单二&quot;,Toast.LENGTH_SHORT).show();" />
                    <outline text="break;" />
                  </outline>
                  <outline text="case R.id.three:">
                    <outline text="Toast.makeText(MainActivity.this,&quot;你点击了子菜单三&quot;,Toast.LENGTH_SHORT).show();" />
                    <outline text="item.setCheckable(true);" />
                    <outline text="break;" />
                  </outline>
                </outline>
                <outline text="}" />
              </outline>
              <outline text="return true;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="PopupMenu(弹出式菜单)">
            <outline text="直接上例子:" />
            <outline text="btn_show_menu.setOnClickListener(new View.OnClickListener() {">
              <outline text="public void onClick(View v) {">
                <outline text="PopupMenu popup = new PopupMenu(MainActivity.this,btn_show_menu);" />
                <outline text="popup.getMenuInflater().inflate(R.menu.menu_pop, popup.getMenu());" />
                <outline text="popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {">
                  <outline text="public boolean onMenuItemClick(MenuItem item) {">
                    <outline text="switch (item.getItemId()){">
                      <outline text="case R.id.lpig:">
                        <outline text="Toast.makeText(MainActivity.this,&quot;你点了小猪~&quot;," />
                        <outline text="Toast.LENGTH_SHORT).show();" />
                        <outline text="break;" />
                      </outline>
                      <outline text="case R.id.bpig:">
                        <outline text="Toast.makeText(MainActivity.this,&quot;你点了大猪~&quot;," />
                        <outline text="Toast.LENGTH_SHORT).show();" />
                        <outline text="break;" />
                      </outline>
                    </outline>
                    <outline text="}" />
                    <outline text="return true;" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
                <outline text="popup.show();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="});" />
          </outline>
        </outline>
        <outline text="ViewPager(视图滑动切换工具)">
          <outline text="通过手势滑动可以完成View的切换，一般是用来做APP 的引导页或者实现图片轮播." />
          <outline text="是3.0后引入的. 如果想在低版本下使用，就需要引入v4 兼容包." />
          <outline text="ViewPager是一个简单的页面切换组件，我们可以往里面填充多个View，然后我们可以左 右滑动，从而切换不同的View，我们可以通过setPageTransformer()方法为我们的ViewPager 设置切换时的动画效果." />
          <outline text="属性">
            <outline text="getCount():获得viewpager中有多少个view.  --必须实现." />
            <outline text="destroyItem():移除一个给定位置的页面。适配器有责任从容器中删除这个视图。 这是为了确保在finishUpdate(viewGroup)返回时视图能够被移除。 --必须实现" />
            <outline text="instantiateItem(): ①将给定位置的view添加到ViewGroup(容器)中,创建并显示出来 ②返回一个代表新增页面的Object(key),通常都是直接返回view本身就可以了,当然你也可以 自定义自己的key,但是key和每个view要一一对应的关系 " />
            <outline text="isViewFromObject(): 判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是 代表的同一个视图(即它俩是否是对应的，对应的表示同一个View),通常我们直接写 return view == object!" />
          </outline>
          <outline text="例子">
            <outline text="public class OneActivity extends AppCompatActivity{">
              <outline text="private ViewPager vpager_one;" />
              <outline text="private ArrayList&amp;lt;View&amp;gt; aList;" />
              <outline text="private MyPagerAdapter mAdapter;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_one);" />
                <outline text="vpager_one = (ViewPager) findViewById(R.id.vpager_one);" />
                <outline text="aList = new ArrayList&amp;lt;View&amp;gt;();" />
                <outline text="LayoutInflater li = getLayoutInflater();" />
                <outline text="aList.add(li.inflate(R.layout.view_one,null,false));" />
                <outline text="aList.add(li.inflate(R.layout.view_two,null,false));" />
                <outline text="aList.add(li.inflate(R.layout.view_three,null,false));" />
                <outline text="mAdapter = new MyPagerAdapter(aList);" />
                <outline text="vpager_one.setAdapter(mAdapter);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="DrawerLayout(侧滑菜单)">
          <outline text="3.0以后引入，低版本使用它需要v4兼容包." />
          <outline text="使用的注意事项">
            <outline text="1.主内容视图一定要是DrawerLayout的第一个子视图" />
            <outline text="2.主内容视图宽度和高度需要match_parent" />
            <outline text="3.必须显示指定侧滑视图的android:layout_gravity属性 android:layout_gravity = &quot;start&quot;时，从左向右滑出菜单 android:layout_gravity = &quot;end&quot;时，从右向左滑出菜单 不推荐使用left和right!" />
            <outline text="侧滑视图的宽度以dp为单位，不建议超过320dp(为了总能看到一些主内容视图)" />
            <outline text="最多由三个部分组成，中间的内容部分，左边的侧滑菜单部分，右边的侧滑菜单部分组成." />
            <outline text="设置侧滑事件：mDrawerLayout.setDrawerListener(DrawerLayout.DrawerListener);" />
          </outline>
          <outline text="例子">
            <outline text="// 布局" />
            <outline text="&amp;lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
              <outline text="android:id=&quot;@+id/drawer_layout&quot;" />
              <outline text="android:layout_width=&quot;match_parent&quot;" />
              <outline text="android:layout_height=&quot;match_parent&quot;&amp;gt;" />
              <outline text="&amp;lt;FrameLayout">
                <outline text="android:id=&quot;@+id/ly_content&quot;" />
                <outline text="android:layout_width=&quot;match_parent&quot;" />
                <outline text="android:layout_height=&quot;match_parent&quot; /&amp;gt;" />
              </outline>
              <outline text="&amp;lt;ListView">
                <outline text="android:id=&quot;@+id/list_left_drawer&quot;" />
                <outline text="android:layout_width=&quot;180dp&quot;" />
                <outline text="android:layout_height=&quot;match_parent&quot;" />
                <outline text="android:layout_gravity=&quot;start&quot;" />
                <outline text="android:background=&quot;#080808&quot;" />
                <outline text="android:choiceMode=&quot;singleChoice&quot;" />
                <outline text="android:divider=&quot;#FFFFFF&quot;" />
                <outline text="android:dividerHeight=&quot;1dp&quot; /&amp;gt;" />
              </outline>
            </outline>
            <outline text="&amp;lt;/android.support.v4.widget.DrawerLayout&amp;gt;" />
            <outline text="// 代码" />
            <outline text="// ContentFragment.java" />
            <outline text="public class ContentFragment extends Fragment {">
              <outline text="private TextView tv_content;" />
              <outline text="public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {">
                <outline text="View view = inflater.inflate(R.layout.fg_content, container, false);" />
                <outline text="tv_content = (TextView) view.findViewById(R.id.tv_content);" />
                <outline text="String text = getArguments().getString(&quot;text&quot;);" />
                <outline text="tv_content.setText(text);" />
                <outline text="return view;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="// MainActivity.java" />
            <outline text="public class MainActivity extends AppCompatActivity implements AdapterView.OnItemClickListener{">
              <outline text="private DrawerLayout drawer_layout;" />
              <outline text="private ListView list_left_drawer;" />
              <outline text="private ArrayList&amp;lt;Item&amp;gt; menuLists;" />
              <outline text="private MyAdapter&amp;lt;Item&amp;gt; myAdapter = null;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="drawer_layout = (DrawerLayout) findViewById(R.id.drawer_layout);" />
                <outline text="list_left_drawer = (ListView) findViewById(R.id.list_left_drawer);" />
                <outline text="menuLists = new ArrayList&amp;lt;Item&amp;gt;();" />
                <outline text="menuLists.add(new Item(R.mipmap.iv_menu_realtime,&quot;实时信息&quot;));" />
                <outline text="menuLists.add(new Item(R.mipmap.iv_menu_alert,&quot;提醒通知&quot;));" />
                <outline text="menuLists.add(new Item(R.mipmap.iv_menu_trace,&quot;活动路线&quot;));" />
                <outline text="menuLists.add(new Item(R.mipmap.iv_menu_settings,&quot;相关设置&quot;));" />
                <outline text="myAdapter = new MyAdapter&amp;lt;Item&amp;gt;(menuLists,R.layout.item_list) {">
                  <outline text="public void bindView(ViewHolder holder, Item obj) {">
                    <outline text="holder.setImageResource(R.id.img_icon,obj.getIconId());" />
                    <outline text="holder.setText(R.id.txt_content, obj.getIconName());" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="};" />
                <outline text="list_left_drawer.setAdapter(myAdapter);" />
                <outline text="list_left_drawer.setOnItemClickListener(this);" />
              </outline>
              <outline text="}" />
              <outline text="public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {">
                <outline text="ContentFragment contentFragment = new ContentFragment();" />
                <outline text="Bundle args = new Bundle();" />
                <outline text="args.putString(&quot;text&quot;, menuLists.get(position).getIconName());" />
                <outline text="contentFragment.setArguments(args);" />
                <outline text="FragmentManager fm = getSupportFragmentManager();" />
                <outline text="fm.beginTransaction().replace(R.id.ly_content,contentFragment).commit();" />
                <outline text="drawer_layout.closeDrawer(list_left_drawer);" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="导航栏">
          <outline text="在5.0后，ActionBarActivity被Google弃用了，推荐用 ToolBar." />
          <outline text="" />
        </outline>
        <outline text="SurfaceView">
          <outline text="视频内容, 或openGL内容往往显示在 SurfaceView 中. 一般用于游戏, 高画质图片, 相机预览等场景." />
          <outline text="SurfaceView 可通过 SurfaceHolderAddCallback 方法在子线程中更新UI, 不依赖主线程." />
          <outline text="SurfaceView 刷新效率较高，因为：  #面试题">
            <outline text="它是一个置于应用窗口前面的独立窗口；" />
            <outline text="有独立的 surface(画布)；" />
            <outline text="有专门的线程来画图,  不依赖UI线程；" />
            <outline text="其刷新不会导致view hierarchy 的递归绘制。" />
            <outline text="作为对比, 普通view在刷新时, 会递归刷新其各级父view. 效率非常低下." />
          </outline>
          <outline text="但是SurfaceView 也有缺点, 因为它不在应用窗口, 所以它:   #面试题">
            <outline text="不能使用变换(平移, 缩放, 旋转等), " />
            <outline text="不能放在 ListView 或 ScrollView 等容器中滚动, " />
            <outline text="不能使用ui控制的一些属性, 比如设置透明度." />
          </outline>
        </outline>
        <outline text="TextureView">
          <outline text="TextureView 是SurfaceView的升级版, 取其精华去其糟粕:   #面试题">
            <outline text="为了解决SurfaceView 的缺点, Android 4.0 引入了 TextureView . " />
            <outline text="TextureView 具有SurfaceView 的优点, 可以在独立线程中绘制和渲染. " />
            <outline text="和后者不同的是, TextureView 没有创建独立的Surface 来绘制, 而是继承自view, 因此可以象普通view一样在view hierarchy中管理与绘制, 并处理变换, 比如横竖屏切换, 设置透明度等. " />
            <outline text="TextureView 也有限制, 它必须放在开启硬件加速的窗口中." />
          </outline>
          <outline text="TextureView 持有 SurfaceTexture 和 HardwareLayer. 其要点是: ">
            <outline text="通过重载 draw() 方法, 把 SurfaceTexture 中捕获的图像数据作为openGL纹理更新到 HardwareLayer 中去. " />
            <outline text="SurfaceTexture.OnFrameAvailableListener用于通知 TextureView 有新图像数据到来." />
            <outline text="SurfaceTextureListener 用于通知 TextureView 的使用者, SurfaceTexture 已经准备好. 这样就可以把SurfaceTexture 交给相应的内容源. 其接口包括:">
              <outline text="OnSurfaceTextureAvailable(): 在SurfaceTexture 准备好时被调用." />
              <outline text="OnSurfaceTextureDestroyed(): 在SurfaceTexture 即将被销毁时被调用. ">
                <outline text="注意: 如果该函数返回 true, 则调用此方法后, SurfaceTexture 中不会发生渲染. 如果返回false, 则客户端需要调用 release(). " />
                <outline text="一般应该返回true." />
              </outline>
              <outline text="OnSurfaceTextureSizeChanged(): 在SurfaceTexture 的缓冲区大小更改时被调用." />
              <outline text="OnSurfaceTextureUpdated(): 在SurfaceTexture 更新时被调用. 需要调用 updataTextImage()." />
            </outline>
            <outline text="TextureView 持有 Surface, Surface作为 BufferQueue的 producer接口实现类, 使生产者可以通过它的软件或硬件渲染接口为 SurfaceTexture 内部的 BufferQueue 提供graphic buffer." />
            <outline text="TextureView 可通过TextureView.setSurfaceTextureListener 在子线程中更新UI." />
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;12-显示系统&lt;/b&gt;">
        <outline text="屏幕物理结构（一般是三层）">
          <outline text="最外面是玻璃">
            <outline text="康宁Gorilla玻璃">
              <outline text="俗称大猩猩，比塑料硬30倍，比塑料韧性好20倍，防刮耐磨。" />
              <outline text="硬度在6.5-7之间。也就是说" />
              <outline text="高端智能机基本都用了。" />
            </outline>
          </outline>
          <outline text="中间是TP">
            <outline text="in-cell技术，即tp模组玻璃和前面板玻璃融为一体，也叫单玻璃（OGS）技术。">
              <outline text="只有三家厂商有这个技术：LG Display、夏普以及Japan Display Inc。" />
              <outline text="其产能基本被苹果垄断。" />
            </outline>
            <outline text="电阻屏">
              <outline text="三层膜都是透明的。" />
              <outline text="利用压力感应来控制。" />
              <outline text="原理很简单，两层导电膜之间隔一层电阻膜，后者布满了小孔（孔径小于1/1000英寸）。" />
              <outline text="如果手指按下，两层导电膜会导通，通电位置不同电阻不同，于是就可以算出坐标。" />
              <outline text="常用的电阻屏是四线电阻屏，每层导电膜各有两个线，一个竖直方向，一个水平方向，加5v恒定电压。" />
            </outline>
            <outline text="电容屏">
              <outline text="当手指触摸时，人体的静电流入产生微弱的电流，电流会引起电压的变化，根据电压变化可计算触点的位置。" />
              <outline text="电容屏把人体作为一个电极使用。" />
              <outline text="当人体没接触屏时，面板各处电压都相同，没有电流通过。" />
              <outline text="电容屏的优势">
                <outline text="电容屏中，压力值无效。" />
                <outline text="方便，用手指即可；" />
                <outline text="操作流畅；" />
                <outline text="屏的透光性好。" />
              </outline>
            </outline>
          </outline>
          <outline text="最里面是屏幕. 主要有LCD和 OLED 两种：" />
          <outline text="LCD (Liquid Crystal Display)，即液晶显示器。包括：">
            <outline text="TFT">
              <outline text="TFT(Thin Film Transistor) 即薄膜场效应晶体管，它可以“主动地”对屏幕上的各个独立的像素进行控制，这样可以大大提高反应时间。" />
              <outline text="一般TFT的反应时间比较快，约80毫秒。" />
              <outline text="而且可视角度大，一般可达到130度左右。" />
              <outline text="成本低廉。" />
              <outline text="基于TFT屏幕的改进面板技术包括：IPS、ASV、NOVA" />
            </outline>
            <outline text="IPS">
              <outline text="IPS是一种基于TFT屏幕的改进面板技术。" />
              <outline text="这种LCD已经存在有一段时间了，但在苹果平板电脑之前一直没有大规模使用。" />
              <outline text="IPS能提供更广阔的视角，更好的色彩还原。" />
              <outline text="IPS仍然属于LCD范畴，最大生产商是LG。" />
            </outline>
            <outline text="SLCD">
              <outline text="SLCD，全名Super clear LCD，是由三星研制。" />
              <outline text="其拥有Super AMOLED的艳丽对比度，色彩更暖，更自然，适合人眼观看，屏幕清晰。" />
              <outline text="SLCD是一种液晶屏幕，不是自发光的。可看成TFT的一个超级版。" />
            </outline>
          </outline>
          <outline text="OLED (Organic Light-Emitting Diode)，即有机发光二极管。">
            <outline text="三星引以为傲AMOLED系列屏幕属于OLED，被称誉为“梦幻显示器”。" />
            <outline text="OLED显示技术与传统的LCD显示方式不同，无需背光灯。" />
            <outline text="它采用非常薄的有机材料涂层和玻璃基板。当电流通过时，有机材料就会发光。" />
            <outline text="在显示黑色时，相应的像素点无需发光，可以减少电量消耗，提升手机续航. " />
            <outline text="而且OLED屏幕可以做得更轻更薄，可视角度更大，并能显著的节省耗电。" />
          </outline>
        </outline>
        <outline text="摩氏矿物硬度表">
          <outline text="硬度可以分为10个等级：">
            <outline text="1 滑石" />
            <outline text="2 石膏" />
            <outline text="3 方解石" />
            <outline text="4 萤石" />
            <outline text="5 磷灰石" />
            <outline text="6 正长石" />
            <outline text="7 石英" />
            <outline text="8 黄玉" />
            <outline text="9 刚玉" />
            <outline text="10 金刚石" />
          </outline>
          <outline text="硬度高的可以刮花硬度低的。" />
          <outline text="普通玻璃的硬度是6-7左右，而钢的硬度仅为5，所以即使是普通的玻璃，用刀也是刮不花的。" />
          <outline text="真正刮花手机屏幕的是沙子，沙子里包含了石英，摩氏硬度为7.5左右。" />
        </outline>
        <outline text="LCD连接方式：RGB">
          <outline text="数据位传输有6位，16位，18位，24位之分。" />
          <outline text="连线有：">
            <outline text="VSYNC" />
            <outline text="HSYNC" />
            <outline text="DOTCLK" />
            <outline text="CS" />
            <outline text="RESET，有的也需要RS" />
            <outline text="剩下都是数据线" />
          </outline>
          <outline text="它的优缺点:">
            <outline text="不耗费GRAM. 可以支持大屏." />
            <outline text="控制复杂." />
          </outline>
        </outline>
        <outline text="LCD常见问题  #经验总结 ">
          <outline text="包括白屏、黑屏、花屏、冻屏。" />
          <outline text="LCD初始化流程, 包括寄存器和sleep wakeup的配置，以及配置EBI2总线的LCD控制器，这个时序经常出问题。" />
          <outline text="花屏的原因: " />
          <outline text="MDP和ARM同时控制显示。ARM控制显示一般是为了调节亮度等的时候。此时就需要保护机制。" />
          <outline text="MDP刷屏对时序要求很严格。发现花屏时，可通过LCD_CFG0寄存器来调节时序。" />
        </outline>
        <outline text="TP代码">
          <outline text="核心态代码">
            <outline text="kernel/drivers/input/eventdev.c: 事件处理" />
            <outline text="atml_imc.c: 驱动代码" />
            <outline text="input.c: input子系统，包括电阻屏、电容屏、键盘、鼠标、游戏杆等设备都算input设备" />
          </outline>
          <outline text="用户态代码：hal层">
            <outline text="初始化过程">
              <outline text="register" />
              <outline text="Probe" />
              <outline text=" I2C check -&amp;gt; 取X轴、Y轴，Max_x,Max_y " />
              <outline text="read_PDT(寄存器种event的buffer地址) " />
              <outline text="固件更新，/sys" />
              <outline text="proc，数据处理" />
              <outline text="创建工作队列线程" />
              <outline text="创建工作队列" />
              <outline text="配置中断，低电平触发" />
              <outline text="申请中断；如果非中断，则启动timer" />
              <outline text="注册 early syspend / resume 函数" />
            </outline>
            <outline text="数据处理">
              <outline text="input子系统中，在中断或timer触发下，读取event_table[]，数组下标即设备号，获取当前evnet；" />
              <outline text="通过主设备号，获取input-&amp;gt;fops（event处理函数）处理该event。" />
              <outline text="处理逻辑就是上报键值和坐标。" />
            </outline>
            <outline text="键值上报">
              <outline text="hal层device_poll()读取 /dev/input/event_x，x即设备号，然后上报给framework层。" />
              <outline text="数据结构即 sensor_event_t，包括type、handle、value（union类似，可适配多种input设备）。" />
            </outline>
          </outline>
        </outline>
        <outline text="分辨率相关概念  #面试题">
          <outline text="坐标原点:">
            <outline text="Android 定义屏幕的左上角为坐标原点(0, 0), 向右为x轴, 向下为y轴, 向上为z轴. 都是正数." />
          </outline>
          <outline text="dp(dip): device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。" />
          <outline text="px: pixels(像素). 不同设备显示效果相同." />
          <outline text="pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业." />
          <outline text="sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。size和dp相同." />
        </outline>
        <outline text="刷新率相关概念  #面试题">
          <outline text="FPS: 每秒刷新帧数, frames per second. 即屏幕刷新率，也叫帧率。">
            <outline text="单位是Hz, 赫兹. " />
            <outline text="通常, 要避免动作不流畅的最低FPS是 30. 最佳体验是 60或以上." />
            <outline text="人有视觉暂停的特性，对于连续远动的静态图片，当超过16帧/秒时，就感觉到运动是连贯的。" />
            <outline text="这是视频、动画的原理。" />
          </outline>
          <outline text="一般场合下合理的帧率">
            <outline text="电影 24Hz" />
            <outline text="电视 25Hz" />
            <outline text="电视(NTSL)  29.9Hz" />
            <outline text="CRT显示  75Hz" />
            <outline text="液晶显示  60Hz" />
            <outline text="游戏中">
              <outline text="超过75帧无感觉。" />
              <outline text="帧率（FPS）&amp;lt;30，游戏性就下降。" />
              <outline text="30以上，则可以接受。" />
              <outline text="如果升至60帧则交互性和逼真感大大加强." />
            </outline>
          </outline>
        </outline>
        <outline text="&lt;b&gt;流量 = 分辨率 * 刷新率&lt;/b&gt;">
          <outline text="比特率: 是指每秒传递的比特数(bit), 单位为 bps." />
          <outline text="码流: data rate, 指视频文件在单位时间内使用的数据流量, 也叫码率.  码流的单位 KB/s, 等于 比特率 / 8." />
        </outline>
        <outline text="&lt;b&gt;图像处理能力 = 分辨率 * 刷新率&lt;/b&gt;" />
        <outline text="Android颜色值">
          <outline text="16位整数。" />
          <outline text="一般写成16进制数形式。" />
          <outline text="前2位为透明度(alpha)。00表示全透明(即隐藏了)，FF表示全不透明。7F表示半透。" />
          <outline text="后6位为颜色值。000000表示白色，FFFFFF 表示黑色。" />
        </outline>
        <outline text="&lt;b&gt;UI渲染  #面试题&lt;/b&gt;">
          <outline text="UI渲染是指从App生成帧并显示在屏幕上的行为。" />
          <outline text="60 fps是手机app性能的衡量标准, 这个标准的来历是: 人眼与大脑之前的协作无法感知超过60 FPS的画面, 所以超过60 FPS 没有意义." />
          <outline text="对于60 fps, 1帧即 1000 / 60 = 16ms. " />
          <outline text="Android系统每隔16ms, 会发一次 VSync 信息来通知重绘界面. " />
          <outline text="当一个操作超过 16 ms, 系统在得到 VSync 信息时就无法进行绘制, 只能重新刷之前一帧. 这种情况叫丢帧." />
          <outline text="还有一种情况叫跳帧. 即在一次VSync周期内, 应用产生了超过1帧的数据." />
        </outline>
        <outline text="帧率和刷新频率不一致问题">
          <outline text="Refresh Rate: 屏幕在1秒内刷新屏幕的次数, 这取决于硬件的固定参数, 比如 60Hz." />
          <outline text="Frame Rate: 代表GPU在1秒内绘制操作的帧数, 比如30 FPS." />
          <outline text="GPU 获取图形数据进行渲染, 然后硬件负责把渲染的内容呈现到屏幕上, 他们两者不停的进行协作." />
          <outline text="如果发生帧率和刷新频率不一致的情况, 就会出现Tearing 现象, 画面上下两部分显示内容断裂, 来自不同的两帧数据发生重叠. " />
        </outline>
        <outline text="双缓冲机制  #面试题">
          <outline text="多数系统都会使用双缓冲机制. 即一个buffer用于显示当前帧, 另一个buffer 用于缓存下一帧的数据. 其过程是:" />
          <outline text="1. 屏幕显示缓冲A中的第0帧; " />
          <outline text="2. CPU和GPU在缓冲B中构建第1帧; 构建好后, 并不会马上绘制, 而是必须等待系统的VSync信号." />
          <outline text="3. 系统发出VSync信号, 屏幕向缓冲B请求第1帧的数据, 如成功, 则绘制它;" />
          <outline text="4. 此时, 缓冲A中的数据被清除, CPU和GPU开始构建第2帧." />
          <outline text="在第三步, 如果此时缓冲B的第1帧数据没有准备好, 屏幕只好继续显示缓冲A中的第0帧, 这种情况就叫丢帧, 也叫&quot;Jank&quot;." />
        </outline>
        <outline text="三缓冲机制">
          <outline text="在缓冲A在显示中, 缓冲B数据已经准备好时, 此时时间会被浪费掉. " />
          <outline text="可以再加一个缓冲C, 来准备下一帧数据. 这就是三缓冲机制." />
          <outline text="三缓冲不能根本上解决卡顿问题, 但是会缓解." />
        </outline>
        <outline text="动画  #面试题">
          <outline text="逐帧动画">
            <outline text="逐帧动画的原理就是让一系列的静态图片依次播放，利用人眼“视觉暂留”的原理，实现动画。" />
            <outline text="逐帧动画通常是采用 XML 资源进行定义的，需要在 &amp;lt;animation-list .../&amp;gt; 标签下使用 &amp;lt;item .../&amp;gt; 子元素标签定义动画的全部帧，并指定各帧的持续时间。" />
            <outline text="定义帧动画的方法：">
              <outline text="// res/drawable/frame_animation.xml" />
              <outline text="&amp;lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true|false&quot;&amp;gt;">
                <outline text="&amp;lt;item android:drawable=&quot;@drawable/frame01&quot; android:duration=&quot;100&quot;/&amp;gt;" />
                <outline text="&amp;lt;item android:drawable=&quot;@drawable/frame02&quot; android:duration=&quot;100&quot;/&amp;gt;" />
              </outline>
              <outline text="&amp;lt;/animation-list&amp;gt;" />
              <outline text="其中:">
                <outline text="android:oneshot 控制该动画是否循环播放。如果为true，动画将不会循环播放， 否则该动画将会循环播放." />
                <outline text="android:drawable 为图片资源. 一般会有多张." />
                <outline text="android:duration 为持续时间, 单位为毫秒." />
              </outline>
            </outline>
            <outline text="使用该帧动画的方法:">
              <outline text="在layout 中将 AnimationDrawable 对象直接作为背景.">
                <outline text="// res/layout/activity_frame_animation.xml" />
                <outline text="&amp;lt;ImageView">
                  <outline text="&lt;b&gt;android:background&lt;/b&gt;=&quot;@drawable/frame_animation&quot;" />
                  <outline text="/&amp;gt;" />
                </outline>
              </outline>
              <outline text="Activity 中控制播放与停止">
                <outline text="public class FrameAnimation extends AppCompatActivity {">
                  <outline text="ImageView frame_image;" />
                  <outline text="AnimationDrawable animationDrawable;" />
                  <outline text="@ Override" />
                  <outline text="protected void onCreate(@ Nullable Bundle savedInstanceState) {">
                    <outline text="super.onCreate(savedInstanceState);" />
                    <outline text="setContentView(R.layout.activity_frame_animation);" />
                    <outline text="frame_image = findViewById(R.id.frame_image);" />
                    <outline text="// 获取 AnimationDrawable 对象">
                      <outline text="animationDrawable = (AnimationDrawable) frame_image.getBackground();" />
                    </outline>
                  </outline>
                  <outline text="}" />
                  <outline text="public void start(View view){">
                    <outline text="// 开始播放" />
                    <outline text="animationDrawable.start();" />
                  </outline>
                  <outline text="}" />
                  <outline text="public void stop(View view){">
                    <outline text="//停止播放" />
                    <outline text="animationDrawable.stop();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
            </outline>
          </outline>
          <outline text="补间动画 (过场动画)">
            <outline text="补间动画就是指开发者指定动画的开始、动画的结束的&quot;关键帧&quot;，而动画变化的&quot;中间帧&quot;由系统计算，并补齐。" />
            <outline text="补间动画一般通过 xml 来实现，对于 xml 形式补间动画的定义，也是需要在 res/anim/ 文件夹下定义动画资源." />
            <outline text="补间动画有4种. 定义方法见内.">
              <outline text="淡入淡出： alpha">
                <outline text="// alpha_anim.xml" />
                <outline text="&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;" />
                <outline text="&amp;lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
                  <outline text="android:duration=&quot;1000&quot;" />
                  <outline text="android:fromAlpha=&quot;1.0&quot;" />
                  <outline text="android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;" />
                  <outline text="android:toAlpha=&quot;0.0&quot; /&amp;gt;" />
                </outline>
                <outline text="其中: interpolator 代表插值器，主要作用是可以控制动画的变化速率，可以通过 @ android:anim 来选择不同的插值器。" />
              </outline>
              <outline text="位移：translate">
                <outline text="// translate_anim.xml" />
                <outline text="&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;" />
                <outline text="&amp;lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
                  <outline text="android:fromDegree=&quot;0&quot;" />
                  <outline text="android:toDegree=&quot;1800&quot;" />
                  <outline text="android:pivotX = &quot;50%&quot;" />
                  <outline text="android:pivotY=&quot;50%&quot;" />
                  <outline text="android:duration = &quot;3000&quot; /&amp;gt;" />
                </outline>
                <outline text="其中: pivot 这个属性主要是在translate 和 scale 动画中，这两种动画都牵扯到view 的“物理位置“发生变化，所以需要一个参考点。而pivotX和pivotY就共同决定了这个点；它的值可以是float或者是百分比数值。" />
                <outline text="以 pivotX 为例，说明其取不同的值的含义：" />
                <outline text="10:距离动画所在view自身左边缘10像素" />
                <outline text="10% :距离动画所在view自身左边缘 的距离是整个view宽度的10%" />
                <outline text="10%p:距离动画所在view父控件左边缘的距离是整个view宽度的10%" />
              </outline>
              <outline text="缩放：scale">
                <outline text="// scale_anim.xml" />
                <outline text="&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;" />
                <outline text="&amp;lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
                  <outline text="android:duration=&quot;1000&quot;" />
                  <outline text="android:fromXScale=&quot;0.0&quot;" />
                  <outline text="android:fromYScale=&quot;0.0&quot;" />
                  <outline text="android:pivotX=&quot;50%&quot;" />
                  <outline text="android:pivotY=&quot;50%&quot;" />
                  <outline text="android:toXScale=&quot;1.0&quot;" />
                  <outline text="android:toYScale=&quot;1.0&quot;/&amp;gt;" />
                </outline>
              </outline>
              <outline text="旋转： rotate">
                <outline text="// rotate_anim.xml" />
                <outline text="&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;">
                  <outline text="&amp;lt;rotate">
                    <outline text="android:fromDegrees=&quot;float&quot;" />
                    <outline text="android:toDegrees=&quot;float&quot;" />
                    <outline text="android:pivotX=&quot;50%&quot;" />
                    <outline text="android:pivotY=&quot;50%&quot; /&amp;gt;" />
                  </outline>
                </outline>
              </outline>
              <outline text="这4种动画形式可作用于同一个动画." />
            </outline>
            <outline text="使用该补间动画的方法:">
              <outline text="利用 AnimationUtils 工具类来加载指定动画资源，加载成功后返回一个 Animation，该对象可以控制图片或者视图播放动画。" />
              <outline text="public class tweenAnimation extends AppCompatActivity {">
                <outline text="Button tween_start;" />
                <outline text="@ Override" />
                <outline text="protected void onCreate(@ Nullable Bundle savedInstanceState) {">
                  <outline text="super.onCreate(savedInstanceState);" />
                  <outline text="setContentView(R.layout.activity_tween_animation);" />
                  <outline text="final ImageView  tween_image = findViewById(R.id.tween_image);" />
                  <outline text="tween_start = findViewById(R.id.tween_start);" />
                  <outline text="// 加载动画资源" />
                  <outline text="final Animation anim = AnimationUtils.loadAnimation(this, R.anim.alpha_anim);" />
                  <outline text="// 设置动画结束后保留结束状态" />
                  <outline text="anim.setFillAfter(true);" />
                  <outline text="tween_start.setOnClickListener(new View.OnClickListener() {">
                    <outline text="@Override" />
                    <outline text="public void onClick(View view) {">
                      <outline text="tween_image.startAnimation(anim);" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="});" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="动画监听">
              <outline text="为了实现一些需求，如动画结束后开始另一个动画或者页面跳转，这时候就需要监听动画。" />
              <outline text="Animation.addListener(new AnimatorListener() {">
                <outline text="public void onAnimationStart(Animation animation) {">
                  <outline text="// 动画开始时执行" />
                </outline>
                <outline text="}" />
                <outline text="public void onAnimationRepeat(Animation animation) {">
                  <outline text="// 动画重复时执行" />
                </outline>
                <outline text="}" />
                <outline text="});" />
                <outline text="public void onAnimationCancel()(Animation animation) {">
                  <outline text="// 动画取消时执行" />
                </outline>
                <outline text="}" />
                <outline text="public void onAnimationEnd(Animation animation) {">
                  <outline text="// 动画结束时执行" />
                </outline>
                <outline text="}" />
              </outline>
            </outline>
          </outline>
          <outline text="属性动画">
            <outline text="属性动画可以看作是补间动画的升级版，不同之处在：">
              <outline text="补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。" />
              <outline text="补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。" />
            </outline>
            <outline text="与补间动画类似的是，属性动画也需要定义几个方面的属性：">
              <outline text="动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。" />
              <outline text="动画插值方式。通过 android:interploator 指定。" />
              <outline text="动画重复次数。通过 android:repeatCount 指定。" />
              <outline text="重复行为。通过 android:repeatMode 指定。" />
              <outline text="动画集。在属性资源文件中通过 &amp;lt;set .../&amp;gt; 来组合。" />
              <outline text="帧刷新率。指定多长时间播放一帧。默认为 10 ms。" />
            </outline>
            <outline text="属性动画 API">
              <outline text="Animator: 提供创建属性动画的基类，基本不会直接使用这个类。" />
              <outline text="ValueAnimator:属性动画用到的主要的时间引擎，负责计算各个帧的属性值。" />
              <outline text="ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。" />
              <outline text="AnimatorSet：Animator 的子类，用于组合多个 Animator。" />
            </outline>
            <outline text="除了这些 API,属性动画还提供了一个 Evaluator ，用来控制属性动画如何计算属性值。">
              <outline text="IntEvaluator:计算 int 类型属性值的计算器。" />
              <outline text="FloatEvaluator: 用于计算 float 类型属性值的计算器。" />
              <outline text="ArgbEvaluator: 用于计算十六进制形式表示的颜色值的计算器。" />
              <outline text="TypeEvaluator: 可以自定义计算器。" />
            </outline>
            <outline text="使用 ValueAnimator 创建动画的步骤：">
              <outline text="调用 ValueAnimator 的 ofInt()、ofFloat() 或者 ofObject() 静态方法创建 ValueAnimator 实例。" />
              <outline text="调用 ValueAnimator 的 setXxx() 等方法设置持续时间，插值方式、重复次数等。" />
              <outline text="调用 ValueAnimator 的 start() 方法启动动画。" />
              <outline text="为 ValueAnimator 注册 AnimatorUpdateListener 监听器，在该监听器中可以监听 ValueAnimator 计算出来的值改变，并将这些值应用到指定对象上。" />
            </outline>
            <outline text="属性动画的一般使用：" />
            <outline text="定义属性动画和补间动画等类似，有两种方式：">
              <outline text="使用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。" />
              <outline text="使用资源文件来定义动画。" />
            </outline>
            <outline text="属性动画的使用：">
              <outline text="创建 ValueAnimator 或 ObjectAnimator 对象 —— 即可以从 XML 资源文件加载该动画也可以直接调用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。" />
              <outline text="根据需要为 Animator 对象设置属性。" />
              <outline text="如果需要监听 Animator 的动画开始事件，动画结束事件、动画重复事件、动画值改变事件，并根据事件提供响应处理代码，需要为Animator 对象设置监听器。" />
              <outline text="如果有多个动画需要同时播放，需要使用 AnimatorSet 组合这些动画。" />
              <outline text="调用 Animator 对象的 start 启动动画。" />
            </outline>
          </outline>
        </outline>
        <outline text="夜间模式方案">
          <outline text="在夜间弱光环境下我们长时间注视屏幕，会引起视疲劳。" />
          <outline text="为了解决这个问题，厂商推出了夜间模式，它可以降低屏幕亮度，缩小屏幕显示内容与环境光强度的差距，让你在夜间看屏幕时不会太刺眼。" />
        </outline>
        <outline text="AOD(息屏显示)方案">
          <outline text="现在大多数旗舰手机使用的都是OLED屏幕." />
          <outline text="其自发光特性是LCD屏所不具备的，在显示黑色时，相应的像素点无需发光，可以减少电量消耗，提升手机续航." />
          <outline text="安卓厂商也基于此原理推出了息屏显示AOD (Always On Display)功能。" />
          <outline text="AOD都是黑色的." />
        </outline>
        <outline text="Canvas">
          <outline text="普通view渲染时不用 OpenGL, 用 skia, 不用硬件加速, 依赖CPU性能." />
          <outline text="SurfaceView/TextureView 用 OpenGL, 用硬件加速." />
        </outline>
        <outline text="Skia（2D图形引擎, 又叫 SGL）">
          <outline text="Canvas 底层用 skia库实现. " />
          <outline text="Android系统用 skia 来画普通的图形元素，包括：">
            <outline text="image" />
            <outline text="shap" />
            <outline text="color" />
            <outline text="pre-defined 动画." />
          </outline>
        </outline>
        <outline text="OpenGL（3D图形引擎）" />
        <outline text="SurfaceManager/Surfaceflinger" />
      </outline>
      <outline text="13-事件处理">
        <outline text="Android的事件处理分为 基于监听的机制, 以及基于回调的机制." />
        <outline text="&lt;b&gt;基于监听的机制  #面试题&lt;/b&gt;">
          <outline text="实现方式有多种: " />
          <outline text=" 用匿名内部类, 最常见.">
            <outline text="最常用的一种:直接 setXxxListener后, 重写里面的方法即可." />
            <outline text="使用场景: 匿名类临时使用一次, 复用性不高. 匿名类最大的好处是免得为取名字而费脑筋." />
            <outline text="public class MainActivity extends Activity {">
              <outline text="private Button btnshow;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="btnshow = (Button) findViewById(R.id.btnshow);" />
                <outline text="btnshow.&lt;b&gt;setOnClickListener&lt;/b&gt;(new OnClickListener() {">
                  <outline text="//重写点击事件的处理方法onClick()" />
                  <outline text="public void onClick(View v) {">
                    <outline text="//显示Toast信息" />
                    <outline text="Toast.makeText(getApplicationContext(), &quot;你点击了按钮&quot;, Toast.LENGTH_SHORT).show();" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="});" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="用内部类, 比较常见.">
            <outline text="对监听类进行命名. " />
            <outline text="目的是复用. 如果本activity中的多个控件使用同一个监听器类, 则会节省很多代码." />
            <outline text="public class MainActivity extends Activity {">
              <outline text="private Button btnshow;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="btnshow = (Button) findViewById(R.id.btnshow);" />
                <outline text="//直接new一个内部类对象作为参数" />
                <outline text="btnshow.&lt;b&gt;setOnClickListener&lt;/b&gt;(new BtnClickListener());" />
              </outline>
              <outline text="}" />
              <outline text="// 定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法" />
              <outline text="class &lt;b&gt;BtnClickListener &lt;/b&gt;implements View.OnClickListener {">
                <outline text="public void onClick(View v) {">
                  <outline text="Toast.makeText(getApplicationContext(), &quot;按钮被点击了&quot;, Toast.LENGTH_SHORT).show();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="使用外部类">
            <outline text="这种形式用的比较少！因为外部类不能直接访问用户界面类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁." />
            <outline text="使用场景是多个activity共用同一个监听器类, 则可以这么用. 但是这样耦合性太高, 不建议." />
            <outline text="将内部类外部化即可, 不累述." />
          </outline>
          <outline text="直接使用Activity作为事件监听器">
            <outline text="需要让Activity类实现XxxListener事件监听接口, 在Activity中定义重写对应的事件处理器方法." />
            <outline text="// 让Activity方法实现OnClickListener接口" />
            <outline text="public class MainActivity extends Activity implements &lt;b&gt;OnClickListener &lt;/b&gt;{">
              <outline text="private Button btnshow;" />
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="btnshow = (Button) findViewById(R.id.btnshow);" />
                <outline text="// 直接写个this" />
                <outline text="btnshow.&lt;b&gt;setOnClickListener&lt;/b&gt;(&lt;b&gt;this&lt;/b&gt;);" />
              </outline>
              <outline text="}" />
              <outline text="// 重写接口中的抽象方法" />
              <outline text="public void onClick(View v) {">
                <outline text="Toast.makeText(getApplicationContext(), &quot;点击了按钮&quot;, Toast.LENGTH_SHORT).show();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="直接绑定到布局文件">
            <outline text="就是直接在xml布局文件中对应得Activity中定义一个事件处理方法" />
            <outline text="// 布局文件" />
            <outline text="&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
              <outline text="xmlns:tools=&quot;http://schemas.android.com/tools&quot;">
                <outline text="android:id=&quot;@+id/LinearLayout1&quot;" />
                <outline text="android:layout_width=&quot;match_parent&quot;" />
                <outline text="android:layout_height=&quot;match_parent&quot;" />
                <outline text="android:orientation=&quot;vertical&quot; &amp;gt;" />
                <outline text="&amp;lt;Button">
                  <outline text="android:layout_width=&quot;wrap_content&quot;" />
                  <outline text="android:layout_height=&quot;wrap_content&quot;" />
                  <outline text="android:text=&quot;按钮&quot;" />
                  <outline text="// 直接使用函数名" />
                  <outline text="android:onClick=&quot;&lt;b&gt;myclick&lt;/b&gt;&quot;/&amp;gt;" />
                </outline>
              </outline>
              <outline text="&amp;lt;/LinearLayout&amp;gt;" />
            </outline>
            <outline text="// 代码" />
            <outline text="public class MainActivity extends Activity {">
              <outline text="protected void onCreate(Bundle savedInstanceState) {">
                <outline text="super.onCreate(savedInstanceState);" />
                <outline text="setContentView(R.layout.activity_main);" />
              </outline>
              <outline text="}" />
              <outline text="// 自定义一个方法,传入一个view组件作为参数" />
              <outline text="public void &lt;b&gt;myclick&lt;/b&gt;(View source) {">
                <outline text="Toast.makeText(getApplicationContext(), &quot;按钮被点击了&quot;, Toast.LENGTH_SHORT).show();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;基于回调的机制  #面试题 &lt;/b&gt;">
          <outline text="主要使用场景是自定义view." />
          <outline text="当用户在GUI组件上激发某个事件时, 组件有自己特定的方法会负责处理该事件. 通常用法:继承基本的GUI组件,重写该组件的事件处理方法,即自定义view." />
          <outline text="注意: 在xml布局中使用自定义的view时,需要使用&quot;全限定类名&quot;." />
          <outline text="常见的回调方法有:">
            <outline text="在该组件上触发屏幕事件: boolean &lt;b&gt;onTouchEvent&lt;/b&gt;(MotionEvent event);" />
            <outline text="在该组件上按下某个按钮时: boolean &lt;b&gt;onKeyDown&lt;/b&gt;(int keyCode,KeyEvent event);" />
            <outline text="松开组件上的某个按钮时: boolean &lt;b&gt;onKeyUp&lt;/b&gt;(int keyCode,KeyEvent event);" />
            <outline text="长按组件某个按钮时: boolean &lt;b&gt;onKeyLongPress&lt;/b&gt;(int keyCode,KeyEvent event);" />
            <outline text="键盘快捷键事件发生: boolean &lt;b&gt;onKeyShortcut&lt;/b&gt;(int keyCode,KeyEvent event);" />
            <outline text="在组件上触发轨迹球屏事件: boolean onTrackballEvent(MotionEvent event);" />
            <outline text="当组件的焦点发生改变,和前面的6个不同,这个方法只能够在View中重写哦！ protected void &lt;b&gt;onFocusChanged&lt;/b&gt;(boolean gainFocus, int direction, Rect previously FocusedRect)" />
          </outline>
        </outline>
        <outline text="自定义view使用事件回调的例子:">
          <outline text="// 布局" />
          <outline text="&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;">
            <outline text="xmlns:tools=&quot;http://schemas.android.com/tools&quot;" />
            <outline text="android:layout_width=&quot;match_parent&quot;" />
            <outline text="android:layout_height=&quot;match_parent&quot;" />
            <outline text="tools:context=&quot;.MyActivity&quot;&amp;gt;" />
            <outline text="&amp;lt;example.jay.com.mybutton.MyButton">
              <outline text="android:layout_width=&quot;wrap_content&quot;" />
              <outline text="android:layout_height=&quot;wrap_content&quot;" />
              <outline text="android:text=&quot;按钮&quot;/&amp;gt;" />
            </outline>
          </outline>
          <outline text="// MyButton.java" />
          <outline text="public class MyButton extends Button{">
            <outline text="private static String TAG = &quot;呵呵&quot;;" />
            <outline text="public MyButton(Context context, AttributeSet attrs) {">
              <outline text="super(context, attrs);" />
            </outline>
            <outline text="}" />
            <outline text="//重写键盘按下触发的事件" />
            <outline text="public boolean onKeyDown(int keyCode, KeyEvent event) {">
              <outline text="super.onKeyDown(keyCode,event);" />
              <outline text="Log.i(TAG, &quot;onKeyDown方法被调用&quot;);" />
              <outline text="&lt;b&gt;return true;&lt;/b&gt;" />
            </outline>
            <outline text="}" />
            <outline text="//重写弹起键盘触发的事件" />
            <outline text="public boolean onKeyUp(int keyCode, KeyEvent event) {">
              <outline text="super.onKeyUp(keyCode,event);" />
              <outline text="Log.i(TAG,&quot;onKeyUp方法被调用&quot;);" />
              <outline text="return true;" />
            </outline>
            <outline text="}" />
            <outline text="//组件被触摸了" />
            <outline text="public boolean onTouchEvent(MotionEvent event) {">
              <outline text="super.onTouchEvent(event);" />
              <outline text="Log.i(TAG,&quot;onTouchEvent方法被调用&quot;);" />
              <outline text="return true;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="&lt;b&gt;冒泡事件传播&lt;/b&gt;">
          <outline text="这个概念非常关键, 但是理解有难度. 注意好好掌握. " />
          <outline text="事件传播的顺序:">
            <outline text="触发组件绑定的事件监听器" />
            <outline text="触发组件提供的回调;" />
            <outline text="传播到父view, 也是先事件监听器, 后回调;" />
            <outline text="传播到组件所在的activity." />
          </outline>
          <outline text="这个链条的每个方法的返回值都是 Boolean, 用于表示该事件是否处理完了. 如果返回 True, 则表示处理完了. 如果返回 False, 则会继续传递." />
        </outline>
        <outline text="复杂事件处理: OnTouchListener, 包括:">
          <outline text="onTouch(View v, MotionEvent event):这里面的参数依次是触发触摸事件的组件,触碰事件event 封装了触发事件的详细信息，同样包括事件的类型、触发时间等信息。比如event.getX(),event.getY()" />
          <outline text="我们也可以对触摸的动作类型进行判断,使用event.getAction( )再进行判断;如:" />
          <outline text="event.getAction == MotionEvent.ACTION_DOWN：按下事件" />
          <outline text="event.getAction == MotionEvent.ACTION_MOVE:移动事件" />
          <outline text="event.getAction == MotionEvent.ACTION_UP:弹起事件" />
          <outline text="例子:" />
          <outline text="public class MyView extends View{">
            <outline text="public float X = 50;" />
            <outline text="public float Y = 50;" />
            <outline text="//创建画笔" />
            <outline text="Paint paint = new Paint();" />
            <outline text="public MyView(Context context,AttributeSet set)" />
            <outline text="{">
              <outline text="super(context,set);" />
            </outline>
            <outline text="}" />
            <outline text="public void onDraw(Canvas canvas) {">
              <outline text="super.onDraw(canvas);" />
              <outline text="paint.setColor(Color.BLUE);" />
              <outline text="canvas.drawCircle(X,Y,30,paint);" />
            </outline>
            <outline text="}" />
            <outline text="public boolean onTouchEvent(MotionEvent event) {">
              <outline text="this.X = event.getX();" />
              <outline text="this.Y = event.getY();" />
              <outline text="//通知组件进行重绘" />
              <outline text="this.invalidate();" />
              <outline text="return true;" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="多点触碰">
          <outline text="多点触碰就是多个手指在屏幕上进行操作，用的最多的估计是放大缩功能吧，比如很多的图片浏览器都支持缩放！理论上Android系统本身可以处理多达256个手指的触摸，当然这取决于手机硬件的支持." />
          <outline text="前面两点都有用到 MotionEvent，可根据event.getAction() &amp;amp; MotionEvent.ACTION_MASK 来判断是哪种操作, 包括按下, 抬起, 移动." />
          <outline text="除了上面介绍的三种单点操作外，还有两个多点专用的操作：">
            <outline text="MotionEvent.ACTION_POINTER_DOWN:当屏幕上已经有一个点被按住，此时再按下其他点时触发。" />
            <outline text="MotionEvent.ACTION_POINTER_UP:当屏幕上有多个点被按住，松开其中一个点时触发（即非最后一个点被放开时）。" />
          </outline>
          <outline text="事件上报流程:">
            <outline text="当我们一个手指触摸屏幕 --&amp;gt; 触发ACTION_DOWN事件" />
            <outline text="接着有另一个手指也触摸屏幕 --&amp;gt; 触发ACTION_POINTER_DOWN事件,如果还有其他手指触摸，继续触发" />
            <outline text="有一个手指离开屏幕 --&amp;gt; 触发ACTION_POINTER_UP事件，继续有手指离开，继续触发" />
            <outline text="当最后一个手指离开屏幕 --&amp;gt; 触发ACTION_UP事件" />
            <outline text="而且在整个过程中，ACTION_MOVE事件会一直不停地被触发." />
          </outline>
          <outline text="可以通过 event.getX(int)或者 event.getY(int)来获得不同触摸点的位置： 比如 event.getX(0)可以获得第一个接触点的X坐标，event.getX(1)获得第二个接触点的X坐标这样." />
          <outline text="可以通过 MotionEvent.getPointerCount()方法判断当前有多少个手指在触摸. 例如：" />
          <outline text="public class MainActivity extends Activity implements OnTouchListener {">
            <outline text="private ImageView img_test;" />
            <outline text="// 縮放控制" />
            <outline text="private Matrix matrix = new Matrix();" />
            <outline text="private Matrix savedMatrix = new Matrix();" />
            <outline text="// 不同状态的表示：" />
            <outline text="private static final int NONE = 0;" />
            <outline text="private static final int DRAG = 1;" />
            <outline text="private static final int ZOOM = 2;" />
            <outline text="private int mode = NONE;" />
            <outline text="// 定义第一个按下的点，两只接触点的重点，以及出事的两指按下的距离：" />
            <outline text="private PointF startPoint = new PointF();" />
            <outline text="private PointF midPoint = new PointF();" />
            <outline text="private float oriDis = 1f;" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);">
                <outline text="setContentView(R.layout.activity_main);" />
                <outline text="img_test = (ImageView) this.findViewById(R.id.img_test);" />
                <outline text="img_test.setOnTouchListener(this);" />
              </outline>
            </outline>
            <outline text="}" />
            <outline text="public boolean onTouch(View v, MotionEvent event) {">
              <outline text="ImageView view = (ImageView) v;">
                <outline text="switch (event.getAction() &amp;amp; MotionEvent.ACTION_MASK) {" />
                <outline text="// 单指" />
                <outline text="case MotionEvent.ACTION_DOWN:">
                  <outline text="matrix.set(view.getImageMatrix());" />
                  <outline text="savedMatrix.set(matrix);" />
                  <outline text="startPoint.set(event.getX(), event.getY());" />
                  <outline text="mode = DRAG;" />
                  <outline text="break;" />
                </outline>
                <outline text="// 双指" />
                <outline text="case MotionEvent.ACTION_POINTER_DOWN:">
                  <outline text="oriDis = distance(event);" />
                  <outline text="if (oriDis &amp;gt; 10f) {">
                    <outline text="savedMatrix.set(matrix);" />
                    <outline text="midPoint = middle(event);" />
                    <outline text="mode = ZOOM;" />
                  </outline>
                  <outline text="}" />
                  <outline text="break;" />
                </outline>
                <outline text="// 手指放开" />
                <outline text="case MotionEvent.ACTION_UP:" />
                <outline text="case MotionEvent.ACTION_POINTER_UP:">
                  <outline text="mode = NONE;" />
                  <outline text="break;" />
                </outline>
                <outline text="// 单指滑动事件" />
                <outline text="case MotionEvent.ACTION_MOVE:">
                  <outline text="if (mode == DRAG) {">
                    <outline text="// 是一个手指拖动" />
                    <outline text="matrix.set(savedMatrix);" />
                    <outline text="matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y);" />
                  </outline>
                  <outline text="} else if (mode == ZOOM) {">
                    <outline text="// 两个手指滑动" />
                    <outline text="float newDist = distance(event);" />
                    <outline text="if (newDist &amp;gt; 10f) {">
                      <outline text="matrix.set(savedMatrix);" />
                      <outline text="float scale = newDist / oriDis;" />
                      <outline text="matrix.postScale(scale, scale, midPoint.x, midPoint.y);" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="}" />
                  <outline text="break;" />
                </outline>
                <outline text="}" />
                <outline text="// 设置ImageView的Matrix" />
                <outline text="view.setImageMatrix(matrix);" />
                <outline text="return true;" />
              </outline>
            </outline>
            <outline text="}" />
            <outline text="// 计算两个触摸点之间的距离" />
            <outline text="private float distance(MotionEvent event) {">
              <outline text="float x = event.getX(0) - event.getX(1);">
                <outline text="float y = event.getY(0) - event.getY(1);" />
                <outline text="return FloatMath.sqrt(x * x + y * y);" />
              </outline>
            </outline>
            <outline text="}" />
            <outline text="// 计算两个触摸点的中点" />
            <outline text="private PointF middle(MotionEvent event) {">
              <outline text="float x = event.getX(0) + event.getX(1);">
                <outline text="float y = event.getY(0) + event.getY(1);" />
                <outline text="return new PointF(x / 2, y / 2);" />
              </outline>
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="响应系统设置的事件(Configuration类)">
          <outline text="Configuration类是用来描述手机设备的配置信息的，比如屏幕方向，触摸屏的触摸方式等，代码在 frameworks/base/core/java/android/content/res/Configuration.java." />
          <outline text="方法列表">
            <outline text="densityDpi：屏幕密度" />
            <outline text="fontScale：当前用户设置的字体的缩放因子" />
            <outline text="hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：">
              <outline text="HARDKEYBOARDHIDDEN_NO,  十六进制的0" />
              <outline text="HARDKEYBOARDHIDDEN_YES，十六进制的1" />
            </outline>
            <outline text="keyboard：获取当前关联额键盘类型：该属性的返回值：KEYBOARD_12KEY（只有12个键的小键盘）、KEYBOARD_NOKEYS、KEYBOARD_QWERTY（普通键盘）" />
            <outline text="keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。" />
            <outline text="locale：获取用户当前的语言环境" />
            <outline text="mcc：获取移动信号的国家码" />
            <outline text="mnc：获取移动信号的网络码" />
            <outline text="ps:国家代码和网络代码共同确定当前手机网络运营商" />
            <outline text="navigation：判断系统上方向导航设备的类型。该属性的返回值：NAVIGATION_NONAV（无导航）、 NAVIGATION_DPAD(DPAD导航）NAVIGATION_TRACKBALL（轨迹球导航）、NAVIGATION_WHEEL（滚轮导航）" />
            <outline text="orientation：获取系统屏幕的方向。该属性的返回值：ORIENTATION_LANDSCAPE（横向屏幕）、ORIENTATION_PORTRAIT（竖向屏幕）" />
            <outline text="screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示" />
            <outline text="touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：">
              <outline text="TOUCHSCREEN_NOTOUCH（无触摸屏）" />
              <outline text="TOUCHSCREEN_STYLUS（触摸笔式触摸屏）" />
              <outline text="TOUCHSCREEN_FINGER（接收手指的触摸屏）" />
            </outline>
            <outline text="" />
          </outline>
          <outline text="例子:" />
          <outline text="// 在AndroidManifest.xml添加下述内容" />
          <outline text="权限: &amp;lt; uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&amp;gt;" />
          <outline text="在&amp;lt; activity标签中添加:android:configChanges=&quot;orientation&quot; 将targetSdkVersion改为12以上的,12也可以." />
          <outline text="public class MainActivity extends Activity {">
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="Button btn = (Button) findViewById(R.id.btncahange);" />
              <outline text="btn.setOnClickListener(new OnClickListener() {">
                <outline text="public void onClick(View v) {">
                  <outline text="Configuration config = getResources().getConfiguration();" />
                  <outline text="//如果是横屏的话切换成竖屏" />
                  <outline text="if(config.orientation == Configuration.ORIENTATION_LANDSCAPE) {">
                    <outline text="MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);" />
                  </outline>
                  <outline text="}" />
                  <outline text="//如果竖屏的话切换成横屏" />
                  <outline text="if(config.orientation == Configuration.ORIENTATION_PORTRAIT) {">
                    <outline text="MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="});" />
            </outline>
            <outline text="}" />
            <outline text="public void onConfigurationChanged(Configuration newConfig) {">
              <outline text="super.onConfigurationChanged(newConfig);" />
              <outline text="String screen = newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE?&quot;横屏&quot;:&quot;竖屏&quot;;" />
              <outline text="Toast.makeText(MainActivity.this, &quot;系统屏幕方向发生改变 \n 修改后的方向为&quot; + screen, Toast.LENGTH_SHORT).show();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="Configuration: 系统状态事件">
          <outline text="Configuration类是用来描述手机设备的配置信息的，比如屏幕方向， 触摸屏的触摸方式等." />
          <outline text="代码在: frameworks/base/core/java/android/content/res/Configuration.java" />
          <outline text="有如下方法:">
            <outline text="densityDpi：屏幕密度" />
            <outline text="fontScale：当前用户设置的字体的缩放比" />
            <outline text="hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：HARDKEYBOARDHIDDEN_NO,HARDKEYBOARDHIDDEN_YES，分别是十六进制的0和1" />
            <outline text="keyboard：获取当前关联额键盘类型：该属性的返回值：">
              <outline text="KEYBOARD_12KEY（只有12个键的小键盘）" />
              <outline text="KEYBOARD_NOKEYS (没有键盘)" />
              <outline text="KEYBOARD_QWERTY（普通键盘）" />
            </outline>
            <outline text="keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。" />
            <outline text="locale：获取用户当前的语言环境" />
            <outline text="mcc：获取移动信号的国家码" />
            <outline text="mnc：获取移动信号的网络码" />
            <outline text="ps:国家代码和网络代码共同确定当前手机网络运营商" />
            <outline text="navigation：判断系统中方向导航设备的类型 (都已经不支持了)。该属性的返回值：">
              <outline text="NAVIGATION_NONAV（无导航）" />
              <outline text=" NAVIGATION_DPAD (DPAD导航）" />
              <outline text="NAVIGATION_TRACKBALL（轨迹球导航）" />
              <outline text="NAVIGATION_WHEEL（滚轮导航）" />
            </outline>
            <outline text="orientation：获取系统屏幕的方向。该属性的返回值：">
              <outline text="ORIENTATION_LANDSCAPE（横向屏幕）" />
              <outline text="ORIENTATION_PORTRAIT（竖向屏幕）" />
            </outline>
            <outline text="screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示" />
            <outline text="touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：">
              <outline text="TOUCHSCREEN_NOTOUCH（无触摸屏）" />
              <outline text="TOUCHSCREEN_STYLUS（触摸笔式触摸屏）" />
              <outline text="TOUCHSCREEN_FINGER（接收手指的触摸屏）" />
            </outline>
          </outline>
          <outline text="例子:" />
          <outline text="// 在AndroidManifest.xml中申请权限权限" />
          <outline text="&amp;lt; uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&amp;gt;" />
          <outline text="// 监听系统属性变化" />
          <outline text="public void onConfigurationChanged(Configuration newConfig) {">
            <outline text="super.onConfigurationChanged(newConfig);" />
            <outline text="String screen = {(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) ? &quot;横屏&quot; : &quot;竖屏&quot;);" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="Gestures(手势)">
          <outline text="在应用中通过手势来操作会大大提升用户体验." />
          <outline text="手势交互的执行顺序">
            <outline text="1.手指触碰屏幕时，触发MotionEvent事件." />
            <outline text="2.该事件被OnTouchListener监听，可在它的onTouch()方法中获得该MotionEvent对象." />
            <outline text="3.通过GestureDetector转发MotionEvent对象给OnGestureListener." />
            <outline text="4.我们可以通过OnGestureListener获得该对象，然后获取相关信息，以及做相关处理." />
          </outline>
          <outline text="GestureListener 提供了下述回调方法：">
            <outline text="按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。" />
            <outline text="抛掷（onFling）： 手指在触摸屏上迅速移动，并松开的动作。" />
            <outline text="长按（onLongPress）： 手指按在持续一段时间，并且没有松开。" />
            <outline text="滚动（onScroll）： 手指在触摸屏上滑动。" />
            <outline text="按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。" />
            <outline text="抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。" />
          </outline>
          <outline text="知道了 GestureListener的相关方法后，实现手势检测也很简单，步骤如下：">
            <outline text="创建GestureDetector对象，创建时需实现GestureListener传入" />
            <outline text="将Activity或者特定组件上的TouchEvent的事件交给GestureDetector处理." />
          </outline>
          <outline text="" />
        </outline>
        <outline text="导航栏事件">
          <outline text="点击home键后, 系统会发出一个 Intent_Action_Close_System_Dialogs 的广播." />
        </outline>
      </outline>
      <outline text="14-Service">
        <outline text="Service(服务)">
          <outline text="是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。" />
          <outline text="启动后会常驻内存。即使启动服务的组件（Activity）已销毁也不受影响。" />
          <outline text="如果Service挂了, 系统会自动重新启动." />
          <outline text="Service不是一个单独的进程, 而是和所在应用程序在同一个进程中. 应避免在Service中进行耗时操作. " />
        </outline>
        <outline text="定义Service">
          <outline text="Service都是通过继承Service基类自定义而来的。也都需要在AndroidManifest.xml中声明。" />
          <outline text="Service在清单文件中的声明">
            <outline text="&amp;lt;service android:enabled=[&quot;true&quot; | &quot;false&quot;]">
              <outline text="android:exported=[&quot;true&quot; | &quot;false&quot;]" />
              <outline text="android:icon=&quot;drawable resource&quot;" />
              <outline text="android:isolatedProcess=[&quot;true&quot; | &quot;false&quot;]" />
              <outline text="android:label=&quot;string resource&quot;" />
              <outline text="android:name=&quot;string&quot;" />
              <outline text="android:permission=&quot;string&quot;" />
              <outline text="android:process=&quot;string&quot; &amp;gt;" />
              <outline text=". . ." />
            </outline>
            <outline text="&amp;lt;/service&amp;gt;" />
            <outline text="其中：" />
            <outline text="android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。" />
            <outline text="android:permission：是权限声明" />
            <outline text="android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。">
              <outline text="注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思。" />
              <outline text="前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。" />
            </outline>
          </outline>
          <outline text="重写类的如下方法：">
            <outline text="onBind()。当使用方通过调用 bindService() 与服务绑定时被系统调用。" />
            <outline text="onCreate()。首次创建服务时被系统调用。仅调用一次。" />
            <outline text="onStartCommand()。当使用者通过调用 startService() 请求启动服务时被系统调用。" />
            <outline text="onDestroy()。服务被销毁时被调用。" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;Service的生命周期  #面试题 &lt;/b&gt;">
          <outline text="非绑定service, 用 &lt;b&gt;startService&lt;/b&gt;() 启动的service.">
            <outline text="onCreate: 当客户端第一次调用 startService()被调, 在整个生命周期中只会调用一次." />
            <outline text="&lt;b&gt;onStartCommand &lt;/b&gt;/ onStart: &lt;b&gt;当客户端每次调用 startService()时会回调.&lt;/b&gt; 一个客户端可多次调用StartService(), 多个客户端分别调用StartService(), 也不会有负面影响.  onStart() 和 onStartCommand()的关系见后." />
            <outline text="onDestory: 当Service被销毁时会回调，只会回调一次." />
            <outline text="非绑定service, Service的生命周期与它的客户端的生命周期无绑定关系. 当客户端结束自己的生命周期时, 只要不调用 stopService(), 那么Service还会继续运行." />
          </outline>
          <outline text="绑定service, 用 &lt;b&gt;bindService&lt;/b&gt;() 启动的service.">
            <outline text="onCreate: 同上." />
            <outline text="&lt;b&gt;onBind&lt;/b&gt;: 该方法是Service都必须实现的方法，该方法会返回一个 IBinder对象，app通过该对象与Service组件进行通信." />
            <outline text="&lt;b&gt;onUnbind&lt;/b&gt;: 当该Service上绑定的所有客户端都断开时会回调该方法." />
            <outline text="onDestory: 同上." />
            <outline text="当首次使用 bindService()绑定一个Service时, 默认情况下, 系统会实例化一个Service实例,并调用其onCreate()和onBind()方法, 然后客户端就可以通过IBinder和Service进行交互了." />
            <outline text="此后如果再次使用bindService()绑定Service,系统不会创建新的Sevice实例,也不会再调用onBind()方法,只会直接把IBinder对象传递给后来的客户端." />
            <outline text="如果我们解除与服务的绑定,只需调用 unbindService(), 此时 onUnbind()会被调用. 如果只有这一个客户端, 则接着 onDestory()方法也会被调用. 如果是多个客户端, 只有最后一个客户端都调用了 unbindService(),  onDestory()才会被调用.  --按逻辑行事." />
            <outline text="&lt;b&gt;bindService模式下, Service是与客户端是绑定关系. 在bindService后, 如果客户端在onUnbind()前异常退出, 那么Service也会被终止.&lt;/b&gt;" />
          </outline>
          <outline text="onStartCommand 和 onStart的关系: 后者不建议使用. 如果使用, 则相当于重写了 onStartCommand, 而且返回值是 START_STICKY." />
          <outline text="&lt;b&gt;onStartCommand：&lt;/b&gt;返回值. 非常重要.">
            <outline text="START_STICKY: 系统在调用完onStartCommand()方法后，如果当前服务被终止了，系统会使该服务保持在启动状态，不过它不会保留之前传递的Intent对象。但是由于它保持启动状态，随后系统会尝试重新创建service，但之前的Intent对象没有被保存。在这个情况下，如果期间没有任何启动命令被传递到Service，那么参数Intent将为null。因此使用START_STICKY作为返回值，适用于不执行命令的媒体播放器（或类似的服务），它只是无限期的运行着并等待工作的到来." />
            <outline text="START_NOT_STICKY: 系统在调用完onStartCommand方法后，如果当前服务被终止了并且在此期间没有任何启动命令被传递到Service，那么系统将是使当前服务退出启动状态，并且除非重新调用Context.startService(Intent)，否则不会重新被创建（即不会重新调用onCreate方法）。因为当前服务退出了启动状态，所以除非在此期间启动命令被传递到Service，否则也不会调用。这是最安全的选项，用来避免在不需要的时候运行你的服务。" />
            <outline text="START_REDELIVER_INTENT: 如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。并且在在该服务调用stopSelf方法之前，能够一直保留intent对象数据。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。" />
            <outline text="START_STICKY_COMPATIBILITY: START_STICKY的兼容版本，但不保证服务被终止后一定能重启。被异常kill后, 服务虽然被重建，但没有重启." />
          </outline>
          <outline text="无论启动了多少次Service,只需调用一次StopService即可停掉Service. " />
          <outline text="&lt;b&gt;bindService() &lt;/b&gt;的函数原型:">
            <outline text="bindService(Intent Service, ServiceConnection conn, int flags); 其中参数是: " />
            <outline text="service: 通过该intent指定要启动的Service." />
            <outline text="conn: ServiceConnection对象,用户监听访问者与Service间的连接情况.">
              <outline text="连接成功回调该对象中的onServiceConnected(ComponentName,IBinder)方法; " />
              <outline text="如果Service所在的宿主由于异常终止或者其他原因终止,导致Service与访问者间断开 连接时调用onServiceDisconnected(CompanentName)方法." />
              <outline text="客户端主动调用unBindService() 方法断开, 不会收到 onServiceDisconnected()回调." />
            </outline>
            <outline text="flags: 指定绑定时是否自动创建Service(如果Service还未创建), 参数值域是: ">
              <outline text="0(不自动创建)." />
              <outline text="BIND_AUTO_CREATE(自动创建). 默认值." />
            </outline>
          </outline>
          <outline text="StartService启动Service后, 再bindService绑定的情况">
            <outline text="如果Service已经由某个客户端通过 StartService()启动,接下来其他客户端再调用bindService() 绑定到该Service后, 再调用 unbindService()解除绑定, 最后再调用bindService() 绑定到 Service的话, 此时所触发的生命周期方法如下:" />
            <outline text="onCreate() -&amp;gt; onStartCommand() -&amp;gt; onBind() -&amp;gt; onUnbind() -&amp;gt; onRebind()" />
            <outline text="&lt;b&gt;注意:  如果你需要在有新客户端连接上时获得onRebind()回调, 则必须在onUnbind()中返回true. 返回false 则收不到. Android就是这么约定的. &lt;/b&gt;" />
            <outline text="这里或许部分读者有疑惑了,调用了unbindService后Service不是应该调用 onDistory()方法么?" />
            <outline text="其实这是因为这个Service是由我们的StartService来启动的 ,所以你调用onUnbind()方法取消绑定,Service也是不会终止的." />
            <outline text="得出的结论: 假如我们使用bindService来绑定一个启动的Service,注意是已经启动的Service. 系统只是将Service的内部IBinder对象传递给Activity,并不会将Service的生命周期与此Activity绑定, 因此调用unBindService( )方法取消绑定时, Service也不会被销毁。" />
          </outline>
        </outline>
        <outline text="Service例子:">
          <outline text="public class TestService2 extends Service {">
            <outline text="private final String TAG = &quot;TestService2&quot;;" />
            <outline text="private int count;" />
            <outline text="private boolean quit;" />
            <outline text="// 定义onBinder方法所返回的对象" />
            <outline text="private MyBinder binder = new MyBinder();" />
            <outline text="public class MyBinder extends Binder {">
              <outline text="public int getCount() {">
                <outline text="return count;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
            <outline text="//必须实现的方法,绑定改Service时回调该方法" />
            <outline text="public IBinder onBind(Intent intent) {">
              <outline text="Log.i(TAG, &quot;onBind方法被调用!&quot;);" />
              <outline text="return binder;" />
            </outline>
            <outline text="}" />
            <outline text="//Service被创建时回调" />
            <outline text="public void onCreate() {">
              <outline text="super.onCreate();" />
              <outline text="Log.i(TAG, &quot;onCreate方法被调用!&quot;);" />
              <outline text="//创建一个线程动态地修改count的值" />
              <outline text="new Thread() {">
                <outline text="public void run() {">
                  <outline text="while(!quit) {">
                    <outline text="try {">
                      <outline text="Thread.sleep(1000);" />
                    </outline>
                    <outline text="} catch(InterruptedException e) { e.printStackTrace(); }" />
                    <outline text="count++;" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="};" />
              </outline>
              <outline text="}.start();" />
            </outline>
            <outline text="}" />
            <outline text="//Service断开连接时回调" />
            <outline text="public boolean onUnbind(Intent intent) {">
              <outline text="Log.i(TAG, &quot;onUnbind方法被调用!&quot;);" />
              <outline text="return true;" />
            </outline>
            <outline text="}" />
            <outline text="//Service被关闭前回调" />
            <outline text="@Override" />
            <outline text="public void onDestroy() {">
              <outline text="super.onDestroy();" />
              <outline text="this.quit = true;" />
              <outline text="Log.i(TAG, &quot;onDestroyed方法被调用!&quot;);" />
            </outline>
            <outline text="}" />
            <outline text="@Override" />
            <outline text="public void onRebind(Intent intent) {">
              <outline text="Log.i(TAG, &quot;onRebind方法被调用!&quot;);" />
              <outline text="super.onRebind(intent);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="" />
          <outline text="// 在AndroidManifest.xml中对Service组件进行注册" />
          <outline text="&amp;lt;service android:name=&quot;.TestService2&quot; android:exported=&quot;false&quot;&amp;gt;">
            <outline text="&amp;lt;intent-filter&amp;gt;">
              <outline text="&amp;lt;action android:name=&quot;com.jay.example.service.TEST_SERVICE2&quot;/&amp;gt;" />
            </outline>
            <outline text="&amp;lt;/intent-filter&amp;gt;" />
          </outline>
          <outline text="&amp;lt;/service&amp;gt;" />
          <outline text="" />
          <outline text="// 在 MainActivity.java 中使用service." />
          <outline text="public class MainActivity extends Activity {">
            <outline text="TestService2.MyBinder &lt;b&gt;binder&lt;/b&gt;;" />
            <outline text="// 定义ServiceConnection对象" />
            <outline text="private &lt;b&gt;ServiceConnection conn &lt;/b&gt;= new ServiceConnection() {">
              <outline text="// Activity与Service断开连接时回调该方法" />
              <outline text="public void onServiceDisconnected(ComponentName name) {">
                <outline text="System.out.println(&quot;------Service DisConnected-------&quot;);" />
              </outline>
              <outline text="}" />
              <outline text="// Activity与Service连接成功时回调该方法" />
              <outline text="public void onServiceConnected(ComponentName name, IBinder service) {">
                <outline text="System.out.println(&quot;------Service Connected-------&quot;);" />
                <outline text="binder = (TestService2.MyBinder) service;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="};" />
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="final Intent &lt;b&gt;intent &lt;/b&gt;= new Intent();" />
              <outline text="intent.setAction(&quot;com.jay.example.service.TEST_SERVICE2&quot;);" />
              <outline text="// btnbind 和 btncancel &lt;b&gt;是两个 &lt;/b&gt;Button, 不重要." />
              <outline text="btnbind.&lt;b&gt;setOnClickListener&lt;/b&gt;(new OnClickListener() {">
                <outline text="public void onClick(View v) {">
                  <outline text="&lt;b&gt;bindService&lt;/b&gt;(&lt;b&gt;intent&lt;/b&gt;, &lt;b&gt;conn&lt;/b&gt;, Service.BIND_AUTO_CREATE);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="});" />
              <outline text="btncancel.setOnClickListener(new OnClickListener() {">
                <outline text="public void onClick(View v) {">
                  <outline text="&lt;b&gt;unbindService&lt;/b&gt;(conn);" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="});" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="IntentService: 多线程的一种实现方式。耗时操作放在这里">
          <outline text="IntentService是继承与Service并处理异步请求的一个类. 在 IntentService中有一个工作线程来处理耗时操作, 请求的Intent记录会加入队列." />
          <outline text="客户端通过 startService(Intent)来启动IntentService." />
          <outline text="可以启动 IntentService 多次, 每个操作以工作队列的方式在 IntentService的 onHandleIntent回调方法中执行,并且每次只会执行一个工作线程." />
          <outline text="并不需要手动地区控制  IntentService, 当任务执行完后会自动停止." />
          <outline text="当一个后台的任务需要分成几个子任务, 再按先后顺序执行子任务 (简单的说就是异步操作). 此时如果我们还是定义一个普通Service, 然后在onStart方法中开辟线程, 然后又要去控制线程, 这样显得非常的繁琐; 此时就应该自定义一个 IntentService, 然后在 onHandleIntent() 方法中完成相关任务. " />
          <outline text="例子:" />
          <outline text="// IntentService 就是 Service." />
          <outline text="public class TestService3 extends IntentService {">
            <outline text="private final String TAG = &quot;hehe&quot;;" />
            <outline text="public TestService3() {">
              <outline text="super(&quot;TestService3&quot;);" />
            </outline>
            <outline text="}" />
            <outline text="// onHandleIntent是核心方法, 重视." />
            <outline text="protected void &lt;b&gt;onHandleIntent&lt;/b&gt;(Intent intent) {">
              <outline text="// Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务" />
              <outline text="String action = intent.getExtras().getString(&quot;param&quot;);" />
              <outline text="if(action.equals(&quot;s1&quot;)) { Log.i(TAG,&quot;启动service1&quot;); }" />
              <outline text="else if(action.equals(&quot;s2&quot;)) { Log.i(TAG,&quot;启动service2&quot;); }" />
              <outline text="else if(action.equals(&quot;s3&quot;)) { Log.i(TAG,&quot;启动service3&quot;); }" />
              <outline text="// 让服务休眠2秒" />
              <outline text="try { ">
                <outline text="Thread.sleep(2000);" />
              </outline>
              <outline text="} catch (InterruptedException e) { e.printStackTrace(); }" />
            </outline>
            <outline text="}" />
            <outline text="public IBinder onBind(Intent intent) {">
              <outline text="Log.i(TAG,&quot;onBind&quot;);" />
              <outline text="return super.onBind(intent);" />
            </outline>
            <outline text="}" />
            <outline text="public void onCreate() {">
              <outline text="Log.i(TAG,&quot;onCreate&quot;);" />
              <outline text="super.onCreate();" />
            </outline>
            <outline text="}" />
            <outline text="public int onStartCommand(Intent intent, int flags, int startId) {">
              <outline text="Log.i(TAG,&quot;onStartCommand&quot;);" />
              <outline text="return super.onStartCommand(intent, flags, startId);" />
            </outline>
            <outline text="}" />
            <outline text="public void setIntentRedelivery(boolean enabled) {">
              <outline text="super.setIntentRedelivery(enabled);" />
              <outline text="Log.i(TAG,&quot;setIntentRedelivery&quot;);" />
            </outline>
            <outline text="}" />
            <outline text="public void onDestroy() {">
              <outline text="Log.i(TAG,&quot;onDestroy&quot;);" />
              <outline text="super.onDestroy();" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="// AndroidManifest.xml注册下Service" />
          <outline text="&amp;lt;service android:name=&quot;.TestService3&quot; android:exported=&quot;false&quot;&amp;gt;">
            <outline text="&amp;lt;intent-filter &amp;gt;">
              <outline text="&amp;lt;action android:name=&quot;com.test.intentservice&quot;/&amp;gt;" />
            </outline>
            <outline text="&amp;lt;/intent-filter&amp;gt;" />
          </outline>
          <outline text="&amp;lt;/service&amp;gt;" />
          <outline text="// 在MainActivity启动三次服务" />
          <outline text="public class MainActivity extends Activity {">
            <outline text="protected void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);" />
              <outline text="setContentView(R.layout.activity_main);" />
              <outline text="Intent it1 = new Intent(&quot;com.test.intentservice&quot;);" />
              <outline text="Bundle b1 = new Bundle();" />
              <outline text="b1.putString(&quot;param&quot;, &quot;s1&quot;);" />
              <outline text="it1.putExtras(b1);" />
              <outline text="Intent it2 = new Intent(&quot;com.test.intentservice&quot;);" />
              <outline text="Bundle b2 = new Bundle();" />
              <outline text="b2.putString(&quot;param&quot;, &quot;s2&quot;);" />
              <outline text="it2.putExtras(b2);" />
              <outline text="Intent it3 = new Intent(&quot;com.test.intentservice&quot;);" />
              <outline text="Bundle b3 = new Bundle();" />
              <outline text="b3.putString(&quot;param&quot;, &quot;s3&quot;);" />
              <outline text="it3.putExtras(b3);" />
              <outline text="// 接着启动多次IntentService,每次启动,都会新建一个工作线程. 但始终只有一个IntentService实例" />
              <outline text="startService(it1);" />
              <outline text="startService(it2);" />
              <outline text="startService(it3);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="Activity与Service通信">
          <outline text="假如我们启动的是一个下载的后台Service，而我们想知道Service中下载任务的进度. 这涉及 Service 与Activity进行通信. 其基本流程如下：" />
          <outline text="在Service中自定义一个 Binder类，然后将需要暴露的方法写到该类中." />
          <outline text="Service类中，实例化这个自定义 Binder类，然后重写 onBind()方法，将这个Binder对象返回." />
          <outline text="Activity类中实例化一个 ServiceConnection对象，重写 onServiceConnected()方法，然后获取Binder对象，然后调用相关方法即可." />
        </outline>
        <outline text="前台服务">
          <outline text="Service默认是后台服务. 后台服务的缺点是优先级较低, 当内存不足时会优先回收后台服务. 方法是:" />
          <outline text="在自定义的Service类中，重写onCreate()，然后根据自己的需求定制Notification； 定制完毕后，调用 startForeground(1,notification对象)即可." />
          <outline text="public void onCreate() {">
            <outline text="super.onCreate();" />
            <outline text="Notification.Builder localBuilder = new Notification.Builder(this);" />
            <outline text="localBuilder.setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0));" />
            <outline text="localBuilder.setAutoCancel(false);" />
            <outline text="localBuilder.setSmallIcon(R.mipmap.ic_cow_icon);" />
            <outline text="localBuilder.setTicker(&quot;Foreground Service Start&quot;);" />
            <outline text="localBuilder.setContentTitle(&quot;Socket服务端&quot;);" />
            <outline text="localBuilder.setContentText(&quot;正在运行...&quot;);" />
            <outline text="startForeground(1, localBuilder.getNotification());" />
          </outline>
          <outline text="}" />
        </outline>
        <outline text="定时后台线程">
          <outline text="Android中给我们提供的定时方式有两种: Timer类 与 Alarm机制." />
          <outline text="前者不适合于需要长期在后台运行的定时任务，CPU一旦休眠，Timer中的定时任务就无法运行." />
          <outline text="Alarm则不存在这种情况，具有唤醒CPU的功能. 另外，要区分CPU唤醒与屏幕唤醒." />
          <outline text="方法是:" />
          <outline text="1, 获得Service: ">
            <outline text="AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);" />
          </outline>
          <outline text="2, 通过set方法设置定时任务:">
            <outline text="int anHour = 2 * 1000; " />
            <outline text="long triggerAtTime = SystemClock.elapsedRealtime() + anHour; " />
            <outline text="manager.&lt;b&gt;set&lt;/b&gt;(AlarmManager.RTC_WAKEUP,triggerAtTime,pendingIntent);" />
          </outline>
          <outline text="3, 定义一个Service 在onStartCommand中开辟一条事务线程,用于处理一些定时逻辑." />
          <outline text="4, 定义一个Broadcast(广播)，用于启动Service 最后别忘了，在AndroidManifest.xml中对这Service与Boradcast进行注册." />
          <outline text="参数详解： &lt;b&gt;set&lt;/b&gt;(int type,long startTime,PendingIntent pi);" />
          <outline text="&lt;b&gt;type&lt;/b&gt;的值域是:">
            <outline text="ELAPSED_REALTIME: 闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3;" />
            <outline text="ELAPSED_REALTIME_WAKEUP 闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；" />
            <outline text="RTC 闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；" />
            <outline text="RTC_WAKEUP 表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0;" />
            <outline text="POWER_OFF_WAKEUP 表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一， 该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；" />
          </outline>
          <outline text="&lt;b&gt;startTime&lt;/b&gt;: type决定startTime的含义.">
            <outline text="如果是 ELAPSED_REALTIME 和 ELAPSED_REALTIME_WAKEUP, 就用: SystemClock.elapsedRealtime()方法可以获得系统开机到现在经历的毫秒数;" />
            <outline text="如果是RTC、RTC_WAKEUP、POWER_OFF_WAKEUP的就用: System.currentTimeMillis() 可获得从1970.1.1 0点到现在做经历的毫秒数." />
          </outline>
          <outline text="&lt;b&gt;PendingIntent&lt;/b&gt;: 绑定了闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent 是Intent的封装类。">
            <outline text="如果是通过启动服务来实现闹钟提示的话， PendingIntent对象的获取就应该采用Pending.getService (Context c,int i,Intent intent,int j)方法；" />
            <outline text="如果是通过广播来实现闹钟提示的话， PendingIntent对象的获取就应该采用 PendingIntent.getBroadcast (Context c,int i,Intent intent,int j)方法；" />
            <outline text="如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取 就应该采用 PendingIntent.getActivity(Context c,int i,Intent intent,int j) 方法。" />
          </outline>
          <outline text="从4.4版本后(API 19),Alarm任务的触发时间可能变得不准确,有可能会延时,是系统 对于耗电性的优化,如果需要准确无误可以调用 setExtra()方法." />
          <outline text="例子:" />
          <outline text="public class LongRunningService extends Service {">
            <outline text="public IBinder onBind(Intent intent) {">
              <outline text="return null;" />
            </outline>
            <outline text="}" />
            <outline text="public int onStartCommand(Intent intent, int flags, int startId) {">
              <outline text="//这里开辟一条线程,用来执行具体的逻辑操作:" />
              <outline text="new Thread(new Runnable() {">
                <outline text="public void run() {">
                  <outline text="Log.d(&quot;BackService&quot;, new Date().toString());" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}).start();" />
              <outline text="AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);" />
              <outline text="// 这里是定时的,这里设置的是每隔两秒打印一次时间=-=,自己改" />
              <outline text="int anHour = 2 * 1000;" />
              <outline text="long triggerAtTime = SystemClock.elapsedRealtime() + anHour;" />
              <outline text="Intent i = new Intent(this,AlarmReceiver.class);" />
              <outline text="PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0);" />
              <outline text="manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);" />
              <outline text="return super.onStartCommand(intent, flags, startId);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="public class AlarmReceiver extends BroadcastReceiver {">
            <outline text="public void onReceive(Context context, Intent intent) {">
              <outline text="Intent i = new Intent(context,LongRunningService.class);" />
              <outline text="context.startService(i);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
        </outline>
      </outline>
      <outline text="15-&lt;b&gt;Broadcast&lt;/b&gt;">
        <outline text="Android的广播机制是一种 Publish/subscribepattern. ">
          <outline text="Publish(发布者)只会将不同类型的讯息传送出去, 并不会在意subscribe(订阅者);" />
          <outline text="而 subscribe(订阅者)只在意想接收的讯息, 并不会在意谁是Publish(发布者)." />
        </outline>
        <outline text="静态注册">
          <outline text="静态注册是在AndroidManifest.xml上加一个receiver tag来指定. 在编译android app就指定好了" />
        </outline>
        <outline text="动态注册">
          <outline text="在代码中, 调用 Context.registerReceiver() 来注册. " />
          <outline text="registerReceiver() 的实现在 ContextImpl.java.">
            <outline text="public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {">
              <outline text="return registerReceiver(receiver, filter, null, null);" />
            </outline>
            <outline text="}" />
            <outline text="public Intent &lt;b&gt;registerReceiver&lt;/b&gt;(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) {">
              <outline text="return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext());" />
            </outline>
            <outline text="}" />
            <outline text="// registerReceiverInternal() 做了两件事, 先将传入reciever包装产生一个IIntentReceiver, 然后再将IIntentReceiver传送给 AMS 去注册." />
            <outline text="private Intent &lt;b&gt;registerReceiverInternal&lt;/b&gt;(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) {">
              <outline text="IIntentReceiver rd = null;" />
              <outline text="if (receiver != null) {">
                <outline text="[…]" />
                <outline text="// mPackageInfo是一个LoadedApk的对象." />
                <outline text="rd = mPackageInfo.&lt;b&gt;getReceiverDispatcher&lt;/b&gt;(receiver, context, scheduler, mMainThread.getInstrumentation(), true);" />
                <outline text="} else {">
                  <outline text="[…]" />
                  <outline text="rd = new LoadedApk.ReceiverDispatcher(receiver, context, scheduler, null, true).getIIntentReceiver();" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
              <outline text="try {">
                <outline text="final Intent intent = ActivityManagerNative.getDefault().&lt;b&gt;registerReceiver&lt;/b&gt;(mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId);" />
                <outline text="[…]" />
                <outline text="return intent;" />
              </outline>
              <outline text="} catch (RemoteException e) {">
                <outline text="throw e.rethrowFromSystemServer();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="继续看下 LoadedApk.getReceiverDispatcher()">
            <outline text="先产生一个receiver的ReceiverDispatcher然后再产生一个ArrayMap&amp;lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&amp;gt;来做管理.最后会执行ReceiverDispatcher的getIIntentReceiver方法." />
            <outline text="public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler,Instrumentation instrumentation, boolean registered) {">
              <outline text="synchronized (mReceivers) {">
                <outline text="LoadedApk.ReceiverDispatcher rd = null;">
                  <outline text="ArrayMap&amp;lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&amp;gt; map = null;" />
                  <outline text="[…]" />
                  <outline text="if (rd == null) {">
                    <outline text="rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered);" />
                    <outline text="if (registered) {">
                      <outline text="if (map == null) {">
                        <outline text="map = new ArrayMap&amp;lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&amp;gt;();" />
                        <outline text="mReceivers.put(context, map);" />
                      </outline>
                      <outline text="}" />
                      <outline text="map.put(r, rd);" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="} else {">
                    <outline text="rd.validate(context, handler);" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="[…]" />
                <outline text="// getIIntentReceiver()回传的 IItentReciever是一道Receiver Binder interface." />
                <outline text="return rd.getIIntentReceiver();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="至此, InnerReceiver(IBinder) 创建出来, 下面看 AMS.registerReceiver()">
            <outline text="// 启动一个binder调用. request id 是 REGISTER_RECEIVER_TRANSACTION." />
            <outline text="public Intent registerReceiver(IApplicationThread caller, String packageName, IIntentReceiver receiver, IntentFilter filter, String perm, int userId) throws RemoteException {">
              <outline text="Parcel data = Parcel.obtain();" />
              <outline text="Parcel reply = Parcel.obtain();" />
              <outline text="[…]" />
              <outline text="mRemote.&lt;b&gt;transact&lt;/b&gt;(REGISTER_RECEIVER_TRANSACTION, data, reply, 0);" />
              <outline text="[…]" />
            </outline>
            <outline text="}" />
            <outline text="最终调用到 ActivityManagerService.java 的 registerReceiver()." />
            <outline text="// 使用 mRegisteredReceivers 将IIntentReceiver放进Receiver list.最后在执行 mReceiverResolver的addFilter新增一个BroadcastFilter. 之后在发送讯息阶段时,就会利用 mReceiverResolver来做传送媒介." />
            <outline text="public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {">
              <outline text="[…]" />
              <outline text="mRegisteredReceivers.put(receiver.asBinder(), rl);" />
              <outline text="[…]" />
              <outline text="BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);" />
              <outline text="rl.add(bf);  // rl 是一个ReceiverList data." />
              <outline text="[…]" />
              <outline text="mReceiverResolver.addFilter(bf); // mReceiverResolver是一个IntentResolver&amp;lt;BroadcastFilter, BroadcastFilter&amp;gt; data" />
              <outline text="[…]" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="发送广播" />
      </outline>
      <outline text="16-SQL">
        <outline text="Provider 即内容提供器. 是Android上对MySQL数据库的封装, 用于系统和应用对外公布和管理关系数据库数据." />
        <outline text="系统提供的ContentProvider包括：">
          <outline text="Browser：存储如浏览器的信息。" />
          <outline text="CallLog：存储通话记录等信息。" />
          <outline text="Contacts：存储联系人等信息。" />
          <outline text="MediaStore：存储媒体文件的信息。" />
          <outline text="Settings：存储设备的设置和首选项信息。" />
        </outline>
        <outline text="某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过这个接口来操作它的内部数据。" />
        <outline text="被访问者实现 &lt;b&gt;ContentProvider&lt;/b&gt;." />
        <outline text="访问者实现 &lt;b&gt;ContentResolver&lt;/b&gt;. 通过与ContentProvider同名的方法请求执行，被执行的就是ContentProvider中的同名方法。" />
        <outline text="Uri">
          <outline text="Uri是一种资源访问方式。对于ContentProvider而言，Uri 是固定格式的：&amp;lt;srandard_prefix&amp;gt;://&amp;lt;authority&amp;gt;/&amp;lt;data_path&amp;gt;/&amp;lt;id&amp;gt;" />
          <outline text="&amp;lt;srandard_prefix&amp;gt;: ContentProvider的srandard_prefix始终是 content:// ." />
          <outline text="&amp;lt;authority&amp;gt;: ContentProvider的名称。" />
          <outline text="&amp;lt;data_path&amp;gt;: 请求的数据类型。" />
          <outline text="&amp;lt;id&amp;gt;: 指定请求的特定数据。" />
        </outline>
        <outline text="ContentProvider 需要在 AndroidManifest.xml 中进行配置。格式如下: ">
          <outline text="&amp;lt;provider android:name=&quot;.MyContentProviderDemo&quot; android:authorities=&quot;com.content.MyUsers&quot;&amp;gt;" />
          <outline text="&amp;lt;/provider&amp;gt;" />
          <outline text="android:authorities 为授权码, 是字符串. 访问者只有在申明了该授权码后才可以访问." />
          <outline text="一般有如下权限:">
            <outline text="android:grantUriPermssions:临时许可标志。" />
            <outline text="android:permission:Provider 读写权限。" />
            <outline text="android:readPermission:Provider 的读权限。" />
            <outline text="android:writePermission:Provider 的写权限。" />
            <outline text="android:enabled:标记允许系统启动Provider。" />
            <outline text="android:exported:标记允许其他应用程序使用这个Provider。" />
            <outline text="android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。" />
          </outline>
        </outline>
        <outline text="ContentProvider必须实现的方法：">
          <outline text="onCreate()：初始化提供者。" />
          <outline text="query(Uri, String[], String, String[], String)：查询数据，返回一个数据Cursor对象。" />
          <outline text="insert(Uri, ContentValues)：插入一条数据。" />
          <outline text="update(Uri, ContentValues, String, String[])：根据条件更新数据。" />
          <outline text="delete(Uri, String, String[])：根据条件删除数据。" />
          <outline text="getType(Uri) 返回MIME类型对应内容的URI。" />
          <outline text="除了onCreate()和getType()方法外，其他的均为CRUD操作." />
          <outline text="这些方法中，Uri参数为与ContentProvider匹配的请求Uri，剩下的参数和SQLite的CRUD操作基本一致." />
          <outline text="SQLite">
            <outline text="SQLite基于文本。" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;SQL语言&lt;/b&gt;">
          <outline text="基本语法">
            <outline text="建表格">
              <outline text="create table table_name(" />
              <outline text="column1 datatype [not null] [not null primary key]," />
              <outline text="column2 datatype [not null]," />
              <outline text="...）" />
              <outline text="其中, datatype --是资料的格式，详见下。" />
              <outline text="nut null --可不可以允许资料有空的（尚未有资料填入）。" />
              <outline text="primary key --是本表的主键。" />
            </outline>
            <outline text="sqlite支持的数据结构">
              <outline text="smallint: 16 位元的整数。" />
              <outline text="interger: 32 位元的整数。" />
              <outline text="decimal(p,s): p 精确值和 s 大小的十进位整数，精确值p是指全部有几个数(digits)大小值，s是指小数点後有几位数。如果没有特别指定，则系统会设为 p=5; s=0 。" />
              <outline text="float: 32位元的实数。" />
              <outline text="double: 64位元的实数。" />
              <outline text="char(n): n 长度的字串，n不能超过 254。" />
              <outline text="varchar(n): 长度不固定且其最大长度为 n 的字串，n不能超过 4000。" />
              <outline text="graphic(n): 和 char(n) 一样，不过其单位是两个字元 double-bytes， n不能超过127。这个形态是为了支援两个字元长度的字体，例如中文字。" />
              <outline text="vargraphic(n): 可变长度且其最大长度为 n 的双字元字串，n不能超过 2000。" />
              <outline text="date: 包含了 年份、月份、日期。" />
              <outline text="time: 包含了 小时、分钟、秒。" />
              <outline text="timestamp: 包含了 年、月、日、时、分、秒、千分之一秒。" />
            </outline>
            <outline text="更改表格">
              <outline text="alter table table_name: 修改表名" />
              <outline text="add column column_name datatype: 增加一个字段（没有删除某个栏位的语法)。" />
              <outline text="add primary key (column_name): 更改表得的定义把某个栏位设为主键。" />
              <outline text="drop primary key (column_name): 把主键的定义删除。" />
            </outline>
            <outline text="建立索引">
              <outline text="create index index_name on table_name (column_name)" />
              <outline text="说明：对某个表格的栏位建立索引以增加查询时的速度。" />
            </outline>
            <outline text="删除表格: drop table_name" />
            <outline text="删除索引: drop index_name" />
            <outline text="增加记录">
              <outline text="insert into table_name (column1,column2,...) values ( value1,value2, ...)" />
              <outline text="说明：" />
              <outline text="1. 若没有指定column 系统则会按表格内的栏位顺序填入资料。" />
              <outline text="2. 栏位的资料形态和所填入的资料必须吻合。" />
              <outline text="3. table_name 也可以是景观 view_name。" />
              <outline text="insert into table_name (column1,column2,...) select columnx,columny,... from another_table" />
              <outline text="说明：也可以经过一个子查询（subquery）把别的表格的资料填入。" />
            </outline>
            <outline text="基本查询">
              <outline text="select column1,columns2,… from table_name">
                <outline text="说明：查询指定字段的记录." />
              </outline>
              <outline text="select * from table_name where column1 = xxx [and column2 &amp;gt; yyy] [or column3 zzz]">
                <outline text="说明：1.'*'表示查询全部字段." />
                <outline text="2.where 之後是接条件式，把符合条件的资料列出来。" />
              </outline>
              <outline text="select column1,column2 from table_name order by column2 [desc]">
                <outline text="说明：order by 是指定以某个栏位做排序，[desc]是指从大到小排列，若没有指明，则是从小到大排列" />
              </outline>
            </outline>
            <outline text="组合查询">
              <outline text="组合查询是指所查询得资料来源并不只有单一的表格，而是联合一个以上的表格才能够得到结果的。" />
              <outline text="select * from table1,table2 where table1.colum1=table2.column1" />
              <outline text="说明： 1.查询两个表格中其中 column1 值相同的资料。" />
              <outline text="2.当然两个表格相互比较的栏位，其资料形态必须相同。" />
              <outline text="3.一个复杂的查询其动用到的表格可能会很多个。" />
            </outline>
            <outline text="整合性查询">
              <outline text="select count (*) from table_name where column_name = xxx">
                <outline text="说明：查询符合条件的资料共有几笔。" />
              </outline>
              <outline text="select sum(column1) from table_name">
                <outline text="说明： 1.计算出总和，所选的栏位必须是可数的数字形态。" />
                <outline text="2.除此以外还有 avg() 是计算平均、max()、min()计算最大最小值的整合性查询。" />
              </outline>
              <outline text="select column1,avg(column2) from table_name group by column1 having avg(column2) &amp;gt; xxx">
                <outline text="说明：1.group by: 以column1 为一组计算 column2 的平均值必须和 avg、sum等整合性查询的关键字一起使用。" />
                <outline text="2.having : 必须和 group by 一起使用作为整合性的限制。" />
              </outline>
            </outline>
            <outline text="复合性查询">
              <outline text="select * from table_name1 where exists (select * from table_name2 where conditions )">
                <outline text="说明：1.where 的 conditions 可以是另外一个的 query。" />
                <outline text="2.exists 在此是指存在与否。" />
              </outline>
              <outline text="select * from table_name1 where column1 in ( select column1 from table_name2 where conditions )">
                <outline text="说明：1. in 後面接的是一个集合，表示column1 存在集合里面。" />
                <outline text="2. select 出来的资料形态必须符合 column1。" />
              </outline>
            </outline>
            <outline text="其他查询">
              <outline text="select * from table_name1 where column1 like 'x%'">
                <outline text="说明：like 必须和後面的'x%' 相呼应表示以 x为开头的字串。" />
              </outline>
              <outline text="select * from table_name1 where column1 in ('xxx','yyy',..)">
                <outline text="说明：in 後面接的是一个集合，表示column1 存在集合里面。" />
              </outline>
              <outline text="select * from table_name1 where column1 between xx and yy">
                <outline text="说明：between 表示 column1 的值介於 xx 和 yy 之间。" />
              </outline>
            </outline>
            <outline text="更改资料">
              <outline text="update table_name set column1='xxx' where conditoins" />
              <outline text="说明：1.更改某个栏位设定其值为'xxx'。" />
              <outline text="2.conditions 是所要符合的条件、若没有 where 则整个 table 的那个栏位都会全部被更改。" />
            </outline>
            <outline text="删除资料">
              <outline text="delete from table_name where conditions" />
              <outline text="说明：删除符合条件的资料。" />
            </outline>
          </outline>
          <outline text="SQLite内建函数表">
            <outline text="算术函数">
              <outline text="abs(X): 返回给定数字表达式的绝对值。" />
              <outline text="max(X,Y[,...]): 返回表达式的最大值。" />
              <outline text="min(X,Y[,...]): 返回表达式的最小值。" />
              <outline text="random(*): 返回随机数。" />
              <outline text="round(X[,Y]): 返回数字表达式并四舍五入为指定的长度或精度。" />
            </outline>
            <outline text="字符处理函数">
              <outline text="length(X): 返回给定字符串表达式的字符个数。" />
              <outline text="lower(X): 将大写字符数据转换为小写字符数据后返回字符表达式。" />
              <outline text="upper(X): 返回将小写字符数据转换为大写的字符表达式。" />
              <outline text="substr(X,Y,Z): 返回表达式的一部分。" />
              <outline text="randstr()" />
              <outline text="quote(A)" />
              <outline text="like(A,B): 确定给定的字符串是否与指定的模式匹配。" />
              <outline text="glob(A,B)" />
            </outline>
            <outline text="条件判断函数">
              <outline text="coalesce(X,Y[,...])" />
              <outline text="ifnull(X,Y)" />
              <outline text="nullif(X,Y)" />
            </outline>
            <outline text="集合函数">
              <outline text="avg(X): 返回组中值的平均值。" />
              <outline text="count(X): 返回组中项目的数量。" />
              <outline text="max(X): 返回组中值的最大值。" />
              <outline text="min(X): 返回组中值的最小值。" />
              <outline text="sum(X): 返回表达式中所有值的和。" />
            </outline>
            <outline text="其他函数">
              <outline text="typeof(X): 返回数据的类型。" />
              <outline text="last_insert_rowid(): 返回最后插入的数据的ID。" />
              <outline text="sqlite_version(*): 返回SQLite的版本。" />
              <outline text="change_count(): 返回受上一语句影响的行数。" />
              <outline text="last_statement_change_count()" />
            </outline>
          </outline>
          <outline text="处理时间数据">
            <outline text="sqlite中存放的NSDate">
              <outline text="coredata存储NSDate时，在内部是存储了字参考时间以来的NSTimeInterval（以秒计算），而这个参考时间根据 apple dateandtimes doc, NSDate computes time as seconds relative to an absolute reference time: the first instant of January 1, 2001 GMT." />
              <outline text="其实参考日期是2001.1.1，而非1970年1月1日，因此有些语言在直接读取coredata NSDate属性的sqlite Timestamp字段并转换成日期后，与原来存储的日期不一样了。" />
            </outline>
            <outline text="关于where条件后面如果包含有日期的比较，不同数据库有不同的表达式。具体如下：">
              <outline text="如果是access数据库，则为：where mydate&amp;gt;#2000-01-01#" />
              <outline text="如果是oracle数据库，则为：where mydate&amp;gt;cast('2000-01-01' as date)" />
              <outline text="或：where mydate&amp;gt;to_date('2000-01-01','yyyy-mm-dd')" />
              <outline text="在delphi中写成：" />
              <outline text="thedate='2000-01-01';" />
              <outline text="query1.sql.add('select * from abc where mydate&amp;gt;cast('+''''+thedate+''''+' as date)');" />
              <outline text="如果比较日期时间型，则为：" />
              <outline text="where mydatetime&amp;gt;to_date('2000-01-01 10:00:01','yyyy-mm-dd hh24:mi:ss')" />
            </outline>
            <outline text="IOS上的日期比较">
              <outline text="SELECT columnName FROM table WHERE (julianday(date(columnName))-julianday(date('now')))&amp;gt;10" />
              <outline text="julianday()这个函数会返回一个天数，从格林威治时间公元前4714年11月24号开始算起。date()函数返回一个以“YYYY-MM-DD”为格式的日期。因此上面那条语句也就不难理解了。" />
            </outline>
            <outline text="查询一天：">
              <outline text="select * from table where to_days(column_time) = to_days(now());" />
              <outline text="select * from table where date(column_time) = curdate();" />
            </outline>
            <outline text="查询一周：">
              <outline text="select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &amp;lt;= date(column_time);" />
            </outline>
            <outline text="查询一个月：">
              <outline text="select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &amp;lt;= date(column_time);" />
            </outline>
            <outline text="查询一周：">
              <outline text="select * from table where DATE_SUB(CURDATE(), INTERVAL 1 WEEK) &amp;lt;= date(column_time);" />
            </outline>
          </outline>
          <outline text="MySQL 数据类型详解 @iFile" />
          <outline text="跨表查询">
            <outline text="左链接（left join）">
              <outline text="指从左表中返回所有的值，即使右表中没有满足条件的行。" />
              <outline text="select * from table1 left join table2 ON table1.col = table2.col" />
            </outline>
            <outline text="右链接（right join）:  和左链接正好相反。" />
            <outline text="内链接（Inner join）:  即join，指两个表中满足条件的行进行链接。 " />
            <outline text="内链接去重复:  使用 distinct 。 " />
            <outline text="全链接（full join）">
              <outline text="将两个表的所有行都返回。" />
              <outline text="Mysql不支持Full join,不过可以通过UNION 关键字来合并 LEFT JOIN 与 RIGHT JOIN来模拟FULL join." />
            </outline>
          </outline>
          <outline text="巧用update和join、count()更新统计字段">
            <outline text="UPDATE property u">
              <outline text="LEFT JOIN thing_property u_m ON u_m.property_UUID=u.property_UUID" />
              <outline text="SET u.hot_index=(SELECT COUNT(property_UUID) FROM thing_property WHERE property_UUID=u.property_UUID)" />
              <outline text="WHERE u.property_UUID=u_m.property_UUID ;" />
            </outline>
          </outline>
          <outline text="插入时判断是否重复: insert or ignore into" />
          <outline text="统计字数: SELECT sum(char_length(thing)) FROM `thing_time`" />
          <outline text="mysql允许我们在一条sql语句中批量插入数据:">
            <outline text="INSERT INTO example  (example_id, name, value, other_value)  VALUES">
              <outline text="(100, 'Name 1', 'Value 1', 'Other 1')," />
              <outline text="(101, 'Name 2', 'Value 2', 'Other 2')," />
              <outline text="(102, 'Name 3', 'Value 3', 'Other 3')," />
            </outline>
          </outline>
          <outline text="&lt;b&gt;尽可能不用 in子句:  性能很差。不如用联合 inner。&lt;/b&gt;" />
          <outline text="3个常用的PHP访问数据库的代码">
            <outline text="返回一个数组的情况">
              <outline text="$tag_uuids = array();" />
              <outline text="$sql_string = &quot;select property_UUID, hot_index from property&quot;;" />
              <outline text="$result = mysql_query($sql_string);" />
              <outline text="if ($result == FALSE) {">
                <outline text="$GLOBALS['log']-&amp;gt;error(&quot;error: re_calc_tag_hot_index() -- $sql_string 。&quot;);" />
                <outline text="return 0;" />
              </outline>
              <outline text="}" />
              <outline text="while($row = mysql_fetch_array($result)) {">
                <outline text="$tag_uuids[] = $row['property_UUID'];" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="返回一个值的情况">
              <outline text="$sql_string = &quot;select count(*) from thing_time &quot;;" />
              <outline text="$result = mysql_query($sql_string);" />
              <outline text="if($result == FALSE) {">
                <outline text="$GLOBALS['log']-&amp;gt;error(&quot;error: get_thing_count_by_period() -- $sql_string 。&quot;);" />
                <outline text="return -1;" />
              </outline>
              <outline text="}" />
              <outline text="$row = mysql_fetch_row($result);    // 返回一行." />
              <outline text="if ($row == NULL) {">
                <outline text="return &quot;&quot;;" />
              </outline>
              <outline text="}" />
              <outline text="return $row[0];" />
            </outline>
            <outline text="不需要返回值的情况">
              <outline text="$sql_string = &quot;update thing_time set year_order=time where time_type=2&quot;;" />
              <outline text="if (!mysql_query($sql_string)) {">
                <outline text="$GLOBALS['log']-&amp;gt;error(&quot;error: re_calc_year_order() -- $sql_string 。&quot;);" />
                <outline text="return 0;" />
              </outline>
              <outline text="}" />
            </outline>
          </outline>
        </outline>
        <outline text="&lt;b&gt;SQL性能优化&lt;/b&gt;">
          <outline text="尽可能不用 distinct">
            <outline text="大多数情况下，Distinct函数都会导致对最终结果集完成一次排序，因此，这就成为成本最昂贵的排序之一。Distinct一直是SQL语言中成本最高的函数之一。解决方法有两个：" />
            <outline text="使用GroupBy（V9之前），这会利用关联索引来消除为确定唯一性所导致的排序。" />
            <outline text="使用一个Exists子查询重写查询。如果某个表可能导致重复（由于是一对多关系），但是这个表中并不包含结果集将返回的数据，这种情况下这种方法就很适用。 " />
          </outline>
          <outline text="推荐使用COMMIT">
            <outline text="SQLite保存大数据集非常非常快。例如地图程序应该把图块缓存在SQLite里。最昂贵的部分是硬盘I/O。" />
            <outline text="要避免在大块之间产生大量的小的写入，就需要用 BEGIN和 COMMIT。" />
            <outline text="我们使用2秒钟的计时器去重置每次新的提交。一旦计时器国企，就发送COMMIT，这样所有些操作就写到一个大块里面了。" />
            <outline text="SQLLite把事务数据保存在磁盘上，使用Begin/End包装可以避免产生大量的事务文件，把所有的事务写到一个文件里。" />
          </outline>
          <outline text="使用多线程">
            <outline text="当SQLite在主线程的时候会阻塞你的界面。" />
            <outline text="如果你执行非常长的查询，一个好办法是把你的查询保存成静态对象，然后在另一个线程查询。" />
            <outline text="把所有会修改数据库的查询用@synchronize() {}块包起来。" />
            <outline text="短查询就放在主线程，简单方便。" />
          </outline>
          <outline text="在多线程里面使用SQLite还有一个更简单的方法">
            <outline text="用sqlite3_open_v2打开数据库，flag用SQLITE_OPEN_FULLMUTEX，这样SQLite的所有函数就是线程安全的了，不需要synchronize了。" />
            <outline text="不过不确定哪个效率更高。" />
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;17-Binder&lt;/b&gt;">
        <outline text="&lt;a href=&quot;https://www.cnblogs.com/samchen2009/p/3316001.html&quot;&gt;https://www.cnblogs.com/samchen2009/p/3316001.html&lt;/a&gt;  图解Android - Binder 和 Service" />
        <outline text="&lt;a href=&quot;http://www.mysixue.com/?p=137&quot;&gt;http://www.mysixue.com/?p=137&lt;/a&gt;  Binder详解  @Good " />
        <outline text="Binder是Android系统中的进程间通讯方式之一. " />
        <outline text="Binder和传统IPC对比  #面试题">
          <outline text="传统IPC有如下方式：">
            <outline text="socket: 通用接口, 传输效率低, 多用于跨网络或本机的低速通讯。" />
            <outline text="消息队列 / 管道, 采取存储-转发方式, 至少需要两次拷贝. ">
              <outline text="消息队列 / 管道需要共享内存地址, 所以只能用于同进程的两个线程间通信。" />
            </outline>
            <outline text="共享内存无需拷贝, 但是控制复杂, 难以使用和扩展." />
            <outline text="它们的缺点是: 主要是没有安全机制, 无法获得访问线程的可靠的UID/PID, 无法鉴别访问者身份. 而且传统IPC访问接入点是开放的, 无法建立私有通道." />
          </outline>
          <outline text="Binder的优势有:">
            <outline text="性能高(数据只拷贝1次, 消息队列和管道至少两次)." />
            <outline text="安全(通过UID/PID可校验访问者身份, 并支持匿名Binder)." />
            <outline text="和共享内存比, 读写两方各自管理自己的数据, 控制较简单. " />
          </outline>
          <outline text="Binder的缺点: 只能单向由Client发起请求，而Service无法主动传输数据. 这个限制了它的使用场景." />
        </outline>
        <outline text="Binder 5要素">
          <outline text="提供业务能力的server.  它同时要提供访问接入点, 类似于: ip地址+端口号" />
          <outline text="使用业务的client;  它需要具有探测访问接入点的能力;" />
          <outline text="双方的通讯协议. IBinder的扩展类. 分别为 server 和 client 继承。" />
          <outline text="Native层的 ServiceManager (SMgr)">
            <outline text="它的功能类似于互联网的域名服务器DNS, 作用是将字符串格式的Binder名字转化为Client中对Binder server的应用, 以完成寻址." />
          </outline>
          <outline text="内核态的Binder驱动: 位于核心态. ">
            <outline text="设备节点是 /dev/Binder, 主要通过 ioctl() 接口对上提供能力.  " />
            <outline text="代码在 drivers/misc/binder.c." />
            <outline text="跨进程能力就是由 Binder驱动提供." />
          </outline>
        </outline>
        <outline text="&lt;b&gt;Binder通讯过程 (核心)&lt;/b&gt;">
          <outline text="先看数据结构: server/client/Binder驱动, 三方都使用 binder_tansaction_data 结构来封装信息. 包括如下字段: ">
            <outline text="&lt;b&gt;code&lt;/b&gt;, 整数, Binder方法的句柄." />
            <outline text="&lt;b&gt;data_buffer&lt;/b&gt;, 存放参数." />
            <outline text="&lt;b&gt;traget, 这个字段比较复杂. 它是一个联合体, 在server侧, 它是 ptr, 指向被调用的Binder对象的地址. 在client端, 它是handle, 指向BinderProxy对象的句柄.&lt;/b&gt;" />
          </outline>
          <outline text="server侧注册过程">
            <outline text="Service 可以运行在native 层(C/C++)，也可以运行在Java 层。" />
            <outline text="先定义一个抽象接口类封装 server 的所有功能, 其中包含一系列纯虚函数, 待server和client分别实现." />
            <outline text="使用AIDL, client可自动生成(因为client只是一个影子类, 目的是编译通过), server则必须得自己实现." />
            <outline text="server 创建Binder实体, 命名, 并实现其业务能力; " />
            <outline text="然后server需要写一个实现 IBinder接口的 Remote class，来处理client的Binder请求, 其中最重要的是函数是 &lt;b&gt;onTransact&lt;/b&gt;(). 它负责按请求来调用server端的实体函数. " />
            <outline text="最后，调用 ServiceManager.&lt;b&gt;AddService&lt;/b&gt;() 把自己注册到 ServiceManager。">
              <outline text="ServiceManager.AddService(string Name, IBinder Service);" />
              <outline text="可将一个IBinder与name字符串绑定。" />
            </outline>
            <outline text="ServiceManager 向 Binder驱动注册该server." />
            <outline text="Binder驱动为这个 Binder创建位于内核的实体节点, 以及 ServiceManager对实体节点的引用. 并把这些信息返回给ServiceManager.">
              <outline text="对驱动而言, 引用就是0,1,2,...这样的整数, 相当于是函数的序号. " />
              <outline text="所以server和client要事先约定好函数顺序。" />
            </outline>
            <outline text="ServiceManager 收到信息后, 把名称和引用填入查找表. " />
            <outline text="至此，server初始化工作完成了。系统的server，比如ams，wms也是这样一个流程。" />
          </outline>
          <outline text="client侧调用过程">
            <outline text="由于client 持有 IBinder 的影子类, 所以尽管自身代码中有调用service接口的代码, 并无实现, 也可以编译通过. " />
            <outline text="在Client 进程中, 先调用 ServiceManager.GetService(string Name) 获取系统service对象, 参数为字符串, 然后获取到Name对应的Server线程的编号(handle), 后者是个32位的正整数(0有其它用途), 值随机." />
            <outline text="IBinder对象的最重要的一个函数是 IBinder.&lt;b&gt;TransAct&lt;/b&gt;(int code, Parcel data, Parcel reply, int flag);  其中:">
              <outline text="code 是要调用的函数;" />
              <outline text="data 是函数参数打包到Parcel 中去. binder引用地址写入 traget.handle. " />
              <outline text="reply 是返回值." />
            </outline>
            <outline text="然后调用remote()-&amp;gt;transact(xxx);" />
            <outline text="remote()是在BpXXXService的父类BpRefBase中实现的，返回的就是一个BpBinder.实际上调用的就是BpBinder的 transact();" />
            <outline text="BpBinder的transact实现，就是直接调用 IPCThreadState::self()-&amp;gt;transact() 发送数据。" />
            <outline text="&lt;b&gt;命令发出后, 如果是同步调用, client端线程会被阻塞, 直到收到 reply。&lt;/b&gt;" />
          </outline>
          <outline text="server侧响应调用过程">
            <outline text="该命令首先发给 &lt;b&gt;Binder驱动&lt;/b&gt;, 驱动会根据 traget.handle 往 traget&lt;b&gt;.&lt;/b&gt;ptr 字段中填写Binder对象的地址. 并把它转给server. " />
            <outline text="server端通过 IPCThreadState 接收到 client的请求后，首先会调用 BBinder的 transact()。" />
            <outline text="BBinder的 transact() 负责取出traget.ptr指针, reinterpret_cast 强转为Binder抽象类, 然后调用它的 onTransact() 方法. 这个方法是在 BnXXXService 中实现的。" />
            <outline text="onTransact() 负责取出根据命令字id调用具体的方法." />
            <outline text="执行结果会通过binder驱动返回给 client." />
          </outline>
          <outline text="具体代码是:">
            <outline text="server端代码">
              <outline text="Class myService extends Binder {">
                <outline text="protected boolean OnTransact (int code, Parcel data, Parcel reply, int flags) throws RemoteException {...}" />
              </outline>
              <outline text="关键是实现OnTransact(), 根据code实现逻辑分发." />
            </outline>
            <outline text="Client端代码">
              <outline text="IBinder myBinder = getService(Context.ACCESSIBILITY_SERVICE);   // 参数是字符串" />
              <outline text="myBinder.transact(code, data, reply, 0);    // 执行完这一步, 线程会挂起" />
              <outline text="reply.readException();" />
            </outline>
          </outline>
        </outline>
        <outline text="&lt;b&gt;Native层的binder (核心)&lt;/b&gt;">
          <outline text="&lt;b&gt;ProcessState: 管理设备节点 &lt;/b&gt;/dev/binder">
            <outline text="frameworks/native/libs/binder/&lt;b&gt;ProcessState&lt;/b&gt;.cpp, 主要接口是:" />
            <outline text="ProcessState::self() : 主要功能是 open(/dev/binder), Server/Client都会用到, 因为它们都得打开内核设备节点." />
            <outline text="ProcessState::startThreadPool() : Server进程会用到, 主要目的是创建一个线程, 在线程里面while循环, 监听是否有数据写入设备节点." />
          </outline>
          <outline text="&lt;b&gt;IPCThreadState: &lt;/b&gt;通过ioctl 读写 /dev/binder,完成用户空间与内核空间的数据交互.">
            <outline text="frameworks/native/libs/binder/&lt;b&gt;IPCThreadState&lt;/b&gt;.cpp, 主要接口是:" />
            <outline text=" IPCThreadState::transact() : Client进程会用到, 目的是往设备节点写入数据.">
              <outline text="transact里面会分 waitForResponse(reply) 和 waitForResponse(NULL) 这两种情况, 前者的意思是Client发送一个数据（请求/命令…）给Server后, 需要等待Server的执行结果, 结果存储在reply中; 后者的意思是Client只是发送个请求, 不需要等待对应的执行结果." />
              <outline text="两个 waitForResponse() 都会调用talkWithDriver, 后者会调用 ioctl与 /dev/binder 交互." />
            </outline>
            <outline text="IPCThreadState::joinThreadPool : Server进程会用到, ProcessState::startThreadPool()最终就是调用的IPCThreadState::joinThreadPool, 目的就是监听设备节点. ">
              <outline text="joinThreadPool会调用getAndExecuteCommand(), " />
              <outline text="后者会调用talkWithDriver()监听设备节点, 当收到一个数据后, 就解析并执行相应的操作(ExecuteCommand)." />
            </outline>
          </outline>
          <outline text="上面这两个类主要用于通讯, 下面几个类主要用于binder数据封装." />
          <outline text="&lt;b&gt;IBinder:  &lt;/b&gt;是 BBinder 和 BpBinder 的基类.">
            <outline text="frameworks/native/include/binder/&lt;b&gt;IBinder&lt;/b&gt;.h" />
            <outline text="它里面定义的一个重要接口是 transact()." />
          </outline>
          <outline text="IInterface: BnInterface 和 BpInterface 的基类">
            <outline text="IInterface 定义了两个非常关键的接口:" />
            <outline text="interface_cast(): 功能是统一管理binder对象(不分客户端和服务器端). 代码如下:">
              <outline text="template&amp;lt;typename INTERFACE&amp;gt;" />
              <outline text="inline sp&amp;lt;INTERFACE&amp;gt; interface_cast(const sp&amp;lt;IBinder&amp;gt;&amp;amp; obj) {">
                <outline text="return INTERFACE::&lt;b&gt;asInterface&lt;/b&gt;(obj);" />
              </outline>
              <outline text="}" />
              <outline text="这是一个模板函数. 每个binder对象都会按自己的类型来展开. 下面以 ICameraClient为例展开." />
              <outline text="inline sp&amp;lt;ICameraClient &amp;gt; interface_cast(const sp&amp;lt;IBinder&amp;gt;&amp;amp; obj) {">
                <outline text="return ICameraClient ::asInterface(obj);" />
              </outline>
              <outline text="}" />
              <outline text="ICameraClient ::asInterface() 在哪里定义的?" />
              <outline text="frameworks/av/include/camera/android/hardware/ICameraClient.h 的内容是:" />
              <outline text="DECLARE_META_INTERFACE(CameraClient);" />
              <outline text="frameworks/av/camera/ICameraClient.cpp 的内容是:" />
              <outline text="IMPLEMENT_META_INTERFACE(CameraClient, &quot;android.hardware.ICameraClient&quot;);" />
              <outline text="即通过宏 DECLARE_META_INTERFACE 和 IMPLEMENT_META_INTERFACE 来展开." />
              <outline text="其中, ICameraClient::asInterface() 的展开代码如下:" />
              <outline text="android::sp&amp;lt;ICameraClient&amp;gt; ICameraClient::asInterface( const android::sp&amp;lt;android::IBinder&amp;gt;&amp;amp; obj) {">
                <outline text="android::sp&amp;lt;ICameraClient&amp;gt; intr;" />
                <outline text="if (obj != NULL) {">
                  <outline text="&lt;b&gt;// queryLocalInterface()是在IBinder中定义的，默认返回NULL. 但在BBinder的子类BnInterface中，重载了该方法，返回this，而BpBinder没有重载，使用IBinder的默认实现，返回NULL  --关键&lt;/b&gt;" />
                  <outline text="intr = static_cast&amp;lt;ICameraClient*&amp;gt;(obj-&amp;gt;&lt;b&gt;queryLocalInterface&lt;/b&gt;(ICameraClient::descriptor).get());" />
                  <outline text="if (intr == NULL) {">
                    <outline text="// 构建INTERFACE的Bp端代理对象" />
                    <outline text="intr = new BpCameraClient(obj);" />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
                <outline text="return intr;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="asBinder():">
              <outline text="asBinder() 会直接调用 onAsBinder(). 而后者在子类中定义, 其中:" />
              <outline text="BnInterface的onAsBinder()， 直接返回自身;">
                <outline text="template&amp;lt;typename INTERFACE&amp;gt; IBinder* BnInterface&amp;lt;INTERFACE&amp;gt;::onAsBinder() {">
                  <outline text="return this;" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="BpInterface的onAsBinder()，调用remote()方法并返回.">
                <outline text="template&amp;lt;typename INTERFACE&amp;gt; inline IBinder* BpInterface&amp;lt;INTERFACE&amp;gt;::onAsBinder() {">
                  <outline text="return remote();" />
                </outline>
                <outline text="}" />
                <outline text="remote() 在其父类 BpRefBase 中实现，就是返回 mRemote 变量." />
                <outline text="而mRemote变量是在创建BpInterface对象时，将remote变量传给了其父类BpRefBase.">
                  <outline text="template inline BpInterface::BpInterface(const sp&amp;amp; remote) : BpRefBase(remote) {" />
                  <outline text="}" />
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="&lt;b&gt;BpRefBase&lt;/b&gt;: 客户端类">
            <outline text="frameworks/native/include/binder/Binder.h, frameworks/native/libs/binder/Binder.cpp" />
            <outline text="BpRefBase里面定义了一个变量 : IBinder* const mRemote; 这个mRemote实际上指的就是BpBinder." />
            <outline text="BpRefBase用于Client端, Client端的代码会继承BpRefBase, 当Client端想往Server发送数据时, 会使用mRemote-&amp;gt;transact()的形式." />
          </outline>
          <outline text="&lt;b&gt;BBinder: 服务器端&lt;/b&gt;">
            <outline text="frameworks/native/include/binder/Binder.h, frameworks/native/libs/binder/Binder.cpp" />
            <outline text="BBinder继承了IBinder, 也实现了IBinder中定义的transact函数.前文我们说过Server端会开启一个线程, 监听/dev/binder节点. 当收到数据时, Server端的这个线程会调用BBinder::transact." />
            <outline text="BBinder用于Server端, BBinder除了继承了IBinder中的transact接口, 它自己也定义了一个onTransact接口, Server端的代码一般会实现onTransact接口. " />
            <outline text="BBinder::transact里面会调用onTransact函数, 继而把Client端通过内核传递过来的数据交给Server端的代码进行处理, 从而完成一次进程间通信." />
          </outline>
          <outline text="&lt;b&gt;BpBinder: 客户端数据封装类, &lt;/b&gt;继承了IBinder. 它存在于 BpRefBase中的 mRemote的成员变量中。">
            <outline text="frameworks/native/include/binder/BpBinder.h, frameworks/native/libs/binder/BpBinder.cpp" />
            <outline text="BpBinder并不在继承关系当中，它只是一个打包数据，该数据通过IPCThreadState::self()-&amp;gt;transact()方法发送出去。" />
          </outline>
          <outline text="&lt;b&gt;BnInterface&lt;/b&gt;: 模板类, 所有服务器端类都是它的子类. 主要方法是: onAsBinder()." />
          <outline text="&lt;b&gt;BpInterface&lt;/b&gt;: 模板类, 所有客户端类都是它的子类. 主要方法是: onAsBinder()." />
        </outline>
        <outline text="Binder驱动">
          <outline text="binder驱动在以misc设备进行注册，作为虚拟字符设备，但是这个设备没有操作硬件，只是对内存的处理。" />
          <outline text="操作一个Binder，相当于打开 “/dev/binder”，然后通过该节点的 ioctl 接口传入命令。" />
          <outline text="对 /dev/binder 的访问, 即是进行系统调用(syscall), 此时代码会陷入内核态. 陷入流程是:">
            <outline text="比如, 打开Binder驱动方法的调用链为： open-&amp;gt; __open() -&amp;gt; binder_open()。" />
            <outline text="其中, open()为用户空间的方法;" />
            <outline text="__open()便是系统调用中相应的处理方法;" />
            <outline text="对应调用到内核binder驱动的binder_open()方法." />
            <outline text="其它接口也是大同小异." />
          </outline>
          <outline text="&lt;b&gt;接口:&lt;/b&gt;">
            <outline text="代码在：binder_module.h。" />
            <outline text="open/close" />
            <outline text="ioctl: 这是主要的接口.">
              <outline text="参数包括三个：">
                <outline text="fd，文件句柄；" />
                <outline text="cmd，命令字；">
                  <outline text="BINDER_WRITE_READ，Binder读写（主要命令）；">
                    <outline text="由于有返回值，所以一旦write之后，必须有read操作，所以这两个动作放在一个命令中。" />
                  </outline>
                  <outline text="BINDER_SET_IDLE_TIMEOUT，设置请求超时；" />
                  <outline text="BINDER_SET_REPALY_TIMEOUT，设置reply超时；" />
                  <outline text="BINDER_SET_MAX_THREADS，设置线程池容量。" />
                  <outline text="代码在：binder.h。" />
                </outline>
                <outline text="args，参数和返回值。" />
              </outline>
            </outline>
          </outline>
          <outline text="kernel space中，/dev/binder 有如下接口：">
            <outline text="binder_open: 进行初始化" />
            <outline text="binder_ioctl: 对命令字进行解析和分发" />
            <outline text="binder_mmap: 内存映射，将Binder对象从内核空间映射到用户空间" />
            <outline text="binder_flush: 将处在等待中的进程唤醒并返回" />
            <outline text="代码在：binder.c。" />
          </outline>
          <outline text="&lt;b&gt;binder_ioctl() 处理流程&lt;/b&gt;">
            <outline text="如果传入的cmd是 BINDER_WRITE_READ, 则调用 binder_thread_write()." />
            <outline text="后者对命令进一步解析，发现cmd为 bcTransaction，即发起IPC transaction，则将参数 binder_transaction_data 复制到内核空间。" />
            <outline text="binder_transaction() 根据 binder_transaction_data 中的target字段可寻出被调者的进程，从该进程的缓冲区中&lt;b&gt;选择一个处在wait for ioctl的线程，将 binder_transaction_data 复制给它，并唤醒它。&lt;/b&gt;" />
            <outline text="被调者用户线程执行相应指令。然后将执行结果写入新的 binder_transaction_data 中，通过ioctl发给内核，即发起一个新的transaction。" />
            <outline text="&lt;b&gt;内核将结果写入调用者线程的buffer中，并唤醒该线程。调用者得到结果。&lt;/b&gt;" />
            <outline text="Binder可以传递对象引用。传递过程中，内核负责将其添加到对象映射表中。" />
            <outline text="server进程收到rpc调用，则从线程池中选择一个线程处理rpc请求，包括cmd和reply两个过程。内核收到reply后，将其传给client。" />
          </outline>
          <outline text="Binder内存机制">
            <outline text="由binder_mmap() 完成. 主要功能是:" />
            <outline text="首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；" />
            <outline text="然后再申请1个page大小的物理内存，" />
            <outline text="再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。" />
          </outline>
        </outline>
        <outline text="和第三方service的通讯过程">
          <outline text="第三方service和系统service大同小异, 就是要定义唯一的字符串来作为service的名称, server和client要一致." />
        </outline>
        <outline text="AIDL">
          <outline text="AIDL相当于Binder脚本. 目的是" />
          <outline text="RPC系统一般都会定义自己的接口定义语言（IDL），android上的叫aidl." />
          <outline text="aidl语法和java类似。例如:">
            <outline text="interface IMyInterface {">
              <outline text="int getData(int a);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="AIDL文件如何编译？">
            <outline text="用tools 目录下的aidl.exe编译." />
            <outline text="编译结果是 IMyInterface，以及内镶类 proxy和stub。" />
            <outline text="IMyInterface 拷贝到 client 工程中使用." />
          </outline>
        </outline>
        <outline text="server 和 client 如何和 SMgr 通讯呢? ">
          <outline text="这种情况下, SMgr是server, 而各server 和 client 都是client. " />
          <outline text="它们之前的Binder的引用固定为0, 不需要寻址. " />
          <outline text="当一个进程建立Binder时, 使用 BINDER_SET_CONTEXT_MGR 来发起和SMgr的通讯, 完成注册自己. " />
          <outline text="既然servicemanager作为所有Server进程/Client进程的服务端, 那是不是应该提供相应的客户端的封装, 以便客户端能方便与servicemanager通信呢? Android系统确实提供了这样的封装, 它就是 frameworks/native/libs/binder/IServiceManager.cpp. " />
        </outline>
        <outline text="匿名Binder">
          <outline text="不向ServiceManager注册名字的Binder即位匿名Binder." />
          <outline text="其通讯方式是：通过已经建立的Binder连接将新的Binder实体传递给client. " />
          <outline text="也就是说，它要求server和client之间至少已经存在了一个实名Binder." />
          <outline text="匿名Binder无法被第三方破解, 比较安全." />
        </outline>
        <outline text="Binder与service类" />
        <outline text="Binder与intent" />
      </outline>
      <outline text="&lt;b&gt;20-FWK-Input&lt;/b&gt;">
        <outline text="&lt;a href=&quot;https://www.viseator.com/categories/Android/View/&quot;&gt;https://www.viseator.com/categories/Android/View/&lt;/a&gt; , @Good" />
        <outline text="&lt;a href=&quot;http://gityuan.com/2016/12/31/input-ipc/&quot;&gt;http://gityuan.com/2016/12/31/input-ipc/&lt;/a&gt;,  @Good" />
        <outline text="&lt;a href=&quot;http://www.mysixue.com/?p=144&quot;&gt;http://www.mysixue.com/?p=144&lt;/a&gt;, @Good " />
        <outline text="&lt;a href=&quot;https://www.viseator.com/2017/09/14/android_view_event_1/&quot;&gt;https://www.viseator.com/2017/09/14/android_view_event_1/&lt;/a&gt;" />
        <outline text="&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/9097463/&quot;&gt;https://blog.csdn.net/guolin_blog/article/details/9097463/&lt;/a&gt;" />
        <outline text="代码静态结构">
          <outline text="frameworks/native/services/inputflinger/  --  &lt;a href=&quot;http://libinputflinger.so&quot;&gt;libinputflinger.so&lt;/a&gt;">
            <outline text="InputDispatcher.cpp" />
            <outline text="InputReader.cpp" />
            <outline text="InputManager.cpp" />
            <outline text="EventHub.cpp" />
            <outline text="InputListener.cpp" />
          </outline>
          <outline text="frameworks/native/libs/input/  --  &lt;a href=&quot;http://libinput.so&quot;&gt;libinput.so&lt;/a&gt;">
            <outline text="InputTransport.cpp" />
            <outline text="Input.cpp" />
            <outline text="InputDevice.cpp" />
            <outline text="Keyboard.cpp" />
            <outline text="KeyCharacterMap.cpp" />
            <outline text="IInputFlinger.cpp" />
          </outline>
          <outline text="frameworks/base/services/core/  --  services. jar,  libandroid_services.so">
            <outline text="java/com/android/server/input/InputManagerService.java" />
            <outline text="jni/com_android_server_input_InputManagerService.cpp" />
          </outline>
          <outline text="frameworks/base/libs/input/  --  &lt;a href=&quot;http://libinputservice.so&quot;&gt;libinputservice.so&lt;/a&gt;">
            <outline text="PointerController.cpp" />
            <outline text="SpriteController.cpp" />
          </outline>
        </outline>
        <outline text="初始化流程 #面试题 ">
          <outline text="&lt;b&gt;开机过程中, systemserver.java, 调用&lt;/b&gt;startOtherServices(), 创建InputManagerService 对象。" />
          <outline text="为这个对象设置与 WindowManagerService相关的回调函数，然后调用InputManagerService的start()。" />
          <outline text="start()通过JNI调用，进行native层初始化。" />
          <outline text="在native层初始化的时候，创建 NativeInputMnager 的对象（重要）。">
            <outline text="InputReader 和 InputDispatcher 和其他模块的交互由 NativeInputMnager 负责中转。" />
            <outline text="NativeInputMnager 持有 InputReaderPolicyInterface和 InputDispatcherPolicyInterface。" />
            <outline text="负责创建 InputManager。">
              <outline text="InputManager 创建 InputReader 和 InputDispatcher 两个线程。 代码在: InputManager::InputManager()" />
              <outline text="InputReader::InputReader() 构造时, mQueuedListener = new QueuedInputListener(listener);" />
            </outline>
            <outline text="负责管理 EventHub，InputReader，InputReaderThread，InputDispatcher，InputDispatcherThread等对象。" />
          </outline>
        </outline>
        <outline text="事件上报流程 #面试题 ">
          <outline text="EventHub">
            <outline text="frameworks/native/services/inputflinger/EventHub.cpp" />
            <outline text="事件的起源地，所有的事件都是它从驱动中读取出来的。" />
            <outline text="负责监视  /dev/input/eventX 多个FD上产生的事件，包括设备添加，移除，以及触摸等事件, 然后把事件封装成 RawEvent 结构体供 InputReader 使用。" />
            <outline text="使用的结构体叫 RawEvent。" />
            <outline text="监听机制，是通过Linux提供的epoll机制来实现。epoll机制简单地说就是高效地I/O多路复用机制，使用epoll_wait来监听所需要的文件描述符的变化。" />
          </outline>
          <outline text="InputReader">
            <outline text="frameworks/native/services/inputflinger/InputReader.cpp" />
            <outline text="是 systemserver子线程。" />
            <outline text="InputReader 持有 EventHub 和 InputDispatcher , 是Input子系统的核心. " />
            <outline text="InputReader 负责完成描点. (开发人员选项中可打开描点)  --代码在哪儿?   @Plan " />
            <outline text="void InputReader::&lt;b&gt;loopOnce&lt;/b&gt;()   // 核心函数">
              <outline text="&lt;b&gt;1. 接受事件&lt;/b&gt;" />
              <outline text="mEventHub-&amp;gt;getEvents()   // 通过 threadLoop，周期性的从EventHub中读取事件。">
                <outline text="这些事件是 rawdata，即没有经过加工处理的事件；" />
                <outline text="最终调用 epoll_wait() 来读取 /dev/input/input* 上的事件信息." />
              </outline>
              <outline text="&lt;b&gt;2. 对事件信息进行数据封装&lt;/b&gt;" />
              <outline text="processEventLocked()" />
              <outline text="device-&amp;gt;process(rawEvents, count);   // InputDevice代表输入设备" />
              <outline text="mapper-&amp;gt;process(rawEvent);     // InputMapper, 负责定义每种键值事件是如何处理的.   一个InputDevice对应多个InputMapper。" />
              <outline text="我们关注的触摸屏有如下处理:">
                <outline text="void TouchInputMapper::process(const RawEvent* rawEvent)" />
                <outline text="void TouchInputMapper::sync(nsecs_t when)" />
                <outline text="void TouchInputMapper::processRawTouches(bool timeout)" />
                <outline text="void TouchInputMapper::cookAndDispatch(nsecs_t when)" />
                <outline text="void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) " />
                <outline text="void TouchInputMapper::&lt;b&gt;dispatchMotion&lt;/b&gt;(nsecs_t when...)  // 封装 NotifyArgs事件" />
                <outline text="void QueuedInputListener::notifyMotion(...)" />
                <outline text="mArgsQueue.&lt;b&gt;push&lt;/b&gt;();   // 事件数据保存到 QueuedInputListener的 mArgsQueue中." />
              </outline>
              <outline text="&lt;b&gt;3. 事件分发&lt;/b&gt;" />
              <outline text="mQueuedListener-&amp;gt;flush();   // QueuedInputListener, 事件监视器" />
              <outline text="NotifyMotionArgs::notify()" />
              <outline text="listener-&amp;gt;&lt;b&gt;notifyMotion&lt;/b&gt;(this);">
                <outline text="listener 即 QueuedInputListener, 事件监视器, 持有 mInnerListener, 指向 InputDispatcher对象." />
                <outline text="这便是 InputReader跟 InputDispatcher交互的中转站。" />
              </outline>
              <outline text="InputDispatcher::notifyMotion()   // 这里就是 InputDispatcher了." />
            </outline>
          </outline>
          <outline text="InputDispatcher">
            <outline text="frameworks/native/services/inputflinger/InputDispatcher.cpp" />
            <outline text="InputDispatcher为&lt;b&gt;systemserver子线程。&lt;/b&gt;" />
            <outline text="InputDispatcher.&lt;b&gt;notifyMotion&lt;/b&gt;()  // 将 NotifyArgs 构建KeyEvent。" />
            <outline text="enqueueInboundEventLocked(newEntry);  // 将事件entry 放入消息队列." />
            <outline text="InputDispatcher::dispatchOnce()   // 死循环执行事件分发. " />
            <outline text="InputDispatcher::dispatchMotionLocked()  // 分发触摸事件." />
            <outline text="" />
            <outline text="开始事件的分发，通过InputChannel把事件分发给WindowManager或者应用。" />
            <outline text="如果是应用的话，可通过 registerInputChannel来定义输入事件的目标。" />
            <outline text="" />
            <outline text="将 KeyEvent传递给WindowManagerService去处理。" />
            <outline text="事件在入队前(before enqueue)的处理：">
              <outline text="NativeInputManager" />
              <outline text="interceptKeyBeforeQueueing" />
              <outline text="InputManagerService.interceptKeyBeforeQueueing" />
              <outline text="InputMonitor.interceptKeyBeforeQueueing " />
              <outline text="PhoneWindowManager.&lt;b&gt;interceptKeyBeforeQueueing&lt;/b&gt;" />
              <outline text="一般首先把事件都标记上PASS_TO_USER，即这个事件要交给应用程序去处理，但是在处理过程中决定，有些事件是没必要传递给应用程序的。" />
            </outline>
            <outline text="调用 dispatchKeyLocked() 分发事件">
              <outline text="根据每一个target（一个事件可以有多个）对应的inputChannel找到connection，" />
              <outline text="然后 prepareDispatchCycleLocked使用这个connection把事件逐个分发到target中。 " />
              <outline text="在prepareDispatchCycleLocked方法中，主要就是根据事件是否可以分割，分别把事件放入队列。" />
              <outline text="在入队列的之后，InputPublisher的发布事件的队列就不再为空，然后会调用 startDispatchCycleLocked方法，通过InputPublisher开始发布事件。" />
            </outline>
          </outline>
          <outline text="InputChannel">
            <outline text="InputChannel就是一个通道，具有通信功能。" />
            <outline text="每个活跃的activity都有自己的 InputChannel对象。在 ViewRootImpl.&lt;b&gt;setView&lt;/b&gt;() 中创建。然后把 InputChannel 传递给 WindowManagerService。" />
            <outline text="通过 sendMessage() 发生事件, 通过 receiveMessage() 接受事件." />
            <outline text="1. 原始事件通过建立好的InputChannel的 sendMessage()函数发送触摸事件." />
            <outline text="2. 直接调用send()函数向fd表示的socket中写入数." />
            <outline text="3. 在另一边的 epoll_wait()调用就会因socket另一端fd数据的到来而唤醒，并通过fd找到注册好的request." />
            <outline text="4. 进而调用request中的 NativeInputEventReceiver的 handleEvent()方法，参数就是我们接收到的事件信息与数据。" />
          </outline>
          <outline text="InputPublisher">
            <outline text="InputTransport.cpp 的内部类." />
            <outline text="调用 InputChannel 发送事件, 并接受finish事件." />
          </outline>
          <outline text="InputConsumer">
            <outline text="InputTransport.cpp 的内部类" />
            <outline text="消费来自 inputChannel 的事件." />
          </outline>
          <outline text="InputFilter">
            <outline text="这是一个java类." />
            <outline text="负责对事件进行拦截, 过滤. 比如手势识别, 辅助功能, 盲人模式等模块会用. " />
            <outline text="AccessbilityManagerService 负责初始化 InputFilter." />
            <outline text="然后赋值给 InputManagerService. InputManagerService 只支持一个InputFilter, 新注册的InputFilter会把老的覆盖。" />
            <outline text="filterInput() 的调用是发生在Input Reader线程里，通过InputManagerService 里的 InputFilterHost 对象通知另外一个线程里的InputFilter 开始真正的解析工作。" />
            <outline text="InputFilter 的工作也分为两个步骤，首先由InputEventConsistencyVerifier 对象（InputEventConsistencyVerifier.java）对输入事件的完整性做一个检查，检查事件的ACTION_DOWN 和 ACTION_UP 是否一一配对。" />
            <outline text="接下来，进入到 AccessibilityInputFilter 的 onInputEvent()，这里将把输入事件（主要是MotionEvent)进行处理，根据需要变成另外一个Event，然后通过sendInputEvent() 将事件发回给InputDispatcher。最终调用到injectInputEvent() 将这个事件送入 mInBoundQueue." />
          </outline>
        </outline>
        <outline text="power 键规格">
          <outline text="0-500毫秒： 亮灭屏" />
          <outline text="500-2500毫秒：语音助手" />
          <outline text="2500毫秒以上： 关机" />
        </outline>
        <outline text="应用层事件传递流程 #面试题 ">
          <outline text="Activity -&amp;gt; Windows -&amp;gt; DecorView -&amp;gt; ViewGroup -&amp;gt; 各子View" />
          <outline text="Activity中 InputEventReceiver的 &lt;b&gt;onInputEvent ()&lt;/b&gt;被回调，开始 java层touch事件传递。" />
          <outline text="InputStage的子类有: NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage、EarlyPostImeInputStage、NativePostImeInputStage、ViewPostImeInputStage、SyntheticInputStage.">
            <outline text="它们构成一个输入事件处理链，如果本阶段对事件没有处理，则传递到下一个对象进行处理，直至事件被处理。" />
            <outline text="NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage三个类用来实现输入法的按键派发和处理，如果事件不传递到输入法服务中，这三个类可以跳过。" />
            <outline text="EarlyPostImeInputStage对象开始处理，在 ViewPostImeInputStage 对象处理阶段调用了主View 对象（对应PhoneWindow中的DecorView对象）的事件提交函数如（dispatchTouchEvent）函数向视图对象提交输入事件, 在当前窗口的视图树中派发事件。" />
          </outline>
          <outline text="MainActivity. &lt;b&gt;DecorView&lt;/b&gt; 在传递事件过程中首先将事件传给Activity的 dispatchTouchEvent()方法，所以我们可以重写这个方法来阻止事件继续传递。" />
          <outline text="如果 onInterceptTouchEvent() 返回true，&lt;b&gt;ViewGroup &lt;/b&gt;就会拦截touch事件，由自己的dispatchTouchEvent()  继续分发. " />
          <outline text="&lt;b&gt;ViewGroup.dispatchTouchEvent() 详解:&lt;/b&gt;">
            <outline text="TouchTarget链表保存了处理了初始触摸事件的子View，注意只有一系列触摸动作的初始事件（Down事件）才会找到对应的子View并生成TouchTarget的一个节点。后面的系列事件都会分发给TouchTarget链表中保存的子View，这也就意味着，如果一个子View没有处理初始的Down事件，那么它也就不会再接收到后面的move up等事件。" />
            <outline text="如果onInterceptTouchEvent()返回true，当前ViewGroup拦截了该事件，那么该事件不会再向下面分发，并且会向TouchTarget中保存的所有子View发送cancel事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会移除分发记录，意味着后面的事件也不再会分发到子View。" />
            <outline text="如果是辅助功能的事件，那么会优先分发给支持辅助功能的View，如果不存在这样的view，则进行一般的事件分发。" />
            <outline text="1. 判断是否被拦截" />
            <outline text="2. 如果未被拦截且为初始事件，找到可以处理事件的子View（在点击范围内且可被点击），分发事件后如果该子View处理了事件（dispatchTouchEvent()方法返回true）则存入TouchTarget链表并停止子View的遍历（后面的子View就没有机会再收到事件），如果该子View没有处理该事件，则继续遍历寻找" />
            <outline text="3. 如果事件被拦截，向TouchTarget中的子View发送cancel事件" />
            <outline text="4. 将未被2、3情况处理的事件分发给TouchTarget中的子View，如果TouchTarget为空，则交给ViewGroup本身父View的dispatchTouchEvent()方法处理. " />
          </outline>
          <outline text="当一个触摸事件分发到一个非ViewGroup的View或者ViewGroup不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么View类的dispatchTouchEvent()将会被调用." />
          <outline text="&lt;b&gt;View.dispatchTouchEvent() 详解:&lt;/b&gt;">
            <outline text="主要是先检查是否注册了onTouchListener，如果注册了监听并且调用返回了true消耗了该事件，那么说明该View处理了该事件，也会收到后续的事件，" />
            <outline text="如果没有注册监听或者没有消耗，就调用View本身的 onTouchEvent()，如果返回true则消耗事件。" />
          </outline>
          <outline text="View&lt;b&gt;.&lt;/b&gt;onTouchEvent(), 按事件类型(up, down, move, cancel) 分别处理. 判断是否触发单击、长按、长按等, 并提供了默认的按下、点击、长按的视觉反馈。" />
          <outline text="应用层事件封装成 MotionEvent。">
            <outline text="mAction的低8位（也就是0-7位）是动作类型信息。" />
            <outline text="mAction的8-15位，是触控点的索引信息。（即表示是哪一个触控点的事件）。" />
            <outline text="MotionEvent有两个方法，一个是getAction(),另一个是getActionMasked(), 二个方法就是通过掩码的方式隐去触控点的索引信息。" />
          </outline>
        </outline>
        <outline text="java 层消息机制">
          <outline text="Java层的Looper是为了处理的消息队列中的消息." />
        </outline>
        <outline text="native 层消息机制">
          <outline text="Native中的Looper是为了处理注册的自定义Fd引起的Request 消息，这些消息一般来自于系统底层如触摸事件等." />
        </outline>
        <outline text="&lt;b&gt;事件通知机制: epoll (kernel)&lt;/b&gt;">
          <outline text="&lt;a href=&quot;https://www.viseator.com/categories/Android/Event/&quot;&gt;https://www.viseator.com/categories/Android/Event/&lt;/a&gt;  --相当不错" />
          <outline text="Android系统本质上是一个事件驱动的系统. 消息机制在android系统中占据核心位置. " />
          <outline text="这里说的消息机制, 分为3个层面:">
            <outline text="IO设备管理方面, 通过native层消息机制完成数据传输的同步控制. 比如Input;" />
            <outline text="消息队列, Looper, 通过java层消息机制完成跨线程通讯." />
            <outline text="Binder机制也是通过java层消息机制完成的." />
          </outline>
          <outline text="android的消息机制分为native与java两个部分.">
            <outline text="java层消息机制, 是通过native层消息机制实现的." />
            <outline text="连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理." />
            <outline text="native层消息机制中, 最关键的超时与唤醒机制, 是通过kernel层epoll机制实现." />
          </outline>
          <outline text="Epoll属于哪个领域的概念?">
            <outline text="Epoll机制属于事件通知机制, 而事件通知机制看起来属于跨进程通讯的范畴, 但是它实际上属于设备管理的范畴." />
            <outline text="事件通知机制本质上要处理CPU和设备之间的不同步问题. 简言之, 就是CPU通知设备做点事, 设备不一定能马上处理完并返回的问题. " />
          </outline>
          <outline text="这里说的&quot;事件&quot;的含义是什么?">
            <outline text="所谓&quot;事件&quot;, 就其本质而言, 产生于设备的内核缓冲区, 当然最终是设备硬件中断产生的. " />
            <outline text="事件和硬件中断不是一一对应的. 以网卡为例:">
              <outline text="当数据量很少的时候，每来一个数据包网卡都回产生一个中断，os响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。" />
              <outline text="当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。" />
              <outline text="当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到&lt;b&gt;轮询&lt;/b&gt;处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。" />
            </outline>
            <outline text="事件包括4种:">
              <outline text="内核读缓冲器非空.  (读方关注)">
                <outline text="沿触发: 有人写入" />
                <outline text="状态触发: 事件未处理完.  (常用)" />
              </outline>
              <outline text="内核读缓冲区空. (读方关注)">
                <outline text="沿触发: 刚空. (常用)" />
                <outline text="状态触发: 空." />
              </outline>
              <outline text="写缓冲区满.  (写方关注)">
                <outline text="沿触发: 刚满" />
                <outline text="状态触发: 满" />
              </outline>
              <outline text="写缓冲区非满. (写方关注)">
                <outline text="沿触发: 刚非满" />
                <outline text="状态触发: 非满" />
              </outline>
            </outline>
          </outline>
          <outline text="事件通知机制有三种: 阻塞, 轮询, IO 多路复用.">
            <outline text="阻塞指读取数据时, 数据没有准备好, 读进程会停止运行, 等数据准备好再被系统唤醒. ">
              <outline text="阻塞是一种同步机制." />
              <outline text="缺点是一个线程只能处理一路IO. 原因是如果同时处理两路, 一路阻塞了, 另外一路就得不到处理了. " />
            </outline>
            <outline text="轮询指轮流查询各路IO的状态. ">
              <outline text="缺点是浪费CPU时间." />
            </outline>
            <outline text="IO多路复用机制是, 数据没有准备好, 也会阻塞, 但是系统会设置一个IO&lt;b&gt;代理&lt;/b&gt;, 当若干路IO就绪时, 由代理唤醒线程, 并告诉它是哪路IO就绪, 从而提升处理效率.">
              <outline text="IO多路复用机制相当于阻塞机制的改进." />
              <outline text="epoll即 I/O多路复用机制的实现." />
            </outline>
          </outline>
          <outline text="epoll背景知识">
            <outline text="epoll机制于Linux 2.5.44首度登场." />
            <outline text="设计目的旨在取代既有POSIX select(2)与poll(2)系统函数." />
            <outline text="优势是处理多路IO事件时, 性能提升非常多. 旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n). (很多材料说是 O(1), 这是错误的)." />
            <outline text="性能提升的原因是它能够只关注有数据的FD(文件描述符), 而不是所有FD都轮询一遍." />
          </outline>
          <outline text="epoll 通过使用红黑树(RB-tree)搜索被监视的文件描述符(file descriptor, FD)。" />
          <outline text="在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。" />
          <outline text="程序接口">
            <outline text="接口实现在 /bionic/libc/bionic/sys_epoll.cpp" />
            <outline text="int epoll_create(int size);  // 在内核中创建epoll实例并返回一个epoll文件描述符。" />
            <outline text="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  // 添加、修改或删除对 fd 上事件 event 的监听。">
              <outline text="op 可以为 EPOLL_CTL_ADD, 添加新的事件" />
              <outline text="EPOLL_CTL_MOD, 修改文件描述符上监听的事件类型. 类型包括沿触发和状态触发. " />
              <outline text="EPOLL_CTL_DEL, 从实例上删除一个事件" />
            </outline>
            <outline text="int &lt;b&gt;epoll_wait&lt;/b&gt;(int epfd, struct epoll_event *events, int maxevents, int timeout);   // 监听并阻塞, 等待唤醒">
              <outline text="当 timeout 为 0 时，epoll_wait 永远会立即返回。" />
              <outline text="而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。" />
              <outline text="当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。" />
            </outline>
          </outline>
          <outline text="唤醒">
            <outline text="应用程序调用 &lt;b&gt;epoll_wait() 启动监听, 并阻塞自身后, 需要等待另一个进程唤醒.&lt;/b&gt;" />
            <outline text="唤醒的机制是通过对event FD写入一个数据(一般是1, 显然在这个上下文下写入的内容无关紧要), epoll会监听这个FD, 发现有新数据了, 就把上面监听的进程逐一放入系统的就绪队列, 逐一处理." />
          </outline>
          <outline text="沿触发和状态触发">
            <outline text="沿触发时，epoll_wait() 仅会在新的事件首次被加入epoll队列时返回." />
            <outline text="状态触发时, epoll_wait在事件状态未变更前将不断被触发。" />
            <outline text="状态触发模式是默认的模式。" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;同步, 异步, 阻塞, 非阻塞, 轮询, 事件之间的关系  @me&lt;/b&gt;">
          <outline text="这几个概念之所以很混乱, 是因为汉语中把同步调用和跨线程的同步控制, 这两个几乎无关系的概念, 都缩写成&quot;同步&quot;这个词. 这导致了广泛的概念混淆." />
          <outline text="这几个概念不是并列的. 其关系如下:" />
          <outline text="同步调用">
            <outline text="同步就是同一个线程一直在跑, 函数调用返回的时候, 就拿到了调用结果. " />
            <outline text="但是, 如果调用涉及到IO操作, 即对硬件的处理. 由于一般情况下面 硬件的访问速度比CPU和内存慢若干个数量级, 所以就存在调用了不能马上得到调用结果的问题. ">
              <outline text="反推回去, 同步之所以行得通, 仅仅因为CPU和内存的速度处在同一个数量级上的(当然, 这个话也不准确, 为了解决这个问题, 有无数的解决方案, 这个领域属于芯片设计, 不提), 由于它们的速度处在同一个数量级, 所以当我们的代码仅仅是读一个数, 做个计算, 再写一个数的时候, 所有这些事情都可以同步完成. " />
            </outline>
            <outline text="面对这种不同步, &lt;b&gt;轮询&lt;/b&gt;是最直接的解决办法. 轮询算同步.">
              <outline text="轮询指调用一个函数, 如果不能马上得到结果, 就反复调用它, 直到得到结果为止. ">
                <outline text="一般情况下, 轮询是消费CPU资源的, 而且会引起界面卡顿等问题. " />
                <outline text="当然也有特殊情况, 此时轮询效率更高." />
              </outline>
            </outline>
          </outline>
          <outline text="异步">
            <outline text="异步是轮询的一种改进, 改进的目的是节省CPU资源." />
            <outline text="异步的特点是, 调用结束时拿不到调用结果, 继续执行别的代码. 然后发生线程切换, 在另外一个线程中执行被调方代码并返回结果. 调用和拿到调用结果, 不是在同一个函数中, 一般也不在同一个线程中." />
            <outline text="异步的常见方式是: 调用的同时注册回调函数, 然后在没有执行结果的情况下直接返回, 接着往下执行. 回调函数则会在被调者执行完之后被调用." />
            <outline text="异步, 实际上是把调用逻辑分为4部分: 调用者前半部, 被调者前半部, 被调者后半部, 调用者后半部(也就是回调函数). " />
            <outline text="&lt;b&gt;调用者前半部&lt;/b&gt; 调用 &lt;b&gt;被调者前半部&lt;/b&gt;, &lt;b&gt;被调者前半部&lt;/b&gt; 想办法调用 &lt;b&gt;被调者后半部&lt;/b&gt;(这里存在跨线程通讯), 这个过程发生在调用者线程中. 然后发生线程切换, 去执行 &lt;b&gt;被调者后半部&lt;/b&gt;, 等它执行完了, 再调用 &lt;b&gt;调用者后半部&lt;/b&gt;(再强调一遍, 也就是回调函数), 这个过程发生在被调者线程中. " />
            <outline text="我之所以说异步是一种特殊的同步实现方法, 是因为调用者前半部 调用 被调者前半部, 是同步调用, 马上得到结果; 被调者后半部, 调用 调用者后半部, 也是同步调用, 马上得到结果. 至于被调者前半部 调用 被调者后半部的机制, 这往往是框架或平台在处理, 对使用者不可见. " />
            <outline text="对初学者而言, 理解异步最困难的是理解回调函数. " />
            <outline text="但是对于有经验的人来说, 回调函数仅仅是把处理的后半部分单独出来, 稍微有些绕而已, 并不难理解. 真正复杂的问题是, 被调者前半部, 怎么去调用 被调者后半部." />
            <outline text="首先要理解的是, 被调者前半部 和 被调者后半部 处在不同的线程中(调用者前半部, 和回调函数也在不同的线程中).  也就是说, 这是一个跨线程的调用. 因此请参见: &quot;跨线程的同步机制&quot;." />
          </outline>
          <outline text="阻塞">
            <outline text="阻塞, 就是调用一个函数半途中发生线程切换, 等拿到调用结果时, 再把线程切换回来继续执行." />
            <outline text="其突出特点是虽然线程切换了, 但是函数没有换, 还是在原来函数中. " />
            <outline text="从某种意义上讲, 阻塞是操作系统(或者虚拟机)帮忙, 以同步的形式, 完成异步的实质. 毕竟, 同步调用, 代码的执行顺序和编写顺序是一致的, 好理解多了." />
          </outline>
          <outline text="非阻塞, 就是异步. 不用阻塞, 又在IO操作中, 只能是异步. " />
          <outline text="epoll: epoll是同步机制, 它支持阻塞, 也可以支持非阻塞. 区别在于入参. epoll_wait() 的" />
          <outline text="跨线程的同步机制">
            <outline text="异步和阻塞, 都涉及到同一个处理逻辑(从业务视角出发), 分解到不同的线程的问题. 因此, 这几个线程之间必须要有同步机制, 才能把业务逻辑处理好. " />
            <outline text="同步机制是消息队列. " />
          </outline>
          <outline text="还有一种分类方式, 就是把阻塞作为一种特殊的同步调用方式. 其理由是, 同步调用就是这个函数执行完了, 就拿到执行结果了. 阻塞没出函数拿到结果, 所以算同步机制. ">
            <outline text="这个仅仅是一个定义的问题. 这么算也可以. 但是阻塞出现了当前线程挂起, 失去CPU, 以及多个线程间的同步控制, 这种算同步就掩盖了很多技术细节." />
          </outline>
          <outline text="同步阻塞的IO会使线程挂起，同步非阻塞(即轮询)的IO会消耗CPU资源在轮询上。" />
          <outline text="IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）." />
          <outline text="直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。" />
        </outline>
        <outline text="&lt;b&gt;Input问题分类&lt;/b&gt;">
          <outline text="器件和驱动问题">
            <outline text="通过查看器件上报的数据确认">
              <outline text="getevent -l" />
              <outline text="前提：研发现场可复现。" />
            </outline>
            <outline text="通过adb模拟事件，如果模拟的事件没问题，则可反向确认是bsp异常。">
              <outline text="前提：研发现场可复现。" />
            </outline>
            <outline text="通过查看 inputReader LOG打印确认上报的数据有没有问题。" />
          </outline>
          <outline text="Fwk policy错误">
            <outline text="input policy主要是在pwm 中对一些按键和手势的拦截处理。涉及这方面要多考虑这块。" />
            <outline text="主要逻辑在 interceptKeyBeforeQueueing() 和 interceptKeyBeforeDispatching()。" />
          </outline>
          <outline text="事件分开过程中出现错误">
            <outline text="事件有没有分发到inputdispatcher。" />
          </outline>
          <outline text="Input性能问题">
            <outline text="一次事件上报过程分为4个环节： 硬件 - kernel - system server - app" />
            <outline text="4个环节可划分5个时间点：">
              <outline text="t1： 硬件中断时间。">
                <outline text="这个可忽略不计。" />
              </outline>
              <outline text="t2： inputReader 从设备节点读出事件的时间">
                <outline text="事件时间戳在这里打上，所以看时间时间戳即可。" />
              </outline>
              <outline text="t3： inputDispatcher 向app进程发送时间的时间">
                <outline text="InputPublisher::publishMeyEvent(). 这里真正发消息了。" />
              </outline>
              <outline text="t4： app开始事件处理的时间">
                <outline text="app通过 InputEventReceiver 接受事件，在 dispatchInputEvent()" />
              </outline>
              <outline text="t5： app完成事件处理的时间">
                <outline text="InputEventReceiver的 finishInputEvent()" />
              </outline>
            </outline>
            <outline text="app处理耗时： t5 - t4" />
            <outline text="system server耗时： t3 - t2" />
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;21-Sensor&lt;/b&gt;">
        <outline text="Android平台支持三类传感器：">
          <outline text="Motion sensors（运动传感器）：测量加速力，以及沿三个轴的旋转力。">
            <outline text="运动传感器中有两个永远是基于硬件的，即加速度计和陀螺仪（accelerometer and gyroscope）。" />
            <outline text="运动传感器中有三个是既可以基于硬件又可以基于软件的，即重力感应器、线性加速度计、旋转向量传感器。" />
            <outline text="加速度传感器">
              <outline text="简称 G-sensor，返回x、y、z三轴的加速度数值。" />
              <outline text="该数值包含地心引力的影响，单位是m/s^2。" />
              <outline text="值域是：">
                <outline text="将手机平放在桌面上，x轴默认为0，y轴默认0，z轴默认9.81。 " />
                <outline text="将手机朝下放在桌面上，z轴为-9.81。 " />
                <outline text="将手机向左倾斜，x轴为正值。 " />
                <outline text="将手机向右倾斜，x轴为负值。 " />
                <outline text="将手机向上倾斜，y轴为负值。" />
                <outline text="将手机向下倾斜，y轴为正值。" />
              </outline>
              <outline text="驱动代码：kernel/drivers/input/accelerometer/gs_mma8452.c。" />
            </outline>
            <outline text="重力感应器">
              <outline text="简称 Gyro-sensor，返回x、y、z三轴的角速度数据。" />
              <outline text="角速度的单位是 radians/second。" />
              <outline text="值域是：">
                <outline text="水平逆时针旋转，Z轴为正。" />
                <outline text="水平逆时针旋转，z轴为负。" />
                <outline text="向左旋转，y轴为负。 " />
                <outline text="向右旋转，y轴为正。 " />
                <outline text="向上旋转，x轴为负。" />
                <outline text=" 向下旋转，x轴为正。" />
              </outline>
            </outline>
            <outline text="陀螺仪，gyroscope">
              <outline text="陀螺仪测量的是设备绕三个轴向的旋转速度，单位是rad/s。" />
              <outline text="所使用的坐标系统仍然和加速度计的一样。" />
              <outline text="旋转的值在逆时针方向为正，即，如果一个观察者从某个轴的正向某点向原点看，如果观察到的旋转是逆时针的，则是一个正值的旋转。这是一个关于旋转方向的标准的数学定义，注意，这个和方向传感器所用的定义不同。" />
            </outline>
            <outline text="Rotation Vector，旋转矢量传感器">
              <outline text="简称 RV-sensor。" />
              <outline text="旋转矢量代表设备的方向，是一个将坐标轴和角度混合计算得到的数据。" />
              <outline text="RV-sensor输出三个数据： xsin(theta/2) ysin(theta/2) z*sin(theta/2) sin(theta/2)是RV的数量级。" />
              <outline text="RV的方向与轴旋转的方向相同。 RV的三个数值，与cos(theta/2)组成一个四元组。 RV的数据没有单位，使用的坐标系与加速度相同。" />
            </outline>
            <outline text="Gravity，重力传感器">
              <outline text="简称 GV-sensor，输出重力数据。" />
              <outline text="在地球上，重力数值为9.8，单位是m/s^2。 坐标系统与加速度传感器相同。 当设备复位时，重力传感器的输出与加速度传感器相同。" />
            </outline>
            <outline text="Linear Acceleration，线性加速度传感器">
              <outline text="简称 LA-sensor。" />
              <outline text="线性加速度传感器是加速度传感器减去重力影响获取的数据。 单位是m/s^2，坐标系统与加速度传感器相同。" />
              <outline text="加速度传感器、重力传感器和线性加速度传感器的计算公式如下： 加速度 = 重力 + 线性加速度。" />
            </outline>
          </outline>
          <outline text="Environmental sensors （环境传感器）：测量各种环境参数，例如环境空气温度和压力，照明和湿度。包括：">
            <outline text="Ambient Light Sensor，环境光传感器">
              <outline text="检测实时的光线强度，光强单位是lux(勒克司度)，其物理意义是照射到单位面积上的光通量。" />
              <outline text="光线感应传感器主要用于LCD自动亮度功能，根据采样到的光强数值实时调整LCD的亮度。" />
            </outline>
            <outline text="Proximity Sensor，接近光传感器">
              <outline text="接近传感器，检测物体与手机的距离，单位是cm(厘米)。" />
              <outline text="一些接近传感器只能返回远和近两个状态， 因此，接近传感器将最大距离返回远状态，小于最大距离返回近状态。" />
              <outline text="接近传感器可用于接听电话时自动关闭LCD屏幕以节省电量。" />
              <outline text="一些芯片集成了接近传感器和环境光传感器两者功能。" />
            </outline>
            <outline text="Barometer Sensor，气压计">
              <outline text="返回当前的压强，单位是百帕斯卡hectopascal（hPa）。" />
            </outline>
            <outline text="Temperature Sensor，温度计">
              <outline text="返回当前的温度。" />
            </outline>
          </outline>
          <outline text="Position sensors （位置传感器）：测量设备的物理位置。包括：">
            <outline text="方向传感器">
              <outline text="简称 O-sensor，返回三轴的角度数据，方向数据的单位是角度。" />
              <outline text="为了得到精确的角度数据，E-compass(电子罗盘传感器)需要获取G-sensor(加速度传感器)的数据， 经过计算生产O-sensor数据，否则只能获取水平方向的角度。" />
              <outline text="方向传感器提供三个数据，分别为azimuth、pitch和roll。">
                <outline text="azimuth：方位，返回水平时磁北极和Y轴的夹角，范围为0°至360°。 0°=北，90°=东，180°=南，270°=西。" />
                <outline text="pitch：x轴和水平面的夹角，范围为-180°至180°。 当z轴向y轴转动时，角度为正值。" />
                <outline text="roll：y轴和水平面的夹角，由于历史原因，范围为-90°至90°。 当x轴向z轴移动时，角度为正值。" />
              </outline>
              <outline text="电子罗盘在获取正确的数据前需要进行校准，通常可用8字校准法。 ">
                <outline text="8字校准法要求用户使用需要校准的设备在空中做8字晃动， 原则上尽量多的让设备法线方向指向空间的所有8个象限。" />
              </outline>
            </outline>
            <outline text="磁力计">
              <outline text="简称为 M-sensor，返回x、y、z三轴的环境磁场数据。" />
              <outline text="该数值的单位是微特斯拉（micro-Tesla），用uT表示。 单位也可以是高斯（Gauss），1Tesla=10000Gauss。 " />
              <outline text="硬件上一般没有独立的磁力传感器，磁力数据由电子罗盘传感器提供（E-compass）。" />
              <outline text="电子罗盘传感器同时提供下文的方向传感器数据。" />
            </outline>
          </outline>
        </outline>
        <outline text="SensorHub">
          <outline text="Android手机通常用到的计步器、陀螺仪、磁力计等传感器，通常都需要低功耗运行，比如在手机灭屏的状态下，仍然能不休眠地继续工作，这得益于SensorHub." />
          <outline text="通过将传感器挂在主CPU外部的一个小低功耗CPU上，并在这个低功耗CPU上运行RTOS，可以实现待机状态下仍持续不停地获取传感器信息." />
          <outline text="Android有HAL层、设计上独立MCU做SensorHub是趋势，适合写Userspace Driver，甚至TP都可以接到Hub上，Hub和MPU串口连，用户层跑daemon与hub通讯，内核打开uio框架和uinput，背光、RTC、各种Sensor，都可搞定，比在内核里上窜下跳的改代码反复编译调试强。" />
          <outline text="至少目前不是你说的那样，现在的SENSORHUB也是通过HAL接入的，而且基本上看到的sensor  hub都比传统的结构更复杂，省电和功能强大是一方面，复杂是另外一面，另外SENSORHUB的软件供应商而且目前不开放源码，这个结果你是知道的。未来，中低端机SENSORHUB会好搞一些，因为基带都会集成，高端机在外面。" />
        </outline>
        <outline text="IMU：惯性测量单元">
          <outline text="如何理解IMU以及其预积分 https://zhuanlan.zhihu.com/p/38009126" />
          <outline text="测量物体三轴姿态角(或角速率)以及加速度的装置。" />
          <outline text="一般情况，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪。" />
          <outline text="加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。" />
        </outline>
        <outline text="应用层调用方法">
          <outline text="1. 获取SensorManager对象" />
          <outline text="2. 获取Sensor对象" />
          <outline text="3. 注册Sensor对象" />
          <outline text="4. 重写onAccuracyChanged，onSensorChanged这两个方法" />
          <outline text="5. 注销Sensor对象" />
          <outline text="例子：" />
          <outline text="public class SensorActivity extends Activity implements SensorEventListener {">
            <outline text="private SensorManager mSensorManager;" />
            <outline text="private Sensor mSensor;" />
            <outline text="public final void onCreate(Bundle savedInstanceState) {">
              <outline text="super.onCreate(savedInstanceState);">
                <outline text="setContentView(R.layout.main);" />
                <outline text="// 第一步：通过getSystemService获得SensorManager实例对象" />
                <outline text="&lt;b&gt;mSensorManager &lt;/b&gt;= (SensorManager) getSystemService(Context.SENSOR_SERVICE);" />
                <outline text="// 第二步：通过SensorManager实例对象获得想要的传感器对象: 参数决定获取哪个传感器" />
                <outline text="mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);" />
                <outline text="if (mSensor  != null) { ">
                  <outline text="// 系统支持该sensor，继续" />
                </outline>
                <outline text="} else {">
                  <outline text="// 系统不支持该sensor，或者处在不可用状态。进行错误处理。" />
                </outline>
                <outline text="}" />
              </outline>
            </outline>
            <outline text="}" />
            <outline text="// 第四步：必须重写的两个方法：onAccuracyChanged，onSensorChanged" />
            <outline text="/** 传感器精度发生改变的回调接口 */" />
            <outline text="public final void onAccuracyChanged(Sensor sensor, int accuracy) {">
              <outline text="// TODO 在传感器精度发生改变时做些操作，accuracy为当前传感器精度" />
            </outline>
            <outline text="}" />
            <outline text="/** 传感器事件值改变时的回调接口：执行此方法的频率与注册传感器时的频率有关 */" />
            <outline text="public final void onSensorChanged(SensorEvent event) {">
              <outline text="// 大部分传感器会返回三个轴方向x,y,x的event值，值的意义因传感器而异" />
              <outline text="float x = event.values[0];" />
              <outline text="float y = event.values[1];" />
              <outline text="float z = event.values[2];" />
              <outline text="// TODO 利用获得的三个float传感器值做些操作" />
            </outline>
            <outline text="}" />
            <outline text="/** 第三步：在获得焦点时注册传感器并让本类实现SensorEventListener接口 */" />
            <outline text="protected void onResume() {">
              <outline text="super.onResume();" />
              <outline text="/**第一个参数：SensorEventListener接口的实例对象" />
              <outline text="*第二个参数：需要注册的传感器实例" />
              <outline text="*第三个参数：传感器获取传感器事件event值频率：">
                <outline text="SensorManager.SENSOR_DELAY_FASTEST = 0：对应0微秒的更新间隔，最快，1微秒 = 1 % 1000000秒" />
                <outline text="SensorManager.SENSOR_DELAY_GAME = 1：对应20000微秒的更新间隔，游戏中常用" />
                <outline text="SensorManager.SENSOR_DELAY_UI = 2：对应60000微秒的更新间隔" />
                <outline text="SensorManager.SENSOR_DELAY_NORMAL = 3：对应200000微秒的更新间隔" />
                <outline text="键入自定义的int值x时：对应x微秒的更新间隔" />
              </outline>
              <outline text="*/ " />
              <outline text="mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);" />
            </outline>
            <outline text="}" />
            <outline text="/** 第五步：在失去焦点时注销传感器 */" />
            <outline text="protected void onPause() {">
              <outline text="super.onPause();" />
              <outline text="mSensorManager.unregisterListener(this);" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="}" />
          <outline text="通过 List&amp;lt;Sensor&amp;gt; deviceSensors = mSensorManager.getSensorList(Sensor.TYPE_ALL); 可列举系统支持的所有sensor。" />
        </outline>
        <outline text="FWK层">
          <outline text="java-Client">
            <outline text="即Android Sensor SDK。" />
            <outline text="SensorManager：封装了 Sensor 相关的 API ，提供给 Application 使用。" />
            <outline text="frameworks/base/core/java/android/hardware/SensorManager.java" />
          </outline>
          <outline text="java-Server">
            <outline text="SystemSensorManager：该类主要实现 SensorManager 控制和数据获取的逻辑。" />
            <outline text="frameworks/base/core/java/android/hardware/SystemSensorManager.java" />
          </outline>
          <outline text="jni">
            <outline text="该文件负责 jave 层和 native 层通信的 JNI 实现，上层的 Java 代码通过 JNI 调用 Native 层提供的服务。" />
            <outline text="android_hardware_SensorManager.cpp" />
          </outline>
          <outline text="native-client">
            <outline text="Sensor 在 Native 层的客户端，负责与服务端 SensorService.cpp 的通信。" />
            <outline text="frameworks/native/libs/gui/SensorManager.cpp" />
          </outline>
          <outline text="native-server">
            <outline text="SensorService.cpp，是 Android Sensor Framework 最核心的模块，它实现了主要的 Sensor控制流和数据流逻辑，完成 Sensor 参数配置，数据分发，Client 请求处理等功能。 frameworks/native/services/sensorservice/SensorService.cpp" />
            <outline text="BnSensorServer，提供类 Sensor 信息获取以及 SensorEventConnection 创建的功能。frameworks/native/include/gui/ISensorServer.h" />
            <outline text="SensorEventConnection，是 Sensor 数据的传输通道，当 Client 开始监听某一个 Sensor 是，一个对应的 SensorEventConnection 将会被创建，Server 端在接收到 Sensor 数据后，通过写入到 SensorEventConnection 传递给 Client 端。 frameworks/native/libs/gui/ISensorEventConnection.cpp" />
            <outline text="SensorDevice，管理和维护系统中的所有 Sensor，封装了 Sensor 的使能、配置、数据读取等功能。 frameworks/native/services/sensorservice/SensorDevice.cpp" />
          </outline>
        </outline>
        <outline text="HAL层">
          <outline text="SensorList，定义了 HAL 层提供的 Sensor，提供 Sensor 类型、供应商、功耗等信息。同时，HAL 层需要实现获取 SensorList 的回调接口。" />
          <outline text="sensors_module_t，HAL 层需要定义一个 sensors_module_t，供系统在启动时加载 Sensor HAL 动态库。sensors_module_t 向上层注册获取 SensorList 和获取 Sensor 控制接口的相关回调函数。" />
          <outline text="HAL 层还需要提供实际控制和获取 Sensor 数据的接口，SensorService 中对 Sensor 的控制和数据的获取最终会调用到这些接口。" />
        </outline>
      </outline>
      <outline text="&lt;b&gt;22-FWK-AMS&lt;/b&gt;">
        <outline text="frameworks\base\core\java\android\app" />
        <outline text="frameworks\base\services\java\com\android\server\am" />
        <outline text="frameworks\base\services\java\com\android\server\wm" />
        <outline text="四大组件都由AMS统一管理生命周期. " />
        <outline text="应用启动流程  #面试题">
          <outline text="先创建Application;" />
          <outline text="启动应用启动的主Activity;" />
          <outline text="执行该Activity的onCreate()，onStart()，onResume()方法;" />
          <outline text="在onResume()中,  向WMS添加注册的应用主窗口。" />
          <outline text="显示主窗口." />
          <outline text="如果在 onCreate()，onStart()，onResume() 中做了耗时操作, 则应用启动会出现暂时的黑屏相信." />
        </outline>
        <outline text="&lt;b&gt;Activity启动流程 #面试题&lt;/b&gt;">
          <outline text="无论是Launcher(Launcher也是应用)启动一个activity, 还是应用内部启动一个activity, 第一步都是应用线程调用 startActivity(), 该函数通过Binder调用ams的 startActivity()." />
          <outline text="ams 调用&lt;b&gt;Zygote的fork(), 复制创建一个虚拟机进程. 然后在进程上创建 ActivityThread. 相关代码在 &lt;/b&gt;scheduleLaunchActivity() 中." />
          <outline text="&lt;b&gt;ActivityThread 负责创建对应的Activity对象, &lt;/b&gt;使用ClassLoader从程序文件中装载指定的Activity对应的Class文件, &lt;b&gt;加载布局和资源.  &lt;/b&gt;" />
          <outline text="最后会调用 attach方法，然后在 PolicyManager实现一个IPolicy接口，接着实现一个 Policy对象。" />
          <outline text="接着调用 makeNewWindow(Context)方法，该方法会返回一个 PhoneWindow对象，而 PhoneWindow 是Window的子类。" />
          <outline text="在这个 PhoneWindow 持有一个DecorView的内部类，是所有应用窗口的根 View， 直接控制 Activity是否显示。" />
          <outline text="DecorView里面有一个 LinearLayout。" />
          <outline text="LinearLayout里面又有两个 FrameLayout, 他们分别拿来装 ActionBar(状态栏)和CustomView。" />
          <outline text="而我们在 setContentView() 加载的布局就放到这个 &lt;b&gt;CustomView &lt;/b&gt;中。" />
          <outline text="整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。" />
          <outline text="View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。" />
          <outline text="&lt;b&gt;在这个过程中, 会回调用户&lt;/b&gt;activity&lt;b&gt;的 onCreate(), onStart(), onResume(). &lt;/b&gt;" />
          <outline text="梳理过程如下: activity -&lt;b&gt;binder&lt;/b&gt;- AMS -&lt;b&gt;biner&lt;/b&gt;- ActivityThread - PhoneWindow - DecorView - ActionBar+CustomView - View." />
          <outline text="执行完onResume()完之后，并且界面没有更新，应用UI主线程的looper会进入MessageQueue.nativePollOnce()。当有消息来临的时候，此looper便会被wake，执行消息。" />
        </outline>
        <outline text="管理activity生命周期">
          <outline text="创建过程中, Activity会先后调用&lt;b&gt;onCreate(), onStart(), onResume(). &lt;/b&gt;" />
          <outline text="销毁过程中, 会先后调用 onPause() 和 onStop+onDestroy方法. 其中,调用完onPause()方法后不能立即调用onStop()方法，因为这个时候我们需要先调用前一个页面的&lt;b&gt;onResume&lt;/b&gt;()方法, 所以我们需要先切回到AMS进程去处理。" />
        </outline>
        <outline text="&lt;b&gt;任务栈: 对Activity进行管理  #面试题&lt;/b&gt;">
          <outline text="APP一般是由多个Activity构成的。Android用 Task(任务)的概念将多个相关的Activity放在&lt;b&gt; Back Stack（回退堆栈）&lt;/b&gt;中管理，以便进行Activity间的跳转与返回." />
          <outline text="注意，是相关的Activity，而不是同一个app的activity。有时候，同一个app的activity在不同的task （参见 taskAffinity ）；有时候，不同app的activity在同一个task。" />
          <outline text="&lt;b&gt;任务栈, 也叫task 栈, 或者 back栈&lt;/b&gt;">
            <outline text="是一种用来放置Activity实例的容器，以栈的形式进行盛放Activity实例，也就是所谓的先进后出(LIFO)." />
            <outline text="处于最顶部的叫栈顶，最底部叫栈底." />
            <outline text="常用操作: 入栈(&lt;b&gt;push&lt;/b&gt;)，出栈(&lt;b&gt;pop&lt;/b&gt;)。" />
          </outline>
          <outline text="&lt;b&gt;栈内切换&lt;/b&gt;">
            <outline text="当用户在主屏幕点击图标打开一个新的App，此时会创建一个&lt;b&gt;新的Task&lt;/b&gt;. 然后开始把新产生的Activity入栈, 作为栈顶. " />
            <outline text="当切换到新的Activity，那么该Activity会被压入栈中，成为新的栈顶。" />
            <outline text="而当用户点击Back键，栈顶的Activity出栈，紧随其后的Activity来到栈顶。" />
            <outline text="有一种特殊情况, 当我们在通讯录的APP中打开了短信APP的页面，但是此时不会新建一个栈，而是继续添加到栈1中。" />
            <outline text="这是 Android推崇一种用户体验方式，即不同应用程序之间的切换能使用户感觉就像是同一个应用程序，连贯的用户体验，官方称其为seamless (无缝衔接）." />
          </outline>
          <outline text="&lt;b&gt;栈间切换&lt;/b&gt;">
            <outline text="同一时间系统会有多个task. 这些task 也组成一个 task堆栈. " />
            <outline text="用户按下Home键回到桌面，再启动另一个应用，这时候&lt;b&gt;Task1&lt;/b&gt;就被移到后台，成为&lt;b&gt;后台任务栈&lt;/b&gt;，而刚启动的那个&lt;b&gt;Task2&lt;/b&gt;就被调到前台，成为&lt;b&gt;前台任务栈&lt;/b&gt;. " />
            <outline text="点击recent键，打开之前的程序，然后&lt;b&gt;Task1&lt;/b&gt;又回到前台了。" />
            <outline text="如果Task1是通讯录的APP中打开了短信APP的页面, 现在回到桌面, 当我们点击主屏幕上通信录的图标打开APP，此时也不会创建新的栈，而是Task1回到前台。" />
          </outline>
          <outline text="注意: 当调用到 onNewIntent(intent)的时候，需要使用 setIntent(intent)赋值给Activity的Intent. 否则后续的 getIntent()都是得到老的Intent。" />
        </outline>
        <outline text="AndroidManifest.xml 的activity相关的配置项  #面试题">
          <outline text="taskAffinity 和 allowTaskReparenting">
            <outline text="默认情况下，一个应用程序中的所有activity使用同一个Affinity，这让它们属于同一个Task。" />
            <outline text="通过 taskAffinity可指定该activity使用独立的Task。" />
            <outline text="不同应用程序中的Activity可以共享同一个Affinity，同一个应用程序中的不同Activity 也可以设置成不同的Affinity。" />
            <outline text="Affinity属性在2种情况下起作用：" />
            <outline text="1）当启动 activity的Intent对象包含FLAG_ACTIVITY_NEW_TASK标记： 当传递给 startActivity()的Intent对象包含 FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的Activity寻找与当前Activity不同Task。">
              <outline text="如果要启动的 Activity的Affinity属性与当前所有的Task的Affinity属性都不相同，系统会新建一个带该Affinity属性的Task，并将要启动的Activity压到新建的Task栈中；" />
              <outline text="否则将Activity压入同一Affinity属性的栈中。" />
            </outline>
            <outline text="2）如果一个activity的 allowTaskReparenting属性为true， 那么它可以从一个Task（Task1）移到另外一个有相同Affinity的Task（Task2）中（Task2带到前台时）。">
              <outline text="如果一个APP从用户角度来看包含了多个&quot;应用程序&quot;，就可能需要对那些 Activity赋不同的Affinity值。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;launchMode  #面试题&lt;/b&gt;">
            <outline text="activity启动模式, 常用且关键. 值域如下:" />
            <outline text="standard(默认): 在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。">
              <outline text="如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，会在A的上面再次启动一个A的实例，即当前的桟中的状态为A--&amp;gt;A。" />
            </outline>
            <outline text="singleTop: 如果一个以singleTop模式启动的Activity的实例已经存在于当前任务栈的栈顶， 那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例， 并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。">
              <outline text="如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中， 那么再启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。 这时任务栈中还是这有一个A的实例。" />
              <outline text="如果以singleTop模式启动的activity的一个实例已经存在与任务栈中，&lt;b&gt;但是不在栈顶&lt;/b&gt;，那么它的行为和standard模式相同，也会创建多个实例。" />
            </outline>
            <outline text="singleTask: 创建一个新的实例时, 如果该实例在当前栈中已经存在，则不管它在不在栈顶, 直接将它移动到顶部，并且清空任务栈中这个activity上面所有的activity。">
              <outline text="intent将被通过onNewIntent()发送." />
              <outline text="singleTask相当于singleTop的彻底版." />
            </outline>
            <outline text="singleInstance: 单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。比如来电界面.">
              <outline text="当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。" />
            </outline>
          </outline>
          <outline text="clearTaskOnLaunch: 清空栈">
            <outline text="默认情况下, 当用户长时间离开Task（当前task被转移到后台）时，系统会清除task中栈底Activity外的所有Activity 。这样，当用户返回到Task时，只留下那个task最初始的Activity了。" />
            <outline text="可通过修改 clearTaskOnLaunch 来改变这种行为. 其值域是: " />
            <outline text="alwaysRetainTaskState: 如果栈底Activity的这个属性被设置为true，上述的情况就不会发生。 Task中的所有activity将被长时间保存。" />
            <outline text="clearTaskOnLaunch: 如果栈底activity的这个属性被设置为true，一旦用户离开Task， 则 Task栈中的Activity将被清空到只剩下栈底activity。这种情况刚好与 alwaysRetainTaskState相反。即使用户只是短暂地离开，task也会返回到初始状态 （只剩下栈底acitivty）。" />
            <outline text="finishOnTaskLaunch: 与clearTaskOnLaunch相似，但它只对单独的activity操 作，而不是整个Task。它可以结束任何Activity，包括栈底的Activity。 当它设置为true时，当前的Activity只在当前会话期间作为Task的一部分存在， 当用户退出Activity再返回时，它将不存在。" />
          </outline>
          <outline text="主要的Intent标志有：">
            <outline text="FLAG_ACTIVITY_NEW_TASK: 放入新的task堆栈. 见上." />
            <outline text="FLAG_ACTIVITY_CLEAR_TOP" />
            <outline text="FLAG_ACTIVITY_SINGLE_TOP" />
          </outline>
        </outline>
        <outline text="管理Service生命周期">
          <outline text="Service是否是独立进程?">
            <outline text="如果Service没有设定属性android:process=”:remote”, Service会和Activity是在同一个进程中的，即主线程." />
            <outline text="如果Service设定属性android:process=”:remote”, 那么就会创建新进程." />
          </outline>
          <outline text="Service的启动方式有两种：" />
          <outline text="startService">
            <outline text="ContextWrapper类中的startService(), 调用了ContextImpl的startService()。" />
            <outline text="在startServiceCommon()中通过binder，调用了AMS服务的startService()。" />
            <outline text="ActiveService.startServiceLocked()" />
            <outline text="在AMS服务中，每个Service都使用一个ServiceRecord对象来描述，然后调用retrieveServiceLocked方法来查找一个和目标Service对应的ServiceRecord，最后将这个ServiceRecord对象封装在ServiceLookupResult对象中。" />
            <outline text="查找方案是首先从AMS服务中的ServiceMap中查找，ServiceMap中保存了AMS服务中所有激活的Service信息，如果在ServiceMap中没有找到，说明该Service还没有启动。那么就需要从PMS服务中查找目标Service的信息并创建一个ServiceRecord对象。最后把它保存在对应的ServiceMap集合中。" />
            <outline text="ActiveService. bringUpServiceLocked()" />
            <outline text="ActiveService.realStartServiceLocked()" />
            <outline text="ActivityThread.handleCreateService()" />
          </outline>
          <outline text="bindService" />
        </outline>
        <outline text="管理BroadcastReceiver生命周期，分发和接受Broadcast" />
        <outline text="管理ContentProvider生命周期">
          <outline text="&lt;a href=&quot;https://www.jianshu.com/p/c35313c52eef&quot;&gt;https://www.jianshu.com/p/c35313c52eef&lt;/a&gt;" />
          <outline text="ContentProvider 封装了数据的跨进程传输，我们可以直接使用 getContentResolver() 拿到 ContentResolver 进行增删改查即可。" />
        </outline>
        <outline text="处理应用程序的Crash" />
      </outline>
      <outline text="&lt;b&gt;23-FWK-WMS&lt;/b&gt;">
        <outline text="frameworks/base/services/java/com/android/server/wm/WindowManagerService.java" />
        <outline text="引入Window的目的是为了实现Activity和其上的视图View的解耦. 解耦之后, Activity只负责生命周期管理. " />
        <outline text="Activity, PhoneWindow, DecorView, titleBar, contentView 之间关系的示意图  @iChart " />
        <outline text="WMS功能">
          <outline text="1. 窗口的添加和删除" />
          <outline text="2. 窗口的显示和隐藏控制" />
          <outline text="3. Z-order顺序管理" />
          <outline text="4. 焦点窗口和焦点应用的管理" />
          <outline text="5. 输入法窗口管理和墙纸窗口管理" />
          <outline text="6. 窗口动画管理" />
          <outline text="7. 系统消息收集和分发" />
        </outline>
        <outline text="创建窗口的过程  #面试题 ">
          <outline text="创建Activity的过程中, 会调用 &lt;b&gt;addWindow&lt;/b&gt;() 来请求WMS添加窗口." />
          <outline text="Window的具体实现类是PhoneWindow. 在Activity初始化执行 attach 的时候，会创建一个PhoneWindow对象。然后给Window对象中的mWindowManager变量赋值。" />
          <outline text="PhoneWindow作为装载根视图DecorView的容器，Activity通过setContentView实际上是调用PhoneWindow来创建DecorView。" />
          <outline text="首先调用installDecor() 为Window类添加窗口装饰，其实就是标题栏." />
          <outline text="然后, 布局文件所定义的界面, 被包含在在窗口内容中。" />
          <outline text="把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后AMS经过一系列调用到 Activity的makeVisible()，该方法将真正完成把窗口添加进Wms中。" />
        </outline>
        <outline text="管理窗口 #面试题 " />
        <outline text="处理系统按键和触摸消息" />
        <outline text="管理窗口动画" />
      </outline>
      <outline text="&lt;b&gt;24-FWK-Other&lt;/b&gt;">
        <outline text="&lt;b&gt;PMS: 包管理&lt;/b&gt;">
          <outline text="APK组成结构">
            <outline text="APK: Android Package, 即安卓应用安装包. APK文件其实是zip格式，但后缀名被修改为apk，通过UnZip解压后，可以看到Dex文件." />
            <outline text="AAPT工具：(android asset packing tool)，安卓资源打包工具" />
            <outline text="APK文件其实是zip格式, 解压缩后是如下目录: ">
              <outline text="META-INF\（Jar文件中常可以看到）" />
              <outline text="res\（存放资源文件的目录）" />
              <outline text="AndroidManifest.xml（程序全局配置文件）">
                <outline text="app包名 + 组件声明 + 程序兼容的最低版本 + 所需权限等程序的配置文件. " />
                <outline text="一个apk一个." />
              </outline>
              <outline text="classes.dex（&lt;b&gt;dex文件，Dalvik字节码&lt;/b&gt;）" />
              <outline text="resources.arsc(编译后的二进制资源文件）" />
            </outline>
            <outline text="&lt;b&gt;其中最重要的是 dex文件，即Dalvik字节码&lt;/b&gt;">
              <outline text="android java代码编译为dex格式（Dalvik execute）文件。" />
              <outline text="dex格式是专为Dalvik设计的一种压缩格式。" />
              <outline text="Dex: DalvikVM executes的简称，即Android Dalvik执行程序, Dalvik字节码. " />
              <outline text="一个dex档通常会有多个.class。" />
              <outline text="dx 是一套工具，可以将 Java .class 转换成 .dex 格式. " />
              <outline text="对classes.dex文件进行Cache优化后, 文件大小会增加1-4倍，这种文件以ODEX结尾。">
                <outline text="APK中原来的classes.dex文件会保留。" />
              </outline>
              <outline text="Dalvik第一次加载时，会对每个apk进行优化，这个过程叫odex。目的是加快apk启动速度。所以手机第一次开机时间较长。" />
            </outline>
          </outline>
          <outline text="AndroidManifest.xml解析" />
          <outline text="APK安装流程" />
          <outline text="APK管理，权限和查询" />
          <outline text="APK卸载流程" />
        </outline>
        <outline text="PowerManagerService: 功耗管理   --参见 &lt;a href=&quot;https://workflowy.com/#/a5573305b407&quot;&gt;https://workflowy.com/#/a5573305b407&lt;/a&gt;" />
        <outline text="BatteryService: 电池管理服务   --参见 &lt;a href=&quot;https://workflowy.com/#/a5573305b407&quot;&gt;https://workflowy.com/#/a5573305b407&lt;/a&gt;" />
        <outline text="NotificationManagerService: 通知栏管理服务   --参见 &lt;a href=&quot;https://workflowy.com/#/2bfbaf316a49&quot;&gt;https://workflowy.com/#/2bfbaf316a49&lt;/a&gt;" />
        <outline text="StatusBarManagerService: 状态栏管理服务" />
        <outline text="视窗系统  --参见 &lt;a href=&quot;https://workflowy.com/#/56a8ba6ce429&quot;&gt;https://workflowy.com/#/56a8ba6ce429&lt;/a&gt;" />
        <outline text="ContentProvider --参见 &lt;a href=&quot;https://workflowy.com/#/e96b8978d6de&quot;&gt;https://workflowy.com/#/e96b8978d6de&lt;/a&gt;" />
        <outline text="Location  --参见 &lt;a href=&quot;https://workflowy.com/#/cb01714441aa&quot;&gt;https://workflowy.com/#/cb01714441aa&lt;/a&gt;" />
        <outline text="&lt;b&gt;其它系统服务(运行于SystemServer)&lt;/b&gt;">
          <outline text="EntropyService: 提供伪随机数" />
          <outline text="AccountManagerService: 账户管理服务，android系统账户" />
          <outline text="LightsService: 自然光强度感应传感器服务" />
          <outline text="VibratorService: 震动器服务" />
          <outline text="AlarmManagerService: 定时器管理服务，提供定时提醒服务" />
          <outline text="BluetoothService: 蓝牙服务" />
          <outline text="DevicePolicyManagerService: 系统级别的设置及属性管理" />
          <outline text="ClipboardService: 系统剪切板服务" />
          <outline text="InputMethodManagerService: 输入法管理服务" />
          <outline text="NetworkManagementService: 网络管理服务" />
          <outline text="NetStatService: 网络状态服务" />
          <outline text="AccessibilityManagerService: 无障碍访问服务" />
          <outline text="MountService: 挂载服务，可通过该服务调用Linux层面的mount程序" />
          <outline text="SearchManagerService: 搜索管理服务" />
          <outline text="DropBoxManagerService: 通过该服务访问Linux层面的Dropbox程序" />
          <outline text="WallpaperManagerService: 墙纸管理服务，墙纸不等同于桌面背景，在View系统内部，墙纸可以作为任何窗口的背景" />
          <outline text="AudioService: 音频管理服务" />
          <outline text="BackupManagerService: 系统备份服务" />
          <outline text="AppWidgetService: Widget服务" />
          <outline text="RecognitionManagerService: 身份识别服务" />
          <outline text="DiskStatsService: 磁盘统计服务" />
        </outline>
        <outline text="XMPP服务">
          <outline text="开源的即时通讯框架." />
        </outline>
        <outline text="Phone MS">
          <outline text="属于协议领域." />
        </outline>
        <outline text="华为飞马架构">
          <outline text="2019年发展到 5.0" />
          <outline text="芯片组件" />
          <outline text="系统组件" />
          <outline text="版本组件" />
          <outline text="定制组件">
            <outline text="代码+配置仓" />
          </outline>
        </outline>
      </outline>
      <outline text="25-系统库&amp;amp;运行时&amp;amp;核心库">
        <outline text="系统库 - 即Android中间件, 通用解决方案">
          <outline text="图层服务" />
          <outline text="媒体库" />
          <outline text="SQLite --参见 &lt;a href=&quot;https://workflowy.com/#/e96b8978d6de&quot;&gt;https://workflowy.com/#/e96b8978d6de&lt;/a&gt;" />
          <outline text="OpenGLE" />
          <outline text="FreeType">
            <outline text="" />
          </outline>
          <outline text="Webkit" />
          <outline text="SGL" />
          <outline text="SSL" />
          <outline text="LibC" />
        </outline>
        <outline text="Android运行时 -- java虚拟机和java语言库">
          <outline text="虚拟机">
            <outline text="Java虚拟机">
              <outline text="java虚拟机是执行字节码文件（.class）的进程。" />
              <outline text="java代码执行流程如下：">
                <outline text="java源程序（.java）被编译器编译成字节码文件（.class）。" />
                <outline text="然后字节码文件由java虚拟机，解释成机器码（不同平台的机器码不同）。" />
                <outline text="最后利用机器码操作硬件和操作系统" />
              </outline>
              <outline text="SUN提供的java虚拟机和Dalvik的区别">
                <outline text="java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。" />
                <outline text="dalvik虚拟机是基于寄存器的。" />
                <outline text="ava虚拟机运行的是java字节码。" />
                <outline text="Dalvik运行的是自定义的.dex字节码格式。java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据。" />
              </outline>
            </outline>
            <outline text="一个应用，一个虚拟机实例，一个linux线程。" />
            <outline text="Android虚拟机的演进历史">
              <outline text="2008, Android 1.0, &lt;b&gt;Dalvik&lt;/b&gt;, 机制是app总是一边编译一边运行. " />
              <outline text="2010, 2.2, &lt;b&gt;JIT&lt;/b&gt;(Just in time). 即时编译. 将编译好的代码存储, 下次直接使用." />
              <outline text="2014-10, 5.0, &lt;b&gt;ART&lt;/b&gt;(Android runtime), 将JIT编译器改为AOT(Ahead of time), 在apk安装时生成dex字节码, 运行时不编译." />
              <outline text="2016, 7.0, ART机制改为安装时不编译, 而是在安装后CPU空闲时编译. 在AOT编译器失效时, 改用JIT编译器. " />
              <outline text="2019, 10.0, ART机制改为预先放置热点代码的标记, 在安装时先生成热点代码的字节码, 而剩下的代码则在CPU空闲时编译." />
            </outline>
            <outline text="Dalvik">
              <outline text="google开发的一种java虚拟机，是基于寄存器的。" />
              <outline text="Dalvik有自己的bytecode, 并非使用 Java bytecode。所以不和sun java兼容。" />
              <outline text="Dalvik为提升性能做的优化">
                <outline text="多个 Class 文件融合进一个 Dex 文件中，以节省内存空间。" />
                <outline text="Dex 文件可以在多个进程之间共享。" />
                <outline text="应用程序运行之前完成字节码的检验操作，因为检验操作十分耗时。" />
                <outline text="优化字节码。" />
                <outline text="个进程共享的代码不能随意编辑，保证安全性。" />
              </outline>
            </outline>
            <outline text="ART">
              <outline text="从 Android 4.4 开始，Art 开始和 Dalvik 共存。" />
              <outline text="5.0 开始，Art 正式取代 Dalvik。" />
              <outline text="Art 相比 Dalvik 在性能上有着显著的优势。">
                <outline text="主要原因在于 Dalvik 虚拟机多数情况下还得通过解释器的方式来执行 Dex 数据；" />
                <outline text="JIT 虽然能在一定程度上提高效率，但也仅仅是针对一小部分情况，作用有限；" />
                <outline text="JIT 在程序运行过程中才会将部分热点代码编译成机器码，这在某种程度上也加重了 CPU 的负担。" />
                <outline text="而 Art 则采用了 AOT(Ahead Of Time) 技术，从而大幅提高了性能。" />
              </outline>
              <outline text="AOT 提前将 Java 代码翻译成针对目标平台的机器码">
                <outline text="虽然这也意味着编译时间有所增加。" />
                <outline text="但 Android 系统的构建原本就慢，所以这点牺牲还是值得的。" />
              </outline>
            </outline>
            <outline text="Art 虚拟机整体框架">
              <outline text="无论是 Dalvik 还是 Art，它们提供的功能将全部封装在一个 so 库中，并且对外需要暴露：">
                <outline text="JNI_GetDefaultVMInitArgs" />
                <outline text="JNI_CreateVM" />
                <outline text="JNI_GetCreatedJavaVMs 三个接口" />
                <outline text="使用者（比如 Zygote）只需要按照统一的接口标准就可以控制和使用所有类型的虚拟机了。" />
              </outline>
            </outline>
          </outline>
          <outline text="核心库 --代码中可以包含.">
            <outline text="Java核心库" />
            <outline text="Android核心库">
              <outline text="android.os" />
              <outline text="android.net" />
              <outline text="android.media" />
            </outline>
          </outline>
        </outline>
        <outline text="内核库  -- C/C++ 语言库">
          <outline text="Bionic">
            <outline text="google开发的c语言库，采用BSD许可形式开源，目的是替代以GPL开源的 glibc." />
            <outline text="&lt;b&gt;google做这个的目的是为了避免开源感染扩散到HAL层。&lt;/b&gt;" />
            <outline text="特点是:">
              <outline text="大小仅200KB，是glibc的一半，且比glibc快。" />
              <outline text="实现了一个更小、更快的pthread；" />
              <outline text="提供了一些android需要的函数，如getprop、LOGI；" />
              <outline text="不完全支持POSIX标准，如C++ exceptions、wide chars等；" />
              <outline text="不提供libthread_db和libm的实现。" />
            </outline>
            <outline text="新增的特性:">
              <outline text="wp、sp是智能指针；" />
              <outline text="string8.h 是定义单字节字符串的类；并提供从 string16 转换的接口。" />
              <outline text="keyedvector.h，定义hash向量表模板，用key（字符串）随机访问数据。" />
            </outline>
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;26-Native&amp;amp;HAL&lt;/b&gt;">
        <outline text="JNI: Java Native Interface. Java本地接口，用来实现Java代码与本地的C/C++代码进行互相调用.">
          <outline text="JNI 是java语言固有的. 非Android特性." />
        </outline>
        <outline text="Native: 本地代码. 相对于托管代码而言.">
          <outline text="FWK及APP层的Java代码运行在虚拟机之上, 即托管代码. " />
          <outline text="相对应, 所有的c代码, 以及部分不依赖虚拟机的java代码, 就是native代码." />
        </outline>
        <outline text="NDK: native development kit. 开发native代码的工具包">
          <outline text="在系统开发中, NDK 用于开发native层代码." />
          <outline text="在纯应用开发中, NDK用于支撑apk调用自己的c 的so库. 然后NDK能帮助程序员自动将so文件和java代码一起打包成apk。">
            <outline text="常见情况是: 出于跨平台考虑，核心算法用C实现。在android平台，用NDK生成c的so库，用java做上层产品实现。" />
          </outline>
        </outline>
        <outline text="HAL: 即Hardware Abstraction Layer. 为硬件供应商定义了一系列标准接口来实现, 以实现fwk代码和硬件的解耦." />
        <outline text="这几组概念的调用关系是:">
          <outline text="java 调用 java api; (即java的native函数)" />
          <outline text="java api 调用 jni;" />
          <outline text="jni 是一层皮, 调用 c 的 native 的 client 层;" />
          <outline text="c 的native 包括 client 和 service, 两者用 binder 方式通讯;" />
          <outline text="native service 调用 HAL." />
        </outline>
        <outline text="JNI函数初始化过程">
          <outline text="Zygote启动过程中会AndroidRuntime.cpp中的 startVm()创建虚拟机，VM创建完成后，紧接着调用 startReg()完成虚拟机中的JNI方法注册。" />
          <outline text="register_jni_procs(gRegJNI, NELEM(gRegJNI), env) 的作用就是就是循环调用 gRegJNI数组成员所对应的方法。" />
          <outline text="gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp. ">
            <outline text="其每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，在Zygote中介绍过，该宏的作用就是调用相应的方法。" />
          </outline>
        </outline>
        <outline text="JNI 就是一层皮, 找到规律后, 从 java 跳到 c 就非常容易理解了.">
          <outline text="java文件中申明的native方法, 如何找对应的实现在哪个c++文件, 函数名是什么?">
            <outline text="Android JNI在函数命名上是有规律的." />
            <outline text="比如 MessageQueue.java 中申明了private native void &lt;b&gt;nativePollOnce&lt;/b&gt;(longptr,inttimeoutMillis); 怎么找? " />
            <outline text="1. MessageQueue.java的全限定名为android.os.MessageQueue.java，方法名：android.os.MessageQueue.nativePollOnce()，而相对应的native层方法名只是将点号替换为下划线，可得android_os_MessageQueue_nativePollOnce()。">
              <outline text="即: nativePollOnce ==&amp;gt; android_os_MessageQueue_nativePollOnce()" />
            </outline>
            <outline text="2. 有了native方法名，那么接下来需要知道该native方法所在的文件名。规律一样, MessageQueue.java ==&amp;gt; android_os_MessageQueue.cpp.">
              <outline text="但是也有例外, 比如: Binder.java所对应的native文件：android_util_Binder.cpp." />
            </outline>
            <outline text="3. 目录在哪里呢? jni文件一般在这3个目录中:">
              <outline text="framework/base/core/jni/" />
              <outline text="framework/base/services/core/jni/" />
              <outline text="framework/base/media/jni/" />
            </outline>
          </outline>
          <outline text="程序自定义的jni函数, 如何找对应的实现呢?">
            <outline text="以MediaPlayer.java为例，其包名为android.media." />
            <outline text="通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库。 接着通过关键字native加在native_init方法之前，便可以在java层直接使用native层方法。" />
            <outline text="接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义LOCAL_MODULE:= libmedia_jni，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。" />
            <outline text="搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/&lt;a href=&quot;http://Android.mk&quot;&gt;Android.mk&lt;/a&gt;。" />
            <outline text="文件名和函数名分别是: android_media_MediaPlayer.cpp 和 android_media_MediaPlayer_native_init()" />
          </outline>
          <outline text="Java代码如何调用C?">
            <outline text="有两种方式: 静态和动态" />
            <outline text="静态注册: 根据函数名建立 Java 方法和 JNI 函数的一一对应关系。流程是：">
              <outline text="先编写 Java 的 native 方法；" />
              <outline text="然后用 javah 工具生成对应的头文件，执行命令 javah packagename.classname可以生成由包名加类名命名的 jni 层头文件，或执行命名 javah -o custom.h packagename.classname，其中 custom.h 为自定义的文件名；" />
              <outline text="实现 JNI 里面的函数，再在Java中通过 &lt;b&gt;System.loadLibrary &lt;/b&gt;加载 so 库即可." />
              <outline text="一个在java代码中叫 swap() 的native方法, 对应的C代码函数体是:">
                <outline text="JNIEXPORT jint JNICALL &lt;b&gt;Java_Com_Oppo_Camera_Jni_swap__&lt;/b&gt;(JNIEnv *, jclass);" />
              </outline>
            </outline>
            <outline text="动态注册: 直接告诉 native 方法其在JNI 中对应函数的指针。通过使用 JNINativeMethod 结构来保存 Java native 方法和 JNI 函数关联关系，流程是：">
              <outline text="先编写 Java 的 native 方法；" />
              <outline text="编写 JNI 函数的实现（函数名可以随便命名）；" />
              <outline text="利用结构体 JNINativeMethod 保存Java native方法和 JNI函数的对应关系；" />
              <outline text="利用registerNatives(JNIEnv* env)注册类的所有本地方法；" />
              <outline text="在 JNI_OnLoad 方法中调用注册方法；" />
              <outline text="在Java中通过 System.loadLibrary 加载完JNI动态库之后，会调用 JNI_OnLoad 函数，完成动态注册." />
            </outline>
          </outline>
          <outline text="C代码如何调用 Java?">
            <outline text="当 Native 层需要调用 Java 的某个方法时，需要通过 JNI函数 GetMethodID()获取它的 ID，根据 ID 调用 JNI 函数获取该方法；变量的获取也是类似。" />
            <outline text="jmethodID   (*&lt;b&gt;GetMethodID&lt;/b&gt;)(JNIEnv*, jclass, const char*, const char*);    //C" />
            <outline text="jmethodID &lt;b&gt;GetMethodID&lt;/b&gt;(jclass clazz, const char* name, const char* sig)  //C++">
              <outline text="{ return functions-&amp;gt;GetMethodID(this, clazz, name, sig); " />
            </outline>
            <outline text="}" />
            <outline text="在实际编程中，如果使用 javah 工具来生成对应的 native 代码，就不需要手动编写对应的类型转换了。" />
          </outline>
          <outline text="C代码方法的定义和 JNIEnv">
            <outline text="JNIEnv 是指线程上下文环境，每个线程有且只有一个JNIEnv实例." />
            <outline text="所有本地函数都会接收 JNIEnv 作为第一个参数." />
            <outline text="JNIEnv 是一个指针，指向一组 JNI 函数，通过这些函数可以实现 Java 层和 JNI 层的交互，就是说通过 JNIEnv 调用 JNI 函数可以访问 Java 虚拟机，操作 Java 对象." />
            <outline text="用作线程局部存储，不能在线程间共享一个 JNIEnv 变量，也就是说 JNIEnv 只在创建它的线程有效，不能跨线程传递；相同的 Java 线程调用本地方法，所使用的 JNIEnv 是相同的，一个 native 方法不能被不同的 Java 线程调用." />
          </outline>
          <outline text="JNI数据类型映射表">
            <outline text="定义参数和返回值时要用到数据类型, JNI一般使用:">
              <outline text="String getString()  -&amp;gt;  Ljava/lang/String;" />
              <outline text="int sum(int a, int b)  -&amp;gt;  (II)I" />
              <outline text="void main(String[] args) -&amp;gt; ([Ljava/lang/String;)V" />
            </outline>
            <outline text="基本数据类型: ">
              <outline text="字符 Java类型    C类型" />
              <outline text="V      void            void" />
              <outline text="Z       jboolean     boolean" />
              <outline text="I        jint              int" />
              <outline text="J       jlong            long" />
              <outline text="D      jdouble       double" />
              <outline text="F      jfloat            float" />
              <outline text="B      jbyte            byte" />
              <outline text="C      jchar           char" />
              <outline text="S      jshort          short" />
            </outline>
            <outline text="数组则以&quot;[&quot;开始，用两个字符表示: ">
              <outline text="[I       jintArray      int[]" />
              <outline text="[F     jfloatArray    float[]" />
              <outline text="[B     jbyteArray    byte[]" />
              <outline text="[C    jcharArray    char[]" />
              <outline text="[S    jshortArray   short[]" />
              <outline text="[D    jdoubleArray double[]" />
              <outline text="[J     jlongArray     long[]" />
              <outline text="[Z     jbooleanArray boolean[]" />
            </outline>
            <outline text="引用类型描述符:">
              <outline text="引用类型不能直接在 Native 层使用. 需要用如下格式: " />
              <outline text="L + 包名/类描述符 + ; ,  注意分号不要丢了." />
              <outline text="比如 CameraBuffer-&amp;gt; Lcom/android/camera/CameraBuffer;   // 真是麻烦." />
              <outline text="一个例外是String类，其对应的类为jstring." />
              <outline text="同时其对应的C函数名的参数则为 &lt;b&gt;jobject&lt;/b&gt;." />
              <outline text="如果JAVA函数位于一个嵌入类，则用$作为类名间的分隔符。如: &quot;(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z&quot;" />
              <outline text="多维数组（含二维数组）都是引用类型，需要使用 jobjectArray 类型存取其值；" />
            </outline>
          </outline>
        </outline>
        <outline text="HAL层是用户态进程访问硬件的标准接口，被编译成so文件，然后被framework代码动态加载。" />
        <outline text="HAL层的必要性">
          <outline text="HAL层主要是为规避GPL而设计的">
            <outline text="它将将硬件驱动分成内核空间和用户空间两部分，" />
            <outline text="其中用户空间部分采用的是商业友好的Apache License。" />
            <outline text="内核驱动层只提供简单的访问硬件逻辑，例如读写硬件寄存器的通道。" />
            <outline text="至于从硬件中读到了什么值或者写了什么值到硬件中的逻辑，都放在HAL中去。" />
            <outline text="这样就可以把商业秘密隐藏起来了。" />
            <outline text="也正是由于这个原因，Android被踢出了Linux内核主线代码树中。Android放在内核空间的驱动程序对硬件的支持是不完整的，把Linux内核移植到别的机器上去时，由于缺乏硬件抽象层的支持，硬件就完全不能用了，这也是为什么说Android是开放系统而不是开源系统的原因。" />
          </outline>
          <outline text="同时是为了满足抽象的要求">
            <outline text="比如framework需要用overlay，通过给 hw_get_module()传入字符串“overlay_module”，就可以取得该设备的标准模块的描述." />
            <outline text="有人实现了overlay，不管是软件加速，还是硬件加速，是基于v4l2，还是基于mmap接口，只要实现成 overlay_module 的样子就成，这样就“抽象”了。" />
          </outline>
        </outline>
        <outline text="如何看native代码?">
          <outline text="java native方法申明: 在java代码中, 方法前面有 native 关键字的就是native方法." />
          <outline text="native方法的命名有规律, 一般是:">
            <outline text="java库: Java_Lang_类名_方法名" />
            <outline text="Android frameworkd : android_Hardware_Camera_CameraOpen()" />
          </outline>
          <outline text="native方法只是一个句柄, 真正的函数体是C代码的. 对应的代码在:">
            <outline text="java库:  delvik/wm/native/" />
            <outline text="Android framework : framework/base/core/jni/" />
          </outline>
        </outline>
        <outline text="编译so文件">
          <outline text="Android系统支持7种CPU建构, 每一种对应一种ABI(应用程序二进制接口)">
            <outline text="armV5 -- armeabi" />
            <outline text="armV7(2010) -- armeabi-v7a" />
            <outline text="x86(2011) -- x86" />
            <outline text="mips(2012) -- mips" />
            <outline text="armV8(2012) -- arm64-v8a" />
            <outline text="mips64(2014) -- mips64" />
            <outline text="x86-64(2014) -- x86-64" />
          </outline>
          <outline text="如果在项目中使用了NDK, 就会生成so文件." />
          <outline text="native libs monitor, 运行在手机上, 可列出各apk使用了哪些so文件, 以及so文件来源于哪些函数库或框架. " />
        </outline>
        <outline text="寻址so文件">
          <outline text="hw_get_module()通过libdl动态加载库文件, 文件路径在 /system/lib/hw/[id].[arch].so" />
          <outline text="其中id即设备id，是字符串. 包括:">
            <outline text="overlay_module: 图层叠加" />
            <outline text="gralloc_*: 图形buffer" />
            <outline text="display_*: 显示控制" />
            <outline text="nfc" />
            <outline text="camera" />
            <outline text="sensors_hardware_*: 传感器" />
          </outline>
          <outline text="arch 即芯片平台id。" />
          <outline text="so文件名类似：camera.msm7630.surf.so 和 nfc.huawei.so。" />
        </outline>
        <outline text="调用so文件提供的接口">
          <outline text="每个so库都要实现标准接口，这个标准即 HAL_MODULE_INFO_SYM，其中定义了一些属性，但要求必须实现的接口只有一个：open()。" />
          <outline text="so文件找到后，调用 dlopen()打开，后者返回值为模块操作句柄。" />
          <outline text="再调用dlsym(),  入参即模块操作句柄及符号名，返回符号对应的地址。不仅可以返回函数指针，也可以获得全局变量的地址." />
          <outline text="其它接口包括:" />
          <outline text="dlclose():关闭库文件。 " />
          <outline text="dlerror()当操作函数执行失败时，可通过此接口返回出错信息。" />
        </outline>
        <outline text="不是所有的设备驱动都用HAL">
          <outline text="电池就不用，因为power是linux内核标准服务，JNI就直接访问内核服务了。" />
        </outline>
        <outline text="&lt;b&gt;Treble架构&lt;/b&gt;">
          <outline text="Android 8.0 推出. Android 9.0 强制使用." />
          <outline text="旨在完成HAL和fwk/应用层的解耦, 提供稳定的供应商接口, 方便framework和应用层(也就是 system.img)快捷升级. 供应商接口主要在vendor目录中定义." />
          <outline text="原理">
            <outline text="老架构下，HAL是一个个的.so库，通过dlopen来加载，库和framework位于同一个进程。" />
            <outline text="新架构下，framework和hal运行于不同的进程，所有的HAL调用使用HIDL技术跨进程完成。" />
            <outline text="为了充分利用存量代码, Android设计了Passthrough模式，经过转换，可以方便的使用存量代码，不需要重新编写相关的HAL." />
            <outline text="跨进程通信通过HIDL接口和 dev/hwbinder 的IPC域来完成。" />
            <outline text="HIDL有两种实现模式：Passthrough和Binderized。前者能最大限度使用存量代码, 适合老代码. 后者是纯Treble架构, Google Docs推荐, 适合新代码." />
          </outline>
          <outline text="HIDL">
            <outline text="新架构下, 所有对HAL的访问都需要跨进程, 也就是搞成 client-server 模式. " />
            <outline text="用户可以使用HIDL语法编写.hal 文件, 然后使用 hidl-gen 自动生成 client 端和 server 端的代码, 很方便 (和AIDL 一回事)." />
            <outline text="比如: hardware/interfaces/power/1.0/IPower.hal，会通过hidl-gen转换成 out/soong/.intermediates/hardware/interfaces/power/1.0/android.hardware.power@1.0_genc++/gen/android/hardware/power/1.0/PowerAll.cpp文件" />
            <outline text="hidl-gen源码路径：system/tools/hidl" />
            <outline text="使用方法：hidl-gen -o output-path -L language (-r interface-root) fqname" />
            <outline text="在hardware/interfaces的子目录里面，存在.hal文件的目录，会产生Android.bp和Android.mk文件。" />
            <outline text="Android.bp 大概是如下内容:">
              <outline text="// This is an autogenerated file, do not edit." />
              <outline text="subdirs = [">
                <outline text="&quot;1.0&quot;," />
                <outline text="&quot;1.0/default&quot;," />
                <outline text="&quot;1.0/vts/functional&quot;," />
              </outline>
              <outline text="]" />
              <outline text="意思是, 编译时需要编译 hardware/interfaces/power目录下的这3个子目录。" />
            </outline>
            <outline text=".hal文件转换成对应的代码后，就具备了Binder通信的能力。" />
            <outline text="参见  HIDL流程图  @iImage " />
          </outline>
          <outline text="Passthrough模式的HIDL实现机制">
            <outline text="以hardware/interfaces/power/1.0作为例子。当编译hardware/interfaces/power/1.0的时候，会生成：" />
            <outline text="中间文件PowerAll.cpp" />
            <outline text="/vendor/bin/hw/android.hardware.power@1.0-service的可执行文件" />
            <outline text="/vendor/lib/hw/android.hardware.power@1.0-impl.so的库文件" />
            <outline text="android.hardware.power@1.0-service.rc会被拷贝到vendor.img里面的vendor/etc/init目录。rc文件的内容如下：" />
            <outline text="service power-hal-1-0 /vendor/bin/hw/android.hardware.power@1.0-service">
              <outline text="class hal" />
              <outline text="user system" />
            </outline>
            <outline text="系统启动时, 会启动hal服务，执行/vendor/bin/hw/android.hardware.power@1.0-service，从而调用hardware/interfaces/power/1.0/default/service.cpp的main方法。代码如下：">
              <outline text="int main() {">
                <outline text="return defaultPassthroughServiceImplementation&amp;lt;IPower&amp;gt;();" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="接下来会调用 PowerAll.cpp 的 IPower::getService(), 获取service对象. 这是关键. 包括:">
              <outline text="defaultPassthroughServiceImplementation(); @hardware/interfaces/power/1.0/default/service.cpp" />
              <outline text="IPower::getService @ PowerAll.cpp 从HwServiceManager里面获取注册的服务。默认情况下是没有注册这个服务的。" />
              <outline text="defaultServiceManager @system/libhidl/transport/ServiceManagement.cpp 打开/dev/hwbinder，通过binder通信，获取HwServiceManager服务端。" />
              <outline text="sm-&amp;gt;getTransport 基本就是按照Binder通信的机制来实现相关的流程。通过HwBinder调用服务端的getTransPort方法。接下来的调用链是:">
                <outline text="BpHwServiceManager::getTransport() @ ServiceManagerAll.cpp" />
                <outline text="BpHwBinder::transact" />
                <outline text="IPCThreadState::self()-&amp;gt;transact" />
                <outline text="IPCThreadState::transact writeTransactionData waitForResponse" />
                <outline text="IPCThreadState::executeCommand" />
              </outline>
            </outline>
            <outline text="ServiceManager::getTransport() @ system/hwservicemanager/ServiceManager.cpp">
              <outline text="getTransport @ system/hwservicemanager/Vintf.cpp 根据framework hal和device hal配置的manifest.xml里面的定义，来判断当前的传输类型是HwBinder还是Passthrough模式。" />
              <outline text="在vendor/manifest.xml里面，power配置的是hwbinder,所以最终就是hwBinder模式。" />
            </outline>
            <outline text="由于我们采取的是defaultPassthroughServiceImplementation&amp;lt;IPower&amp;gt;();进行注册，所以getStub=true.所以会走到const sp&amp;lt;::android::hidl::manager::V1_0::IServiceManager&amp;gt; pm = getPassthroughServiceManager();">
              <outline text="getPassthroughServiceManager @ PowerAll.cpp 获取passthrough服务管理。" />
              <outline text="调用PassthroughServiceManager的get(const hidl_string&amp;amp; fqName, const hidl_string&amp;amp; name)函数 @ ServiceManagement.cpp, " />
              <outline text="根据传入的fqName=(android.hardware.power@1.0::IPower&quot;),获取当前的接口名IPower，拼接出后面需要载入的函数名HIDL_FETCH_IPower和库名字android.hardware.power@1.0-impl，" />
              <outline text="接着通过dlopen载入/vendor/lib/hw/android.hardware.power@1.0-impl.so，然后通过dlsym载入HIDL_FETCH_IPower函数。" />
            </outline>
            <outline text="通过 hw_get_module 就和 Android O 以前的Hal模式一致，这正是Passthrough复用原有hal的原理." />
          </outline>
          <outline text="版本管理">
            <outline text="这里的版本是指service的版本. " />
            <outline text="client 在初始化时可以探测当前系统中的service的版本. " />
            <outline text="系统中可能有多个不同版本的 service的so文件. " />
            <outline text="Google 约定, 1.0 升级到 1.1 , 要保证接口的兼容性, 也就是说只能新增接口, 不能修改删除接口. 1.1 升级到 2.0, 就不保证接口的兼容性, 也就是可以改接口." />
          </outline>
          <outline text="死亡通知">
            <outline text="客户端在注册了死亡通知后, 但服务死亡时可以收到由Treble框架提供的死亡通知。" />
            <outline text="为了完成注册，客户端需要满足以下条件：">
              <outline text="HIDL 类 / 接口 hidl_death_recipient 的子类。（在 C++ 代码中，而非 HIDL）" />
              <outline text="重写它的 serviceDied() 方法。" />
              <outline text="实例化一个 hidl_death_recipient 子类对象。" />
              <outline text="调用服务的方法 &lt;b&gt;linkToDeath&lt;/b&gt;() 给监视器，传入 IDeathRecipient 的接口对象。" />
            </outline>
            <outline text="例子:">
              <outline text="class IMyDeathReceiver : hidl_death_recipient {">
                <outline text="virtual void serviceDied(uint64_t cookie,">
                  <outline text="wp&amp;lt;IBase&amp;gt;&amp;amp; service) override {" />
                  <outline text="log(&quot;RIP service %d!&quot;, cookie);  // Cookie should be 42" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="};" />
              <outline text="IMyDeathReceiver deathReceiver = new IMyDeathReceiver();" />
              <outline text="m_importantService-&amp;gt;&lt;b&gt;linkToDeath&lt;/b&gt;(deathReceiver, 42);" />
            </outline>
          </outline>
        </outline>
        <outline text="NDK开发常见问题">
          <outline text="忘记delete local reference。带New到方法(如：NewByteArray)这样到方法比较好辨认，需要手动调用DeleteLocalRef()来释放(返回值除外)。比较特殊的一个方法是：GetByteArrayELement必须要调用ReleaseByteArrayElements进行释放。当然如果你只是取bytearray中到byte，那么完全可以用GetByteArrayRegion实现。" />
          <outline text="没有NewGlobalRef。 在不同线程调用java方法，需要保存jobject对象，这时需要对jobject对象做全局引用，否则会失效。" />
          <outline text="jbytearray的length。在JNI layer获取到jbytearray到长度是不对到，应该由java获取byte[]的length再传给C layer。否则C layer有可能获得到是乱码。" />
          <outline text="线程问题。 不同线程使用JNIEnv*对象，需要AttachCurrentThread将env挂到当前线程，否则无法使用env。" />
          <outline text=" javap 命令是对java的class文件操作；而javah命令需要在包名到上一层路径运行才行，否则无法生成.h文件。" />
          <outline text="尽量避免频繁调用JNI或者是使用JNI传输大量到数据。" />
          <outline text="Reference Table overflow (max=1024) 或者是 Reference Table overflow (max=512)一定是因为忘记释放global reference或者local reference，请仔细检查代码。" />
          <outline text="不要在windows下使用cygwin编译NDK code，那样会遇到arguments too long问题，因为windows路径长度有限制导致。虽然可以使用subst将路径映射为短路径，但是在编译时间和调试上，windows到孩子都是伤不起。同样到build，在windows下要15分钟左右，而在mac下只要5分多，相差3倍。调试JNI 代码到速度更是不用提了，差太多。" />
        </outline>
      </outline>
      <outline text="27-文件系统&amp;amp;存储&amp;amp;USB">
        <outline text="Linux文件系统接口">
          <outline text="open" />
          <outline text="close" />
          <outline text="read" />
          <outline text="write" />
          <outline text="ioctl" />
          <outline text="access">
            <outline text="int access(const char *pathname, int mode);" />
            <outline text="参数:">
              <outline text="pathname: 需要测试的文件路径名。" />
              <outline text="mode: 需要测试的操作模式，可能值是一个或多个R_OK(可读), W_OK(可写), X_OK(可执行) 或 F_OK(文件存在)的组合体。" />
            </outline>
            <outline text="返回值">
              <outline text="成功执行时，返回0。失败返回-1，&lt;b&gt;errno&lt;/b&gt; 被设为以下的某个值" />
              <outline text="EINVAL： 模式值无效" />
              <outline text="EACCES： 文件或路径名中包含的目录不可访问" />
              <outline text="ELOOP ： 解释路径名过程中存在太多的符号连接" />
              <outline text="ENAMETOOLONG：路径名太长" />
              <outline text="ENOENT：路径名中的目录不存在或是无效的符号连接" />
              <outline text="ENOTDIR： 路径名中当作目录的组件并非目录" />
              <outline text="EROFS： 文件系统只读" />
              <outline text="EFAULT： 路径名指向可访问的空间外" />
              <outline text="EIO：输入输出错误" />
              <outline text="ENOMEM： 不能获取足够的内核内存" />
              <outline text="ETXTBSY：对程序写入出错" />
            </outline>
          </outline>
        </outline>
        <outline text="文件系统">
          <outline text="file_operations">
            <outline text="简称fops，这个结构的每个字段都指向驱动程序中的实现特定操作的函数，同时也是该设备文件对用户发布的接口。" />
            <outline text="采用的包括open/close/read/write/ioctl(用于执行设备特定命令)" />
          </outline>
          <outline text="file">
            <outline text="file表示一个打开的文件，不限于设备文件，每个打开的问题在内核空间都有一个对应的file 结构。" />
            <outline text="指向file的指针一般简称为filp。" />
          </outline>
          <outline text="inode">
            <outline text="inode结构在内部表示文件，和文件一一对应。一个inode结果可能有多个file结构指向它。" />
            <outline text="从inode结构获取主设备号和次设备号：" />
            <outline text="uint iminor(inode *);" />
            <outline text="uint imagor(inode *);" />
          </outline>
          <outline text="cdev结构">
            <outline text="内核用cdev结构来表示字符设备。inode 结构中就有cdev指针的字段。" />
          </outline>
        </outline>
        <outline text="/proc文件系统">
          <outline text="/proc 文件系统是一个由软件创建的文件系统，内核使用它向外界导出信息。" />
          <outline text="/proc 下面的每个文件都绑定于一个内核函数；用户访问这个文件时，该函数动态的生产文件的内容。" />
          <outline text="不建议使用 /proc，建议使用 sysfs。" />
        </outline>
        <outline text="模块">
          <outline text="Linux中的模块一般用于动态加载." />
          <outline text="由于模块参数直接导出为sysfs设备节点, 所以模块放在文件系统中介绍." />
          <outline text="初始化">
            <outline text="static int __init init_func(void){;;;}" />
            <outline text="module_init(init_func);" />
            <outline text="module_init是宏，告诉编译器要在目标代码中加一个特殊段，以便指明init_func() 的位置。" />
          </outline>
          <outline text="清除">
            <outline text="static int __exit exit_func(void){;;;}" />
            <outline text="模块退出时被call." />
          </outline>
          <outline text="模块参数">
            <outline text="定义的模块参数将被公布为sysfs的节点，以供读写。---精彩的设计。" />
            <outline text="内核支持的模块参数类型有限，如下：bool、charp（字符串）、int、long、short、uint、ulong、ushort" />
            <outline text="定义方法：" />
            <outline text="module_param(howmany, int, S_IRUGO);    // 参数分别为名称、类型、sysfs节点的读写权限（定义在 linux/stat.h 中）" />
            <outline text="也支持数组。定义方法：" />
            <outline text="module_param_array(name, type, num, permission);" />
          </outline>
          <outline text="模块log打印  --介绍一个精彩的设计  #经验总结 ">
            <outline text="打印开关 synaptics_debug_mask 被导出为设备节点, 可以在系统运行时动态控制, 非常方便." />
            <outline text="static int synaptics_debug_mask;" />
            <outline text="module_param_named(synaptics_debug, synaptics_debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);" />
            <outline text="#define DBG_MASK(x...) do {\" />
            <outline text="if (synaptics_debug_mask) \" />
            <outline text="printk(KERN_DEBUG x);\" />
            <outline text="} while (0)" />
            <outline text="打印时如下即可：" />
            <outline text="DBG_MASK(&quot;the touch io is ok!\n&quot;);" />
            <outline text="DBG_MASK(&quot;the x is %d the y is %d the stauts is %d!\n&quot;, x, y, finger_status);" />
          </outline>
        </outline>
        <outline text="Vold">
          <outline text="vold.conf: android\system\core\rootdir\etc\msm7630_surf\vold.qcom.conf" />
          <outline text="mount service的代码: nativeDaemonConnector.java 之 doCommand()" />
          <outline text="外置sd卡插拔的uevent发出: VolumeManager::handleBlockEvent()" />
          <outline text="mount service下发mount命令的入口: VolumeManager::mountVolume()" />
          <outline text="mount service下发umount命令的入口: Volume::unmountVol()" />
          <outline text="sd卡mount成功的log: Volume sdcard state Changing 3(checking) -&amp;gt; 4(Mounted)" />
          <outline text="fat check工具">
            <outline text="/system/bin/fsck_msdos -p -f /mnt/sdcard" />
            <outline text="作为对比：windows上，chkdsk h:" />
          </outline>
          <outline text="fat check的处理流程">
            <outline text="在logswap()中，调用fork，创建一个子进程，然后调用child()加载 fsck_msdos工具进行检查。" />
            <outline text="此时父进程通过 wait(&amp;amp;status) 来等待子进程执行完毕。" />
          </outline>
        </outline>
        <outline text="MTP">
          <outline text="PTP（Picture Transfer Protocol），MTP的前身，用在数码相机和MP3播放器上做文件传输。" />
          <outline text="MTP（Media Transfer Protocol，媒体传输协议），微软2006年提出。" />
          <outline text="Android从3.0开始支持MTP。" />
          <outline text="usb插入后，系统会弹出一个对话框，选择“Transfer files&quot;即打开MTP。" />
          <outline text="MTP和UMS（即U盘）的对比">
            <outline text="优势：">
              <outline text="UMS挂载到PC后，存储器就被PC控制，手机侧不能再访问该存储器。这个不方便。" />
              <outline text="在存储器重新挂载到手机后，需要重新扫描媒体文件。" />
              <outline text="MTP则没有这两个问题。当手机的sdcard以MTP模式挂载到PC机上，sdcard的控制权其实还是属于手机。只不过智能手机通过MTP协议向PC机构建了一个虚拟文件系统。PC机操作其中的文件时，都会通过标准MTP协议向智能手机发起请求。" />
              <outline text="MTP模式下，可判断PC机拷贝的媒体文件是否受目标手机支持，甚至会触发对应的转码程序将其转换成手机支持的格式。" />
            </outline>
            <outline text="劣势">
              <outline text="速度较慢。" />
              <outline text="MTP不能直接修改文件本身。只能先拷贝到本地修改，完毕后再拷贝回去。" />
              <outline text="Linux和MacOS对MTP支持还不是很完善。" />
            </outline>
          </outline>
          <outline text="MTP协议有两个部分：Initiator（USB Host，例如PC机）和Responder（USB Client，例如手机或相机）。" />
          <outline text="协议规定所有MTP操作只能由Initator发起。" />
          <outline text="Responder 的作用就是处理Initator发起的请求。同时，它还会根据自身状态的变化发送Event以通知 Initiator。" />
          <outline text="MTP协议栈">
            <outline text="物理层。用于传输数据。目前有三种物理层可供MTP使用。它们分别是：">
              <outline text="USB：其主要特点是传输文件，同步媒体文件时速度快，而且可以边工作边充电，这是目前用的最多的一种方式；" />
              <outline text="IP：基于IP的MTP（简称MTP/IP）将通过UPnP来匹配和发现设备。它是家庭网络中是最理想的传输方式；" />
              <outline text="Bluetooth：MTP/BT是最省电，同时也是速度最慢的一种传输方式，用处较少。" />
            </outline>
            <outline text="传输层：数据传输格式遵循PTP协议。" />
            <outline text="命令层：实现MTP协议中的各种命令。" />
          </outline>
          <outline text="以PC通过MTP打开一个文件为例，介绍其中涉及到几个主要MTP命令：">
            <outline text="当设备第一次连接上PC后，Initiator（即PC）首先会发送一个名为 GetDeviceInfo 的请求以获取设备的信息，包括：">
              <outline text="设备所支持PTP版本的程度，以百分号表示（默认是100）" />
              <outline text="所支持的MTP命令（Operation Supported）、" />
              <outline text="所支持的Event类型等等。" />
            </outline>
            <outline text="接着PC端会发送 OpenSession 命令以创建一个会话，该会话一直保持到设备从PC上断开为止。">
              <outline text="此后所有命令（除GetDeviceInfo命令外）必须在此会话存活期间才能发送。" />
              <outline text="会话由SessionID来标识，它是一个32位的无符号整型。" />
              <outline text="SessionID由PC选择并传给手机。" />
            </outline>
            <outline text="PC端需要通过 GetStorageIDs 命令返回某个盘符对应的 StorageID。">
              <outline text="PC端如果要进行文件操作的话，必须从根目录开始定位目标文件。在windows上，根目录即为盘符。" />
              <outline text="StorageID是一个32位无符号整型，每一个StorageID代表了一个逻辑盘符。" />
              <outline text="注意，如果手机内部有两块存储卡的话（如内部存储卡和外部sd卡），Windows中会显示为两个盘符。" />
            </outline>
            <outline text="根据上一步的StorageID号，利用 GetStorageInfo 操作去获取存储设备的信息，例如剩余存储空间、文件系统类型、访问权限等。" />
            <outline text="通过 GetObjectHandles 命令来获取此盘符下的文件和子目录的Object Handles。">
              <outline text="一个Object Handle代表一个文件或目录。该值由Responder生成并保证唯一性。" />
              <outline text="有了Object Handle，PC就可以操作这些文件或目录了，例如继续通过GetObjectHandles获取某个目录中子文件和子目录的信息。" />
            </outline>
            <outline text="如果需要拷贝一个文件到手机上，那么PC会通过SendObjectInfo命令将文件信息（如文件名、文件大小）等传递给手机。而手机需要检查目标目录是否有足够的空间和对应权限。" />
            <outline text="如果一切正常，PC将通过SendObject把数据传递给手机。真正写文件到设备存储空间的则是手机中的Responder。Android实现的MTP还会在媒体文件传输完毕后，将信息更新到媒体数据库中。" />
            <outline text="PC还可利用SetObjectPropValue 命令来设置文件的各种属性值，如Audio BitRate（比特率），Sample Rate（采样率），Number Of Channels（声道）等。" />
          </outline>
          <outline text="UsbService">
            <outline text="Android 的 UsbService 可同时管理USB Host/USB Device。其中：">
              <outline text="UsbDeviceManager管理Usb Device端的功能。" />
              <outline text="UsbHostManager管理Usb Host端的功能。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;MtpServer&lt;/b&gt;">
            <outline text="Client">
              <outline text="&lt;b&gt;MtpReceiver&lt;/b&gt;负责接收广播，接收到广播后会启动/关闭MtpService；例如，MtpReceiver收到&quot;Android设备 和 PC连上&quot;的消息时，会启动MtpService。" />
              <outline text="&lt;b&gt;MtpService&lt;/b&gt;的作用是提供管理MTP的服务，它会启动MtpServer，以及将本地存储内容和MTP的内容同步。" />
              <outline text="&lt;b&gt;MediaProvider&lt;/b&gt;负责本地存储内容查找和本地内容同步。" />
            </outline>
            <outline text="Server">
              <outline text="&lt;b&gt;MtpServer&lt;/b&gt;相当于一个服务器，它通过和底层进行通信从而提供了MTP的相关服务。">
                <outline text="MtpServer会不断地监听Kernel的消息&quot;MTP请求&quot;，并对相应的消息进行相关处理。" />
                <outline text="同时，MTP的Event事件也是通过MtpServer发送给MTP驱动的。" />
                <outline text="android_mtp_MtpServer 是一个JNI类，完成底层通讯。" />
              </outline>
              <outline text="&lt;b&gt;MtpDatabase&lt;/b&gt;充当着数据库的功能，但它本身并没有数据库对数据进行保存，本质上是通过MediaProvider数据库获取所需要的数据。">
                <outline text="android_mtp_MtpDatabase 是一个JNI类，完成对MediaProvider的操作。" />
              </outline>
              <outline text="&lt;b&gt;MtpStorage&lt;/b&gt;对应一个&quot;存储单元&quot;。例如，SD卡就对应一个MtpStorage。" />
              <outline text="&lt;b&gt;MtpPacket &lt;/b&gt;和 &lt;b&gt;MtpEventPacket&lt;/b&gt;负责对MTP消息进行打包。" />
            </outline>
            <outline text="JNI">
              <outline text="初始化过程中，MtpServer.cpp中的MtpServer::run()会打开MTP文件节点&quot;/dev/mtp_usb&quot;。" />
              <outline text="数据过程中，通过 read()，不断的从中读取&quot;PC发来的消息&quot;消息并进行处理。" />
            </outline>
          </outline>
          <outline text="MTP启动详细流程">
            <outline text="开启MTP的核心代码如下：">
              <outline text="mUsbManager = context.getSystemService(UsbManager.class);" />
              <outline text="mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_MTP, true);" />
            </outline>
            <outline text="UsbManager的服务端实现为UsbService，其功能是：">
              <outline text="1.  设置sys.usb.config属性的值为 mtp,adb，底层响应属性改变，切换到MTP功能。文件在： system/core/rootdir/init.usb.configfs.rc" />
              <outline text="2.  上层mUEventObserver监听到USB状态改变，在手机通过USB连接到电脑的情况下，会生成两个通知，以及发送一个USB状态改变的广播。frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java">
                <outline text="ACTION_USB_STATE广播携带了很多extra（可以到Tethering.java中查看extra参数用途）。" />
                <outline text="这个广播是&lt;b&gt;黏性广播&lt;/b&gt;，这意味着你在注册broadcastReceiver后马上就能收到一次。所以即使我们插着usb线开机，没有插入usb线的操作去trigger，我们注册广播后依然可以把usb模式转换为mtp模式。" />
              </outline>
              <outline text="MtpReceiver.java属于packages/providers/MediaProvider模块。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java" />
              <outline text="handleUsbState()方法如何处理USB状态改变的。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java">
                <outline text="USB连接时，状态是从DISCONNECTED到CONNECTED，再到CONFIGURED。" />
                <outline text="handleUsbState中启动MtpService。参数unlocked的值是true。" />
              </outline>
              <outline text="MtpService 启动时候执行onStartCommand函数。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java" />
              <outline text="StartServer函数启动MtpServer。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java" />
              <outline text="frameworks/base/media/java/android/mtp/MtpServer.java" />
              <outline text="native_run函数最终调用JNI的函数android_mtp_MtpServer_run()。 frameworks/base/media/jni/android_mtp_MtpServer.cpp" />
              <outline text="android_mtp_MtpServer_run调用MtpServer.cpp的run方法。" />
              <outline text="frameworks/av/media/mtp/MtpServer.cpp。" />
              <outline text="MtpServer.cpp不断从文件描述符读取请求，然后调用handleRequest进行处理。最后把处理结果返回给对端。" />
            </outline>
          </outline>
        </outline>
        <outline text="FAT32">
          <outline text="FAT32 system图示  @iChart " />
        </outline>
        <outline text="MBR: 主引导记录（Master Boot Record）">
          <outline text="可引导磁盘驱动器上的第一个物理扇区。" />
          <outline text="计算机刚开始引导时，系统 BIOS 查看该扇区以确定当前哪个分区是活动的（可引导的），随后读取该分区的第一个（引导）扇区并从该分区引导。" />
        </outline>
        <outline text="RAID: 设备冗余阵列（Redundant Array of Independent/Inexpensive Disks/Devices）">
          <outline text="一种提供数据冗余、改善性能和／或从磁盘崩溃中迅速恢复数据的方法，它是通过在多个磁盘驱动器上分布或复制数据来实现这一点的。" />
          <outline text="常用的 RAID 类型包括 RAID 0（数据条带化），RAID 1（磁盘镜像）和 RAID 5（具有分布式奇偶校验的条带化）。" />
          <outline text="RAID 配置通常需要 SCSI 磁盘驱动器（而不是 IDE/EIDE），可能要求磁盘相同（相同的容量、品牌等等）。" />
          <outline text="操作系统将 RAID 阵列看作单个设备。" />
        </outline>
        <outline text="SD卡驱动">
          <outline text="线序">
            <outline text="共计10根线" />
            <outline text="data 0-3（左右两边各2）">
              <outline text="data3还可以做卡插入识别功能。" />
              <outline text="一般卡座上会另外加一根中断线侦听sd卡插拔，所以不这么用。" />
            </outline>
            <outline text="clk（左4）" />
            <outline text="GP1（左5）" />
            <outline text="cmd（左6）" />
          </outline>
          <outline text="理论速度： 4根data线，若clk配成50Mhz，则理论速率为25MB。" />
          <outline text="命令字">
            <outline text="识别高速卡： SD_ACMD 13 命令可获取sd_status，其中有speed class。" />
            <outline text="识别spec版本： ACMD 51 命令，获取SCR寄存器，其中有版本号。" />
            <outline text="获取制造商信息及串号： CMD2 获取，CID寄存器中有。" />
          </outline>
          <outline text="SD卡初始化命令序列">
            <outline text="power" />
            <outline text="clk" />
            <outline text="CMD5: 寻找SD卡">
              <outline text="有回应即为SDIO卡。" />
            </outline>
            <outline text="config clk: 初始化阶段配置为400K" />
            <outline text="CMD0: reset" />
            <outline text="CMD8: 识别SDHC">
              <outline text="有回应即为SDHC卡" />
            </outline>
            <outline text="CMD55: 是否支持ACMD" />
            <outline text="ACMD41: 电压协商">
              <outline text="有回应即为SD卡。" />
            </outline>
            <outline text="CMD1: idle">
              <outline text="有回应即为 MMC卡." />
              <outline text="如果这个也不能回应，则为不可识别的卡。" />
            </outline>
          </outline>
          <outline text="SDIO控制器">
            <outline text="sdio host控制器硬件在芯片中，共有4个控制器接口。其中:" />
            <outline text="sdio1给sd卡用" />
            <outline text="sdio2给wifi用" />
            <outline text="sdio3给emmc用" />
            <outline text="sdio4 闲置." />
          </outline>
          <outline text="驱动代码">
            <outline text="kernel/drivers/mmc/. 下面有三个目录：">
              <outline text="core">
                <outline text="核心代码，与平台无关的通用代码放在这里。" />
                <outline text="对 SDIO/SD/MMC的识别就在这个目录中。" />
              </outline>
              <outline text="host">
                <outline text="对应的各硬件平台的sd host控制器与sd卡交互的代码，以及sd卡驱动参数配置。" />
                <outline text="如 msm_sdcc.c就是负责把sd命令发给sd卡。" />
              </outline>
              <outline text="card">
                <outline text="block.c 即块设备驱动，负责把读写IO请求放入队列；" />
                <outline text="queue.c 即队列管理，把读写IO请求翻译为sd host控制器可以识别的信息。" />
              </outline>
            </outline>
            <outline text="平台设备部分">
              <outline text="sdio模块的驱动在内核中注册的是platform驱动模型." />
              <outline text="GPIO配置、SD VDD电源和时钟等，在/kernel/arch/arm/board_msm7***.c中配置。" />
              <outline text="这部分每个产品都有区别，独立出来方便管理。" />
              <outline text="初始化步骤分为:">
                <outline text="device 的注册">
                  <outline text="msm7x2x_init_mmc" />
                  <outline text="msm_add_sdcc(2, &amp;amp;msm7x2x_sdc2_data) " />
                  <outline text="platform_device_register  //注册的设备名为msm_sdcc" />
                </outline>
                <outline text="driver 的注册">
                  <outline text="kernel/drivers/mmc/msm_sdcc.c" />
                  <outline text="msmsdcc_init()" />
                  <outline text="platform_driver_register(&amp;amp;msmsdcc_driver);" />
                </outline>
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="EMMC驱动">
          <outline text="emmc初始化的代码: board_msm7x27a.c，msm7x27a_init_mmc()" />
          <outline text="配置sdcc gpio的代码">
            <outline text="board_msm7x30.c" />
            <outline text="msm_gpio sdc4_cfg_data[]" />
            <outline text="{GPIO_CFG(58, 1, GPIO_CFG_OUTPUT, ..., GPIO_CFG_15MA (启动能力), &quot;sdc4_clk&quot;};" />
          </outline>
          <outline text="EMMC特性">
            <outline text="EMMC 就是sd卡，最小容量为2G，替代flash作为存储介质。" />
            <outline text="emmc的一个主要特征是只允许一个执行单元访问." />
            <outline text="所以在app阶段，app负责访问emmc，而modem侧代码不能直接访问。">
              <outline text="那么, modem侧文件系统怎么机制?">
                <outline text="使用ram fs。" />
                <outline text="modem 读写ram fs；" />
                <outline text="其读写请求会被app侧获取，然后app访问真正的emmc，然后app把数据同步到ram fs；" />
                <outline text="最后modem 从ram fs 中得到数据。" />
                <outline text="也就是说，modem 必须异步的调用。" />
              </outline>
            </outline>
          </outline>
          <outline text="分区表">
            <outline text="生成方式变了，通过 xml+loadpt.cmm = bin文件；不需要编译。" />
            <outline text="mbr 下有三个主分区 + 一个扩展分区（ebr）；" />
            <outline text="ebr 下面之后可以容纳15 个逻辑分区。" />
          </outline>
          <outline text="如何新建分区？">
            <outline text="修改这个文件：AMSS\products\**\tools\jsdcc\partition_load_pt\partition.xml" />
            <outline text="添加如下代码:&amp;lt;extended order=&quot;1&quot; type=&quot;59&quot; label=&quot;OEMINFO&quot; size=&quot;24576&quot; readonly=&quot;false&quot;&amp;gt;&amp;lt;file name=&quot;***.mbn&quot; offset=&quot;0&quot;/&amp;gt;&amp;lt;/extended&amp;gt;" />
            <outline text="其中：">
              <outline text="order: 分区的位置；" />
              <outline text="type: 分区id, 自己定义；" />
              <outline text="size: 大小, 定位为sector, 即 512Byte；" />
              <outline text="file name: 有这个选项后, 会自动生成下载该分区的cmm脚本." />
            </outline>
            <outline text="运行 loadpt.exe ，生成 partition.bin 及cmm脚本。" />
          </outline>
          <outline text="emmc读写速率">
            <outline text="emmc是8根data线，时钟最大是50mhz，所以理论速率为50MBs." />
            <outline text="实测数据是10MBs。" />
          </outline>
          <outline text="EMMC有两种方案">
            <outline text="SLC">
              <outline text="Single Layer Cell 单层单元。" />
              <outline text="SLC的特点是成本高、容量小、速度快。" />
              <outline text="SLC闪存的优点是复写次数高达100000次，比MLC闪存高10倍。" />
            </outline>
            <outline text="MLC">
              <outline text="Multi-Level Cell 多层单元。" />
              <outline text="MLC的特点是容量大，但速度慢。" />
              <outline text="MLC的每个单元是2bit的，相对SLC来说整整大了一倍。" />
              <outline text="由于结构复杂，出错的几率增加，需要做错误修正，导致其性能大幅落后于SLC闪存。 " />
            </outline>
          </outline>
        </outline>
        <outline text="SD/EMMC问题定位经验  #经验总结 ">
          <outline text="注意sd卡插拔诊断方式的处理代码，是否整个sd卡初始化流程根本没有启动。" />
          <outline text="电源电压值是否ok，是否没有打开电源。出现的概率最高，也最好测出来。" />
          <outline text="上电时序要符合协议要求；0到2.6V，要平滑上升。" />
          <outline text="clk是否成功配下去，clk线的速率是否和配置值吻合;  data 线是否有数据交互。" />
          <outline text="sd卡的类型是否成功识别；" />
          <outline text="是否底层已经初始化成功，但是没有正确的通知上层，导致ui无法访问卡内容；" />
          <outline text="读卡过程中出现 crc fail错误，一般为频率太高。我们的硬件信号在50M高速传输下有问题，将其改为20M此错误会不出现。" />
          <outline text="sd卡 第0个sector 读失败，导致FAT32 无法mount，很像兼容性问题。格式化能解决该问题（数据会丢失）。" />
          <outline text="文件夹混乱问题。使用 winhex.exe 定位。" />
          <outline text="SD卡初始化时间过长，导致时序相关问题。（升级时vvs不恢复）" />
          <outline text="SD卡访问速度太慢问题。排除卡自身的问题后，软件方面的原因较可能是时钟频率设得太低。" />
          <outline text="sd卡错误处理中断注册的问题。高通代码中对sd卡的大部分中断都没有处理，导致一些问题。遇到了注册上即可。" />
          <outline text="在上层调用底层接口往sd卡写数据之前，应该清一下cache；因为底层sd卡读写是采用DMA 方式。如果cache和内存有不同步的地方，则DMA会写入错误的数据。" />
          <outline text="由于高通默认配置中，蓝牙电源使用GP1配置，而我们的硬件上GP1电源给SD卡。但是相关代码没有按照这个修改来调整，导致蓝牙开关电源时实际上是在控制GP1电源，最终导致sd卡状态不正常。" />
          <outline text="文件名超长问题。" />
          <outline text="文件只读导致无法修改、删除、剪贴。" />
          <outline text="seek超过文件大小的问题。" />
          <outline text="文件系统性能。" />
        </outline>
        <outline text="" />
        <outline text="&lt;b&gt;USB协议&lt;/b&gt;">
          <outline text="端点">
            <outline text="位于USB设备或主机上的一个数据缓冲区，用来存放和发送USB的各种数据，每一个端点都有惟一的确定地址，有不同的传输特性（如输入端点、输出端点、配置端点、批量传输端点）" />
          </outline>
          <outline text="帧">
            <outline text="时间概念，在USB中，一帧就是1MS，它是一个独立的单元，包含了一系列总线动作，USB将1帧分为好几份，每一份中是一个USB的传输动作。" />
          </outline>
          <outline text="上行、下行">
            <outline text="设备到主机为上行，主机到设备为下行" />
          </outline>
          <outline text="USB的传输线结构是如何的呢？">
            <outline text="一条USB的传输线分别由地线、电源线、D+、D-四条线构成，D+和D-是差分输入线." />
            <outline text="使用的是3.3V的电压，而电源线和地线可向设备提供5V电压." />
            <outline text="最大电流为500MA（可以在编程中设置的，至于硬件的实现机制，就不要管它了）。" />
          </outline>
          <outline text="USB的编码方案">
            <outline text="数据在USB线里传送是由低位到高位发送的。" />
            <outline text="USB采用不归零取反来传输数据，当传输线上的差分数据输入0时就取反，输入1时就保持原值." />
            <outline text="为了确保信号发送的准确性，当在USB总线上发送一个包时，传输设备就要进行位插入***作（即在数据流中每连续6个1后就插入一个0），从而强迫NRZI码发生变化。" />
          </outline>
          <outline text="USB的数据格式是怎么样的呢？">
            <outline text="USB数据是由二进制数字串 构成的，首先数字串构成域（有七种），域再构成包，包再构成事务（IN、OUT、SETUP），事务最后构成传输（中断传输、并行传输、批量传输和控制传 输）。" />
            <outline text="域：是USB数据最小的单位，由若干位组成（至于是多少位由具体的域决定），域可分为七个类型：">
              <outline text="同步域（SYNC），八位，值固定为0000 0001，用于本地时钟与输入同步" />
              <outline text="标识域（PID），由四位标识符+四位标识符反码构成，表明包的类型和格式，这是一个很重要的部分，这里可以计算出，USB的标识码有16种，具体分类请看问题五。" />
              <outline text="地址域（ADDR）：七位地址，代表了设备在主机上的地址，地址000 0000被命名为零地址，是任何一个设备第一次连接到主机时，在被主机配置、枚举前的默认地址，由此可以知道为什么一个USB主机只能接127个设备的原因。" />
              <outline text="端点域（ENDP），四位，由此可知一个USB设备有的端点数量最大为16个。" />
              <outline text="帧号域（FRAM），11位，每一个帧都有一个特定的帧号，帧号域最大容量0x800，对于同步传输有重要意义（同步传输为四种传输类型之一，请看下面）。" />
              <outline text="数据域（DATA）：长度为0~1023字节，在不同的传输类型中，数据域的长度各不相同，但必须为整数个字节的长度" />
              <outline text="校验域（CRC）：对令牌包和数据包（对于包的分类请看下面）中非PID域进行校验的一种方法，CRC校验在通讯中应用很泛，是一种很好的校验方法，至于具体的校验方法这里就不多说，请查阅相关资料，只须注意CRC码的除法是模2运算，不同于10进制中的除法。" />
            </outline>
            <outline text="包：由域构成的包有四种类型，分别是令牌包、数据包、握手包和特殊包，前面三种是重要的包，不同的包的域结构不同，介绍如下:">
              <outline text="令牌包：可分为输入包、输出包、设置包和帧起始包（注意这里的输入包是用于设置输入命令的，输出包是用来设置输出命令的，而不是放据数的）">
                <outline text="其中输入包、输出包和设置包的格式都是一样的： SYNC+PID+ADDR+ENDP+CRC5（五位的校验码）" />
                <outline text="帧起始包的格式：SYNC+PID+11位FRAM+CRC5（五位的校验码）" />
              </outline>
              <outline text="数据包：分为DATA0包和DATA1包，当USB发送数据的时候，当一次发送的数据长度大于相应端点的容量时，就需要把数据包分为好几个包，分批发送， DATA0包和DATA1包交替发送，即如果第一个数据包是 DATA0，那第二个数据包就是DATA1。">
                <outline text="但也有例外情况，在同步传输中（四类传输类型中之一），所有的数据包都是为DATA0." />
                <outline text="数据格式如下：SYNC+PID+0~1023字节+CRC16" />
              </outline>
              <outline text="握手包：结构最为简单的包，格式如下: SYNC+PID" />
            </outline>
            <outline text="事务: 分别有IN事务、OUT事务和SETUP事务三大事务.">
              <outline text="每一种事务都由令牌包、数据包、握手包三个阶段构成，这里用阶段的意思是因为这些包的发送是有一定的时间先后顺序的." />
              <outline text="事务的三个阶段如下：">
                <outline text="令牌包阶段：启动一个输入、输出或设置的事务" />
                <outline text="数据包阶段：按输入、输出发送相应的数据" />
                <outline text="握手包阶段：返回数据接收情况，在同步传输的IN和OUT事务中没有这个阶段，这是比较特殊的。" />
              </outline>
              <outline text="事务的三种类型如下:">
                <outline text="IN事务：">
                  <outline text="令牌包阶段——主机发送一个PID为IN的输入包给设备，通知设备要往主机发送数据；" />
                  <outline text="数据包阶段——设备根据情况会作出三种反应（要注意：数据包阶段也不总是传送数据的，根据传输情况还会提前进入握手包阶段）" />
                  <outline text="1） 设备端点正常，设备往入主机里面发出数据包（DATA0与DATA1交替）；" />
                  <outline text="2） 设备正在忙，无法往主机发出数据包就发送NAK无效包，IN事务提前结束，到了下一个IN事务才继续；" />
                  <outline text="3） 相应设备端点被禁止，发送错误包STALL包，事务也就提前结束了，总线进入空闲状态。" />
                  <outline text="握手包阶段——主机正确接收到数据之后就会向设备发送ACK包。" />
                </outline>
                <outline text="OUT事务：">
                  <outline text="令牌包阶段——主机发送一个PID为OUT的输出包给设备，通知设备要接收数据；" />
                  <outline text="数据包阶段——比较简单，就是主机会设备送数据，DATA0与DATA1交替" />
                  <outline text="握手包阶段——设备根据情况会作出三种反应" />
                  <outline text="1）设备端点接收正确，设备往入主机返回ACK，通知主机可以发送新的数据，如果数据包发生了CRC校验错误，将不返回任何握手信息；" />
                  <outline text="2） 设备正在忙，无法往主机发出数据包就发送NAK无效包，通知主机再次发送数据；" />
                  <outline text="3） 相应设备端点被禁止，发送错误包STALL包，事务提前结束，总线直接进入空闲状态。" />
                </outline>
                <outline text="SETUT事务：">
                  <outline text="令牌包阶段——主机发送一个PID为SETUP的输出包给设备，通知设备要接收数据；" />
                  <outline text="数据包阶段——比较简单，就是主机会设备送数据，注意，这里只有一个固定为8个字节的DATA0包，这8个字节的内容就是标准的USB设备请求命令." />
                  <outline text="握手包阶段——设备接收到主机的命令信息后，返回ACK，此后总线进入空闲状态，并准备下一个传输（在SETUP事务后通常是一个IN或OUT事务构成的传输）" />
                </outline>
              </outline>
            </outline>
            <outline text="传输: 传输由OUT、IN、SETUP事务其中的若干事务构成.">
              <outline text="传输有四种类型，中断传输、批量传输、同步传输、控制传输." />
              <outline text="其中中断传输和批量转输的结构一样，" />
              <outline text="同步传输有最简单的结构，" />
              <outline text="而控制传输是最重要的也是最复杂的传输。" />
              <outline text="中断传输：由OUT事务和IN事务构成，用于键盘、鼠标等HID设备的数据传输中." />
              <outline text="批量传输：由OUT事务和IN事务构成，用于大容量数据传输，没有固定的传输速率，也不占用带宽，当总线忙时，USB会优先进行其他类型的数据传输，而暂时停止批量转输。" />
              <outline text="同步传输：由OUT事务和IN事务构成，有两个特殊地方，第一，在同步传输的IN和OUT事务中是没有返回包阶段的；第二，在数据包阶段所有的数据包都为DATA0." />
              <outline text="控制传输：最重要的也是最复杂的传输，">
                <outline text="控制传输由三个阶段构成（初始设置阶段、可选数据阶段、状态信息步骤），每一个阶段可以看成一个的传输，也就是说控制传输其实是由三个传输构成的." />
                <outline text="控制传输用来于USB设备初次加接到主机之后，主机通过控制传输来交换信息，设备地址和读取设备的描述符，使得主机识别设备，并安装相应的驱动程序，这是每一个USB开发者都要关心的问题。" />
                <outline text="1、初始设置步骤：就是一个由SET事务构成的传输" />
                <outline text="2、可选数据步骤：就是一个由IN或OUT事务构成的传输，这个步骤是可选的，要看初始设置步骤有没有要求读/写数据（由SET事务的数据包阶段发送的标准请求命令决定）" />
                <outline text="3、 状态信息步骤：顾名思义，这个步骤就是要获取状态信息，由IN或OUT事务构成构成的传输，但是要注意这里的IN和OUT事务和之前的INT和OUT事务有两点不同：" />
                <outline text="1） 传输方向相反，通常IN表示设备往主机送数据，OUT表示主机往设备送数据；在这里，IN表示主机往设备送数据，而OUT表示设备往主机送数据，这是为了和可选数据步骤相结合；" />
                <outline text="2） 在这个步骤里，数据包阶段的数据包都是0长度的，即SYNC+PID+CRC16" />
              </outline>
            </outline>
          </outline>
          <outline text="标识码有哪些？">
            <outline text="如同前面所说的标识码由四位数据组成，因此最多可以表示十六种标识码，在USB1.1规范里面，只用了十种标识码，USB2.0使用了十六种标识码. " />
            <outline text="标 识码的作用是用来说明包的属性的，标识码是和包联系在一起的，数据包分为令牌包、数据、握手包和特殊包四种. 标识码分别有以下十六种：" />
            <outline text="令牌包 :">
              <outline text="0x01 输出(OUT）启动一个方向为主机到设备的传输，并包含了设备地址和标号" />
              <outline text="0x09 输入 (IN) 启动一个方向为设备到主机的传输，并包含了设备地址和标号" />
              <outline text="0x05 帧起始（SOF）表示一个帧的开始，并且包含了相应的帧号" />
              <outline text="0x0d 设置（SETUP）启动一个控制传输，用于主机对设备的初始化" />
            </outline>
            <outline text="数据包 :">
              <outline text="0x03 偶数据包（DATA0）." />
              <outline text="0x0b 奇数据包（DATA1）." />
            </outline>
            <outline text="握手包:">
              <outline text="0x02 确认接收到无误的数据包（ACK）" />
              <outline text="0x0a 无效，接收（发送）端正在忙而无法接收（发送）信息" />
              <outline text="0x0e 错误，端点被禁止或不支持控制管道请求" />
              <outline text="特殊包 0x0C 前导，用于启动下行端口的低速设备的数据传输" />
            </outline>
          </outline>
          <outline text="USB主机是如何识别USB设备的？">
            <outline text="当USB设备插上主机时，主机就通过一系列的动作来对设备进行枚举配置（配置是属于枚举的一个态，态表示暂时的状态），这这些态如下：" />
            <outline text="1、接入态（Attached）：设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入；" />
            <outline text="2、供电态（Powered）：就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值（按数据中要求的最大值，可通过编程设置）" />
            <outline text="3、缺省态（Default）：USB在被配置之前，通过缺省地址0与主机进行通信；" />
            <outline text="4、地址态（Address）：经过了配置，USB设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；" />
            <outline text="5、配置态（Configured）：通过各种标准的USB请求命令来获取设备的各种信息，并对设备的某此信息进行改变或设置。" />
            <outline text="6、挂起态（Suspended）：总线供电设备在3ms内没有总线***作，即USB总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过280UA。" />
          </outline>
          <outline text="标准的USB设备请求命令究竟是什么？">
            <outline text="标准的USB设备请求命令是用在控制传输中的“初始设置步骤”里的数据包阶段（即DATA0，由八个字节构成），请看回问答四的内容。标准USB设 备请求命令共有11个，大小都是8个字节，具有相同的结构，由5 个字段构成（字段是标准请求命令的数据部分），结构如下（括号中的数字表示字节数，首字母bm,b,w分别表示位图、字节，双字节）：" />
            <outline text="bmRequestType(1) + bRequest（1）+wvalue（2）+wIndex（2）+wLength（2）" />
            <outline text="各字段的意义如下：">
              <outline text="bmRequestType：D7D6D5D4D3D2D1D0">
                <outline text="D7=0主机到设备, =1设备到主机；" />
                <outline text="D6D5=00标准请求命令; =01 类请求命令; =10用户定义的命令; =11保留值" />
                <outline text="D4D3D2D1D0=00000 接收者为设备. =00001 接收者为设备; =00010 接收者为端点; =00011 接收者为其他接收者; =其他 其他值保留" />
              </outline>
              <outline text="bRequest：请求命令代码，在标准的USB命令中，每一个命令都定义了编号，编号的值就为字段的值，编号与命令名称如下（要注意这里的命令代码要与 其他字段结合使用，可以说命令代码是标准请求命令代码的核心，正是因为这些命令代码而决定了11个USB标准请求命令）：">
                <outline text="0） 0 GET_STATUS：用来返回特定接收者的状态" />
                <outline text="1） 1 CLEAR_FEATURE：用来清除或禁止接收者的某些特性" />
                <outline text="2） 3 SET_FEATURE：用来启用或激活命令接收者的某些特性" />
                <outline text="3） 5 SET_ADDRESS：用来给设备分配地址" />
                <outline text="4） 6 GET_DEscriptOR：用于主机获取设备的特定描述符" />
                <outline text="5） 7 SET_DEscriptOR：修改设备中有关的描述符，或者增加新的描述符" />
                <outline text="6） 8 GET_CONFIGURATION：用于主机获取设备当前设备的配置值（注同上面的不同）" />
                <outline text="7） 9 SET_CONFIGURATION：用于主机指示设备采用的要求的配置" />
                <outline text="8） 10 GET_INTERFACE：用于获取当前某个接口描述符编号" />
                <outline text="9） 11 SET_INTERFACE：用于主机要求设备用某个描述符来描述接口" />
                <outline text="10） 12 SYNCH_FRAME：用于设备设置和报告一个端点的同步帧" />
              </outline>
            </outline>
            <outline text="以上的11个命令要说得明白真的有一匹布那么长，请各位去看书吧，这里就不多说了，控制传输是USB的重心，而这11个命令是控制传输的重心，所以这11个命令是重中之重，这个搞明白了，USB就算是入门了。" />
          </outline>
          <outline text="Descriptor, 即描述符">
            <outline text="是一个完整的数据结构，可以通过C语言等编程实现，并存储在USB设备中，用于描述一个USB设备的所有属性， USB主机是通过一系列命令来要求设备发送这些信息的。" />
            <outline text="它的作用就是通过如问答节中的命令***作来给主机传递信息，从而让主机知道设备具有什么功能、属 于哪一类设备、要占用多少带宽、使用哪类传输方式及数据量的大小." />
            <outline text="只有主机确定了这些信息之后，设备才能真正开始工作。" />
            <outline text="标准的描述符有5种，USB为这些描述符定义了编号：" />
            <outline text="设备描述符">
              <outline text="struct _DEVICE_DEscriptOR_STRUCT {">
                <outline text="BYTE bLength; //设备描述符的字节数大小，为0x12" />
                <outline text="BYTE bDescriptorType; //描述符类型编号，为0x01" />
                <outline text="WORD bcdUSB; //USB版本号" />
                <outline text="BYTE bDeviceClass; //USB分配的设备类代码，0x01~0xfe为标准设备类，0xff为厂商自定义类型" />
                <outline text="//0x00不是在设备描述符中定义的，如HID" />
                <outline text="BYTE bDeviceSubClass; //usb分配的子类代码，同上，值由USB规定和分配的" />
                <outline text="BYTE bDeviceProtocl; //USB分配的设备协议代码，同上" />
                <outline text="BYTE bMaxPacketSize0; //端点0的最大包的大小" />
                <outline text="WORD idVendor; //厂商编号" />
                <outline text="WORD idProduct; //产品编号" />
                <outline text="WORD bcdDevice; //设备出厂编号" />
                <outline text="BYTE iManufacturer; //描述厂商字符串的索引" />
                <outline text="BYTE iProduct; //描述产品字符串的索引" />
                <outline text="BYTE iSerialNumber; //描述设备序列号字符串的索引" />
                <outline text="BYTE bNumConfiguration; //可能的配置数量" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="配置描述符">
              <outline text="struct _CONFIGURATION_DEscriptOR_STRUCT {">
                <outline text="BYTE bLength; //设备描述符的字节数大小，为0x12" />
                <outline text="BYTE bDescriptorType; //描述符类型编号，为0x01" />
                <outline text="WORD wTotalLength; //配置所返回的所有数量的大小" />
                <outline text="BYTE bNumInterface; //此配置所支持的接口数量" />
                <outline text="BYTE bConfigurationVale; //Set_Configuration命令需要的参数值" />
                <outline text="BYTE iConfiguration; //描述该配置的字符串的索引值" />
                <outline text="BYTE bmAttribute; //供电模式的选择" />
                <outline text="BYTE MaxPower; //设备从总线提取的最大电流" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="字符描述符">
              <outline text="struct _STRING_DEscriptOR_STRUCT {">
                <outline text="BYTE bLength; //设备描述符的字节数大小，为0x12" />
                <outline text="BYTE bDescriptorType; //描述符类型编号，为0x01" />
                <outline text="BYTE SomeDescriptor[36];  //UNICODE编码的字符串" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="接口描述符">
              <outline text="struct _INTERFACE_DEscriptOR_STRUCT {">
                <outline text="BYTE bLength; //设备描述符的字节数大小，为0x12" />
                <outline text="BYTE bDescriptorType; //描述符类型编号，为0x01" />
                <outline text="BYTE bInterfaceNunber; //接口的编号" />
                <outline text="BYTE bAlternateSetting;//备用的接口描述符编号" />
                <outline text="BYTE bNumEndpoints; //该接口使用端点数，不包括端点0" />
                <outline text="BYTE bInterfaceClass; //接口类型" />
                <outline text="BYTE bInterfaceSubClass;//接口子类型" />
                <outline text="BYTE bInterfaceProtocol;//接口所遵循的协议" />
                <outline text="BYTE iInterface; //描述该接口的字符串索引值" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="端点描述符">
              <outline text="struct _ENDPOIN_DEscriptOR_STRUCT {">
                <outline text="BYTE bLength; //设备描述符的字节数大小，为0x12" />
                <outline text="BYTE bDescriptorType; //描述符类型编号，为0x01" />
                <outline text="BYTE bEndpointAddress; //端点地址及输入输出属性" />
                <outline text="BYTE bmAttribute; //端点的传输类型属性" />
                <outline text="WORD wMaxPacketSize; //端点收、发的最大包的大小" />
                <outline text="BYTE bInterval; //主机查询端点的时间间隔" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="上面的描述符之间有一定的关系，一个设备只有一个设备描述符，而一个设备描述符可以包含多个配置描述符，而一个配置描述符可以包含多个接口描述符，一个接口使用了几个端点，就有几个端点描述符。" />
          </outline>
        </outline>
        <outline text="USB autorun方案">
          <outline text="方案的主要思想是自动安装驱动和后台软件." />
          <outline text="它要解决的核心问题是手机侧如何知道pc上是否安装了usb 驱动。" />
          <outline text="有两种方案:">
            <outline text="由手机来判断pc是否安装驱动.">
              <outline text="优缺点: 便利. 但是受制于windows的实现." />
              <outline text="方案也有两种:">
                <outline text="延迟判断法">
                  <outline text="usb驱动按照modem、diag口（串口）、光盘来设计，第一个口是modem。" />
                  <outline text="手机插入后，先报唯一一个光盘。" />
                  <outline text="然后，如果pc安装过驱动，则pc会认为第一个端口为modem，它不会发命令查看光盘的内容。" />
                  <outline text="如果没有安装驱动，pc会加载标准光盘启动，并查看光盘内容。" />
                  <outline text="经验表明，这个时间大约是3秒。3秒内，pc没查询光盘内容，则表明它安装过驱动，此时手机自动切换为三端口。" />
                </outline>
                <outline text="set feature判断法">
                  <outline text="这个方案的本质和延迟判断法基本一样，根据pc在两种情况下的行为不同来判断。" />
                  <outline text="但是判断的是set feature命令。" />
                  <outline text="如果没有安装驱动，pc会加载光盘驱动，不会发set feature命令；" />
                  <outline text="如果相反，则会发。" />
                  <outline text="所以当收到set feature时，就切换三端口。" />
                </outline>
              </outline>
            </outline>
            <outline text="由手机光盘中的exe程序自动启动后从windows系统中判断是否安装驱动。" />
          </outline>
          <outline text="Android手机上, 没有使用 autorun方案, 仅保留光盘." />
        </outline>
        <outline text="USB spec">
          <outline text="device">
            <outline text="对应物理设备本身。" />
            <outline text="device descriptor包括：">
              <outline text="USB版本号" />
              <outline text="设备类型" />
              <outline text="子类型" />
              <outline text="协议类型（这三个字段在多设备中是空的）" />
              <outline text="EP包大小" />
              <outline text="vendor id及字符串" />
              <outline text="产品id及字符串" />
              <outline text="支持的配置数量" />
            </outline>
          </outline>
          <outline text="configuration">
            <outline text="一个device至少有个一个配置，一般就一个。" />
            <outline text="config des包括：">
              <outline text="支持的interface数量" />
              <outline text="是否直供电" />
              <outline text="是否支持远程唤醒" />
              <outline text="需要的最大总线电量" />
            </outline>
          </outline>
          <outline text="interface">
            <outline text="一个配置至少一个接口；" />
            <outline text="多用途设备会有多个接口；接口数量和端口数量一一对应。" />
            <outline text="interface des中包括：">
              <outline text="设备类型" />
              <outline text="子类型" />
              <outline text="协议类型" />
              <outline text="支持的EP数量" />
            </outline>
          </outline>
          <outline text="EP">
            <outline text="EP是位于usb设备或主机上的一个数据缓冲区。一个端口至少有一对端点。" />
            <outline text="EP des包括：">
              <outline text="EP地址">
                <outline text="EP地址包括ID和方向。每个EP是编号和方向唯一确定的." />
                <outline text="EP地址的结构是：0-3为EP id，即最多有16对。" />
                <outline text="方向">
                  <outline text="IN（device-&amp;gt;host）" />
                  <outline text="OUT（hos-&amp;gt;device）。" />
                  <outline text="第7位为方向：out=0，in=1." />
                </outline>
              </outline>
              <outline text="传输类型">
                <outline text="control: 用于控制，专指EP0">
                  <outline text="host发起的配置命令等，专用EP0通道。" />
                  <outline text="EP0为短向的，其它都是单向的。" />
                  <outline text="可分配10%带宽，如不用则分配给bulk传输。" />
                </outline>
                <outline text="bulk: 块传输. 比如U盘.">
                  <outline text="支持大量数据，但无时间要求。" />
                  <outline text="块传输没有保留带宽，但可使用当前总线所有空闲带宽，最高可达90%。" />
                </outline>
                <outline text="interrupt: 中断传输. 比如键盘鼠标.">
                  <outline text="响应时间受限的少量数据，如事件通知、键盘、鼠标设备等。" />
                  <outline text="中断传输在初始化时就会申请足够的带宽，如果当前系统满足不了，则初始化失败。" />
                  <outline text="申请的带宽会一直保留。" />
                </outline>
                <outline text="同步传输: 比如USB语音.">
                  <outline text="响应时间受限的大量数据，如语音通话。同步传输可分配90%的带宽。" />
                </outline>
              </outline>
            </outline>
            <outline text="EP 0为控制通道，不需要EP des。" />
          </outline>
          <outline text="windows系统usb识别的特殊问题">
            <outline text="windows用vid、pid、interface id来区分一个usb设备">
              <outline text="如果3者都一样，则被认为是同一个设备。" />
              <outline text="windows会保存EP number到注册表中, 而不从驱动配置文件中获取." />
              <outline text="如果某个设备修改了EP，则需要更新这三个中的至少一个，否则会通讯失败。" />
            </outline>
            <outline text="windows识别设多端口备的另一个要求">
              <outline text="该设备各端口的interface id必须是从0开始，连续排列的。" />
            </outline>
          </outline>
          <outline text="如何区分usb host还是usb充电器？">
            <outline text="当前高通方案是，有usb插入，先识别为usb，然后在usb中断中识别是不是充电器。" />
            <outline text="方法是给D+、D-上电，usb host会给D+、D-加下拉电阻，外部上电，内部状态不变。" />
            <outline text="而充电器是D+、D-短接的，外部上电，内部就上拉。如此就识别到了。" />
            <outline text="非官方充电器，如果没做短接，有两个选择，1是分别上拉看情况；2是就认为是usb，反正后续usb协商无响应，对系统没影响。" />
          </outline>
          <outline text="传输的发起者">
            <outline text="除了中断传输，允许device发起外，其中传输都是host发起。" />
            <outline text="正是这个原因，所以网卡、modem等都需要interrupt EP，因为它们需要device发起的传输。" />
          </outline>
          <outline text="传输的物理单位">
            <outline text="帧，时间概念。" />
            <outline text="1毫秒为1帧，usb传输按帧来组织传输。" />
            <outline text="对usb2.0，大约是12K大小。" />
          </outline>
          <outline text="传输的逻辑单位">
            <outline text="传输。一次请求的发起和结束。" />
            <outline text="事务。一个传输包括一个或多个事务。">
              <outline text="事务由3段组成：标记、数据和握手。" />
              <outline text="每段由1-2个包组成，分别叫标记包、数据包和握手包。" />
            </outline>
            <outline text="包">
              <outline text="只有数据包中有数据，最长不超过64B。" />
              <outline text="包由PID、帧编号、地址、CRC和数据组成。" />
              <outline text="特色包包括帧同步包，包含SOF记号标示帧起始；" />
              <outline text="还有低速向导包。" />
              <outline text="不同传输模式下，包结构不同。" />
              <outline text="块传输的包大小">
                <outline text="1.1协议是 64B;" />
                <outline text="2.0协议是 512B。" />
              </outline>
            </outline>
          </outline>
          <outline text="著名的零包问题">
            <outline text="usb协议中规定，小于size的包表示transfer结束." />
            <outline text="所以如果数据大小正好整除，那么就需要传输一个零包。" />
          </outline>
          <outline text="USB远程唤醒">
            <outline text="suspend的目的是为了节能。" />
            <outline text="当device处在挂起状态时，它从总线上吸取的电流在500uA到2.5mA之间。" />
            <outline text="当host检测总线没有活动一段时间后（大约3-5秒），就会把总线置为低电模式，并不再发帧开始包。" />
            <outline text="当device 3ms没有收到帧开始包后，就应该进入挂起状态，10ms后必须进入此状态。" />
            <outline text="此外，host端在必要的情况下，可随时通过set_prot_feather请求来挂起device。" />
            <outline text="设备处在挂起状态时，两种情况可以使它resume:">
              <outline text="一是总线上的任何活动都导致resume；" />
              <outline text="二是如果device有远程唤醒机制，那么device可在任何情况下请求恢复。" />
            </outline>
            <outline text="" />
          </outline>
          <outline text="双U盘方案">
            <outline text="驱动: androdi_usb_pdata{} 之 nluns = 2，即可。" />
            <outline text="挂载点: system/etc/vold.conf，volume_usb2 之 media_path = /devices/platform/msm_hsusb_host/usb2。" />
            <outline text="FWK: vold模块的修改较多." />
          </outline>
        </outline>
        <outline text="USB线的物理结构">
          <outline text="一条usb线分别有地线、电源线、D+、D- 4条线构成。" />
          <outline text="其中D+、D-为差分输入线，使用3.3V电压。" />
          <outline text="而电源线可向设备提供5V、最高500mA的电流。" />
          <outline text="" />
        </outline>
        <outline text="U盘的serial number问题    #经验总结 ">
          <outline text="windows对U盘的识别策略是：">
            <outline text="如果串号为空，则只识别第一个U盘；" />
            <outline text="如果不为空，但相同，则多个U盘插入，windows会重启；" />
            <outline text="如果不为空，且不同，则可分别识别。" />
          </outline>
          <outline text="对u盘sn号的处理">
            <outline text="google模式下用蓝牙地址；" />
            <outline text="CTS模式下用字符串“hw_smart_phone”的asc码（因为CTS需要在linux下测试，需要串号）。" />
            <outline text="normal等其它模式都没有sn号。" />
          </outline>
        </outline>
        <outline text="USB传输速率的优化经验（MTP）  #经验总结 ">
          <outline text="没有并行的使用usb，而是采用传输--处理--传输的方式。改为改为并行方式，最佳情况下速率可提高一倍。" />
          <outline text="sd卡写操作是一个瓶颈，可以绕开vfs接口，直接用驱动接口（要先从vfs上unmount sd卡）。" />
          <outline text="更新sql，要和其它逻辑并行，因为这些sql数据，都是被动收到的信息，不影响后续逻辑，缓存起来慢慢写没有问题。" />
          <outline text="各层buffer都使用乒乓buffer，两个满了再等待。或者用buffer队列。" />
          <outline text="buffer放大到64K。" />
          <outline text="上层直接用底层buffer，可减少若干次memcpy。要注意，上层要及时读走数据。" />
          <outline text="收到的文件放在底层写。" />
        </outline>
        <outline text="通讯问题必须先分清是链路层问题还是应用层问题  #经验总结 ">
          <outline text="链路层不问数据内容，主要收到正确即返回ACK；这个响应很快。" />
          <outline text="应用层要解析数据内容后，再根据内容是否正确做适当响应；这个响应很慢。" />
          <outline text="Response 是链路层，还是应用层? 如果是链路层，则只要收到就会ACK；如果是应用层，则必须识别后才能response." />
        </outline>
        <outline text="设计通讯协议的关注项  #经验总结 ">
          <outline text="字节序。x86和arm正好相反，需要注意。" />
          <outline text="4字节对齐；非常容易出问题。" />
          <outline text="常见错误是字段类型的预期不一致。length字段的宽度要统一，4字节还是2字节；" />
          <outline text="字符串编码，是utf8还是ascii/GBT。" />
          <outline text="字符串是用C字符串，还是Pascal字符串；" />
          <outline text="数组的实现，比如MTP数组在开始有4字节的长度。" />
        </outline>
      </outline>
      <outline text="28-安全">
        <outline text="安全包括如下内容：">
          <outline text="保密性（数据加密）" />
          <outline text="完整性" />
          <outline text="可靠性（不可篡改）" />
          <outline text="可用性（不可失去能力）" />
          <outline text="不可抵赖性" />
          <outline text="可控性" />
        </outline>
        <outline text="加密算法 (完成保密性)">
          <outline text="对称算法">
            <outline text="又叫传统密码方法，是n多种算法的统称。" />
            <outline text="基于秘钥。" />
            <outline text="主要特征是加密和解密用的秘钥一样。" />
            <outline text="由于安全系数比较低，二战后长期普遍不用，直到DES出现。" />
            <outline text="DES">
              <outline text="全称为Data Encryption Standard，即数据加密标准。" />
              <outline text="1977年被美国政府确定为联邦资料处理标准，开始流行。" />
              <outline text="优点是速度较快，适用于加密大量数据的场合。" />
              <outline text="被认为是不安全的。" />
              <outline text="DES设计中使用了分组密码设计的两个原则：混淆（confusion）和扩散(diffusion)，其目的是抗击敌手对密码系统的统计分析。">
                <outline text="混淆是使密文的统计特性与密钥的取值之间的关系尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的。" />
                <outline text="扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。" />
              </outline>
              <outline text="DES算法的入口参数有三个：Key、Data、Mode。">
                <outline text="Key为7个字节共56位，是DES算法的工作密钥；" />
                <outline text="Data为8个字节64位，是要被加密或被解密的数据；" />
                <outline text="Mode为DES的工作方式,有两种:加密或解密。" />
              </outline>
            </outline>
            <outline text="AES">
              <outline text="高级加密标准（Advanced Encryption Standard）。取代DES。" />
              <outline text="AES使用的是区块置换-组合架构。" />
              <outline text="区块长度固定为128位，密钥长度则可以是128，192或256位。" />
              <outline text="被认为是安全的。" />
              <outline text="代码：">
                <outline text="crypto_aes_init()" />
                <outline text="crypto_aes_encrypt_block：块加密，输入必须为块长的整数倍" />
                <outline text="crypto_aes_deencrypt_block：块解密" />
              </outline>
            </outline>
          </outline>
          <outline text="非对称算法">
            <outline text="主要特征是加密、解密分别用不同的密钥。其中解密的叫公钥，可以公开，因此又叫公开密钥算法。" />
            <outline text="加密的叫私钥，不能公开。" />
            <outline text="RSA">
              <outline text="RSA是最有影响力的非对称算法，业界公认它能抵抗迄今为止已知的所有的攻击方法。" />
              <outline text="RSA于1978年发明。" />
              <outline text="其优势是公钥公开，适应网络的开放性要求，同时同一算法可支持签名和加密。" />
              <outline text="缺点是算法复杂，效率较低。" />
              <outline text="为了保证安全，请使用 1024、2048位。" />
              <outline text="RSA的安全性依赖大数分解。">
                <outline text="公钥和私钥都是两个大素数（大于100个二进制位）的函数。" />
                <outline text="据推测，从一个密钥和密文推断出明文的难度等同于分解两个素数的积。" />
              </outline>
              <outline text="RSA可用于签名，即私钥加密，公钥解密。" />
              <outline text="也可用于加密，公钥加密，私钥解密。" />
              <outline text="代码">
                <outline text="rsa_public_decrypt：公钥解密" />
                <outline text="ras_private_encrypt：私钥加密" />
                <outline text="有反过来用的api。" />
              </outline>
            </outline>
            <outline text="DSA">
              <outline text="1024位。" />
              <outline text="被认为是安全的。" />
            </outline>
            <outline text="PH">
              <outline text="1024、2048位。" />
              <outline text="被认为是安全的。" />
            </outline>
            <outline text="ECC">
              <outline text="椭圆曲线加密" />
              <outline text="192、216位。" />
              <outline text="被认为是安全的。" />
            </outline>
            <outline text="ECDSA">
              <outline text="椭圆曲线加密" />
              <outline text="192、216位。" />
              <outline text="被认为是安全的。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;公钥加密，私钥签名。&lt;/b&gt;" />
        </outline>
        <outline text="签名和数字证书 (完成除保密性之前的其它内容)">
          <outline text="加密签名都要求接受信息的一方获得正确的公钥，这就是数字证书的作用了。" />
          <outline text="签名算法">
            <outline text="数字签名有两种功效：">
              <outline text="1是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。" />
              <outline text="2是数字签名能确定消息的完整性。" />
            </outline>
            <outline text="做法是对一段明文做 SHA/MD5 等算法；要求得到的值要短，且尽可能是唯一的。" />
            <outline text="一个高效的数字签名技术 = 消息摘要技术 + 非对称加密技术（RSA算法）。" />
            <outline text="CRC">
              <outline text="循环冗余校验。" />
              <outline text="算法历史较长，版本多样，应用很广泛。" />
              <outline text="通讯领域用得最多的是CRC32，它由不限长的数据，生成一个32位的校验值。" />
              <outline text="优势是简单，速度快，缺点是很容易碰撞，只能针对小数据。" />
            </outline>
            <outline text="MD5">
              <outline text="90年代由MIT发明，经由md2、md3、md4发展起来。" />
              <outline text="将任意上的字符串变换成一个128位的整数，不可逆，即无法由密文转为明文。" />
              <outline text="MD5的典型应用时对一段数据产生指纹，以防止被“篡改”，这就是数字签名。" />
              <outline text="被认为是不安全的。" />
              <outline text="代码">
                <outline text="hash_md5_init：初始化" />
                <outline text="hash_md5_update：喂数据进去，可多次调用" />
                <outline text="hash_md5_final：给出结果" />
              </outline>
            </outline>
            <outline text="SHA1 / SHA224 / SHA256 / SHA384 / SHA512">
              <outline text="与CRC、MD5类似，都是一种散列算法。" />
              <outline text="它产生的签名长，更为安全，是散列算法的发展方向。" />
              <outline text="SHA1有160位，其它几种即以位宽命名。" />
              <outline text="SHA1被认为是不安全的。其它几种安全。" />
              <outline text="目前主要用于数字签名。" />
              <outline text="代码">
                <outline text="hash_sha1_init：初始化" />
                <outline text="hash_sha1_update：update数据进去" />
                <outline text="hash_sha1_final：给出结果" />
              </outline>
            </outline>
            <outline text="HMAL-SHA（带密钥）">
              <outline text="强度同SHA。" />
              <outline text="被认为是安全的。" />
            </outline>
          </outline>
          <outline text="数字证书可以保证数字证书里面的公钥确实是这个证书所有者的，这样就可以解决公钥的安全发放了。" />
          <outline text="如何保证这一点呢？这就用到了一种约定。我们理论上认为某些有公信力的机构发放的证书是安全的。" />
          <outline text="这些发放证书的机构叫做&lt;b&gt;CA&lt;/b&gt;（Certificate Authority）。" />
          <outline text="CA用自己的私钥对申请证书的人的公钥和一些基本信息，做签名，然后把申请者的公钥，基本信息，和数字签名放到一起组成一个证书。" />
          <outline text="CA本身也会生成一个证书，是自签名的，也叫根证书，会内置在操作系统里面。" />
          <outline text="一个数字证书包括如下内容：">
            <outline text="证书持有者的信息" />
            <outline text="持有者的公钥" />
            <outline text="证书签发机构（CA）的信息" />
            <outline text="CA机构对证书本身的签名信息" />
          </outline>
          <outline text="数字证书主要用于解决公钥的安全发放问题。" />
        </outline>
        <outline text="&lt;b&gt;Android安全包括如下元素：&lt;/b&gt;" />
        <outline text="应用层">
          <outline text="代码安全">
            <outline text="代码混淆" />
            <outline text="反编译">
              <outline text="apk反编译就是通过使用apk编译工具，将apk文件中的源文件和资源反编译出来，得到的源文件和资源文件可以进行处理后再进行编译，以达到个性化定制、汉化apk等目的。" />
              <outline text="最典型的apk编译工具的核心是apktool，但是因为操作需要调用cmd命令，所以出现了很多具有可视化界面的各种编译工具，像easyapk、apkdb、doapk。" />
              <outline text="方法:">
                <outline text="获取apk（在/system/app下），和dex文件（在/data/dalvik-cache下）。" />
                <outline text="用dex2jar，将dex文件转为jar文件。" />
                <outline text="用jd-gui，将jar转化为java代码。" />
              </outline>
            </outline>
          </outline>
          <outline text="进程隔离  #面试题">
            <outline text="通过进程UID进行进程隔离。" />
            <outline text="继承于linux." />
            <outline text="每个apk都有各自不同的UID. " />
            <outline text="由于私有目录只能由同一uid应用访问, 就保证了进程隔离和数据安全." />
            <outline text="多个app可通过shareuid的方式可以使用同一个userid，这样就可以访问别人的私有目录." />
          </outline>
          <outline text="签名 #面试题 ">
            <outline text="签名是权限系统的重要组成部分。常用于如下场景：">
              <outline text="apk文件必须被开发者数字签名后才可以被安装。" />
              <outline text="当apk升级时，需要检查新版应用的数字签名与已安装的应用程序的签名是否相同，不同会被当做一个新的应用程序。" />
              <outline text="同一开发者可指定不同的应用程序共享UID，进而它们运行于同一进程空间，共享资源。" />
              <outline text="permission在设置/自定义其权限时也经常会使用到签名。" />
              <outline text="对于系统签名的应用，会有一些特殊的功能。" />
            </outline>
            <outline text="签名的作用：">
              <outline text="识别代码的作者。" />
              <outline text="检测应用程序是否发生了改变。" />
              <outline text="在应用程序之间建立信任，以便于应用程序可以安全地共享代码和数据。" />
            </outline>
            <outline text="Keystore &amp;amp; Keytool">
              <outline text="keystore叫做key(密钥)store(仓库)。顾名思义里面的存放的是密钥，分为公钥和私钥。" />
              <outline text="类似于 sqlite 文件的一张表，每一条记录都是一个公私钥对和一些相关信息。" />
              <outline text="Keytool 是jdk提供的一个把钥匙和证书储存到keystore中的工具。">
                <outline text="&lt;b&gt;-genkey：&lt;/b&gt;在用户主目录中创建密钥库（Keystore），后缀名为.keystore。" />
                <outline text="&lt;b&gt;-alias&lt;/b&gt; [alias]：产生别名，后面跟别名内容。若未指定，则别名默认为mykey." />
                <outline text="&lt;b&gt;-keystore：&lt;/b&gt;指定.keystore文件的名称，如：">
                  <outline text="keytool -genkey -keystore dmkf.keystore" />
                </outline>
              </outline>
              <outline text="常用 Keytool 指令操作">
                <outline text="创建Keystore文件，生成一个别名为dmkf，名为dmkf.keystore的文件。">
                  <outline text="keytool -genkey -alias dmkf -keystore dmkf.keystore -keyalg RSA" />
                </outline>
                <outline text="查看Keystore文件，查看名为dmkf.keystore的Keystore文件信息。">
                  <outline text="keytool -list -v -keystore dmkf.keystore" />
                </outline>
                <outline text="输出Keystore证书，密钥库dmkf.keystore中导出别名为dmkf的证书到dmkf.crt文件中（导出的证书中包括主体信息和公钥）。">
                  <outline text="keytool -export -alias dmkf -keystore dmkf.keystore -file dmkf.crt" />
                </outline>
                <outline text="查看导出的证书信息，查看导出并保存在dmkf.crt文件中的证书信息。">
                  <outline text="keytool -printcert -file dmkf.crt" />
                </outline>
                <outline text="导入证书，从名为dmkf.crt文件中取出别名为dmkf的证书信息导入到名为truststore.keystore密钥库中。">
                  <outline text="keytool -import -alias dmfk -keystore truststore.keystore -file dmkf.crt" />
                </outline>
              </outline>
            </outline>
            <outline text="签名方案V1">
              <outline text="最先生成私有、公共密钥和公共密钥证书（仅需要生成一次）。" />
              <outline text="首先对apk里面的所有文件计算hash（使用SHA1算法计算文件的摘要信息，然后用Base64进行编码），然后保存在 MANIFEST.MF，" />
              <outline text="然后再对这些hash计算hash，保存到 CERT.SF，" />
              <outline text="最后再通过 keystore里面的私钥进行加密并保存到 CERT.RSA，这个文件就是证书文件。" />
              <outline text="可以用 openssl 来查看RSA文件中的证书信息和公钥信息。" />
              <outline text=" 证书是自签名的，并不需要由第三方权威机构发布或者认证的。" />
              <outline text="Android中的签名有两种方式：jarsigner和signapk。这两种方式的区别是：">
                <outline text="jarsigner签名时，需要的是keystore文件，而signapk签名的时候是pk8.x509.pem文件。" />
                <outline text="jarsigner签名之后的SF和RSA文件名默认是keystore的别名，而signapk签名之后文件名是固定的:CERT。" />
                <outline text="keystore文件和pk8.x509.pem文件之间可以互相转化。" />
              </outline>
            </outline>
            <outline text="签名方案V2">
              <outline text="v2是一种全文件签名方案，对整个zip文件（包括zip元数据）进行签名；" />
              <outline text="v2下，zipalign需要在签名之前执行；" />
              <outline text="v2的签名工具-apksigner，位于sdk的build-tools目录下，但由于v2是Android7.0之后才推出的，所以只有版本&amp;gt;25的sdk中才能找到apksigner.jar。" />
              <outline text="为了兼容7.0以下设备，需要同时使用v1和v2签名。此时，在7.0及以上设备中只会验证v2签名，在7.0以下设备中，则只会验证v1签名；" />
              <outline text="如果试图删除v2签名保留v1签名，系统同样会验证不通过，即“防回滚保护”。" />
            </outline>
          </outline>
          <outline text="权限控制 #面试题 ">
            <outline text="Android应用通过权限字符串来控制权限。权限字符串通过签名来保证不被篡改。" />
            <outline text="安装位置会影响权限">
              <outline text="在 system/app下面安装的应用是 system level，能获得一些危险权限，比如静默安装权限。" />
              <outline text="在 data/app 下面安装的应用是 app level." />
            </outline>
            <outline text="在AndroidManifest中定义Permission">
              <outline text="系统会根据应用在AndroidManifest.xml中声明的use-permission而在访问相应api或资源时判断其是否有访问权限，比如常用的android.permission.INTERNET等。" />
              <outline text="这个是最主要的权限控制，一般开发者开发应用主要是接触这个." />
            </outline>
          </outline>
          <outline text="安全模式">
            <outline text="android4.1支持安全模式。" />
            <outline text="在这种模式下，手机界面上显示“safe mode”，并停用所有第三方应用，以方便对问题手机进行检查和维护。" />
            <outline text="进入方式：默认为长按power键，一直到“进入安全模式”菜单出现，然后选择即进入。" />
          </outline>
        </outline>
        <outline text="应用框架">
          <outline text="数字证书" />
        </outline>
        <outline text="Android运行时">
          <outline text="SSL（网络安全库）" />
          <outline text="SQLite（数据库安全）" />
          <outline text="虚拟机（安全沙箱）" />
        </outline>
        <outline text="Kernel层">
          <outline text="root 权限">
            <outline text="如果没有root权限，则 /system/bin/su 文件不存在." />
          </outline>
          <outline text="文件访问控制">
            <outline text="修改文件访问权限：">
              <outline text="system/core/include/private/android_filesystem_config.h，有 android_dirs[], android_files[]。" />
            </outline>
          </outline>
          <outline text="SELinux  #面试题 ">
            <outline text="SELinux之前">
              <outline text="在 SELinux 出现之前，Linux 上的安全模型叫 DAC。" />
              <outline text="DAC，Discretionary Access Control，自主访问控制。" />
              <outline text="DAC 的思想是：进程理论上所拥有的权限与执行它的用户的权限相同。比如，以 root 用户启动 Browser，那么 Browser 就有 root 用户的权限。" />
            </outline>
            <outline text="SELinux之后">
              <outline text="SELinux之后，DAC进化为MAC。" />
              <outline text="MAC，Mandatory Access Control，强制访问控制。" />
              <outline text="MAC 的理论也很简单，任何进程想在 SELinux 系统上干任何事情，都必须在“安全策略文件”中赋予权限，凡是没有出现在安全策略文件中的权限，就不行。" />
              <outline text="Linux 系统先做 DAC 检查。如果没有通过 DAC 权限检查，则操作直接失败。通过 DAC 检查之后，再做 MAC 权限检查。" />
              <outline text="SELinux 有自己的一套规则来编写安全策略文件，这套规则被称之为 SELinux Policy 语言。" />
              <outline text="SELinux 按照默认拒绝的原则运行：任何未经明确允许的行为都会被拒绝。" />
              <outline text="&lt;b&gt;MAC的本质: 没有MAC, 则有root 权限后就可以访问所有文件. 有了MAC, root也不能随便访问文件.&lt;/b&gt;" />
            </outline>
            <outline text="SELinux的两种模式">
              <outline text="宽容模式(permissive)：权限拒绝事件会被记录到Log中，但不会被强制执行。" />
              <outline text="强制模式(enforcing)：权限拒绝事件会被记录下来并强制执行。" />
            </outline>
            <outline text="权限标签。重要">
              <outline text="SELinux依靠标签来匹配任何访问操作和政策。" />
              <outline text="标签在启动过程中给定。" />
              <outline text="打标签的对象包括文件、进程和socket等。" />
              <outline text="标签存放在te 文件中。" />
              <outline text="路径在 /device/&amp;lt;company&amp;gt;/common/sepolicy 及 /device/&amp;lt;company&amp;gt;/$DEVICE/sepolicy 中。" />
              <outline text="定义语法是 “user:role:type:mls_level ”形式（如u:r:init:s0），其中type是关键信息。" />
              <outline text="如果我们需要某些进程对某些目标具有操作权限，需要用这种：allow domains types:classes permissions的形式">
                <outline text="Domain：一个进程或一组进程的标签。也称为域类型，因为它只是指进程的类型。" />
                <outline text="Type：一个对象（例如，文件、套接字）或一组对象的标签。" />
                <outline text="Class：要访问的对象（例如，文件、套接字）的类型。" />
                <outline text="Permission：要执行的操作（例如，读取、写入）。" />
                <outline text="比如 allow init ipa_dev:chr_file open，表示init进程可以对chr_file类型的ipa_dev具有open权限。" />
              </outline>
              <outline text="注意： te文件必须以空行结束。建议在文件末尾放三四个空行。" />
            </outline>
            <outline text="权限拒绝事件的log">
              <outline text="在dmesg 和 logcat 都有。" />
              <outline text="关键字：avc-denied" />
            </outline>
            <outline text="如何查看进程的标签？">
              <outline text="标签又叫context，包括如下几种：">
                <outline text="file_contexts    // 文件的安全上下文" />
                <outline text="seapp_contexts  // app安全上下文" />
                <outline text="property_contexts   // 属性的安全上下文" />
                <outline text="service_contexts      // service文件安全上下文" />
                <outline text="genfs_contexts    // 虚拟文件系统安全上下文" />
              </outline>
              <outline text="adb shell ls –Z，可查看文件的sContext。" />
              <outline text="adb shell ps -Z，可查看进程的sContext。" />
            </outline>
            <outline text="临时关闭SELinux">
              <outline text="setenforce 0" />
              <outline text="修改的是 /sys/fs/selinux/enforce 节点的值。断电之后，节点值会复位。" />
            </outline>
            <outline text="永久关闭SELinux">
              <outline text="kernel 关闭 selinux：SECURITY_SELINUX 设置为 false，重新编译 kernel" />
              <outline text="设置 ro.boot.selinux=permissive 属性，并且修改在 system/core/init/Android.mk 中设置用于 user 版本下 selinux 模式为 permissive。" />
            </outline>
          </outline>
          <outline text="FDE，全盘加密">
            <outline text="Full Disk Encryption。从Android 4.4开始。Android 5.0开始必须打开。" />
            <outline text="对 /data/和sdcard 进行数据加密。" />
            <outline text="基于文件的加密。" />
            <outline text="加密感知型应用：" />
            <outline text="功能">
              <outline text="在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：" />
              <outline text="ce（user/0）：凭据加密 (CE) 存储空间。这是默认存储位置，只有在用户解锁设备后才可用。">
                <outline text="加密方式：">
                  <outline text="EXT4 加密">
                    <outline text="FBF使用了EXT4文件系统的加密机制，配置为：">
                      <outline text="采用 XTS 模式的 AES-256 算法加密文件内容；" />
                      <outline text="采用 CBC-CTS 模式的 AES-256 算法加密文件名" />
                    </outline>
                  </outline>
                </outline>
              </outline>
              <outline text="de（user_de/0）：设备加密 (DE) 存储空间。在直接启动模式（direct boot）期间以及用户解锁设备后均可用。" />
              <outline text="在开机未解锁的场景，ce目录被锁定，只能访问de目录，但是有些应用场景，例如闹钟，即使开机未解锁也需要提供服务，因此需要适配FBE。" />
              <outline text="这种区分能够使工作资料更加安全。" />
              <outline text="应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。" />
            </outline>
            <outline text="启动FDE">
              <outline text="将 fileencryption 标记添加到 userdata 分区最后一列的 fstab 行，即可。" />
              <outline text="必须在可信执行环境 (TEE) 中实现 Keymaster/Keystore 和 Gatekeeper，以便为 DE 密钥提供保护。" />
              <outline text="内核加密性能必须要在使用 AES XTS 时至少达到 50MB/s，以确保良好的用户体验。" />
            </outline>
            <outline text="检查FDE状态">
              <outline text="检查 ro.crypto.state 是否存在，确认 ro.crypto.state 是否已加密。" />
              <outline text="检查 ro.crypto.type 是否存在，确认 ro.crypto.type 是否已设为 file。" />
            </outline>
          </outline>
        </outline>
        <outline text="android系统秘钥源 #面试题">
          <outline text="密钥源 = imei + bt mac + wifi mac + psn" />
          <outline text="其中：psn即emmc的psn号。">
            <outline text="该值为4字节随机数，出厂前写入，无法用软件修改。" />
            <outline text="已确认各供应商都支持该值。" />
          </outline>
        </outline>
        <outline text="OEMINFO">
          <outline text="数据存储方式">
            <outline text="数据按type分，一个type至少占据一块，可以不连续分布。" />
            <outline text="oeminfo分区中，有数据的每块都有一个头，记录该地的type id。" />
            <outline text="因此，可实现不连续存储。" />
          </outline>
          <outline text="type">
            <outline text="otp：RSA公钥A和B。" />
            <outline text="oem_id">
              <outline text="即手机的密钥源。" />
              <outline text="目前有如下几种数据：emei、蓝牙地址、wifi地址、emmc psn号码。" />
              <outline text="所有这些数据，用私钥B加密过，存放在oeminfo中的是密文。" />
            </outline>
            <outline text="simlock数据">
              <outline text="key[5]，5组密码" />
              <outline text="flag：使能标志" />
              <outline text="data：plmn id list。" />
              <outline text="这三部分数据都有不同的加密方式。" />
              <outline text="使用AES加密，可解码成明文。" />
            </outline>
            <outline text="simlock_alterable">
              <outline text="simlock数据中的可修改部分，包括：" />
              <outline text="simlock_dck_count：规定解锁次数" />
              <outline text="simlock_feature_inds" />
            </outline>
            <outline text="nv_backup：rfnv备份数据" />
            <outline text="err_times：nck密码试错的次数（最多5次，5次后手机将锁定，无法搜网）" />
            <outline text="wifi_test：wifi校准数据。" />
            <outline text="prl_roaming_list：prl数据，CDMA用。" />
            <outline text="Type值只能增加，不能减少。" />
          </outline>
          <outline text="头结构">
            <outline text="头结构占据每个block的第一个page，长度有三种：">
              <outline text="emmc和小page nand为512字节，" />
              <outline text="2k nand为2k，" />
              <outline text="4k nand为4k，" />
            </outline>
            <outline text="有效数据则不变，为28字节，由6个字段组成。剩余空间填0xFFFF。" />
            <outline text="头结构包括：">
              <outline text="字段1，8字节长，为migic number，为“oem_info”的asc码值，即 0x5F4D454F 0x4F464849。" />
              <outline text="字段2，version，目前最大为4。表示为4K nand的oeminfo。1表示小块nand，2表示emmc，3没有用。" />
              <outline text="字段3，info_type，数据类型，即oeminfo_info_type_enum_type，目前有大约30多种。" />
              <outline text="字段4，total_blck，本类型共占据多少block；" />
              <outline text="字段5，curr_logical_blck，当前为第多少个block，从1开始；" />
              <outline text="字段6，total_byte，该类型的实际大小，以byte为单位。" />
            </outline>
          </outline>
        </outline>
        <outline text="SimLock">
          <outline text="simlock_key[5]，2组共10个密码。">
            <outline text="第一组5个即 nck密码，用于simlock解锁。">
              <outline text="nck密码解锁：解密时，用户输入一个16位10进制数，经md5加密后和oeminfo中的密文对比。" />
              <outline text="如果匹配，即simlock解锁。" />
            </outline>
            <outline text="第二组，第一个为uck密码，第二个用于diag鉴权.">
              <outline text="nck解锁失败：nck解锁失败10次，手机就锁定了，必须用uck来解。" />
              <outline text="uck可以使用无限次。" />
            </outline>
            <outline text="diag鉴权">
              <outline text="没有鉴权的状态下，diag端口只支持3个鉴权相关的握手命令和一个升级命令。" />
              <outline text="步骤是手机侧生成随机数，传给pc侧私钥加密，然后把密文发给手机侧，手机侧解密后和原来的随机数对比，如吻合则鉴权通过。" />
              <outline text="pc端需要加密狗才可以。" />
              <outline text="鉴权通过后，密码会被置换为16个0." />
            </outline>
            <outline text="其它三套不用。" />
            <outline text="密码的生成方式">
              <outline text="这5套密码均为imei+随机数，并经过md5加密后保存到手机上，即手机上没有保存明文。" />
              <outline text="生产线会在数据库中保存明文，用 emei 可查询。" />
            </outline>
          </outline>
          <outline text="flag：simlock使能标志">
            <outline text="当值为imei+“disable”，并经过md5加密后的值时，将去使能simlock；" />
            <outline text="其它值，或无值，均为使能simlock。" />
          </outline>
          <outline text="simlock_data：simlock数据">
            <outline text="imei号的长度：11字节，8字节有效数据，1字节有效数据长度，2字节crc值。" />
            <outline text="蓝牙地址：6字节蓝牙地址，和2字节crc值。" />
            <outline text="MEID：9字节，7字节有效数据+2字节crc。  ESN：6字节，4字节有效数据+2字节crc。" />
            <outline text="simlock_data数据会用imei做加密。" />
          </outline>
          <outline text="IMSI 数据结构（关键点）">
            <outline text="sim卡中的数据。IMSI共有15位，其结构为 PLMN+MSIN。" />
            <outline text="PLMN">
              <outline text="Public Land Mobile Network，公共陆地移动网络。" />
              <outline text="另外，固定电话系统叫公用交换电话网络（PSTN）。" />
              <outline text="PLMN=MCC+MNC。">
                <outline text="MCC">
                  <outline text="Mobile Country Code，移动国家码，共3位十进制数字。" />
                  <outline text="中国为460。" />
                </outline>
                <outline text="MNC">
                  <outline text="Mobile Network Code，移动网络码，2-3位十进制数字。" />
                  <outline text="中国移动00和02" />
                  <outline text="中国联通01" />
                  <outline text="中国电信03。" />
                </outline>
              </outline>
            </outline>
            <outline text="MSIN">
              <outline text="MSIN = HLR + simcode" />
              <outline text="HLR：子网ID，2字节" />
              <outline text="simcode：&amp;lt;=8字节" />
            </outline>
            <outline text="GID1 / GID2：sim/usim卡上的两个文件，用来标识卡用户的文件。" />
          </outline>
          <outline text="simlock分5级（根据IMSI的数据结构）">
            <outline text="第一级：锁PLMN。解锁码是NCK（网络码）。" />
            <outline text="第二级；锁运营商子网HLR。解锁码：NSCK（子网码）。" />
            <outline text="第三级：锁运营商码GID1。解锁码：SPCK（运营商码）。比较少用。" />
            <outline text="第四级：锁社区、社群。一般不用。" />
            <outline text="第五级：锁指定sim。即只能用指定号。一般不用。" />
          </outline>
          <outline text="simlock方案">
            <outline text="简而言之，就是将simlock_data与sim卡上的IMSI进行匹配，通过了才可以搜网。" />
            <outline text="simlock数据即运营商ID list，和SIM卡的IMSI卡号匹配。" />
            <outline text="匹配方法是：前3位为国家码MCC，后面2-3位为运营商码MNC（具体2位3位取决于MCC），两个字段都匹配上即ok。" />
            <outline text="比如中国移动的运营商ID list包括46000，那么手机IMSI包含这个字符串的手机就只能上中国移动。" />
            <outline text="另外一种是锁HLR和NDC，即锁子网，即只能用运营商指定区域内的网络。很少用。" />
            <outline text="子网定义由运营商自己做，一般由区域码和范围码组成。" />
          </outline>
          <outline text="sim卡上有pin码、puk码">
            <outline text="pin码类似开机密码，用户可以开关其功能，也可以设置其pin码。" />
            <outline text="pin码三次输错，需要用puk码解。" />
            <outline text="puk10次输错，则sim卡自毁。" />
            <outline text="puk码一般在购买sim卡时运营商会告知。" />
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;30-Linux&amp;amp;内核&lt;/b&gt;">
        <outline text="Linux背景知识">
          <outline text="UNIX 和 Linux 有什么不同?">
            <outline text="UNIX（此 名称是源自以前的“Multics”操作系统）于 1969 年在 AT&amp;amp;T 贝尔实验室被创造出来，它是一种健壮的、灵活的和对开发人员友好的计算环境。在其后的很长时间类，它成为最受欢迎的多用户通用操作系统，并在所有计算领域, 甚至包括曾一度被大型机垄断的领域占据主导地位。" />
            <outline text="Linux 不是 UNIX；它只是非常象 UNIX。UNIX 和 Linux 可以在一起非常协调地工作，编写得好的程序可以非常容易地在这两个系统之间进行移植。" />
          </outline>
          <outline text="Unix的强大之处">
            <outline text="简洁. unix 仅提供几百个系统调用. 而其它系统往往提供数千个系统调用，windows7 好几万。" />
            <outline text="抽象。在系统中, 所有的东西都被看做文件. 对数据和设备的操作都可以抽象为 open/read/write/ioctl/close。" />
            <outline text="内核使用c语言, 具有惊人的移植能力。" />
            <outline text="进程创建迅速, 有一个非常独特的fork() 系统调用。" />
            <outline text="简洁稳定的系统间通信原语." />
          </outline>
          <outline text="Linux 是单内核系统">
            <outline text="Linux 内核运行在单独的内核地址空间, 直接调用函数, 无需消息传递。" />
            <outline text="内核为一个不可分割的静态可执行块, 在一个独立的地址空间中运行, 需要硬件提供页机制以管理内存。" />
          </outline>
          <outline text="Linux基本特点">
            <outline text="Unix的优点">
              <outline text="简洁. unix 仅提供几百个系统调用. 而其它系统往往提供数千个系统调用，windows7 好几万。" />
              <outline text="抽象。在系统中, 所有的东西都被看做文件. 对数据和设备的操作都可以抽象为 open/read/write/ioctl/close。" />
              <outline text="内核使用c语言, 具有惊人的移植能力。" />
              <outline text="进程创建迅速, 有一个非常独特的fork() 系统调用。" />
              <outline text="简洁稳定的系统间通信原语." />
            </outline>
            <outline text="1991年, Linux诞生。" />
            <outline text="带奇数的内核版本（即 2.3、2.5、2.7 等）是实验性的开发版内核。" />
            <outline text="稳定的发行版内核的版本号是偶数（即 2.4、2.6、2.8 等）。" />
          </outline>
          <outline text="Linux 分发版">
            <outline text="Linux 内核（核心）连同各种用户界面、实用程序、驱动程序及其它软件打包成可交付给用户的软件包。" />
            <outline text="分发版通常是以免费下载或廉价 CD-ROM 软件包的形式提供给用户的。" />
            <outline text="流行的分发版包括 Caldera OpenLinux、CoreLinux、Debian、Red Hat、Slackware、SuSE、TurboLinux 及其它软件。" />
            <outline text="总的说来，Linux 分发版中出现的许多工具都来自自由软件基金会（Free Software Foundation）的 GNU 项目（GNU 是“GNU's Not UNIX”的缩写）。" />
          </outline>
        </outline>
        <outline text="内核开发的特点  #经验总结 ">
          <outline text="没有内存保护机制；" />
          <outline text="不要在内核中使用浮点数；" />
          <outline text="内核栈很小。不要在栈中使用大的结构." />
          <outline text="内核没有libc库和其它库, 但是大部分库函数已得到实现.">
            <outline text="没有实现的最著名的是 printf(), 请用 printk() 代替." />
            <outline text="printk 可以设置优先级. 如: printk(KERN_ERR &quot;This is a error!&quot;);" />
          </outline>
        </outline>
        <outline text="Linxu环境&amp;amp;编译">
          <outline text="内核编译文件: KCONFIG、Makefile" />
        </outline>
        <outline text="进程管理">
          <outline text="进程">
            <outline text="进程是操作系统最基本的抽象之一。" />
            <outline text="进程即处在执行期的程序. 除程序代码外, 还有文件句柄, 信号, 内核内部数据, 处理器状态, 地址空间, 以及一个或多个线程 ." />
          </outline>
          <outline text="线程">
            <outline text="即进程中活动的对象. 内核调度的对象是线程, 而不是进程。" />
            <outline text="Linux中, 每个线程都有自己的 task_struct." />
            <outline text="在内核眼里, 线程就是进程, 不过线程可以和自己的兄弟线程共享地址空间而已." />
            <outline text="Linux线程和windows线程的区别">
              <outline text="windows等操作系统上, 线程被称为轻量级进程, 进程和线程分别有一套机制来管理. " />
              <outline text="在Linux上, 由于进程就足够轻了. 所以就不做过多的区分." />
            </outline>
          </outline>
          <outline text="linux进程的堆栈">
            <outline text="linux每个用户进程都有自己的堆栈，而且有两个，一个为系统堆栈，除1K的进程控制块外，还有7K的空间供内核进程调度时用于保存进程上下文。" />
          </outline>
          <outline text="创建进程（fork，进程复制)">
            <outline text="linux 中经常通过复制一个现有进程来创建新的进程. ">
              <outline text="目的是快速创建。因为在创建进程过程中仅需要分配新的PID 即可完成. " />
            </outline>
            <outline text="调用 fork 的进程被称为&lt;b&gt;父进程&lt;/b&gt;." />
            <outline text="新产生的进程被称为&lt;b&gt;子进程&lt;/b&gt;。" />
            <outline text="在该调用结束时, 在返回点这个相同位置上, 父进程恢复执行, 子进程开始执行。" />
            <outline text="fork系统调用从内核中返回两次:">
              <outline text="一次回到父进程;" />
              <outline text="一次回到新诞生的子进程。" />
            </outline>
            <outline text="fork 通过返回值来判断现在跑在哪一个进程里。返回值为0表示当前进程为新产生的子进程，不为零（实际为pid）的即为父进程。" />
            <outline text="fork之后这两个进程的关系">
              <outline text="创建后的子进程和父进程共享同一个地址空间的拷贝. " />
              <outline text="只有在需要写入时，才会把父进程的相应页写入子进程的地址空间.  这叫写时拷贝技术." />
              <outline text="如果创建子进程后马上调用 exec() 来 load 自己的代码映像(一般情况是如此) , 则拷贝不需要发生. 因为此种情况下父进程和子进程的地址空间完全不相干." />
              <outline text="这样做提高性能。" />
            </outline>
            <outline text="子进程如何加载自己的代码？">
              <outline text="调用child()加载。" />
            </outline>
          </outline>
          <outline text="创建线程">
            <outline text="创建进程和创建线程基本一样. " />
            <outline text="不同点在于, 创建线程时, 需要指明共享资源." />
          </outline>
          <outline text="进程退出">
            <outline text="进程退出时要清理如下资源：">
              <outline text="内核定时器；" />
              <outline text="用户地址空间；" />
              <outline text="IPC信号；" />
              <outline text="文件描述符；" />
              <outline text="文件系统数据；" />
              <outline text="进程命名空间；" />
              <outline text="信号处理函数." />
            </outline>
            <outline text="经过这一轮清理后, 进程进入僵死状态, 它还占有的资源就是内核栈, thread_info, task_struct, 其目的是向其父进程提供信息。" />
          </outline>
          <outline text="进程控制块（也叫进程描述符）">
            <outline text="每个进程都用进程控制块来描述, 在 sched.h 中定义。" />
            <outline text="所有的进程描述符放在一个叫 task list 的双向链表中. " />
            <outline text="字段包括：" />
            <outline text="进程序号：PID。默认情况下，最大值为32768，这个值可以改。" />
            <outline text="PPID：父进程序号。所有进程都是PID为1的 init进程的后代。" />
            <outline text="vruntime： 虚拟运行时间" />
            <outline text="sum_exec_runtime：进程总共执行的实际时间" />
            <outline text="prev_sum_exec_runtime：上次该进程被调度时已经占用的实际时间。" />
            <outline text="ideal_runtime：在一个调度周期中进程应该运行的实际时间" />
          </outline>
          <outline text="进程状态：state">
            <outline text="task_running：进程可执行(即就绪态). ">
              <outline text="它或者正在执行, 或者在运行队列中等待执行。" />
              <outline text="进程在用户空间中执行的唯一可能的状态。" />
              <outline text="正在执行的进程, 可以被优先级更高的进程抢占, 此时被抢占的进程处在运行队列中等待执行。" />
            </outline>
            <outline text="task_interruptible：进程在睡眠, 或者说被阻塞. ">
              <outline text="进程为了等待特定事件, 在等待队列中睡眠. " />
              <outline text="进程休眠有各种原因, 但肯定是为了等待一些事件. 常见的比如文件IO. 休眠进程放在等待队列中. 等待队列即 wake_queue_head_t." />
              <outline text="一旦等待的事件发生, 进程被唤醒并重新置入运行队列. ">
                <outline text="唤醒操作由 wake_up(), 它会唤醒指定的等待队列中的所有进程." />
                <outline text="通常哪段代码促进等待条件达成, 则负责调用wake_up(). 比如,当磁盘数据到来后, VFS就负责对等待队列调用,以便唤醒等待队列中等待这些数据的进程." />
              </outline>
              <outline text="阻塞中的线程也可以被信号提前唤醒." />
            </outline>
            <outline text="task_uninterruptible">
              <outline text="除了不会因为接受到信号而被唤醒外, 这个状态和上一个一样. " />
              <outline text="在进程执行重要操作时, 比如持有信号量, 为了避免被信号打断当前流程, 而是用此状态. " />
              <outline text="这个状态较少使用." />
            </outline>
            <outline text="task_zombile：僵死">
              <outline text="进程已经结束, 但是父进程还没有调用 wait4() 系统调用. " />
              <outline text="为了父进程能够知道其状态, 子进程的进程描述符仍被保留。" />
            </outline>
            <outline text="task_stopped：停止">
              <outline text="进程收到stop信号时退出，释放所有资源。" />
            </outline>
          </outline>
          <outline text="内核线程">
            <outline text="内核经常需要在后台执行一些操作，通过内核线程完成. " />
            <outline text="内核线程没有独立的地址空间, 它使用统一的内核空间. 其它和普通进程一样。" />
            <outline text="一般内核线程会一直执行. " />
            <outline text="在需要的时候, 它会被唤醒和执行, 然后再次休眠." />
            <outline text="内核模块启动优先级">
              <outline text="在kernel/include/linux/init.h：" />
              <outline text="#define core_initcall(fn) __define_initcall(&quot;1&quot;,fn,1)" />
              <outline text="#define core_initcall_sync(fn) __define_initcall(&quot;1s&quot;,fn,1s)" />
              <outline text="#define postcore_initcall(fn) __define_initcall(&quot;2&quot;,fn,2)" />
              <outline text="#define postcore_initcall_sync(fn) __define_initcall(&quot;2s&quot;,fn,2s)" />
              <outline text="#define arch_initcall(fn) __define_initcall(&quot;3&quot;,fn,3)" />
              <outline text="#define arch_initcall_sync(fn) __define_initcall(&quot;3s&quot;,fn,3s)" />
              <outline text="#define subsys_initcall(fn) __define_initcall(&quot;4&quot;,fn,4)" />
              <outline text="#define subsys_initcall_sync(fn) __define_initcall(&quot;4s&quot;,fn,4s)" />
              <outline text="#define fs_initcall(fn) __define_initcall(&quot;5&quot;,fn,5)" />
              <outline text="#define fs_initcall_sync(fn) __define_initcall(&quot;5s&quot;,fn,5s)" />
              <outline text="#define rootfs_initcall(fn) __define_initcall(&quot;rootfs&quot;,fn,rootfs)" />
              <outline text="#define device_initcall(fn) __define_initcall(&quot;6&quot;,fn,6)" />
              <outline text="#define device_initcall_sync(fn) __define_initcall(&quot;6s&quot;,fn,6s)" />
              <outline text="#define late_initcall(fn) __define_initcall(&quot;7&quot;,fn,7)" />
              <outline text="#define late_initcall_sync(fn) __define_initcall(&quot;7s&quot;,fn,7s)" />
            </outline>
          </outline>
          <outline text="守护程序（Daemon）">
            <outline text="操作系统的后台进程，通常具有 root 安全级别许可权。" />
            <outline text="守护程序通常隐藏在后台，直至被某个事件（例如特定的时间或日期、时间间隔、收到电子邮件等）触发后它才会进入活动状态。" />
          </outline>
          <outline text="进程调度">
            <outline text="2.5之前，Linux 使用传统的UNIX调度算法，即时间片 + 优先级的调度器。" />
            <outline text="2.5上，linux 使用了 O(1) 的调度算法。" />
            <outline text="&lt;b&gt;2.6.23 上，linux 使用了完全公平调度器（CFS），不再使用时间片。&lt;/b&gt;">
              <outline text="同时也支持实时调度（仅在实时操作系统上使用，实际上较少使用）" />
            </outline>
            <outline text="Linux 的两种优先级">
              <outline text="普通优先级">
                <outline text="nice值由 -20到19。" />
                <outline text="默认值为0。" />
                <outline text="值越大优先级越低。" />
                <outline text="nice 值还可以决定分配的时间片的大小, -20 最长 19 最短。" />
              </outline>
              <outline text="实时优先级">
                <outline text="nice 值由 0 到 99. " />
                <outline text="任何实时进程的优先级都高于普通进程。" />
              </outline>
            </outline>
            <outline text="所谓完全公平调度（CFS），就是在选取下个进程的时候，总是选取当前所有普通进程中运行时间最少的进程。" />
            <outline text="但是这里的运行时间，并不是实际运行时间，而是虚拟运行时间。这是CFS 调度算法的关键。">
              <outline text="虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重(优先级)" />
              <outline text="NICE_0_LOAD/ 权重(优先级) 即衰减因子。" />
              <outline text="对于正常优先级的任务（nice值为 0），衰减因子为1，虚拟运行时间与实际物理运行时间是相同的。" />
              <outline text="对于底优先级任务，衰减因子大于1，它的虚拟运行时间上升得越快，因此相当于优先级会更快的衰减。" />
              <outline text="对于底优先级任务，衰减因子小于1，它的虚拟运行时间上升得越慢，因此相当于优先级会更慢的衰减。" />
            </outline>
            <outline text="CFS 采用红黑树来管理task控制块">
              <outline text="当一个任务变成可运行时，它被添加到树上。" />
              <outline text="当一个任务变成不可运行时（例如，当阻塞等待 I/O 时），它从树上被删除。" />
              <outline text="一般来说，得到较少处理时间的任务（虚拟运行时间较小）会偏向树的左侧；得到较多处理时间的任务会偏向树的右侧。" />
              <outline text="根据二分搜索树的性质，最左侧的结点有最小的键值；从 CFS 调度程序角度而言，这也是具有最高优先级的任务。" />
              <outline text="由于红黑树是平衡的，找到最左侧结点会需要 O(lgN) 操作（这里 N 为树内结点总数）。" />
              <outline text="不过，为高效起见，Linux 调度程序将这个值缓存在变量 rb_leftmost 中，从而确定哪个任务运行只需检索缓存的值。" />
            </outline>
            <outline text="&lt;b&gt;调度时机&lt;/b&gt;">
              <outline text="分为3步：" />
              <outline text="1. 判断是否应该被抢占的时机">
                <outline text="当当前进程的本次调度占用实际时间， 大于ideal_runtime时；" />
                <outline text="当前进程的 vruntime(虚拟运行时间)大于红黑树中最小的进程的vruntime，且差值大于ideal_time时." />
              </outline>
              <outline text="2. 应该被抢占，也不会被马上抢占。仅仅在该进程上打一个标签TIF_NEED_RESCHED。" />
              <outline text="3. 真正发生抢占的时机">
                <outline text="当前task主动释放cpu；">
                  <outline text="进程退出" />
                  <outline text="进程收到stop信号" />
                  <outline text="进程代码显式的调用 schedule()函数。" />
                </outline>
                <outline text="当前task被阻塞；" />
                <outline text="当前task进行系统调用，完成，从内核态返回用户态时。" />
                <outline text="从中断处理上下文返回用户空间。" />
                <outline text="从异常处理上下文返回用户空间。" />
                <outline text="在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这时也是一个执行抢占的时机。" />
              </outline>
            </outline>
            <outline text="CFS把线程分为I/O 密集型 和 CPU 密集型">
              <outline text="I/O 密集型：在运行很短时间后就会阻塞以便等待更多的 I/O。">
                <outline text="大部分时间都在等待用户交互. 比如文字编辑。" />
                <outline text="此类程序应该有更高的优先级。" />
              </outline>
              <outline text="CPU 密集型：只要有在处理器上运行的机会，就会用完它的时间片。">
                <outline text="大部分时间都在进行cpu处理. 比如视频编解码程序。" />
              </outline>
              <outline text="判断依据">
                <outline text="看进程休眠的时间长短. 长的就是I/O 密集型，短的就是CPU 密集型。" />
                <outline text="这个推断机制准确得惊人, 而且反应极快, 当一个进程由IO消耗性转变为CPU消耗型, 调度程序会很快做出反应." />
              </outline>
              <outline text="I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。" />
              <outline text="这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。" />
            </outline>
            <outline text="实时调度">
              <outline text="linux 提供了两种实时调度策略: sched_fifo 和 sched_rr." />
              <outline text="前者非时间片, 即这种优先级的进程会一直执行下去, 直到它被阻塞或主动释放cpu. 但是可以被更高优先级的进程抢占." />
              <outline text="后者即带时间片的sched_fifo." />
              <outline text="linux 的实时调度算法提供了一种软实时工作方式, 它不能保证总能满足实时进程的需求。尽管如此, 2.6 的核心可以满足非常严格的实时要求." />
            </outline>
            <outline text="内核抢占">
              <outline text="内核抢占是在2.5.4版本发布时加入, 同SMP(Symmetrical Multi-Processing, 对称多处理器), 作为内核的可选配置。" />
            </outline>
          </outline>
          <outline text="锁处理">
            <outline text="多CPU系统下, 每个CPU都有自己的可执行队列和锁. 但假如各CPU苦乐不均, 那么就需要负载平衡程序来解决." />
          </outline>
          <outline text="kernel 中加延迟的方法">
            <outline text="msleep()：有任务调度的，时间很不准确；" />
            <outline text="mdelay()：无任务调度，直接死循环。很准确，但是会浪费cpu资源。" />
          </outline>
        </outline>
        <outline text="系统调用">
          <outline text="系统调用时用户空间访问内核的唯一手段。除异常和陷入外, 它是内核唯一的合法入口。" />
          <outline text="linux 的系统调用是作为c库的一部分提供的. " />
          <outline text="系统调用在内核中实现, 运行于内核空间。应用程序不需要关注系统调用." />
          <outline text="陷入">
            <outline text="一般程序在用户空间执行. " />
            <outline text="当它调用了一个系统调用, 或者触发了一个异常, 它就陷入了内核空间。" />
          </outline>
          <outline text="API和系统调用的区别">
            <outline text="API是由OS提供的、供应用程序使用的编程接口. " />
            <outline text="它的实现可以是一个系统调用, 也可以是多个系统调用, 亦可和系统调用无关." />
          </outline>
          <outline text="POSIX标准">
            <outline text="UNIX 可移植操作系统接口（Portable Operating System Interface for uniX）, 一组编程接口标准，它们规定如何编写应用程序源代码以便应用程序可在操作系统之间移植。" />
            <outline text="POSIX 基于 UNIX，它是 The Open Group 的 X/Open 规范的基础。" />
            <outline text="linux 最流行的API 是基于POSIX标准的。" />
            <outline text="标准是IEEE负责发布的, " />
            <outline text="目的是为了基于unix 的可移植操作系统的标准. " />
            <outline text="linux与之兼容. " />
            <outline text="windows , 也提供了和POSIX兼容的库." />
          </outline>
          <outline text="机制和策略">
            <outline text="关于unix的界面设计有一句格言: &quot;提供机制而不是策略&quot;. " />
            <outline text="换句话说, unix的系统调用抽象出用于完成某种确定目的的函数; 至于这些函数怎么使用完全不需要内核去关心." />
            <outline text="区分机制(mechanism)和策略（policy）是Unix设计中的一大亮点。" />
            <outline text="大部分的编程问题都可以被切割成两个部分：“需要提供什么功能”（机制）和“怎样实现这些功能”（策略）。" />
            <outline text="如果由程序中的独立部分分别负责机制和策略的实现，那么开发软件就更容易，也更容易适应不同的需求。" />
            <outline text="Linux抽象出对这些对象的执行机制">
              <outline text="程序的执行机制--进程；" />
              <outline text="内核函数的执行机制--线程；" />
              <outline text="中断服务程序的执行机制--中断信号触发；" />
              <outline text="中断下半部的执行机制--softirq，tasklet，工作队列；" />
              <outline text="系统调用的执行--软中断（int $0x80触发）。" />
            </outline>
          </outline>
          <outline text="系统调用在内核中实现">
            <outline text="例子:" />
            <outline text="asmlinkage long sys_getpid(void){">
              <outline text=" return current-&amp;gt;tgid;" />
            </outline>
            <outline text="}" />
            <outline text="函数声明中有asmlinkage, 所有系统调用都需要这个限定词." />
            <outline text="系统调用 get_pid() 在内核中被定义为 sys_getpid(). 这个是linux系统调用都遵守的命名规则, 即加入 sys_ 前缀." />
          </outline>
          <outline text="系统调用号">
            <outline text="每个系统调用都被赋予一个系统调用号. " />
            <outline text="一旦被分配, 就不能有任何变更. " />
            <outline text="该列表存储在 sys_call_table 中." />
          </outline>
          <outline text="调用过程">
            <outline text="应用程序如何通知内核自己需要执行一个系统调用？">
              <outline text="软中断. 通过引发一个异常来促使系统切换到内核态去执行异常处理程序.  " />
              <outline text="x86系统上的软中断是通过 int $0x80指令产生. " />
              <outline text="这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序, 而该程序就是系统调用处理程序, 即 system_call()." />
            </outline>
            <outline text="系统陷入内核空间还不够, 系统调用号是如何传入的呢? ">
              <outline text="x86上是通过eax寄存器传递的." />
            </outline>
            <outline text="系统调用还有参数, 要如何传递?">
              <outline text="寄存器. " />
              <outline text="x86 上, ebx, ecx, edx, esi 和 edi 可以放前5个参数. " />
              <outline text="如果有6个或以上的参数(不多见), 则有一个寄存器存放指向所有参数的用户空间的指针." />
            </outline>
            <outline text="返回值放在哪里？">
              <outline text="返回值也是放在寄存器的. x86上是eax." />
            </outline>
            <outline text="整个流程如下">
              <outline text="用户程序调用 read() -&amp;gt; c库封装的代码 -&amp;gt; system_call() -&amp;gt; sys_read()." />
            </outline>
          </outline>
          <outline text="系统调用上下文">
            <outline text="内核在执行系统调用时, 处在进程上下文。" />
            <outline text="在进程上下文中, 内核可以休眠和被抢占。" />
            <outline text="休眠的能力非常重要">
              <outline text="明系统调用可以使用内核提供的绝大部分功能. " />
              <outline text="与之对应的是, 由于中断上下文不具休眠能力, 导致其能进行的操作相当受限." />
            </outline>
          </outline>
          <outline text="系统调用的参数检验">
            <outline text="最重要的检查是检查用户传入的指针是否有效." />
            <outline text="别对别人会怎么用它做过多的假设. 比如不要对字节长度和字节序做假设. " />
            <outline text="参数是属于用户空间的;" />
            <outline text="参数在该进程的地址空间内的 , 也就是说不能属于其它进程." />
            <outline text="参数访问必须有对应的权限." />
          </outline>
          <outline text="权限检查">
            <outline text="针对调用者是否有合法权限. 采用 capable() 函数来检查. " />
            <outline text="比如, capable(CAP_SYS_NICE) 可检查调用者是否有权改变其它进程的nice值。" />
            <outline text="相关权限列表见 linux/capability.h。" />
          </outline>
          <outline text="向用户空间读写数据">
            <outline text="写，核提供了copy_to_user(), 它需要三个参数: ">
              <outline text="进程空间的目标内存地址, " />
              <outline text="内核空间的源地址, " />
              <outline text="需要拷贝的字节数." />
            </outline>
            <outline text="读内核提供了 copy_from_user()。" />
            <outline text="如果执行失败, 两个函数返回的都是没能完成拷贝的数据的字节数. " />
            <outline text="如果成功, 返回0." />
          </outline>
          <outline text="创建新的系统调用已经不再被允许了。替代办法是创建一个设备节点。">
            <outline text="通过 open() close() , read() 和 write()访问它. " />
            <outline text="用  ioctl() 进行特别的设置操作和获取特别的信息." />
          </outline>
        </outline>
        <outline text="中断&amp;amp;异常&amp;amp;下半部">
          <outline text="中断">
            <outline text="中断使得硬件得以和CPU进行通讯。" />
            <outline text="它本质上是一种特殊的电信号, 由外设发给处理器。" />
            <outline text="处理器一经检测到此信号, 便中断自己的当前工作转而处理中断。" />
            <outline text="中断随时会发生。" />
            <outline text="中断请求线(IRQ)">
              <outline text="不同的设备对应的中断不同。每个中断都通过一个唯一的数字标示来区分. 这些中断值被称为IRQ. " />
              <outline text="比如x86上, IRQ0 是时钟中断, IRQ1 是键盘中断. " />
              <outline text="PCI 总线上的设备的中断IRQ是动态分配的." />
            </outline>
            <outline text="中断处理程序(ISR)">
              <outline text="ISR 是被内核调用来响应中断的. 它运行在中断上下文中。" />
              <outline text="除此之外, ISR 就是普通的c函数。" />
            </outline>
            <outline text="注册中断处理程序(ISR): request_irq()">
              <outline text="中断处理程序是管理硬件的驱动程序的组成部分。" />
              <outline text="如果设备使用中断 (大部分设备都如此), 那么相应的驱动程序会注册一个中断处理程序。" />
              <outline text="注册isr用request_irq()，其参数表是：">
                <outline text="1. 表示要分配的中断号. 对于传统设备, 比如部分时钟和键盘, 这个值是定死的. 而对于大多数其它设备, 这个值要么是通过探测获取, 或者在编程动态确定." />
                <outline text="2. 即中断处理程序的指针. 其原型是确定的." />
                <outline text="3. irqflags 可以为0, 也可以为如下值:">
                  <outline text="SA_INTERRUPT: 表示为快中断. 加此标志的中断会在禁止所有中断的情况下运行. 这使得FIQ 的处理不被打扰. 一般IRQ则只屏蔽自己这条中断线, 而其它中断都是激活的." />
                  <outline text="SA_SAMPLE_RANDOM: 表示当前isr 的中断间隔时间作为熵源填充到内核的熵池中. 熵池是为了产生真随机数." />
                  <outline text="SA_SHIRQ: 表示当前isr 和 其它isr共享同一个中断线. 同一中断线上注册的每个处理程序都必须指定这个标志." />
                </outline>
                <outline text="4. devname 是入中断有关的设备的名字的ascii 码字符串. 这个名字会被 /proc/irq 和 /proc/interrupt 使用." />
                <outline text="5. dev_id 主要用于共享中断线. 当一个中断处理程序需要释放时, 此参数将提供唯一的标示信息, 以便从共享中断线的诸多中断处理函数中删除指定的一个." />
              </outline>
              <outline text="返回值:">
                <outline text="0 表示成功. " />
                <outline text="非0 表示失败. 最常见的错误是:">
                  <outline text="-EBUSY, 表示给定的中断线已经在使用, 或者没有共享中断线没有加 SA_SHIRQ。" />
                </outline>
              </outline>
              <outline text="调用 request_irq() 可能会睡眠">
                <outline text="在注册过程中,内核需要在 /proc/irq 中增加一个项, proc_mkdir()即是干这个的,proc_mkdir()通过 proc_create()对这个新的profs项进行设置。而后者会调用 kmalloc()请求内存。而后者可以睡眠。" />
                <outline text="由于它会睡眠，所以不能在中断上下文或其它不允许阻塞的代码中调用。" />
                <outline text="只能在进程上下文调用此函数。" />
              </outline>
            </outline>
            <outline text="释放ISR: free_irq()">
              <outline text="对于非共享中断线, 释放中断处理程序将导致该中断线禁用。" />
              <outline text="必须在进程上下文调用此函数。" />
            </outline>
            <outline text="实现ISR">
              <outline text="ISR是无需考虑重入的. " />
              <outline text="因为当一个给定的isr 在执行时, 相应的中断线在所有的cpu上都会被屏蔽掉." />
            </outline>
            <outline text="共享中断线">
              <outline text="系统支持的中断线数量有限，所以一些设备需要共享中断线。" />
              <outline text="软件上，可以往一个IRQ上注册多个ISR。" />
              <outline text="内核收到一个中断后, 它将依次调用在该中断线上注册的每一个ISR." />
              <outline text="所以, ISR必须有办法得知它的设备是否真的产生了中断. " />
              <outline text="这既需要硬件支持, 也需要ISR中有相应的处理逻辑. " />
              <outline text="如果ISR与之相关的硬件并没有产生中断, 则它应该立即退出，把CPU让给下一个ISR。" />
            </outline>
            <outline text="中断从硬件到内核的路由">
              <outline text="硬件设备: 产生一个中断(电信号)；" />
              <outline text="中断控制器将其传给给CPU。" />
              <outline text="CPU: 如果该中断不被禁止, CPU会中断当前工作, 关闭中断系统, 然后跳到内存中预定义的位置(即ISR的入口点)开始执行. ">
                <outline text="每条中断线都对应一个唯一的位置. 所以, 内核就知道所接受的IRQ号了." />
              </outline>
              <outline text="do_IRQ(): 计算中断号,确认该号上是否注册有isr.">
                <outline text="如果没有, 则跳到ret_from_intr()执行。" />
              </outline>
              <outline text="handle_IRQ_evnet(): 主要做如下事：">
                <outline text="禁止本中断线, 或者禁止所有中断线(依赖于中断线属性是否有SA_INTERRUPT)；" />
                <outline text="运行该线注册的所有isr." />
              </outline>
              <outline text="如果注册期间指定了SA_SAMPLE_RANDOM属性, 则调用 add_interrupt_randomness()." />
              <outline text="isr调用完后，调用ret_from_intr(): 检查是否有必要进行经常调度. 细节如下：">
                <outline text="重新调度是否正在挂起(即设置了 need_resched), 而且内核正在访问用户空间(即中断了用户进程), 则调用 schedule()." />
                <outline text="如果内核正在返回内核空间(即中断了内核), 只有在 preempt_count 为0 时, schedule() 才会被调用(否则, 抢占内核便是不安全的)." />
              </outline>
            </outline>
            <outline text="中断上下文和进程上下文">
              <outline text="这两个概念都只和内核空间有关系. 表明内核运行的两种状态。" />
              <outline text="进程上下文是一种内核所处的操作模式, 此时内核代表进程执行，包括；">
                <outline text="执行系统调用" />
                <outline text="运行内核线程" />
              </outline>
              <outline text="在进程上下文下, 可以做如下事:">
                <outline text="可以通过current宏关联当前进程. " />
                <outline text="可以睡眠." />
                <outline text="可以调用调度程序." />
              </outline>
              <outline text="中断上下文">
                <outline text="和进程没有什么关系. 所以current 宏指向的是被中断的进程. " />
                <outline text="不可以睡眠. 因为没有进程的背景, 如何睡眠? 阻塞后如何重新调度? 因此, 不可以在中断上下文中调用那些会导致睡眠的函数." />
                <outline text="中断上下文具有严格的时间限制. 必须尽可能的迅速简洁. 应该尽量把工作从isr中分离出来, 放在下半部来执行." />
                <outline text="中断上下文具有严格的空间限制. ">
                  <outline text="2.6版本之前, isr 没有自己的栈, 相反它们共享被中断进程的内核栈. 内核栈的大小为两页, 具体说, 32位系统为8KB, 62位系统为16K." />
                  <outline text="2.6版本后, 提供了一个选项, 把内核栈的大小减为1页. 这减轻了内存的压力, 因为系统中每个进程原来都需要8K不可换出的内核内存. " />
                  <outline text="为了应对栈的减少, isr有了自己的栈, 每个cpu一个, 大小为4K. 这个栈称为中断栈." />
                </outline>
              </outline>
            </outline>
            <outline text="Proc fs">
              <outline text="ProcFS是一个虚拟文件系统, 它只存在于内核内存, 一般安装于 /proc 目录下. " />
              <outline text="在proc中读写文件都要调用内核函数, 这些函数模仿从真实文件中读和写." />
              <outline text="/proc/interrupts 存放和中断相关的统计信息。" />
              <outline text="cat 它，可以查看如下数据：LOC:    8603870    5633075   Local timer interrupts">
                <outline text="其中, 第一列为中断线, 这里不显示没有注册处理程序的中断线." />
                <outline text="第二列为接受到的中断数目的计数器. 我们可以看到,时钟中断已经发生了 8603870次." />
                <outline text="第三列式处理这个中断的中断控制器. 在具有 IO APIC的系统上, 多数中断都会用 IO-APIC-edge." />
                <outline text="最后一列是与这个中断相关的设备名称. 这个名称是通过 devname 提供给函数  request_irq()的. ">
                  <outline text="如果中断线是共享的, 比如中断16, 则所有设备都会列出." />
                </outline>
              </outline>
              <outline text="procfs 代码位于 fs/proc, 创建 /proc/interrupts 的函数叫做 show_interruptes()。" />
            </outline>
            <outline text="中断控制, 禁止和激活中断">
              <outline text="所谓中断控制, 即禁止当前处理器的中断系统, 或者屏蔽掉整个机器的一条中断线." />
              <outline text="中断控制的目的是需要提供同步. ">
                <outline text="通过禁止中断, 可以确保某个 isr 不会抢占当前代码. " />
                <outline text="禁止中断, 还可以禁止内核抢占." />
              </outline>
              <outline text="中断控制不能够防止来自其它CPU的并发访问. 而锁可以. 这是两个层面的事. 即锁防止其它CPU的并发访问, 而禁止中断防止来自其它ISR的并发访问." />
              <outline text="api包括：">
                <outline text="禁止当前CPU上的本地中断: local_irq_disable()" />
                <outline text="激活它们: local_irq_enable()" />
                <outline text="禁止中断并保存状态: local_irq_save(flags);    // flags 为uint32." />
                <outline text="恢复中断状态: local_irq_restore(flags);" />
              </outline>
              <outline text="后两者更安全. 因为local_irq_enable() 会无条件激活所有中断, 如果某个中断可能在开始之前就关闭了." />
              <outline text="后两者必须在同一个函数中调用." />
              <outline text="所有这四个函数既可以在中断中调用, 也可以在进程上下文中调用." />
              <outline text="禁止指定中断线">
                <outline text="disable_irq(uint irq): 禁止中断线, ">
                  <outline text="函数只有在当前正在执行的所有isr都完成后, 才能返回. " />
                  <outline text="所以调用者要确保不再指定线上传递新的中断。" />
                  <outline text="同时要确保已经开始执行的isr已经全部退出。" />
                </outline>
                <outline text="disable_irq_nosync(uint irq): ">
                  <outline text="禁止指定中断线, 异步调用. 没有上面函数的限制." />
                </outline>
                <outline text="enable_irq(uint irq): 激活中断线." />
                <outline text="syncchronize_irq(uint irq):  等待特定的isr的退出." />
                <outline text="这些函数实际上很少使用。" />
              </outline>
              <outline text="in_interrupt(): 如果内核存在中断上下文, 返回非0." />
              <outline text="in_irq(): 内核在执行isr 时, 返回非0." />
            </outline>
          </outline>
          <outline text="上半部和下半部">
            <outline text="中断是需要尽快被处理掉的。">
              <outline text="首先硬件可能有严格的时序限制。" />
              <outline text="其次系统的其它被打断的部分需要尽快回去恢复。" />
            </outline>
            <outline text="但是很多中断需要处理的工作量很大, 比如网卡." />
            <outline text="因此我们一般把中断处理切分为两部分：">
              <outline text="上半部即isr，只完成有严格时限的部分. " />
              <outline text="第二部分就叫下半步. 下半部的实现机制有好几种." />
              <outline text="理想状态下, 最好 isr 将所有工作都交给下半部执行. 所以, 很多isr处理逻辑除了做最小范围的状态维护外, 就发一个下半部请求, 然后就直接返回了. (推荐这么做)" />
            </outline>
            <outline text="什么逻辑放在isr，基本的规则是：  #经验总结 ">
              <outline text="如果一个任务对时间非常敏感, 比如将数据从硬件读入内存; 那么就放在isr; " />
              <outline text="如果一个任务和硬件相关, 比如操作硬件对中断的到达进行确认, 那么就放在isr;" />
              <outline text="如果一个任务要保证不被其它中断(特别是同一中断线的中断)打断, 将其放在isr 中执行;" />
              <outline text="凡不是必须放在isr 的任务, 都应该放在下半部." />
            </outline>
            <outline text="下半部的执行时机">
              <outline text="下半部一般并不和isr隔了一段时间再执行, 相反, 多数情况下半部会在isr返回后马上执行." />
              <outline text="下半部的关键在于当它们运行时, &lt;b&gt;允许响应所有的中断。&lt;/b&gt;" />
              <outline text="锁中断的时间长短, 对系统的性能影响极大." />
            </outline>
            <outline text="下半部实现机制">
              <outline text="历史机制（现在已淘汰）">
                <outline text="最早的机制是BH(bottom half)。2.5 内核去掉. 被软中断(softirq)、工作队列取代。" />
                <outline text="任务队列（task queue）, 也是在2.5 内核去掉。被工作队列取代。" />
              </outline>
              <outline text="软中断(SoftIRQ)">
                <outline text="运行在中断上下文。" />
                <outline text="软中断使用较少, 一般用于象网络这种对性能要求高的情况下. " />
                <outline text="代码位于 /kernel/softirq.c" />
                <outline text="软中断由 softirq_action 结构管理：">
                  <outline text="struct softirq_action{">
                    <outline text="void (*action)(struct softirq_action *);" />
                  </outline>
                  <outline text="};" />
                </outline>
                <outline text="软中断需要在编译期间静态分配。" />
                <outline text="softirq.c 定义了 NR_SOFTIRQS个该结构体的数组。">
                  <outline text="NR_SOFTIRQS为软中断的枚举量,每个被注册的软中断都占据该数组的一项。" />
                  <outline text="目前该值为 10. 即系统最多可能有10个软中断。" />
                </outline>
                <outline text="内核代码中明确要求不要再分配新的软中断。因此不建议使用. " />
                <outline text="执行软中断的时机">
                  <outline text="从一个 isr 返回时;" />
                  <outline text="在 ksoftirqd 内核线程中; " />
                  <outline text="在那些显式执行待处理的软中断的代码, 比如网络子系统就是自行重复触发的." />
                  <outline text="不管哪种方式, 软中断都在 do_softirq() 中. " />
                  <outline text="do_softirq() 会遍历寻找所有待处理的软中断, 并根据其优先级依次调用其处理函数." />
                  <outline text="目前, 只有网络和SCSI 两个子系统直接使用软中断. " />
                  <outline text="此外, 内核定时器和 tasklet 都是建立在软中断上的." />
                </outline>
                <outline text="软中断的类型 （同时也是其优先级，排在前面的优先级高）">
                  <outline text="HI_SOFTIRQ（高优先级的tasklet）" />
                  <outline text="TIMER_SOFTIRQ（内核定时器）" />
                  <outline text="NET_TX_SOFTIRQ（发送网络数据包）" />
                  <outline text="NET_RX_SOFTIRQ（接收网络数据包）" />
                  <outline text="BLOCK_SOFTIRQ（块设备？）" />
                  <outline text="BLOCK_IOPOLL_SOFTIRQ（块设备io池？）" />
                  <outline text="TASKLET_SOFTIRQ（tasklet）" />
                  <outline text="SCHED_SOFTIRQ" />
                  <outline text="HRTIMER_SOFTIRQ" />
                  <outline text="RCU_SOFTIRQ" />
                  <outline text="NR_SOFTIRQS" />
                </outline>
                <outline text="软中断的使用方法">
                  <outline text="分配索引." />
                  <outline text="注意, 由于其次序决定优先级, 所以不一定总是添加到列表的末尾." />
                  <outline text="注册处理函数. 调用 open_softirq()">
                    <outline text="open_softirq(TASKLET_SOFTIRQ, tasklet_action);" />
                    <outline text="open_softirq(HI_SOFTIRQ, tasklet_hi_action);" />
                    <outline text="软中断处理程序执行时, 允许响应中断, 当前CPU的软中断被禁止, 但是其他CPU 仍可以执行别的软中断, 甚至是自身. 所以 ,软中断中使用全局变量会很麻烦 , 如果加锁来防止自身的并发执行, 那么软中断就没有任何使用的必要了." />
                  </outline>
                  <outline text="触发软中断">
                    <outline text="raise_softirq_irqoff(TASKLET_SOFTIRQ);" />
                    <outline text="raise_softirq(NET_TX_SOFTIRQ);" />
                  </outline>
                  <outline text="触发的时机">
                    <outline text="在isr中触发软中断是最常见的形式. " />
                    <outline text="在这种情况下, isr 执行硬件设备的相关操作, 然后触发相应的软中断, 最后退出. " />
                    <outline text="内核执行完 isr 后, 马上就会调 do_softirq()." />
                  </outline>
                </outline>
              </outline>
              <outline text="tasklet">
                <outline text="运行在中断上下文。" />
                <outline text="tasklet 是通过软中断实现的。相当于软中断的二级扩展." />
                <outline text="tasklet是中断上下文, 不可睡眠." />
              </outline>
              <outline text="工作队列(work queue)">
                <outline text="工作队列可以把工作推后，交由一个&lt;b&gt;内核线程&lt;/b&gt;去执行. 也就是说, 工作队列运行在&lt;b&gt;进程上下文&lt;/b&gt;。">
                  <outline text="需要注意的是，尽管工作队列运行在进程上下文中，但它不能访问用户空间." />
                </outline>
                <outline text="如果推后执行的任务需要&lt;b&gt;睡眠&lt;/b&gt;，那么就选择工作队列。如果推后执行的任务不需要睡眠，那么就选择tasklet。" />
                <outline text="工作用&amp;lt;linux/workqueue.h&amp;gt;中定义的work_struct结构表示." />
                <outline text="这些结构被连接成链表。当一个工作者线程被唤醒时，它会执行它的链表上的所有工作。工作被执行完毕，它就将相应的work_struct对象从链表上移去。当链表上不再有对象的时候，它就会继续休眠。" />
                <outline text="构建工作队列">
                  <outline text="可通过DECLARE_WORK在编译时静态地建该结构：">
                    <outline text="DECLARE_WORK(name, void (*func) (void*), void *data);" />
                    <outline text="这样就会静态地创建一个名为name，待执行函数为func，参数为data的work_struct结构。" />
                  </outline>
                  <outline text="也可以动态的构建:">
                    <outline text="INIT_WORK(struct work_struct *work, woid(*func) (void *), void *data);  // 这会动态地初始化一个由work指向的工作。" />
                  </outline>
                </outline>
                <outline text="指定工作队列中待执行的函数">
                  <outline text="待执行的函数的原型是： void work_handler(void*data)" />
                </outline>
                <outline text="对工作进行调度">
                  <outline text="想要把给定工作的待处理函数提交给缺省的events工作线程，只需调用">
                    <outline text="schedule_work(&amp;amp;work)；" />
                    <outline text="work马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。" />
                  </outline>
                  <outline text="有时候并不希望工作马上就被执行，而是希望它经过一段延迟以后再执行。在这种情况下，可以调度它在指定的时间执行：">
                    <outline text="schedule_delayed_work(&amp;amp;work,delay);" />
                    <outline text="这时，&amp;amp;work指向的work_struct直到delay指定的时钟节拍用完以后才会执行。" />
                  </outline>
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="临界区">
            <outline text="中断不能用临界区的原因">
              <outline text="如果中断要访问的临界区正在被进程使用，则中断会被进程阻塞，会导致系统的不稳定。" />
            </outline>
            <outline text="临界区的概念">
              <outline text="首先临界区是个资源，该资源不允许并发访问，一个时间只允许一个任务使用。" />
              <outline text="一个模块中访问临界资源的那段代码叫临界区。" />
              <outline text="为了保护临界资源，要求不同任务互斥的访问临界区。" />
            </outline>
            <outline text="临界区之死锁问题">
              <outline text="如果两个进程互相持有对方要的临界区，那么就出现死锁问题。" />
              <outline text="解决办法">
                <outline text="一个进程只允许进一个临界区；" />
                <outline text="要求所有进程用同一个顺序进入临界区。" />
              </outline>
            </outline>
            <outline text="临界区之饥饿问题">
              <outline text="发生场景如下：三个进程，优先级A&amp;gt;B&amp;gt;C，C进临界区，B占据CPU，A想进临界区。" />
              <outline text="显然，A被阻塞，C必须等B执行完，所以A反而需要等待低优先级B。这事不合理的。" />
              <outline text="解决方法：优先级反转，临时将占据临界区的进程优先级提高。" />
            </outline>
          </outline>
          <outline text="异常">
            <outline text="异常由 CPU 产生(换句话说, 是软件产生)。" />
            <outline text="大部分由于当前运行代码出现问题导致, 比如除零异常, 缺页异常, 以及系统调用异常." />
            <outline text="异常和中断">
              <outline text="异常和中断的处理非常类似. 而且又因为异常要考虑与处理器时钟同步，异常常被称为同步中断." />
            </outline>
          </outline>
        </outline>
        <outline text="进程间通讯机制">
          <outline text="管道（pipe）">
            <outline text="用于有亲缘关系的进程间的通讯。" />
          </outline>
          <outline text="命名管道（named pipe）">
            <outline text="除有管道的一切功能外，还允许无亲缘关系的进程间的通讯（因为有名字）。、" />
          </outline>
          <outline text="信号（signal）">
            <outline text="信号实现较复杂。用于通知进程有某事发生。接口为sigal和sigaction，两者兼容。" />
          </outline>
          <outline text="消息队列（message）">
            <outline text="信号能承载的信息少，管道只能承载无符号字节流，为克服这两种不足，设计了消息队列，可以存放多个且格式化的信息。" />
          </outline>
          <outline text="共享内存">
            <outline text="使得多个进程可以访问同一个内存空间，是最快的IPC实现方式。" />
          </outline>
          <outline text="信号量（semaphore）">
            <outline text="主要作为进程间同步手段。" />
          </outline>
          <outline text="socket">
            <outline text="更为一般的IPC方式。" />
          </outline>
        </outline>
        <outline text="内存管理">
          <outline text="统一编址">
            <outline text="arm将ram、rom、mpu、硬件寄存器、外设上的储存单元，统一放在同一个内存地址空间。" />
            <outline text="mpu：Memory Protection Unit">
              <outline text="相当于裁剪了的mmu，最大支持8个region。" />
            </outline>
            <outline text="mmu：内存管理单元，负责管理内存的硬件。">
              <outline text="功能包括：虚存到物理地址的转换、内存保护、对cache的管理。" />
            </outline>
            <outline text="参考文档见 ARM software interface。" />
          </outline>
          <outline text="内存0地址禁止访问">
            <outline text="为了捕捉空指针，将从0开始的若干K的地址空间设置为禁止访问。" />
            <outline text="这是一个优雅的设计。" />
          </outline>
          <outline text="arm的跳转指令只有26B的寻址空间">
            <outline text="因此，链接两个较大.o文件，经常失败。" />
            <outline text="解决办法是把函数调用改成函数指针调用。" />
            <outline text="在汇编下可看到两种方式的不同。" />
          </outline>
          <outline text="虚拟内存">
            <outline text="是一种内存管理的技术，核心点有两个：" />
            <outline text="将多个物理内存碎片，整合为一个连续的地址空间；" />
            <outline text="还可以将部分内存交换到外存中，在需要时再交换进内核。" />
            <outline text="虚拟内存的优势">
              <outline text="提高物理内存的使用效率，使得大型程序的编写更简单。" />
              <outline text="支持多任务。" />
            </outline>
          </outline>
          <outline text="内存页式管理">
            <outline text="现代os中，内存以页的方式管理。" />
            <outline text="每页大小位2的n次方，一般为4K。" />
            <outline text="对于4K的页，地址尾部的12位作为页内偏移量，其余位为页号（虚拟页号）。" />
            <outline text="mmu负责虚拟页号转换为物理页号，这个过程要map（映射）。" />
            <outline text="如果没有找到，则产生缺页异常（page fault）。" />
            <outline text="缺页处理">
              <outline text="将尝试找空白页，并建立页表项，并将外存上的数据load到内存。" />
              <outline text="如果没有空白页，则找最旧的页，将其原内容保存到外存，然后释放其空间再使用。" />
            </outline>
            <outline text="内存页用页表项来管理。包括如下字段：">
              <outline text="脏位" />
              <outline text="存取位（标识最后访问时间）" />
              <outline text="mode（用户态还是核心态）" />
              <outline text="是否被cache" />
            </outline>
          </outline>
          <outline text="kernel的swap方案">
            <outline text="有两种方案：交换分区和交换文件。" />
            <outline text="分区方式效率更高，因为文件是非连续的。" />
          </outline>
          <outline text="linux内存管理api">
            <outline text="set_page_address() 和 page_address()，只针对高端内存。" />
            <outline text="ioremap()   // 内存分配，地址是虚地址" />
            <outline text="phys_to_page() / virb_to_page()   // 虚地址和实地址的互转" />
          </outline>
          <outline text="linux内存分配方法">
            <outline text="SLUB方式。" />
            <outline text="其调试宏为 CONFIG_SLUB_DEBUG=y，打开后有更详细的panic信息。" />
          </outline>
          <outline text="应用内存分区">
            <outline text="code区">
              <outline text="又叫text段。存放代码本身。" />
              <outline text="如果程序试图写这个区域，会产生一个P abort异常。" />
            </outline>
            <outline text="ro区">
              <outline text="又叫常量段。存放只读数据，常量放在这里。" />
              <outline text="如果程序试图写这里，会产生一个D abort异常。" />
            </outline>
            <outline text="rw区">
              <outline text="又叫数据段。存放初始化为非零值的全局变量和静态变量。" />
              <outline text="这些变量在code区另有一个映像，即内存中会有两份。" />
            </outline>
            <outline text="zi区">
              <outline text="又叫BSS段。存放初始化为零的全局变量和静态变量。" />
              <outline text="在代码中只保留zi区的大小，运行时再展开，系统会自动间这个区域初始化为全零。" />
            </outline>
            <outline text="nzi区">
              <outline text="重启时这段区域不做清零处理。目前只有diagdiag_nzi.c " />
            </outline>
            <outline text="堆栈区：其它都是堆栈。" />
          </outline>
        </outline>
        <outline text="文件系统  --参见 &lt;a href=&quot;https://workflowy.com/#/c365fbe9a586&quot;&gt;https://workflowy.com/#/c365fbe9a586&lt;/a&gt;" />
        <outline text="设备管理 (也叫IO管理)">
          <outline text="设备大致分为&lt;b&gt;块设备&lt;/b&gt;(block device) 和 &lt;b&gt;字符设备&lt;/b&gt;(character device).">
            <outline text="块设备: 把数据存储在固定长度的块中, 每块有自己的地址. 一般块大小在512B-16K之间. ">
              <outline text="块设备的基本特征是能独立的读写单个块." />
              <outline text="典型的块设备比如硬盘, SD卡." />
              <outline text="从本质上讲，字符设备和块设备其实只有接口不同。" />
            </outline>
            <outline text="字符设备: 以字符为单位发送或接收一个字符流, 不考虑任何块结构.">
              <outline text="象文件一样、可以按字节流访问的设备。" />
              <outline text="其驱动程序通常需要open、close、read和write等接口。" />
              <outline text="字符设备不编址, 也不寻址." />
              <outline text="典型的字符设备比如显示器, 网卡, 鼠标. 大部分非存储的设备, 都是字符设备." />
            </outline>
            <outline text="网络设备较特殊, 单独列. " />
          </outline>
          <outline text="还有另外一种分类方法，即根据总线类型分，比如USB、串行设备、SCSI、I2C、FireWire等。">
            <outline text="内核一般会提供这类设备的附加层，比如USB驱动层，实现其共有特性，从而降低特定设备的驱动开发者的工作量。" />
          </outline>
          <outline text="主设备号和次设备号">
            <outline text="在/dev 下执行 ls -l，可以列出当前系统的设备文件，其中第一个字母为c的表示字符设备，b表示块设备。另外，还可以看到两个数字，表示主设备号和次设备号。" />
            <outline text="主设备号对应相应的驱动程序。多数设备按照一个主设备号对应一个驱动程序的原则来组织。" />
            <outline text="次设备号由内核使用，和设备文件一一对应。" />
            <outline text="dev_t类型">
              <outline text="用来存储设备编号。在2.6.0的内核中，它是32bit，其中前12bit表示主设备号，后20bit表示次设备号。" />
              <outline text="获取主次设备号的宏：">
                <outline text="MAJOR(dev_t dev);" />
                <outline text="MINOR(dev_t dev);" />
              </outline>
              <outline text="将主次设备号转化为dev_t类型，使用 MKDEV(int major, iint minor);" />
            </outline>
          </outline>
          <outline text="存储器映像IO">
            <outline text="部分系统把设备控制器上的存储空间(寄存器和cache), 作为通用存储器地址空间的一部分." />
            <outline text="又叫统一编址." />
            <outline text="这个映射关系是CPU硬件具体映射关系参见芯片的软硬件接口规格." />
          </outline>
          <outline text="&lt;b&gt;DMA&lt;/b&gt;: direct memory access, 直接存储器访问">
            <outline text="很多&lt;b&gt;块设备&lt;/b&gt;支持DMA模式." />
            <outline text="没有DMA时, 磁盘如何读?">
              <outline text="1. CPU向磁盘控制器发出读指令, 同时提供读的磁盘地址." />
              <outline text="2. 控制器从磁盘驱动器串行地一位一位的读一个快(或者一个扇区, sector), 直到把整块信息放入控制器的内部缓冲区中去." />
              <outline text="3. 控制器计算校验和, 以确保没有读错误发生." />
              <outline text="4. 控制器产生一个中断, 提醒CPU." />
              <outline text="5. 操作系统收到中断, 进入isr. 它重复的从缓冲区中一次一个字节的读取该块的数据, 并把它存入通用存储器中." />
            </outline>
            <outline text="DMA针对的是第四部. 因为这一步浪费了CPU时间." />
            <outline text="有DMA时, 磁盘如何读?">
              <outline text="1. CPU除了向控制器提供读块的磁盘地址外, 还需要向控制器提供两个信息: 读出块要送往内存的起始地址和要传输的字节数." />
              <outline text="2. 控制器将整个块从设备读入其内部缓冲区, 并进行校验. (即上面的2和3)" />
              <outline text="3.  控制器将缓冲区的第一个字节拷贝到指定的通用存储器的地址上. 然后分别对DMA地址和DMA计算器进行步增和步减的操作, 重复, 直到DMA计数变成零." />
              <outline text="4. 控制器发中断信号. 此时操作系统不需要拷贝数据了, 因为数据已经在内存中." />
            </outline>
          </outline>
          <outline text="驱动模块入口是: module_init()." />
          <outline text="驱动子系统入口是: subsys_initcall()。" />
          <outline text="volatile 关键字">
            <outline text="在向总线上写数据的时候，总线的地址指针和数据指针必须用volatile进行定义。" />
            <outline text="以防止编译过程中将某些数据的写入步骤给优化掉。" />
          </outline>
        </outline>
        <outline text="Shell">
          <outline text="命令行界面  --参见 &lt;a href=&quot;https://workflowy.com/#/f19ba04141e1&quot;&gt;https://workflowy.com/#/f19ba04141e1&lt;/a&gt;" />
          <outline text="图形用户桌面环境   --参见 &lt;a href=&quot;https://workflowy.com/#/f110f01ed23d&quot;&gt;https://workflowy.com/#/f110f01ed23d&lt;/a&gt;" />
        </outline>
      </outline>
      <outline text="31-启动流程  #面试题">
        <outline text="开机">
          <outline text="开机">
            <outline text="长按power键">
              <outline text="PS_HOLD是一个硬件管脚，功能是使能pmic芯片的。" />
              <outline text="触发任何开机事件时，pmic都会自动给CPU上电。" />
              <outline text="但如果在300ms内，软件没有将 ps_hold 拉高，则pmic会认为开机异常，而将CPU下电。" />
            </outline>
            <outline text="关机闹钟">
              <outline text="设置关机闹钟时, 会给系统时钟源(RTC)设置一个定时器, 当定时器到时时会使能pmic芯片." />
              <outline text="系统开机过程中, 会检索所有的闹钟, 再重新将下一个闹钟设置到RTC上去. " />
            </outline>
            <outline text="充电线插入" />
          </outline>
          <outline text="重启">
            <outline text="watchdog超时重启（不踢狗）, 是唯一软件能控制的重启，场景分为：">
              <outline text="watchdog超时重启" />
              <outline text="关机菜单" />
              <outline text="升级" />
              <outline text="恢复出厂设置" />
              <outline text="死机">
                <outline text="system_server重启" />
                <outline text="kernel空指针或跑飞" />
                <outline text="kernel watchdog超时，kernel异常导致。" />
              </outline>
              <outline text="ADB reboot命令" />
            </outline>
            <outline text="瞬间掉电重启" />
            <outline text="Android重启">
              <outline text="即SystemServer 重启. " />
              <outline text="除init进程/Zygote&lt;b&gt;外, 其它用户态进程都死掉.&lt;/b&gt;" />
            </outline>
          </outline>
        </outline>
        <outline text="Loader">
          <outline text="Boot Rom">
            <outline text="当电源按下时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行.">
              <outline text="ARM系统在上电或复位时通常都从地址 0x00000000 处开始执行." />
            </outline>
            <outline text="Boot Rom负责加载引导程序Bootloader到RAM，然后执行。" />
            <outline text="Boot Rom属于片内系统。" />
          </outline>
          <outline text="BootLoader">
            <outline text="BootLoader负责加载Android系统。" />
            <outline text="代码在 bootable/bootloader/lk。" />
            <outline text="代码入口: bootable/bootloader/lk/app/aboot/aboot.c，aboot_init()。" />
            <outline text="lk意思是light kernel，为高通开发，因为组织良好，被很多平台采用。" />
            <outline text="二进制包">
              <outline text="nand版本叫 appsboot.mbn" />
              <outline text="emmc版本叫 emmc_appsboot.mbn" />
            </outline>
            <outline text="BootLoader的功能">
              <outline text="进fastboot">
                <outline text="停在aboot等待后台命令。比如，fastboot flash boot boot.image" />
                <outline text="该模式中可以用的命令，可通过 fastboot_register()来添加。" />
                <outline text="通过 adb reboot bootloader命令，可以让手机重启并直接进入Fastboot 中去。" />
              </outline>
              <outline text="进 recovery和FTM">
                <outline text="代码在: bootable/recovery/recovery.c" />
                <outline text="升级代码一般放在这里。" />
              </outline>
              <outline text="一般情况下直接    启动kernel。" />
            </outline>
            <outline text="Boot Loader 严重地依赖于硬件而实现, 尤其是芯片. ">
              <outline text="Boot Loader通常分为两个部分:">
                <outline text="stage1通常完成硬件设备的初始化，通常用汇编实现，以达到短小快速的目的。通常包括如下步骤：">
                  <outline text="最基本的硬件设备的初始化。包括:">
                    <outline text="屏蔽所有的中断。为中断提供服务通常是 OS 设备驱动程序的责任，因此在 Boot Loader 的执行全过程中可以不必响应任何中断。中断屏蔽可以通过写 CPU 的中断屏蔽寄存器或状态寄存器（比如 ARM 的 CPSR 寄存器）来完成。" />
                    <outline text="设置 CPU 的速度和时钟频率。" />
                    <outline text="RAM 初始化。包括正确地设置系统的内存控制器的功能寄存器以及各内存库控制寄存器等。" />
                    <outline text="初始化 LED。典型地，通过 GPIO 来驱动 LED，其目的是表明系统的状态是 OK 还是 Error。如果板子上没有 LED，那么也可以通过初始化 UART 向串口打印 Boot Loader 的 Logo 字符信息来完成这一点。" />
                    <outline text="关闭 CPU 内部指令／数据 cache。" />
                  </outline>
                  <outline text="为加载 Boot Loader 的 stage2 准备 RAM 空间。">
                    <outline text="由于 stage2 通常是 C 语言执行代码，因此在考虑空间大小时，除了 stage2 可执行映象的大小外，还必须把堆栈空间也考虑进来。" />
                    <outline text="此外，空间大小最好是 memory page 大小(通常是 4KB)的倍数。" />
                    <outline text="一般而言，1M 的 RAM 空间已经足够了。" />
                    <outline text="具体的地址范围可以任意安排，比如 blob 就将它的 stage2 可执行映像安排到从系统 RAM 起始地址 0xc0200000 开始的 1M 空间内执行。" />
                    <outline text="将 stage2 安排到整个 RAM 空间的最顶 1MB(也即(RamEnd-1MB) - RamEnd), 也是一种值得推荐的方法。" />
                    <outline text="还必须确保所安排的地址范围的的确确是可读写的 RAM 空间，因此，必须对你所安排的地址范围进行测试。blob 的方法是：以 memory page 为被测试单位，测试每个 memory page 开始的两个字是否是可读写的。" />
                  </outline>
                  <outline text="拷贝 Boot Loader 的 stage2 到 RAM 空间中。">
                    <outline text="拷贝时要确定两点：" />
                    <outline text="stage2 的可执行映象在固态存储设备的存放起始地址和终止地址；" />
                    <outline text="RAM 空间的起始地址。" />
                  </outline>
                  <outline text="设置好堆栈。">
                    <outline text="堆栈指针的设置是为了执行 C 语言代码作好准备。" />
                    <outline text="通常我们可以把 sp 的值设置为(stage2_end-4)，也即在 3.1.2 节所安排的那个 1MB 的 RAM 空间的最顶端(堆栈向下生长)。" />
                  </outline>
                  <outline text="跳转到 stage2 的 C 入口点。">
                    <outline text="在上述一切都就绪后，就可以跳转到 Boot Loader 的 stage2 去执行了。" />
                    <outline text="比如，在 ARM 系统中，这可以通过修改 PC 寄存器为合适的地址来实现。" />
                  </outline>
                </outline>
                <outline text="stage2 则通常用C语言来实现，这样可以实现给复杂的功能，而且代码会具有更好的可读性和可移植性。">
                  <outline text="提供main() 入口.">
                    <outline text="stage2 的代码通常用 C 语言来实现，但是与普通 C 语言应用程序不同的是，在编译和链接 boot loader 这样的程序时，我们不能使用 glibc 库中的任何支持函数。" />
                    <outline text="这就给我们带来一个问题，那就是从那里跳转进 main() 函数呢？直接把 main() 函数的起始地址作为整个 stage2 执行映像的入口点或许是最直接的想法。但是这样做有两个缺点：1)无法通过main() 函数传递函数参数；2)无法处理 main() 函数返回的情况。" />
                    <outline text="一种更为巧妙的方法是利用 trampoline(弹簧床)的概念。也即，用汇编语言写一段trampoline 小程序，并将这段 trampoline 小程序来作为 stage2 可执行映象的执行入口点。然后我们可以在 trampoline 汇编小程序中用 CPU 跳转指令跳入 main() 函数中去执行；而当 main() 函数返回时，CPU 执行路径显然再次回到我们的 trampoline 程序。简而言之，这种方法的思想就是：用这段 trampoline 小程序来作为 main() 函数的外部包裹(external wrapper)。" />
                    <outline text="下面给出一个简单的 trampoline 程序示例(来自blob)：" />
                    <outline text=".text" />
                    <outline text=".globl _trampoline" />
                    <outline text="_trampoline:">
                      <outline text="bl main" />
                      <outline text="/* if main ever returns we just call it again */" />
                      <outline text="b _trampoline" />
                    </outline>
                    <outline text="可以看出，当 main() 函数返回后，我们又用一条跳转指令重新执行 trampoline 程序――当然也就重新执行 main() 函数，这也就是 trampoline(弹簧床)一词的意思所在。" />
                  </outline>
                  <outline text="初始化本阶段要使用到的硬件设备。">
                    <outline text="比如, 初始化至少一个串口，以便和终端用户进行 I/O 输出信息；" />
                    <outline text="以及, 初始化计时器等。" />
                  </outline>
                  <outline text="检测系统内存映射(memory map)。">
                    <outline text="所谓内存映射就是指在整个 4GB 物理地址空间中有哪些地址范围被分配用来寻址系统的 RAM 单元。Boot Loader必须知道 CPU 预留的全部 RAM 地址空间中的哪些被真正映射到 RAM 地址单元，哪些是处于 &quot;unused&quot; 状态的。" />
                    <outline text="怎么做哩？一个标准的做法是：从基地址开始，以 memory page 为被测试单位，测试每个 memory page 开始的两个字是否是可读写的。" />
                    <outline text="每找到一块连续的内存区，则使用如下结构保存起来：" />
                    <outline text="typedef struct memory_area_struct {">
                      <outline text="u32 start; /* the base address of the memory region */" />
                      <outline text="u32 size; /* the byte number of the memory region */" />
                      <outline text="int used;" />
                    </outline>
                    <outline text="} memory_area_t;" />
                    <outline text="其中：(1)used=1，则说明这段连续的地址范围已被实现，也即真正地被映射到 RAM 单元上。(2)used=0，则说明这段连续的地址范围并未被系统所实现，而是处于未使用状态。" />
                  </outline>
                  <outline text="将 kernel 映像和根文件系统映像从 flash 上读到 RAM 空间中。">
                    <outline text="对于内核映像，一般将其拷贝到从(MEM_START＋0x8000) 这个基地址开始的大约1MB大小的内存范围内(嵌入式 Linux 的内核一般都不操过 1MB)。为什么要把从 MEM_START 到 MEM_START＋0x8000 这段 32KB 大小的内存空出来呢？这是因为 Linux 内核要在这段内存中放置一些全局数据结构，如：启动参数和内核页表等信息。" />
                    <outline text="而对于根文件系统映像，则一般将其拷贝到 MEM_START+0x0010,0000 开始的地方。如果用 Ramdisk 作为根文件系统映像，则其解压后的大小一般是1MB。" />
                    <outline text="由于像 ARM 这样的嵌入式 CPU 通常都是在统一的内存地址空间中寻址 Flash 等固态存储设备的，因此从 Flash 上读取数据与从 RAM 单元中读取数据并没有什么不同。用一个简单的循环就可以完成从 Flash 设备上拷贝映像的工作：" />
                    <outline text="while(count) {">
                      <outline text="*dest++ = *src++; /* they are all aligned with word boundary */" />
                      <outline text="count -= 4; /* byte number */" />
                    </outline>
                    <outline text="};" />
                  </outline>
                  <outline text="为内核设置启动参数。">
                    <outline text="Linux 2.4.x 以后的内核都期望以标记列表(tagged list)的形式来传递启动参数。启动参数标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。每个标记由标识被传递参数的 tag_header 结构以及随后的参数值数据结构来组成。数据结构 tag 和 tag_header 定义在 Linux 内核源码的include/asm/setup.h 头文件中。" />
                    <outline text="在嵌入式 Linux 系统中，通常需要由 Boot Loader 设置的常见启动参数有：ATAG_CORE、ATAG_MEM、ATAG_CMDLINE、ATAG_RAMDISK、ATAG_INITRD等。" />
                    <outline text="比如，设置 ATAG_CORE 的代码如下：" />
                    <outline text="params = (struct tag *)BOOT_PARAMS;">
                      <outline text="params-&amp;gt;hdr.tag = ATAG_CORE;" />
                      <outline text="params-&amp;gt;hdr.size = tag_size(tag_core);" />
                      <outline text="params-&amp;gt;u.core.flags = 0;" />
                      <outline text="params-&amp;gt;u.core.pagesize = 0;" />
                      <outline text="params-&amp;gt;u.core.rootdev = 0;" />
                      <outline text="params = tag_next(params);" />
                    </outline>
                    <outline text="其中，BOOT_PARAMS 表示内核启动参数在内存中的起始基地址，指针 params 是一个 struct tag 类型的指针。宏 tag_next() 将以指向当前标记的指针为参数，计算紧临当前标记的下一个标记的起始地址。注意，内核的根文件系统所在的设备ID就是在这里设置的。" />
                    <outline text="下面是设置内存映射情况的示例代码：" />
                    <outline text="for(i = 0; i &amp;lt;  NUM_MEM_AREAS; i++) {">
                      <outline text="if(memory_map[i].used) {">
                        <outline text="params-&amp;gt;hdr.tag = ATAG_MEM;">
                          <outline text="params-&amp;gt;hdr.size = tag_size(tag_mem32);" />
                          <outline text="params-&amp;gt;u.mem.start = memory_map[i].start;" />
                          <outline text="params-&amp;gt;u.mem.size = memory_map[i].size;" />
                          <outline text="params = tag_next(params);" />
                        </outline>
                        <outline text="}" />
                      </outline>
                    </outline>
                    <outline text="}" />
                    <outline text="可以看出，在 memory_map［］数组中，每一个有效的内存段都对应一个 ATAG_MEM 参数标记。" />
                    <outline text="Linux 内核在启动时可以以命令行参数的形式来接收信息，利用这一点我们可以向内核提供那些内核不能自己检测的硬件参数信息，或者重载(override)内核自己检测到的信息。比如，我们用这样一个命令行参数字符串&quot;console=ttyS0,115200n8&quot;来通知内核以 ttyS0 作为控制台，且串口采用 &quot;115200bps、无奇偶校验、8位数据位&quot;这样的设置。下面是一段设置调用内核命令行参数字符串的示例代码：" />
                    <outline text="char *p;">
                      <outline text="/* eat leading white space */" />
                      <outline text="for(p = commandline; *p == ' '; p++) ;" />
                      <outline text="/* skip non-existent command lines so the kernel will still use its default command line. */" />
                      <outline text="if(*p == '\0')">
                        <outline text="return;" />
                      </outline>
                      <outline text="params-&amp;gt;hdr.tag = ATAG_CMDLINE;" />
                      <outline text="params-&amp;gt;hdr.size = (sizeof(struct tag_header) + strlen(p) + 1 + 4) &amp;gt;&amp;gt;  2;" />
                      <outline text="strcpy(params-&amp;gt;u.cmdline.cmdline, p);" />
                      <outline text="params = tag_next(params);" />
                    </outline>
                    <outline text="请注意在上述代码中，设置 tag_header 的大小时，必须包括字符串的终止符'\0'，此外还要将字节数向上圆整4个字节，因为 tag_header 结构中的size 成员表示的是字数。" />
                    <outline text="下面是设置 ATAG_INITRD 的示例代码，它告诉内核在 RAM 中的什么地方可以找到 initrd 映象(压缩格式)以及它的大小：">
                      <outline text="params-&amp;gt;hdr.tag = ATAG_INITRD2;" />
                      <outline text="params-&amp;gt;hdr.size = tag_size(tag_initrd);" />
                      <outline text="params-&amp;gt;u.initrd.start = RAMDISK_RAM_BASE;" />
                      <outline text="params-&amp;gt;u.initrd.size = INITRD_LEN;" />
                      <outline text="params = tag_next(params);" />
                    </outline>
                    <outline text="下面是设置 ATAG_RAMDISK 的示例代码，它告诉内核解压后的 Ramdisk 有多大（单位是KB）：" />
                    <outline text="params-&amp;gt;hdr.tag = ATAG_RAMDISK;" />
                    <outline text="params-&amp;gt;hdr.size = tag_size(tag_ramdisk);" />
                    <outline text="params-&amp;gt;u.ramdisk.start = 0;" />
                    <outline text="params-&amp;gt;u.ramdisk.size = RAMDISK_SIZE; /* 请注意，单位是KB */" />
                    <outline text="params-&amp;gt;u.ramdisk.flags = 1; /* automatically load ramdisk */" />
                    <outline text="params = tag_next(params);" />
                    <outline text="最后，设置 ATAG_NONE 标记，结束整个启动参数列表：" />
                    <outline text="static void setup_end_tag(void)" />
                    <outline text="{">
                      <outline text="params-&amp;gt;hdr.tag = ATAG_NONE;" />
                      <outline text="params-&amp;gt;hdr.size = 0;" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="调用内核。">
                    <outline text="Boot Loader 调用 Linux 内核的方法是直接跳转到内核的第一条指令处，也即直接跳转到 MEM_START＋0x8000 地址处。在跳转时，下列条件要满足：" />
                    <outline text="1． CPU 寄存器的设置：" />
                    <outline text="R0＝0；" />
                    <outline text="R1＝机器类型 ID；关于 Machine Type Number，可以参见 linux/arch/arm/tools/mach-types。" />
                    <outline text="R2＝启动参数标记列表在 RAM 中起始基地址；" />
                    <outline text="2． CPU 模式：" />
                    <outline text="必须禁止中断（IRQs和FIQs）；" />
                    <outline text="CPU 必须 SVC 模式；" />
                    <outline text="3． Cache 和 MMU 的设置：" />
                    <outline text="MMU 必须关闭；" />
                    <outline text="指令 Cache 可以打开也可以关闭；" />
                    <outline text="数据 Cache 必须关闭；" />
                    <outline text="如果用 C 语言，可以像下列示例代码这样来调用内核：" />
                    <outline text="void (*theKernel)(int zero, int arch, u32 params_addr) = (void (*)(int, int, u32))KERNEL_RAM_BASE;" />
                    <outline text="theKernel(0, ARCH_NUMBER, (u32) kernel_params_start);" />
                    <outline text="注意，theKernel()函数调用应该永远不返回的。如果这个调用返回，则说明出错。" />
                  </outline>
                </outline>
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="Kernel">
          <outline text="swapper（pid=0）">
            <outline text="内核启动时，先启动系统的第一个进程，swapper，完成内核的初始化。" />
            <outline text="swapper对应于Windows系统的idle 进程。" />
            <outline text="在多处理器系统中，每个CPU都有一个进程swapper进程。" />
            <outline text="swapper初始化进程管理、内存管理。" />
            <outline text="swapper加载驱动">
              <outline text="Camera driver" />
              <outline text="Display driver" />
              <outline text="Binder driver" />
              <outline text="等等。" />
            </outline>
          </outline>
          <outline text="init.rc">
            <outline text="自举过程结束后，内核首先在 /system 分区中寻找 init.rc 文件；然后启动init进程." />
            <outline text="init进程是系统的第二个进程（pid=1）, 也是第一个用户态进程。" />
            <outline text="init进程负责一行行执行 init.rc 文件;" />
            <outline text="init进程是所有用户态进程的父父进程。" />
          </outline>
          <outline text="kthreadd (pid=2)">
            <outline text="内核启动 kthreadd，它是所有内核进程的父进程，负责动态加载内核守护进程。" />
            <outline text="所有内核进程都运行于内核态，用户都是root." />
          </outline>
          <outline text="kthreadd 启动的内核守护进程（运行于内核态，顺序基本上是启动顺序）">
            <outline text="ksoftirqd/0：负责监测CPU 0上的软中断" />
            <outline text="kworker/0:0：第0个CPU的第0个工作进程" />
            <outline text="kworker/0:1：第0个CPU的第1个工作进程" />
            <outline text="kworker/0:0H： 第0个cpu的第0H工作进程" />
            <outline text="kworker/u4:0：u代表的是unbound,即未与CPU绑定的进程" />
            <outline text="migration/0：CPU 0上的用于在不同的CPU间迁移的进程" />
            <outline text="rcu_preempt：读写更新，抢占器" />
            <outline text="rcu_bh：" />
            <outline text="rcu_sched：读写更新，调度" />
            <outline text="ksoftirqd/1：负责监测CPU 1上的软中断" />
            <outline text="kworker/1:0H：第1个cpu的第0H工作进程" />
            <outline text="kworker/u4:1：u代表的是unbound,即未与CPU绑定的进程" />
            <outline text="migration/1：CPU 1上的用于在不同的CPU间迁移的进程" />
            <outline text="khelper： 用于调用内核模块的用户空间实现" />
            <outline text="writeback：存储回写" />
            <outline text="bioset：block i/o管理" />
            <outline text="kblockd：用于卸载和影响ios延迟/吞吐率" />
            <outline text="ata_sff：ata是 IDE硬盘接口。" />
            <outline text="khubd：" />
            <outline text="md：Multiple Devices driver for Linux" />
            <outline text="cfg80211：配置802.11协议，即配置wifi的进程" />
            <outline text="kswapd0：页交换" />
            <outline text="fsnotify_mark：文件系统通知标记进程" />
            <outline text="crypto：加密子进程" />
            <outline text="scsi_eh_0：cpu 0上的scsi_eh进程(SCSI是一种存储硬件接口标准.),这进程在ubuntu上也存在" />
            <outline text="scsi_eh_1：cpu 1上的scsi_eh进程" />
            <outline text="uether：" />
            <outline text="dm_bufio_cache：dm是指 RAID and LVM drivers 缓冲io" />
            <outline text="binder：binder驱动" />
            <outline text="deferwq：defer work queue 开启延迟设备检测" />
            <outline text="jbd2/vda-8：journal block device2，vda-8是设备名称" />
            <outline text="ext4-dio-unwrit：ext4文件系统相关进程" />
            <outline text="therm_core：热管理" />
            <outline text="watchdog：看门狗" />
            <outline text="perf" />
            <outline text="netns" />
            <outline text="rpm-smd" />
            <outline text="mpm" />
            <outline text="system" />
            <outline text="mdss_dsi_event" />
            <outline text="kgsl-events" />
            <outline text="spi" />
          </outline>
        </outline>
        <outline text="Native">
          <outline text="&lt;b&gt;init（pid=1）&lt;/b&gt;">
            <outline text="init是系统第二个进程，也是第一个用户态进程。" />
            <outline text="init的代码：system/core/init/init.cpp" />
            <outline text="init.rc文件：system/core/rootdir/init.rc" />
            <outline text="启动Zygote">
              <outline text="在init执行过程中，在on boot阶段，会 trigger zygote-start，on zygote-start，根据当前的加密状态选择启动Zygote。" />
              <outline text="Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。" />
              <outline text="其中，zygote服务的启动脚本在 init.zygoteXX.rc中定义，比如 init.zygote64.rc。该文件位于 system/core/rootdir/。" />
            </outline>
            <outline text="启动 MediaServer" />
            <outline text="启动 &lt;b&gt;ServiceManager&lt;/b&gt; (ContextManager)" />
          </outline>
          <outline text="&lt;b&gt;init fork的守护进程（运行于用户态，顺序基本上是启动顺序）&lt;/b&gt;">
            <outline text="sbin/&lt;b&gt;ueventd： 事件后台进程。最早启动。&lt;/b&gt;" />
            <outline text="system/bin/logd： log的守护进程" />
            <outline text="system/bin/&lt;b&gt;vold&lt;/b&gt;： volume守护进程">
              <outline text="system/bin/sdcard： 由vold进程创建，管理sdcard分区。" />
            </outline>
            <outline text="sbin/healthd：  电池的守护进程" />
            <outline text="system/bin/&lt;b&gt;lmkd&lt;/b&gt;： LowmeMoryKiller守护进程" />
            <outline text="system/bin/S&lt;b&gt;erviceManager： &lt;/b&gt;binder服务的订阅查询服务进程。后面会详细描述。" />
            <outline text="system/bin/&lt;b&gt;surfaceflinger： &lt;/b&gt;UI帧相关的进程" />
            <outline text="kauditd：内核审核守护进程" />
            <outline text="sbin/&lt;b&gt;adbd&lt;/b&gt;： adbd进程(Socket IPC)">
              <outline text="system/bin/sh： ADB启动的 shell终端, 命令行控制台" />
            </outline>
            <outline text="system/bin/netd： 网络相关进程" />
            <outline text="system/bin/debuggerd： 32位调试器" />
            <outline text="system/bin/debuggerd64： 64位调试器" />
            <outline text="system/bin/&lt;b&gt;rild（&lt;/b&gt;ril-daemon&lt;b&gt;）： &lt;/b&gt;Radio Interface Layer（协议栈）的守护进程" />
            <outline text="system/bin/drmserver： 数字版权管理进程" />
            <outline text="system/bin/mediaserver： 媒体管理" />
            <outline text="system/bin/installd： 负责安装应用程序的进程" />
            <outline text="system/bin/keystore： 证书管理" />
            <outline text="&lt;b&gt;zygote64&lt;/b&gt;： 这是第一个客户进程，server_server进程和zygote64进程通信以创建其它的app进程。 后面会详述。" />
            <outline text="zygote： 32位zygote" />
            <outline text="system/bin/&lt;b&gt;gatekeeperd&lt;/b&gt;： 锁屏处理守护进程" />
            <outline text="system/xbin/perfprofd： perf profile collection daemon 性能搜集进程" />
            <outline text="system/bin/fingerprintd: 指纹进程" />
          </outline>
          <outline text="&lt;b&gt;Zygote&lt;/b&gt;">
            <outline text="Zygote是系统的第二个用户态进程，也是所有java进程的父进程。" />
            <outline text="刚开始的名字为“app_process”，运行过程中，通过系统调用将自己名字改为Zygote。" />
            <outline text="分Zygote和Zygote64。64位系统会同时启动这两个。" />
            <outline text="Zygote常驻后台，每当新的apk启动时，Zygote会派生一个linux进程来跑java虚拟机，然后apk会跑在该虚拟机上。" />
            <outline text="进程文件：system/bin/app_process" />
            <outline text="代码：frameworks/base/cmds/app_process/app_main.cpp" />
            <outline text="Zygote完成的初始化动作：">
              <outline text="初始化AppRuntime。AppRuntime继承于AndroidRuntime。" />
              <outline text="初始化Skia图形库。" />
              <outline text="初始化Dalvik虚拟机。" />
              <outline text="注册jni函数。" />
              <outline text="根据参数调用 ZygoteInit 的main方法，启动Zygote自身。关键。" />
              <outline text="创建本地socket。" />
              <outline text="预加载资源。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;Zygote启动SystemServer （fwk的主体，详述见后）&lt;/b&gt;">
            <outline text="Zygote的forkSystemServer方法主要是调用了native方法nativeForkSystemServer；" />
            <outline text="在native层进行fork动作，并设置pid、gid、selinux安全上下文等，最后启动 com.android.server.SystemServer。" />
          </outline>
          <outline text="Zygote启动的 GC守护进程（用户态）">
            <outline text="ReferenceQueueD：引用队列的守护线程" />
            <outline text="FinalizerDaemon：析构的守护线程" />
            <outline text="FinalizerWatchd：析构监控的守护线程" />
            <outline text="HeapTrimmerDaem：堆整理的守护线程" />
            <outline text="GCDaemon：执行GC的守护线程" />
          </outline>
          <outline text="Zygote启动的系统应用 (详述见后)" />
          <outline text="MediaServer">
            <outline text="管理本地系统service (C/C++)。包括:" />
            <outline text="AudioFlinger" />
            <outline text="MediaPlayerService" />
            <outline text="Camera" />
          </outline>
          <outline text="&lt;b&gt;ServiceManager&lt;/b&gt; (ContextManager)">
            <outline text="frameworks/native/cmds/servicemanager/service_manager.c" />
            <outline text="Binder架构的管理者，所有系统service都需要先向 servicemanager注册。" />
            <outline text="framework和app在调用系统服务时，需要向servicemanager申请，然后通过 Binder调用该服务。" />
            <outline text="文件：system/bin/servicemanager" />
            <outline text="对外提供的接口有：">
              <outline text="addService()" />
              <outline text="getService()" />
              <outline text="listServices()" />
            </outline>
          </outline>
          <outline text="开机动画" />
        </outline>
        <outline text="Framework">
          <outline text="&lt;b&gt;SystemServer&lt;/b&gt;">
            <outline text="&lt;b&gt;SystemServer&lt;/b&gt;是zygote的首席大弟子，托起整个Java framework的所有service。" />
            <outline text="启动后完成如下事务：">
              <outline text="调整时间，如果系统时间比1970还要早，调整到1970年" />
              <outline text="设置系统语言" />
              <outline text="调整虚拟机堆内存大小和内存利用率" />
              <outline text="初始化Looper为mainLooper" />
              <outline text="装载库 libandroid_server.so" />
              <outline text="初始化系统Context" />
              <outline text="创建 SystemServiceManager负责系统Service启动" />
              <outline text="创建和启动Java服务" />
              <outline text="调用Looper.loop()，进入处理消息的循环" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;SystemServer 启动的服务进程&lt;/b&gt;">
            <outline text="ActivityManagerService：AMS线程" />
            <outline text="WindowManagerService：WMS线程" />
            <outline text="PowerManagerSer：PMS线程" />
            <outline text="PackageManager：PM线程" />
            <outline text="Binder_：Binder IPC线程， 包含16个" />
            <outline text="Thread_：普通线程，包含若干个" />
            <outline text="Heap thread pool：异步的HeapWorker, 包含5个" />
            <outline text="Signal Catcher：捕捉Kernel信号，比如SIGNAL_QUIT" />
            <outline text="JDWP：虚拟机调试的线程" />
            <outline text="AsyncTask #: 异步任务，包含若干个" />
            <outline text="RenderThread：渲染线程，可以包含若干个" />
            <outline text="PerformanaceCont：性能统计" />
            <outline text="FileObserver：system_server专有" />
            <outline text="CpuTracker：CPU信息统计" />
            <outline text="watchdog：看门狗线程" />
            <outline text="WifiMonitor：system_server专有" />
            <outline text="UEventObserver：system_server专有其它的进程" />
          </outline>
        </outline>
        <outline text="APP">
          <outline text="开机过程中, Zygote 会启动如下核心应用：" />
          <outline text="com.android.systemui： 系统状态栏进程" />
          <outline text="com.android.inputmethod.latin： 输入法进程" />
          <outline text="android.process.media： 媒体进程" />
          <outline text="com.android.phone： telephony通话服务进程" />
          <outline text="android.process.acore： 通讯录数据库进程" />
          <outline text="com.android.deskclock： 闹钟进程" />
          <outline text="com.android.quicksearchbox： 快速搜索框进程" />
          <outline text="com.android.settings： 设置进程" />
          <outline text="com.android.calendar： 日历进程，packages/apps/Calendar" />
          <outline text="com.android.providers.calendar： 日历提供器进程packages/providers/CalendarProvider" />
          <outline text="com.android.launcher3： 启动器进程，即桌面" />
          <outline text="com.android.email： 邮件服务进程" />
          <outline text="com.android.messaging： 短消息进程" />
          <outline text="com.android.smspush：短信发送" />
          <outline text="com.android.wifi：Wifi应用进程" />
        </outline>
        <outline text="开机后系统的大概状态">
          <outline text="swapper： 2个子进程，分别为init， kthreadd" />
          <outline text="init：55个子进程，用户进程" />
          <outline text="kthreadd：303个子进程，内核进程" />
          <outline text="zygote64：41个子进程，64位zygote" />
          <outline text="zygote：3个子进程，32位zygote" />
        </outline>
        <outline text="关机流程">
          <outline text="关机流程从kernel log可看出，power down。" />
          <outline text="SYSCALL_DEFINE4，这是kernel总的reboot和shut down的接口。" />
          <outline text="kernel_power_off()，关机流程基本都在这个函数里面。" />
          <outline text="kernel_shutdown_prepare()，关闭device。log：device_shutdown, dev name=platform。" />
          <outline text="machine_power_off() -&amp;gt; msm_pm_power_off()，进行下电操作。其中调用了 msm_rpcrollter_close()，关闭rpc。" />
        </outline>
        <outline text="&lt;b&gt;系统启动优化经验 #经验总结 &lt;/b&gt;">
          <outline text="去掉打印频繁的log." />
          <outline text="根据器件情况做裁剪, 方法是修改配置文件, yes 改为 no." />
          <outline text="Zygote预加载资源时, 采用单线程, 改为多线程(最多可节省15秒)" />
          <outline text="所有apk在编译时生成odex. " />
        </outline>
      </outline>
      <outline text="32-Memory">
        <outline text="Linux内存管理">
          <outline text="kmalloc() 和 kfree()" />
          <outline text="内核和用户空间之间交换数据">
            <outline text="copy_to_user()" />
            <outline text="copy_from_user()" />
            <outline text="使用它们要特别小心，因为用户空间的内存地址可能已经被交换到外设，此时当前进行会sleep，直至该页交换回内存再唤醒。这就要求调用这些函数的内核代码可以睡眠，并允许重入。" />
            <outline text="这个函数需要检查返回值。" />
          </outline>
          <outline text="linux 用户态进程如何使用内核设备节点的？">
            <outline text="wait_event_interruptible  阻塞" />
            <outline text="wake_up 唤醒" />
          </outline>
        </outline>
        <outline text="Linux / Android / windows的内存管理的理念差异">
          <outline text="在Linux中经常发现空闲内存很少，似乎所有的内存都被系统占用了，表面感觉是内存不够用了，其实不然。这是Linux内存管理的一个优秀特性." />
          <outline text="Windows是只在需要内存时，才为应用程序分配内存，不使用的情况下大量的内存空间被闲置。" />
          <outline text="Linux的想法不同, 在内存空间够用的情况下, 会将一些程序调用过的硬盘数据读入内存，利用内存读写的高速特性来提高系统性能。每增加一些物理内存，Linux都能利用起来，充分发挥了硬件投资带来的好处." />
          <outline text="Android的理念较之Linux更进一步，便是应用程序退出, 系统也会尽可能多保留该进程的内存资源, 以便在用户再次启动时提高响应时间. " />
        </outline>
        <outline text="Android的内存机制">
          <outline text="我们在用安卓手机的时候不需要太在意剩余内存. " />
          <outline text="Bundle传递数据的限制: 不能超过0.5MB, 超过会报 TransactionTooLargeException 异常." />
          <outline text="android上, 每开一个应用就会打开一个独立的虚拟机。其实和java的垃圾回收机制类似，系统有一个规则来回收内存。" />
          <outline text="进行内存调度有个阀值，只有低于这个值系统才会按一个列表来关闭用户不需要的东西。" />
          <outline text="当然这个值默认设置得很小，所以你会看到内存老在很少的数值徘徊。但事实上他并不影响速度。相反加快了下次启动应用的速度。这本来就是 android标榜的优势之一，如果人为去关闭进程，没有太大必要。" />
          <outline text="为什么内存少的时候运行大型程序会慢? 原因是：在内存剩余不多时打开大型程序时会触发系统自身的调进程调度策略，甚至会反复触发, 这是十分消耗系统资源的操作, 对性能压力很大." />
          <outline text="如果不关程序是不是会耗电? android的应用在被切换到后台时，它其实已经被暂停了,并不会消耗cpu资源只保留了运行状态。所以为什么有的程序切出去重进会到主界面。" />
          <outline text="一个程序如果想要在后台处理些东西，如音乐播放，它就会开启一个服务。服务可在后台持续运行，&lt;b&gt;所以在后台耗电的只有带服务的应用了。&lt;/b&gt;" />
          <outline text="malloc 分配的内存需要高地址释放完后再释放低地址空间, 释放是串行的, 会导致虚拟地址占用很高. 相机连拍时易发生. " />
        </outline>
        <outline text="Android应用内存被分为2部分：native和dalvik.">
          <outline text="native即C/C++代码堆栈. " />
          <outline text="dalvik即java堆，我们创建的对象是在这里面分配的." />
          <outline text="而bitmap是直接在native上分配的." />
          <outline text="对于内存的限制是 native+dalvik 不能超过最大限制, android应用一般限制在16M，也有24M的。" />
        </outline>
        <outline text="&lt;b&gt;Swap分区管理&lt;/b&gt;">
          <outline text="为了缓解物理内存不足的问题, 在磁盘上开辟一块空间虚拟为一块内存区, 这个叫swap分区. Windows和 Linux上都用. " />
          <outline text="当物理内存不足时, 内核会将暂时不用的内存块写到swap分区, 然后释放该内存块. 当需要使用之前的内存块时, 这些信息会被重新交换到物理内存中." />
          <outline text="内核根据&quot;最近最常使用&quot;的调度算法, 仅将最久不使用的页交换到swap空间." />
          <outline text="Linux系统会不时进行页交换, 即使物理内存够用, 目的是提高内存页交换性能. 经常出现的一种现象是, 物理内存还有很多, 但是交换空间也用了很多, 这是正常的. " />
          <outline text="Android系统上, 由于外存使用的FLASH/EMMC, 其读写寿命远小于PC上用的磁盘, 所以不能把外存做swap空间. " />
          <outline text="Android系统的办法是把一部分内存作为swap分区. 页交换是在两个内存区之间发生. " />
          <outline text="对于存放在swap中的内存页, 会先压缩再交换(否则没有意义). 回写时要解压缩再交换到物理内存. 交换区叫 zram." />
          <outline text="查询 swap 的命令">
            <outline text="cat /proc/sys/vm/swappiness, 返回:">
              <outline text="0: 最大限度使用物理内存;" />
              <outline text="60: Linux默认值" />
              <outline text="100: 积极使用swap分区." />
            </outline>
            <outline text="cat /proc/sys/wm/drop_caches, 是否自动释放swap. 返回:">
              <outline text="0: 不释放" />
              <outline text="1: 释放页缓存" />
              <outline text="2: 释放dentries 和 inodes" />
              <outline text="3: 释放所有缓存" />
            </outline>
          </outline>
          <outline text="关闭 swap">
            <outline text="echo 0 &amp;gt; /proc/sys/vm/swappiness" />
            <outline text="echo 0 &amp;gt; /proc/sys/vm/direct_swappiness" />
            <outline text="还有一种方法:" />
            <outline text="adb shell sysctl -w vm.swappiness=0" />
          </outline>
        </outline>
        <outline text="标准Linux的OOM Killer机制">
          <outline text="在 mm/oom_kill.c中实现，且会被 __alloc_pages_may_oom调用(在分配内存时，即mm/page_alloc.c中)。" />
          <outline text="核心函数是 out_of_memory，它选择一个bad进程Kill，Kill的方法是通过发送SIGKILL信号。" />
          <outline text="在 out_of_memory中通过调用 select_bad_process() 来选择一个进程Kill，选择的依据在 badness() 中实现，基于多个标准来给每个进程评分，评分最高的被选中并Kill。" />
          <outline text="一般而言，占用内存越多，oom_adj 就越大，也就越有可能被选中。" />
        </outline>
        <outline text="&lt;b&gt;Android LMK (Low Memory Killer)  #面试题 &lt;/b&gt;">
          <outline text="执行条件: 剩余内存小于应用定义的 APP_MEM 值，开始比较进程的adj值，从高往底杀进程。" />
          <outline text="杀进程的方式是: 发送SIGKILL信息，让该进程自杀(换句话说, 被杀的有机会留下临终遗言)。" />
          <outline text="机制的源代码在 kernel/drivers/staging/android/lowmemorykiller.c" />
          <outline text="adj值越高, 优先级越低. " />
          <outline text="进程 omm_adj的大小跟进程的类型以及进程被调度的次序有关。" />
          <outline text="在init.rc中，定义init进程的pid为1，omm_adj 被配置为-16，永远不会被杀死。" />
          <outline text="&lt;b&gt;ActivityManagerService定义各种进程的 oom_adj.   #面试题 &lt;/b&gt;">
            <outline text="NATIVE_ADJ = -17;  // native进程（不被系统管理）" />
            <outline text="SYSTEM_ADJ = -16;  // 系统进程, 永远不会被杀死. init进程就是-16." />
            <outline text="CORE_SERVER_ADJ = -12;   // 核心服务, 永远不会被杀死。" />
            <outline text="&lt;b&gt;FOREGROUND_APP_ADJ = 0;  // 前台进程&lt;/b&gt;" />
            <outline text="&lt;b&gt;VISIBLE_APP_ADJ  = 1;   // 可见进程. 包括widget、输入法窗口等.&lt;/b&gt;" />
            <outline text="&lt;b&gt;PERCEPTIBLE_APP_ADJ = 2;  // 可感知进程. 比如后台音乐播放&lt;/b&gt;" />
            <outline text="&lt;b&gt;HEAVY_WEIGHT_APP_ADJ = 4;  // 后台重量级进程 (在 system/rootdir/init.rc 中定义)&lt;/b&gt;" />
            <outline text="&lt;b&gt;SERVICE_ADJ = 5;  // 服务进程&lt;/b&gt;" />
            <outline text="&lt;b&gt;HOME_APP_ADJ = 6;  // &lt;/b&gt;即 Launcher. " />
            <outline text="&lt;b&gt;PREVIOUS_APP_ADJ = 7;   // 上一个App的进程(往往通过back键或者home键切走的那个进程) . 优先级比服务进程低.&lt;/b&gt;" />
            <outline text="&lt;b&gt;CACHED_APP_MIN_ADJ = 9;  // 不可见进程的adj最小值. app切换到后台即是这个adj值.&lt;/b&gt;">
              <outline text="后台进程的管理策略有多种：" />
              <outline text="有较为积极的方式，一旦程序到达后台立即终止，这种方式会提高程序的运行速度，但无法加速程序的再次启动；" />
              <outline text="也有较消极的方式，尽可能多的保留后台程序，虽然可能会影响到单个程序的运行速度，但在再次启动已启动的程序时，速度会有所提升。" />
            </outline>
          </outline>
          <outline text="内容供应节点（content provider）: 为保证provider所在进程的优先级高于或等于 客户端进程, 所以在被使用时, 它的adj和使用者一样, 使用结束后再恢复为空." />
        </outline>
        <outline text="&lt;b&gt;内存泄漏的种类 #经验总结 #面试题 &lt;/b&gt;">
          <outline text="内存泄漏的根源在于长周期对象, 持有了短周期对象." />
          <outline text="持有Activity context异常">
            <outline text="查看 &lt;b&gt;meminfo&lt;/b&gt; 输出中的Activities. 如果有异常, 比如camera应用是单activity应用, 如果这个值大于2, 一般就是activity泄露. " />
            <outline text="activity泄露的原因是有长周期的对象持有了短周期对象 Activity的 context. " />
            <outline text="修改方案是不要通过Activity来获取 context, 而是通过 Application 获取 context. 因为一个虚拟机线程中只会有一个Application对象, 该对象的生命周期和线程一样长." />
            <outline text="代码如下: getApplicationContext()." />
          </outline>
          <outline text="handle 持有activity导致内存泄漏">
            <outline text="因为 java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用." />
            <outline text="由于Handler是非静态内部类, 所以其持有当前Activity的隐式引用. 如果Handler没有被释放，其所持有的Activity也不可能被释放. 这就导致内存泄漏." />
            <outline text="修改方案是使用静态内部类并继承Handler. 因为静态的内部类不会持有外部类的引用. " />
            <outline text="在这种情况下, 如果Handler内部又要是用外部类, 也就是 Activity, 怎么办?" />
            <outline text="使用弱引用." />
            <outline text="综合以上, 代码如下:" />
            <outline text="private static class MyHandler extends Handler{">
              <outline text="// 持有弱引用HandlerActivity, GC回收时会被回收掉." />
              <outline text="private final WeakReference&amp;lt;HandlerActivity&amp;gt; mActivty;" />
              <outline text="public &lt;b&gt;MyHandler&lt;/b&gt;(HandlerActivity activity){">
                <outline text="mActivty =new WeakReference&amp;lt;HandlerActivity&amp;gt;(activity);" />
              </outline>
              <outline text="}" />
              <outline text="public void &lt;b&gt;handleMessage&lt;/b&gt;(Message msg) {">
                <outline text="super.handleMessage(msg);" />
                <outline text="HandlerActivity activity=mActivty.get();" />
                <outline text="if(activity != null) {">
                  <outline text="// 执行业务逻辑" />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="}" />
          </outline>
          <outline text="AsycTask 持有activity导致内存泄漏">
            <outline text="和handle 持有activity导致内存泄漏完全一样, 解决方案也一样, 使用静态内部类." />
          </outline>
          <outline text="位图资源释放异常" />
          <outline text="动画时序差异, 导致资源未释放">
            <outline text="比如说在动画结束回调中释放资源. 一般情况下, 动画结束时业务逻辑已经执行完了. 但是在低概率情况没执行完. 此时会资源释放失败. 等业务逻辑执行完后, 由于动画早已结束, 导致资源没有释放." />
            <outline text="修改方案: 在业务执行完后, 检查动画状态, 如果动画已经执行完了, 就自行释放资源." />
          </outline>
          <outline text="openGL渲染错误导致内存泄露" />
        </outline>
        <outline text="&lt;b&gt;内存消耗优化  #经验总结 #面试题 &lt;/b&gt;">
          <outline text="清理冗余资源: 图片, 字符串, 冗余类." />
          <outline text="图片压缩" />
          <outline text="bitmap加载优化">
            <outline text="decode bitmap 的时候，尽量配置下Options，例如：inSameSize" />
            <outline text="Bitmap使用完以后，调用 bitmap.recycle()来释放内存" />
            <outline text="如果应用是基于图片的应用，尽量采用LazyLoad和DymanicRecycle" />
            <outline text="decode bitmap 的时候，将decode代码 try catch 出来，catch oom error，避免程序crash，可以在catch里面做一些释放内存操作" />
          </outline>
          <outline text="使用bitmap池" />
        </outline>
        <outline text="&lt;b&gt;Hprof 使用方法&lt;/b&gt;">
          <outline text="用&lt;b&gt;Hprof &lt;/b&gt;分析工具可检测出泄漏的对象、activities、以及冗余重复的字符串。" />
          <outline text="Hprof最初是由J2SE支持的一种二进制堆对象转储格式。但Android的Hprof文件与标准的java Hprof文件格式不一样。" />
          <outline text="抓取方法：">
            <outline text="抓 hprof 文件: 手机要 remount. 然后使用:adb shell am dumpheap com.oppo.camera /data/1.hprof" />
          </outline>
          <outline text="用eclipse MAT 分析 hprof文件">
            <outline text="先把文件转换，进入进入 android-sdk-windows\tools目录,  hprof_conv 1.hprof 1-1.hprof。" />
            <outline text="eclipse上安装MAT: help - install new software - Search &quot;MAT&quot;。" />
            <outline text="打开MAT：在Eclipse中点击 Windows-&amp;gt;Open Perspective-&amp;gt;Other-&amp;gt;Memory Analysis" />
            <outline text="导入.hprof文件: 在MAT中点击 File-&amp;gt;Open File打开刚刚转换而得到的yyyyy.hprof文件，并Cancel掉自动生成报告,点击Dominator Tree，并按Package分组，选择自己所定义的Package类点右键，在弹出菜单中选择List objects-&amp;gt;With incoming references。" />
            <outline text="分析报告: 这时会列出所有可疑类，右键点击某一项，并选择Path to GC Roots-&amp;gt;exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。" />
          </outline>
          <outline text="用AS分析方法：">
            <outline text="在主窗口中点击 Captures按钮，或者选择 View &amp;gt; Tools Windows &amp;gt; Captures，打开Captures窗口；" />
            <outline text="打开堆快照文件夹；双击HPROF文件，打开查看工具界面；" />
            <outline text="选择你想查看的堆:">
              <outline text="App heap - 当前app使用的堆" />
              <outline text="Image heap - 当前app在硬盘上的内存映射" />
              <outline text="Zygote heap - zygote 复制时继承来的库、运行时类和常量的数据集。zygote空间设备启动时创建，从不分配这里的空间。" />
            </outline>
            <outline text="选择你想查看的视图选项：">
              <outline text="Class List View" />
              <outline text="Package Tree View" />
            </outline>
          </outline>
          <outline text="Hprof会展示Java堆，包括如下信息：">
            <outline text="按类展示实例对象的内存使用情况；" />
            <outline text="每次垃圾回收事件的样本数据；" />
            <outline text="帮助分析哪些对象类型也许会导致内存泄漏。" />
          </outline>
          <outline text="工具显示了如下信息：">
            <outline text="Class name	类名" />
            <outline text="Total Count	该类的实例总数" />
            <outline text="Heap Count	所选择的堆中该类的实例的数量" />
            <outline text="Sizeof	单个实例所占空间大小（如果每个实例所占空间大小不一样则显示0）" />
            <outline text="Shallow Size	堆里所有实例大小总和（Heap Count * Sizeof）" />
            <outline text="Retained Size	该类所有实例所支配的内存大小" />
            <outline text="Instance	具体的实例" />
            <outline text="Reference Tree	所选实例的引用，以及指向该引用的引用。" />
            <outline text="Depth	GC根节点到所选实例的最短路径的深度" />
            <outline text="Shallow Size	所选实例的大小" />
            <outline text="Dominating Size	所选实例所支配的内存大小" />
          </outline>
          <outline text="转化成标准的HPROF文件">
            <outline text="转化成标准的HPROF文件后可以使用Android Studio之外的分析工具来分析。" />
            <outline text="Captures窗口HPROF文件列表中选择文件，右键点击 Export to standard .hprof" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;meminfo&lt;/b&gt; 数据含义  ***">
          <outline text="查看内存占用情况: adb shell dumpsys meminfo com.oppo.camera -d" />
          <outline text="&lt;b&gt;反复抓取 dumpsys meminfo&lt;/b&gt; 输出, 看 Total 是否一直增大, 如果是则很可能存在内存泄漏问题." />
          <outline text="列字段:">
            <outline text="Pss total: Proportional set size是内核的度量，包括共享内存。">
              <outline text="私有内存页按100%计算. " />
              <outline text="共享内存则按共享进程的数量均分.">
                <outline text="系统会将共享内存的总大小除以参与共享的进程数。例如，一个在两个进程间共享的内存页, 每个进程更占一半。" />
              </outline>
              <outline text="按照这种方式, 就可以将所有进程的Pss数据相加得到总共的RAM消耗。" />
              <outline text="在进程间比较Pss也能够大致比较两者权重。" />
            </outline>
            <outline text="Private Dirty: 这部分代表进程内存中不能交换到硬盘，也不能和其他的进程共享的部分。换句话说，这部分的消耗只有当应用被销毁的时候才会被系统回收。" />
            <outline text="Private  Clean: 代表当从磁盘载入的时候还没有改变的内存部分. 只要一个页内的内存改变过，且在系统必须要写入时, 才将内存块标记为脏。" />
            <outline text="Swapped Dirty:  交换空间.">
              <outline text="Android设备使用FLASH做磁盘, FLASH不支持交换区机制，所以Android上的Swap 空间是放到RAM中的." />
              <outline text="Swapped Dirty只有当应用退出的时候才会被释放。" />
              <outline text="Android使用 ZRAM 压缩内存页，先压缩再放入Swap 空间，需要的时候先解压再交换回去。" />
            </outline>
            <outline text="Heap Size:  Size 是需要的内存. Size = Alloc + Free" />
            <outline text="Heap Alloc:  Alloc 是分配了的内存." />
            <outline text="Heap Free:  Free 是未使用的内存." />
          </outline>
          <outline text="行字段:">
            <outline text="&lt;b&gt;Native &lt;/b&gt;Heap: 原生堆. 进程自身使用的内存，C\C++代码. 从mallinfo usmblks获得，代表最大总共分配空间. 例如Unity Engine Code， Native C malloc， 和 Mono VM。其中:">
              <outline text="Size = Alloc + Free" />
              <outline text="Alloc: 从mallinfo uorblks获得，总共分配空间" />
              <outline text="Free: 从mallinfo fordblks获得，代表总共剩余空间" />
            </outline>
            <outline text="&lt;b&gt;Dalvik &lt;/b&gt;Heap : 代表Dalvik虚拟机分配的内存.  Java代码. 从Runtime totalMemory()获得，Dalvik Heap总共的内存大小。其中: ">
              <outline text="Size = Alloc + Free" />
              <outline text="Alloc: Runtime totalMemory()-freeMemory() ，Dalvik Heap分配的内存大小。" />
              <outline text="Free:从Runtime freeMemory()获得，Dalvik Heap剩余的内存大小。" />
            </outline>
            <outline text="Dalvik Other：类数据结构和索引占据内存" />
            <outline text="Stack：栈内存" />
            <outline text="Ashmem：不以dalvik- 开头的内存区域，匿名共享内存用来提供共享内存通过分配一个多个进程可以共享的带名称的内存块。匿名共享内存（Anonymous Shared Memory-Ashmem。Android匿名共享内存是基于Linux共享内存的，都是在tmpfs文件系统上新建文件，并将其映射到不同的进程空间，从而达到共享内存的目的，只是，Android在Linux的基础上进行了改造，并借助Binder+fd文件描述符实现了共享内存的传递。" />
            <outline text="Other dev：内部driver占用的内存" />
            <outline text=".so mmap: C库代码占用的内存" />
            <outline text=".jar mmap: java文件代码占用的内存" />
            <outline text=".apk mmap: apk代码占用的内存" />
            <outline text=".ttf mmap: ttf文件代码占用的内存" />
            <outline text=".dex mmap: dex文件代码占用内存。类函数的代码和常量占用的内存，dex mmap是映射classex.dex文件，Dalvik虚拟机从dex文件加载类信息和字符串常量等。Dex文件有索引区和Data区" />
            <outline text="Other mmap: 其它文件占用的内存" />
            <outline text="EGL mtrack: 这个部分是gralloc的内存使用。主要是SurfaceView和TextureView的总和。它也包括了帧缓冲区，因此大小也会取决于framebuffers的尺寸。支持的屏幕分辨率越高，EGL mtrack的数目越高。在这个测试中，帧缓冲区的分辨率被降低了来确保比较好的性能。降低帧缓存的大小也会降低这些缓存需要的内存量。" />
            <outline text="GL mtrack &amp;amp; Gfx dev: GL和Gfx是驱动反馈的GPU内存，主要是GL纹理大小的总和，GL命令缓冲区，固定的全局驱动RAM消耗以及Shader。需要指出，这些不会出现在旧的Android版本上。注意：客户空间驱动和内核空间驱动共享同一个内存空间。在某些Android版本上，这个部分会被重复计算两次，因此Gfx dev要比实际上使用的数值更大。" />
            <outline text="Unknown: Unknown值得是系统不能确定分页属于上面的那种。这个部分包括原生分配或者运行时metadata，因为Adress Space Layout Randomization，这个工具没办法确定内存。Private Dirty是只用于自己应用的未知RAM。" />
            <outline text="Objects and SQL 信息都是从Android Debug信息中获得。" />
            <outline text="Total: 总计. 当 total 超过单个程序内存的最大限制时，OOM就可能出现。" />
          </outline>
          <outline text="Objects (对象统计): " />
          <outline text="Views:       90         ViewRootImpl:        1" />
          <outline text="&lt;b&gt;AppContexts:        4           Activities:        1&lt;/b&gt;" />
          <outline text="Assets:        2        AssetManagers:        2" />
          <outline text="Local Binders:       21        Proxy Binders:       28" />
          <outline text="Parcel memory:       18         Parcel count:       74" />
          <outline text="Death Recipients:        2      OpenSSL Sockets:        2" />
        </outline>
        <outline text="&lt;b&gt;procrank &lt;/b&gt;数据含义">
          <outline text="adb shell procrank，这个工具可以查看所有进程使用的内存量，从高到低列出每个进程使用的内存使用量。部分手机支持. ">
            <outline text="每个进程列出Vss，Rss，Pss，和Uss 这4个数据。" />
          </outline>
          <outline text="Vss - Virtual Set Size, 一个进程总共可以获取的寻址空间。这个指标表明一个进程关联的虚拟内存空间。" />
          <outline text="Rss - Resident Set Size, 一个进程分配到的物理内存页。被多个进程共享的内存页被计算多次。" />
          <outline text="Pss - Proportional Set Size, 和Rss类似，只不过将共享的内存页处理共享的进程数来计算。" />
          <outline text="Uss - Unique Set Size, = Private Dirty的概念，表明进程内不能被分页到硬盘的数据，不能被其他进程共享的内存部分。" />
        </outline>
        <outline text="如果对GC有疑问, 在类中重写 finalize() 方法会有用.">
          <outline text="public void finalize() throws Throwable {">
            <outline text="try {">
              <outline text="Log.e(Tag, &quot;finalize(): &quot; + this);" />
            </outline>
            <outline text="} finally {">
              <outline text="super.finalize();" />
            </outline>
            <outline text="}" />
          </outline>
        </outline>
        <outline text="&lt;b&gt;Android Malloc Debug: native代码内存调试工具&lt;/b&gt;">
          <outline text="工具代码在: bionic/libc/bionic/malloc_debug_common.c/h/cpp. 下面说实操." />
          <outline text="准备一个userdebug或eng版本手机，尽量选择32bit机器，64bit设备会非常卡." />
          <outline text="&lt;b&gt;下述命令, 请在使用前后关开java虚拟机.&lt;/b&gt;" />
          <outline text="打开系统的malloc debug">
            <outline text="adb shell setprop libc.debug.malloc &amp;lt;配置项&amp;gt;. 配置项有:" />
            <outline text="0: 这是默认的等级，仅作最基本的判断" />
            <outline text="1: 在malloc记录调用栈, 检测内存泄漏" />
            <outline text="5: 分配的内存用0xeb填充，释放的内存用0xef填充, 可检测内存的overruns" />
            <outline text="10: 内存分配打 pre-和 post- 的桩子，记录调用栈, 也可检测内存的overruns" />
            <outline text="20: SDK模拟器上检测内存用" />
          </outline>
          <outline text="打开指定app的malloc debug, 有两种方式:">
            <outline text="一种是: setprop wrap.com.oppo.camera &quot;LIBC_DEBUG_MALLOC_OPTIONS=baketrace&quot;" />
            <outline text="另外一种是: setprop libc.debug.malloc.program &quot;com.oppo.camera&quot;" />
          </outline>
          <outline text="定位方法1: adb logcat | findstr &quot;malloc_debug&quot;" />
          <outline text="定位方法2: 通过ddms来看内存泄漏. ">
            <outline text="先要配置ddms: 在~\.android\ ddms.cfg 文件后面添加native=true, 然后打开ddms, 就可以看到Native Heap了." />
            <outline text="在启动ddms前, 需要把 arm-linux-androideabi-addr2linux 所在的路径加到PATH环境变量中." />
            <outline text="点击 snapshot current native heap usageke, 根据提示在 symbol search path里输入相应库的符号表路径就行了." />
            <outline text="找到泄漏后，根据提示的backtrace地址，可以用NDK中的 arm-linux-androideabi-addr2line 工具算出对应的函数地址，" />
            <outline text="也可以把堆栈排列成 tombstone 格式，然后用 stacktrace 工具求出函数调用关系。" />
          </outline>
        </outline>
        <outline text="nativie_heapdump_viewer 使用方法">
          <outline text="python ./nativie_heapdump_viewer.py --verbase &amp;lt;backtrace文件路径&amp;gt; --symbols &amp;lt;符号表位置&amp;gt; &amp;gt; ./memlock_parse.log" />
        </outline>
      </outline>
      <outline text="35-音频">
        <outline text="手机音频硬件">
          <outline text="mic：话筒，手机下部小孔，为输入设备。" />
          <outline text="receiver：听筒，手机上部小孔，为输出设备。" />
          <outline text="耳机：手机耳机有mic和receiver功能，一般还有线控功能。" />
          <outline text="speaker：手机外放，一般在背面，有明显的音腔。输出设备。">
            <outline text="speaker音频通道的输出是通过pm放大后接到外部的speaker器件的，以满足speaker设备对大电流的需要。" />
          </outline>
          <outline text="pm芯片">
            <outline text="pm音效开关；" />
            <outline text="pm功率增益设置，具体增益从-16db到120db；" />
            <outline text="增益设置延时，目的是给功率设置一个冷却时间，有10ms和100ms两种。" />
          </outline>
        </outline>
        <outline text="硬件设计要处理两类问题">
          <outline text="网络相关，即保证自己听得到对方，对方听得到自己。" />
          <outline text="本机回环，即保证自己能听到自己的，即听筒/speaker到耳机或mic。">
            <outline text="这个特性是基于人的本能诉求。" />
            <outline text="这类问题更难搞定。" />
          </outline>
        </outline>
        <outline text="声音的好坏主要取决于结构和硬件  #经验总结 ">
          <outline text="结构是第一位的，主要是音腔大小和结构。音腔不行，靠其它方面去弥补效果有限。" />
          <outline text="其次是音频器件的输出功率和稳定度；" />
          <outline text="第三是其它信号源的干扰。" />
        </outline>
        <outline text="音频驱动的关键元素">
          <outline text="一个表（寄存器配置表）" />
          <outline text="两张图（音频电路原理图和寄存器配置说明图）" />
          <outline text="4个元素">
            <outline text="声音设备（device）">
              <outline text="snd_device_type，用于描述声音所使用的具体硬件设备。" />
              <outline text="包括耳机、speaker、BT、usb等多种。" />
            </outline>
            <outline text="声音方法（method）">
              <outline text="snd_method_type，用于描述声音的具体类型。" />
              <outline text="包括 ring, key_beep, midi 等。" />
            </outline>
            <outline text="声音产生器（generator）">
              <outline text="定义具体的硬件声音产生器。我们用了两种：" />
              <outline text="vocoder设备，产生tone音和voice音；" />
              <outline text="midi设备，产生midi音。" />
            </outline>
            <outline text="codec">
              <outline text="pcm编码通道，voc_codec_type，包括voc_codec_on_chip_o，包括headset、handset、speaker、bt等。" />
              <outline text="codec config：voc_cal_codec_cfg" />
              <outline text="audio path config：音频路径设置，用于区分语音通话用的是cdma还是gsm。" />
            </outline>
          </outline>
          <outline text="在这4个元素之间的3组映射关系">
            <outline text="snd_cal_control_data[][]">
              <outline text="device + method -&amp;gt; codec" />
              <outline text="数组中，声音设备和声音方法的组合，来确定所使用的音量设置，以及所使用的codec。" />
            </outline>
            <outline text="voc_cal_audio_path_config[][]（模拟信号）">
              <outline text="codec + codec config -&amp;gt; 寄存器配置。" />
              <outline text="数组中每个值对应一个寄存器配置。" />
              <outline text="寄存器配置值保存在文件 msmand.h中，数组定义在 voccal.c 中。" />
              <outline text="比如，要使用speaker播放mp3，则当codec config取值为voc_cal_codec_cfg_synth，而codec取值为 voc_codec_sperker时，使用mp3的播放寄存器。" />
            </outline>
            <outline text="voc_pcm_cal_aptr[][]（数字信号）">
              <outline text="PCM path + codec -&amp;gt; pcm参数配置。" />
              <outline text="pcm参数包括滤波器系数、回声消除设置、降噪设置。" />
              <outline text="变量在voccal.c 中定义。" />
            </outline>
          </outline>
        </outline>
        <outline text="音频参数从哪里来？">
          <outline text="音频参数由硬件声学组给我们，我们再用qact工具转成.h/.c文件，入库。" />
        </outline>
        <outline text="PCM码流">
          <outline text="PCM 脉冲编码调制是Pulse Code Modulation的缩写。" />
          <outline text="模拟信号数字化必须经过三个过程，即采样、量化和编码。" />
          <outline text="一次声波振动中，至少要有2个点的采样。当然越多音质越好。" />
          <outline text="PCM码流是cd上用的音乐格式，即所谓的cd音质。" />
          <outline text="非压缩，所以比较大。" />
        </outline>
        <outline text="语音PCM的采样率">
          <outline text="话音PCM的采样率为8kHz，每个量化样值对应一个8位二进制码，故话音数字编码信号的速率为8bits×8kHz=64kb/s。" />
        </outline>
        <outline text="CD音质的采样率">
          <outline text="人耳能够感觉到的最高频率为20kHz，所以40kHz以上的我们可以认为是原声。" />
          <outline text="CD的采样率为44.1kHz，采样带宽为16bit。基本达到人听觉的极限，所以被认为是无损的原始声音格式。" />
          <outline text="音乐无损压缩； 较流行的是ape和FCAC两种。" />
        </outline>
        <outline text="DTMF编码音">
          <outline text="拨号时使用的一种声音编码，是电话系统中电话机与交换机之间的信令，用于发送被叫号码。" />
          <outline text="比较古老的编码方式，一直沿用到现在。" />
          <outline text="传统电话拨号键盘是4×4的矩阵，每一行代表一个低频，每一列代表一个高频。每按一个键就发送一个高频和低频的正弦信号组合，比如'1'相当于697和1209赫兹(Hz)。" />
          <outline text="交换机可以解码这些频率组合并确定所对应的按键。" />
        </outline>
        <outline text="录音buffer的计算方法">
          <outline text="对于录音，其获取音频数据的时间间隔应为：缓冲区大小/采样率/声道/采样精度，即录音buffer大小为2048，采样率为16K，单声道，采样精度2字节，那么时间间隔应该是2048/16000/1/2=64ms." />
        </outline>
        <outline text="高通音频硬件处理流程">
          <outline text="音频数字信号（PCM码流）输入DSP，进行音量、音效等的处理。DSP输出的是PCM。" />
          <outline text="PCM输入到codec_spa，进行D/A转换，变成模拟信号，根据音频通道发给各种设备。" />
        </outline>
        <outline text="蓝牙耳机的数据流">
          <outline text="mp3 -》 pcm码流 -》蓝牙耳机" />
        </outline>
        <outline text="语音通话的数据流">
          <outline text="语音通话 -》 pcm码流 -》amr格式 -》 网络信号" />
        </outline>
        <outline text="IP电话场景">
          <outline text="wifi call" />
          <outline text="skype call" />
        </outline>
        <outline text="耳机插入检测">
          <outline text="耳机插拔侦听">
            <outline text="当前产品统一用GPIO中断方式。" />
            <outline text="耳机按键则是用ADC读写。" />
            <outline text="涉及卡槽插拔的器件，都要做防抖处理。" />
            <outline text="耳机检测的防抖方案是将前3次读到的状态丢弃。" />
          </outline>
          <outline text="四段式耳机的线序">
            <outline text="反线序（手机基本都是用这种）：Mic、G（地）、Right（右声道）、Left（左声道）。" />
            <outline text="标准线序是G、M、R、L，即M和G交换。" />
          </outline>
          <outline text="三段式耳机的线序">
            <outline text="三段式耳机没有mic。所以其线序即G、R、L。" />
          </outline>
          <outline text="如何区分三段还是四段？">
            <outline text="看Mic触点的状态。" />
          </outline>
          <outline text="耳机按键">
            <outline text="使用adc来读耳按键类型，其中2280mv为7健线控耳机，2550mv为单键线控耳机。" />
            <outline text="信号从Mic触点走。当按键按下时，Mic触点会产生一个小于100mV的电流，通过adc能监测到。" />
            <outline text="不按的时候，Mic触点维持在5V。" />
          </outline>
          <outline text="耳机mic">
            <outline text="mic触点还会连接到mic bias上。需要用mic时打开mic bias。" />
            <outline text="mic的种类：手机mic分驻级式mic和硅mic两种。" />
          </outline>
        </outline>
        <outline text="自动应答功能">
          <outline text="高通代码不支持自动应答。我们自己实现的方案。" />
          <outline text="这个功能的难点是高通dsp可实现pcm与amr等格式的互转，但没有开放给我们用。" />
          <outline text="如果录制为amr等压缩格式，那么由于网络侧需要的声音格式很多种，如果格式不匹配，就会无声。比如如果录制为amr格式，则只有W电话才可以用。" />
          <outline text="解决方案是录制pcm声音，自动应答时将pcm码流输入到声音通路上，由协议栈进行压缩和编码。其缺点是pcm非压缩，文件大，所以录音长度受限。" />
        </outline>
        <outline text="声音环回延迟功能">
          <outline text="高通支持声音换回，但无延迟，在生产现场，由于声音嘈杂，导致无法识别。" />
          <outline text="解决方案和自动应答方案类似，将mic中传入的声音用pcm格式进行录音，过一定时间，在传入听筒输出通道中输出。延迟时间可灵活控制。" />
        </outline>
        <outline text="音效">
          <outline text="杜比" />
          <outline text="DTS" />
          <outline text="SRS" />
          <outline text="2012年，DTS收购了SRS后，最新定价是：DTS：$0.16；SRS：$0.20。" />
          <outline text="DTS和SRS比较">
            <outline text="DTS在HAL层集成的，且稳定性较差，和高通LPA方案有冲突；" />
            <outline text="SRS在framework层集成，稳定性较好。" />
          </outline>
          <outline text="高通LPA方案">
            <outline text="高通提供的在音乐播放时降低功耗的方案，在HAL层集成。" />
          </outline>
        </outline>
        <outline text="分贝，DB的概念">
          <outline text="分贝，表示两个量的比值的对数，没有单位。">
            <outline text="用于功率的场景较多，此时其公式是：db=10*lg(A/B)。" />
            <outline text="对于电流、电压、声强等信号强度，db=20*lg(A/B)。" />
            <outline text="分贝也参见于衡量一个系统的输出和输入的比率，即增益。" />
            <outline text="db可以做减法，减法即功率相除，比如信噪比就是db减法。DB一般不做加法，也没有乘除。" />
          </outline>
          <outline text="使用db单位的好处">
            <outline text="数据变小；" />
            <outline text="运算方便，由乘除变加减。" />
            <outline text="符合和人体生物学特征。人对声音响度的感受和功率的相对增长正相关。" />
          </outline>
          <outline text="几个常见的db值">
            <outline text="0db表示增益0。" />
            <outline text="-3db表示减半功率。" />
            <outline text="+3db表示功率大一倍。" />
            <outline text="在电声系统中，正负3db被认为不影响声音特征。" />
          </outline>
          <outline text="无线功率mW和dbm">
            <outline text="dbm定义为相对于1毫瓦（mW）的比例的指数的10倍。" />
            <outline text="根据每10db，增益加10倍的原则，很显然，30dbm=1000mw=1w；10db=10mw。" />
          </outline>
          <outline text="声学中db的概念">
            <outline text="声音强度的单位是巴斯卡，即牛顿/平方米。" />
            <outline text="人耳的感应范围很大，从20微巴到2000巴之间。一般用db来计算声音强度。基准是20微巴。" />
            <outline text="计算公式是：db=20*lg（当前身压值/20微巴)." />
          </outline>
          <outline text="几种常见声音的db值">
            <outline text="0分贝：3米外的一只蚊子在飞；" />
            <outline text="10db：极安静的房间；" />
            <outline text="40-60，正常谈话；" />
            <outline text="60-80：10米外经过的汽车；" />
            <outline text="90：嘈杂的酒吧；" />
            <outline text="120-130：摇滚演唱会的最前排；" />
            <outline text="160：航天飞机引擎声；" />
            <outline text="175：75米外1吨炸药爆炸。" />
            <outline text="一般85分贝以上的声音就会导致听觉细胞开始死亡。" />
          </outline>
        </outline>
      </outline>
      <outline text="36-互联">
        <outline text="多种无线接入方式的简单对比数据 @iFile" />
        <outline text="WiFi">
          <outline text="WiFi的全称是Wireless Fidelity，无线保真技术。属于在办公室和家庭中使用的短距离无线技术。" />
          <outline text="WiFi覆盖范围可达90米左右，且可穿墙。" />
          <outline text="wifi和wlan是不是同一个概念？">
            <outline text="应该这么讲，在国外，这个是同一个概念，因为wifi是wlan的唯一实例。" />
            <outline text="但在中国，还有个WAPI标准。" />
            <outline text="不过WAPI其实就是wifi, 在WiFi协议栈上加了一层安全机制, 但是这个安全层也不甚可靠." />
            <outline text="WAPI每台收费6人民币，wifi标准目前免费。" />
          </outline>
          <outline text="wifi和wimax有什么区别?">
            <outline text="项目           WiFi                                   WiMax" />
            <outline text="标准IEEE     802.11a/b/g                 IEEE 802.16a/d/e" />
            <outline text="多址方式      CKK、OFDM                   OFDM/FDD、TDD" />
            <outline text="频带         2.4GHz，不要许可证            2-11GHz，部分不要许可证" />
            <outline text="最高速率      54Mb/s                      ＞70Mb/s" />
            <outline text="业务         话音与数据                    话音、数据、视频图像" />
            <outline text="覆盖         微蜂窝                       宏蜂窝（＜50km）" />
            <outline text="移动性       静止、步行                    静止、步行" />
            <outline text="频谱利用率    ＜2.7bps/Hz                 3.75bps/Hz" />
            <outline text="成熟度       很好                         不成熟" />
            <outline text="终端         PC卡                        智能信息设备、PC卡" />
          </outline>
          <outline text="wifi使用的频段">
            <outline text="2.4G. 也有5G频段的，较少." />
            <outline text="带宽是20M，一般分为14个信道（channel），编号为1-14。" />
            <outline text="该频段为免费频段。" />
          </outline>
          <outline text="WiFi的功能">
            <outline text="STA：wifi接入(核心)">
              <outline text="有三个主流程:" />
              <outline text="打开/关闭设备" />
              <outline text="扫描/鉴权" />
              <outline text="数据传输" />
            </outline>
            <outline text="AP：软件(虚拟)热点" />
            <outline text="wifi direct：WiFi直连" />
          </outline>
          <outline text="wifi芯片">
            <outline text="博通芯片">
              <outline text="4329（用于10年）" />
              <outline text="4330（用于11-12年）" />
              <outline text="优点是稳定、复合程度高，有三合一、四合一、五合一，目前主打，就是比较贵。" />
            </outline>
            <outline text="高通wcn: 高通主打芯片，不稳定，但高通免费送，且强推。" />
            <outline text="ath: 被高通收购. 便宜，不稳定。" />
          </outline>
          <outline text="硬件管脚">
            <outline text="REG_ON:上电" />
            <outline text="WLAN_WAKEUP_MSM: 唤醒管脚" />
            <outline text="CMD" />
            <outline text="CLK" />
            <outline text="DATA 1-4">
              <outline text="我们手机上clk配置的是25M。" />
              <outline text="BC的 wifi芯片，需要连接 37.4M的晶振。" />
            </outline>
          </outline>
          <outline text="" />
          <outline text="802.11协议族">
            <outline text="只需要关注三个：" />
            <outline text="802.11b，1999年，11Mbit/s；" />
            <outline text="802.11g，2007年，54Mbit/s；" />
            <outline text="&lt;b&gt;802.11n&lt;/b&gt;，2009年，支持MIMO技术（多重输入输出），带宽最高达600Mb/s。" />
            <outline text="另外, 802.11x, 即 winmax，目前已死。wifi和winmax都是inter在主力支持。" />
            <outline text="一般WIFI设备仅支持到 11n的 65Mb/s。" />
          </outline>
          <outline text="802.11协议栈的分层 （6层）">
            <outline text="PHY：硬件" />
            <outline text=" MAC：介质访问控制（以上这两层为硬件层）">
              <outline text="把数据链路层分为两层: 偏硬件的介质访问控制层和偏软件的数据逻辑链路层。" />
              <outline text="新出的通讯协议一般都是如此." />
              <outline text="因为介质访问控制一般作为 fireware放在硬件了。" />
            </outline>
            <outline text=" LLC（数据逻辑链路）" />
            <outline text="IP" />
            <outline text="TCP " />
            <outline text="APP（应用）" />
          </outline>
          <outline text="网络拓扑结构">
            <outline text="Station(STA)">
              <outline text="STA, 工作站，即客户端设备。" />
              <outline text="任何设备只要拥有 IEEE 802.11 的 MAC 层和 PHY 层的接口，就可称为一个工作站。" />
            </outline>
            <outline text="Station Services (SS)">
              <outline text="在安全方面，还提供了身份确认服务(Authentication)和隐密性服务(Privacy)." />
              <outline text="工作站服务，软件概念。提" />
              <outline text="供工作站送收资料的服务." />
            </outline>
            <outline text="Access Point (AP)">
              <outline text="AP即热点，也叫接入点." />
              <outline text="通常在一个 BSA 内只会有一个AP。" />
            </outline>
            <outline text="Basic Service Area (BSA)">
              <outline text="即一个wifi子网，最小的子网即一个热点和一个STA。" />
            </outline>
            <outline text="BSS (Basic Service Set，基础服务集): BSA中所有STA的集合。" />
            <outline text="Distribute System (DS)">
              <outline text="分布式系统，通常是由有线网络所构成，可将数个 BSA 连结起来。" />
            </outline>
            <outline text="Extended Service Area (ESA)">
              <outline text="数个 BSAs 经由 DS 连结在一起，所形成的区域，就叫作一个扩充服务区。" />
            </outline>
            <outline text="ESS">
              <outline text="ESA中上所有STA的集合." />
              <outline text="STA在ESS中的移动（即wifi漫游）对上层不可见，SSID不变，IP地址不变。（适合商业环境）" />
            </outline>
            <outline text="SSID: service set ID，服务集识别码">
              <outline text="需要单独配置的参数：加密方式、SSID名、接入限制、隐藏SSID；" />
              <outline text="多SSID可共用的参数：信道、功率、速率等。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;WiFi需求规格&lt;/b&gt;">
            <outline text="开关WIFI">
              <outline text="除了在WIFI设置界面可以开关WIFI，还有其他的入口可以开关，要查看这些开关状态是否一致。" />
              <outline text="还有就是飞行模式对WIFI开关的影响，由于WIFI开和关都有一个时间过程，而飞行模式的开关瞬间完成，所以有时会出现冲突。" />
            </outline>
            <outline text="开关新可用网络提醒">
              <outline text="新可用网络的定义是自WIFI模块开启后，从未发现过的，为加密的网络。" />
              <outline text="只有满足了新可用网络的定义，才会有提醒。" />
            </outline>
            <outline text="手动添加网络">
              <outline text="可手动输入SIID，网络加密类型，密码。" />
              <outline text="需要路由器关闭SIID广播。" />
              <outline text="如果路由器隐藏了SSID，手动添加的网络是无法连接的。" />
            </outline>
            <outline text="设置静态IP">
              <outline text="android对IP输入的限制是整数0到整数255之间，也就是说0000.000200.001.001这样一个IP都能合法输入。" />
            </outline>
            <outline text="芯片自动扫描">
              <outline text="wifi打开后，芯片会自动开始扫描。" />
              <outline text="扫描方式分为:" />
              <outline text="主动方式：主动发 prob req命令给周边设备。" />
              <outline text="被动方式">
                <outline text="被动就是接受 ap发的命令." />
                <outline text="我们只支持被动。" />
                <outline text="扫描周期是7秒。" />
                <outline text="如果有连接上的（即通过鉴权），就不再扫描。" />
              </outline>
            </outline>
            <outline text="应用发起的扫描">
              <outline text="进入settings wifi设置菜单后，MScanner类会周期性的发起扫描." />
              <outline text="G版本是6秒一次，I版本是10秒一次。" />
              <outline text="无论是否连接上，都会持续扫描。" />
              <outline text="退出界面就不扫了。" />
            </outline>
          </outline>
          <outline text="休眠设置">
            <outline text="WIFI模块是用电大户." />
            <outline text="WIFI开启后会更改电池状态等其他状态。关闭WIFI时，android的策略是卸载驱动来省电。如有缺失就是问题。" />
            <outline text="为了省电，android提供了WiFi休眠策略，可以设置为: 永远不断开，充电时不断开和锁屏时断开这三种。" />
            <outline text="要测试休眠设置是否有效，可以在路由器上PING手机的IP，PING通就是连接状态。" />
            <outline text="部分手机会选择忽略该项设置, 无论选哪个都会一直保持连接，锁屏后15分钟再休眠。" />
          </outline>
          <outline text="代码结构及初始化">
            <outline text="app">
              <outline text="WifiSettings类, 在系统设置中显示." />
              <outline text="WifiEnabler类，打开成功后，将 wifi_DB 写入 Settings_DB。" />
            </outline>
            <outline text="framework">
              <outline text="模块">
                <outline text="netd（daemon）" />
                <outline text="dnasmasq" />
                <outline text="&lt;b&gt;wpa_suppliant&lt;/b&gt;（wifi开源协议栈，目前为主流）">
                  <outline text="&lt;b&gt;wpa_suppliant&lt;/b&gt;是一个安全中间件，为各种无线网卡提供统一的安全机制." />
                </outline>
              </outline>
              <outline text="初始化流程">
                <outline text="在 SystemServer 启动的时候,会生成一个 ConnectivityService的实例." />
                <outline text="ConnectivityService的构造函数会创建WifiService. &lt;b&gt;WifiService&lt;/b&gt;负责启动关闭wpa_supplicant、启动关闭.">
                  <outline text="WifiService extends SystemService，它是运行在进程SystemService中的一个线程, 常驻内存。" />
                </outline>
                <outline text="WifiStateTracker 负责创建 WifiMonitor 接收来自底层的事件. &lt;b&gt;WifiMonitor &lt;/b&gt;监视线程和把命令下发给wpa_supplicant, 然后从wpa_supplicant接收事件通知。" />
                <outline text="&lt;b&gt;WifiService和WifiMonitor是整个模块的核心。&lt;/b&gt;" />
                <outline text="&lt;b&gt;WifiManager&lt;/b&gt;（接口层，状态刷新也是找它）提供api封装。WiFi应用继承它。">
                  <outline text="WifiManager 通过 Binder 调用 WifiService。" />
                </outline>
              </outline>
            </outline>
            <outline text="HAL">
              <outline text="frameworks/base/core/jni/android_net_wifi_Wifi.cpp， android_net_wifi_loadDriver()。" />
            </outline>
            <outline text="driver">
              <outline text="wifi driver" />
              <outline text="SDIO driver">
                <outline text="sdio_readsb ；sdio_writesb：高通SD模块的FIFO读写" />
              </outline>
              <outline text="初始化流程">
                <outline text="wifi.c（hal）" />
                <outline text="通过socket通讯" />
                <outline text="kernel加载wifi.ko（动态加载）">
                  <outline text="hardware\libhardware_legacy\wifi\wifi.c，Wifi_load_driver()" />
                  <outline text="调用insmod()加载 /system/lib/modules/librasdioif.ko 和 /wifi/dhd.ko，" />
                  <outline text="安装librasdioif.ko。" />
                </outline>
                <outline text="驱动层: module_init() ">
                  <outline text="SD模块驱动安装成功的标志: /sys/devices/platform/msm_sdcc.2/polling" />
                  <outline text="调用bcm_wifi_load_driver()，加载博通芯片驱动" />
                </outline>
                <outline text="DHD_open() " />
                <outline text="从 nvram中读出信道、国家码等信息" />
                <outline text="php_init()，启动协议栈。" />
                <outline text="至此，drv层的设备初始化完成。" />
              </outline>
            </outline>
          </outline>
          <outline text="WiFi校准">
            <outline text="nvram是什么？">
              <outline text="/system/wlan/broadcom/nvram.txt 目录下，为txt文件，保存wifi的校准数据。" />
              <outline text="为博通芯片用的。" />
              <outline text="高通芯片也有类似的方案，但是叫 calcdata。" />
            </outline>
            <outline text="自校准方案">
              <outline text="博通芯片内置自校准，不用外界干预。" />
              <outline text="高通芯片不支持，需要外部控制校准，所以产线上需要增设一个WT工位。" />
              <outline text="目前高通正在做自校准方案，不成熟。" />
              <outline text="每出一个产品都需要投递手机给高通重新调试，周期在一周以上。" />
            </outline>
          </outline>
          <outline text="&lt;b&gt;网络连接过程&lt;/b&gt;">
            <outline text="打开WiFi">
              <outline text="WirelessSettings在初始化的时候配置了由WifiEnabler来处理Wifi按钮." />
              <outline text="当用户按下Wifi按钮后, Android会调用 WifiEnabler的onPreferenceChange(), 再由WifiEnabler调用WifiManager的 setWifiEnabled()." />
              <outline text="通过AIDL,实际调用的是 WifiService的setWifiEnabled(), WifiService接着向自身发送一条 MESSAGE_ENABLE_WIFI消息, 在处理该消息的代码中&lt;b&gt;做真正的使能工作.&lt;/b&gt;">
                <outline text="首先装载WIFI内核模块 (该模块的位置硬编码为&quot;/system/lib/modules/wlan.ko&quot; ), " />
                <outline text="然后启动 wpa_supplicant (配置文件硬编码为 &quot;/data/misc/wifi/wpa_supplicant.conf&quot;), " />
                <outline text="再通过 WifiStateTracker来启动 WifiMonitor中的监视线程." />
              </outline>
              <outline text="当使能成功后,会广播发送 WIFI_STATE_CHANGED_ACTION 这个Intent通知外界WIFI已经成功使能了 。" />
              <outline text="WifiEnabler创建的时候就会向 Android 注册接收 WIFI_STATE_CHANGED_ACTION, 因此它会收到该 Intent, 从而开始扫描. " />
            </outline>
            <outline text="查找AP">
              <outline text="扫描的入口函数是 WifiService的startScan(), 它其实也就是往 wpa_supplicant发送 SCAN命令。" />
              <outline text="当wpa_supplicant处理完SCAN命令后,它会向控制通道发送事件通知扫描完成,从而 wifi_wait_for_event() 会接收到该事件, 然后WifiMonitor中的 MonitorThread()会被执行来出来这个事件。" />
              <outline text="WifiStateTracker则接着广播发送 SCAN_RESULTS_AVAILABLE_ACTION 这个Intent。" />
              <outline text="WifiLayer注册了接收 SCAN_RESULTS_AVAILABLE_ACTION 这个Intent, 所以它的相关处理函数 handleScanResultsAvailable()会被调用." />
              <outline text="在该函数中,先会去拿到SCAN的结果(最终是 往wpa_supplicant发送 SCAN_RESULT命令并读取返回值来实现的), ">
                <outline text="List&amp;lt;ScanResult&amp;gt; list = mWifiManager.getScanResults();" />
              </outline>
              <outline text="对每一个扫描返回的AP,WifiLayer会调用 WifiSettings的 onAccessPointSetChanged(), 从而最终把该AP加到GUI显示列表中。" />
              <outline text="需要上报的数据包括ssid、bssid、proto等。" />
              <outline text="每个扫描周期上报一次，即6秒或10秒。" />
              <outline text="找到的AP都会上报; AP数量没有明确的上限。" />
            </outline>
            <outline text="配置AP参数">
              <outline text="当用户在WifiSettings界面上选择了一个AP后,会显示配置AP参数的一个对话框。" />
              <outline text="showAccessPointDialog(state, AccessPointDialog.MODE_INFO);" />
            </outline>
            <outline text="连接AP">
              <outline text="当用户在 AcessPointDialog 中选择好加密方式和输入密钥之后,再点击连接按钮, Android就会去连接这个AP。" />
              <outline text="WifiLayer会先检测这个AP是不是之前被配置过,这个是通过向 wpa_supplicant发送 LIST_NETWORK 命令并且比较返回值来实现的." />
              <outline text="// Need WifiConfiguration for the AP" />
              <outline text="WifiConfiguration config = findConfiguredNetwork(state);" />
              <outline text="如果wpa_supplicant没有这个AP的配置信息,则会向 wpa_supplicant发送 ADD_NETWORK命令来添加该AP." />
              <outline text="ADD_NETWORK 命令会返回一个ID, WifiLayer再用这个返回的ID作为参数向 wpa_supplicant 发送ENABLE_NETWORK命令, 从而让 wpa_supplicant 去连接该AP。" />
            </outline>
            <outline text="配置IP地址">
              <outline text="当wpa_supplicant成功连接上AP之后,它会向控制通道发送事件通知连接上AP了,从而 wifi_wait_for_event()会接收到该事件, 由此WifiMonitor中的MonitorThread()会被执行来出来这个事件." />
              <outline text="WifiMonitor再调用WifiStateTracker的notifyStateChange(), WifiStateTracker则接着会往自身发送 EVENT_DHCP_START 消息来启动DHCP去获取IP地址." />
              <outline text="然后再广播发送 NETWORK_STATE_CHANGED_ACTION这个Intent" />
              <outline text="WifiLayer注册了接收 NETWORK_STATE_CHANGED_ACTION 这个Intent,所以它的相关处理函数handleNetworkStateChanged() 会被调用." />
              <outline text="当DHCP拿到IP地址之后,会再发送E VENT_DHCP_SUCCEEDED消息." />
              <outline text="WifiLayer处理 EVENT_DHCP_SUCCEEDED消 息, 会再次广播发送." />
              <outline text="至此为止,整个连接过程完成." />
            </outline>
            <outline text="鉴权方案分为: ">
              <outline text="open（不需要鉴权）" />
              <outline text="wep（密码）" />
              <outline text="WPA/WPA2（密码）">
                <outline text="最常见认证方案." />
              </outline>
              <outline text="EAP-SIM/EAPAKA鉴权（通过运营商鉴权，自动鉴权）" />
              <outline text="WPS（一系列的简易鉴权方式）">
                <outline text="WPS, 即Wi-Fi Protected Setup" />
                <outline text="最常见的就是按下AP的wps键，自动鉴权，避免用户输入密码，即Push Button Config（PBC）" />
                <outline text="Pin Input Config（PIN）" />
                <outline text="USB Flash Drive Config（UFD）" />
                <outline text="NFC Contactless Token Config（NFC）" />
                <outline text="UDC（u盘）" />
              </outline>
              <outline text="WPS的工作原理">
                <outline text="对于STA来讲，还是需要密码，只是这个密码是AP传过来的，只是省了用户输入的步骤。" />
              </outline>
              <outline text="wifi密码缓存在哪里？">
                <outline text="/data/misc/wifi/wpa_supplicant_conf 中，是明文保存。" />
                <outline text="会记录所有连接过的ap信息。" />
              </outline>
            </outline>
            <outline text="连接后，DHCP（分配IP）的过程">
              <outline text="STA发出discover请求；" />
              <outline text="AP回应effor包，其中包括IP、子网掩码、DNS、IP id这些信息；" />
              <outline text="然后AP发出request指令，" />
              <outline text="STA把IP配置完成后，刷新本地IP及网络配置; " />
              <outline text="STA返回ack告知AP: 设备侧准备就绪。" />
            </outline>
          </outline>
          <outline text="WiFi控制分为三大组件：">
            <outline text="客户端程序，包括wpa_cli命令行或java图形界面程序，通过unix本地socket与wpa_supplicant daemon服务通信，发送命令并接收结果；" />
            <outline text="wpa_supplicant daemon服务，对应上述中间部分，功能是“上传下达”。">
              <outline text="所有客户端通过它控制硬件网卡，通过发送字符串命令控制是否扫描AP，提取扫描结果和是否关联AP等操作，同时将驱动的执行状态发送给用户。" />
              <outline text="该服务是设计支持多种无线网卡芯片，因此各个厂商共同提供了一个通用接口给wpa_supplicant调用." />
              <outline text="在手机内存的/etc/wpa_supplicant.conf中我们可以直接看到WIFI支持的网络类型，每种类型都有例子，比如：">
                <outline text="#Both WPA-PSK and WPA-EAP is accepted. Only CCMP is accepted as pairwise and" />
                <outline text="# group cipher." />
                <outline text="#network={" />
                <outline text="# ssid=&quot;example&quot;" />
                <outline text="# bssid=00:11:22:33:44:55" />
                <outline text="# proto=WPA RSN" />
                <outline text="# key_mgmt=WPA-PSK WPA-EAP" />
                <outline text="# pairwise=CCMP" />
                <outline text="# group=CCMP" />
                <outline text="# psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb" />
                <outline text="#}" />
              </outline>
              <outline text="不同类型的网络，不同的参数等等，应有尽有。" />
            </outline>
            <outline text="网卡驱动" />
          </outline>
          <outline text="beacon包">
            <outline text="手机和AP通过beacon包维持连接。" />
            <outline text="AP每隔100ms发给一次beacon广播。" />
          </outline>
          <outline text="&lt;b&gt;WiFi log&lt;/b&gt;">
            <outline text="wpa_supplicant|wifi monitor" />
            <outline text="wifi打开状态: 通过 wlan.driver.status 来确认。包括ok、locked等。" />
            <outline text="确认wifi硬件状态">
              <outline text="fopen /proc/modules，文本文件." />
              <outline text="如果其中有ar6000，则表示wifi已启动。" />
            </outline>
            <outline text="加载驱动: E/WifiHW ( 1201): ==JOHN DEBUG==: [WIFI] Load Driver" />
            <outline text="收到广播，WIFI状态正在开启">
              <outline text="D/SettingsWifiEnabler( 1321): Received wifi state changed from Disabled to Enabling" />
            </outline>
            <outline text="电池状态改变">
              <outline text="WIFI正在开启: D/WifiService( 1201): ACTION_BATTERY_CHANGED pluggedType: 2" />
            </outline>
            <outline text="WIFI硬件：加载内核模块">
              <outline text="E/WifiHW(1201):==JOHNDEBUG==:moduleaddress:4b938008 filename:/system/lib/modules/dhd.ko args:firmware_path=/system/wlan/broadcom/rtecdc.bin nvram_path=/system/wlan/broadcom/nvram.txt" />
            </outline>
            <outline text="WIFI硬件：返回装载模块报告：返回指令0，未知错误0">
              <outline text="E/WifiHW ( 1201): ==JOHN DEBUG==: return of insmod : ret = 0, Unknown error: 0" />
            </outline>
            <outline text="wpa_supplicant发出事件通知">
              <outline text="I/wpa_supplicant( 2490): CTRL-EVENT-STATE-CHANGE id=-1 state=2" />
            </outline>
            <outline text="WifiMonitor从wpa_supplicant接收事件通知">
              <outline text="V/WifiMonitor( 1201): Event [CTRL-EVENT-STATE-CHANGE id=-1 state=2]" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：准备好开始搜索网络了">
              <outline text="I/wpa_supplicant( 2490): CTRL-EVENT-SCAN-RESULTS Ready" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：驱动命令行.主动搜索.LEN">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd SCAN-ACTIVE len = 4096" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：驱动命令行.主动搜索.LEN">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd SCAN-ACTIVE len = 0, 11" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：驱动命令行.被动搜索.LEN">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd SCAN-PASSIVE len = 4096" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：驱动命令行.被动搜索.LEN=0.12">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd SCAN-PASSIVE len = 0, 12" />
            </outline>
            <outline text="接收到广播：WIFI已经开启">
              <outline text="D/SettingsWifiEnabler( 1321): Received wifi state changed from Enabling to Enabled" />
            </outline>
            <outline text="wpa_supplicant发出事件通知">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd RSSI len = 4096" />
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd RSSI len = 4, 4" />
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd LINKSPEED len = 4096" />
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd LinkSpeed 54 len = 12, 12" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：驱动命令行.MAC地址.LEN">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd MACADDR len = 4096" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：驱动命令行.MAC地址">
              <outline text="E/wpa_supplicant( 2490): wpa_driver_priv_driver_cmd Macaddr = 44:A4:2D:27:25:BE" />
            </outline>
            <outline text="wpa_supplicant发出事件通知:尝试连接，（SSID='LosAngeles'频段=2412 MHz）">
              <outline text="I/wpa_supplicant( 2490): Trying to associate with 1c:bd:b9:f6:a7:9f (SSID='LosAngeles' freq=2412 MHz)" />
            </outline>
            <outline text="WifiMonitor接收wpa_supplicant的事件">
              <outline text="V/WifiMonitor( 1201):Event[Trying to associate with 1c:bd:b9:f6:a7:9f (SSID='LosAngeles' freq=2412 MHz)]" />
            </outline>
            <outline text="WifiMonitor接收事件">
              <outline text="V/WifiMonitor( 1201): Event [CTRL-EVENT-STATE-CHANGE id=-1 state=3]" />
            </outline>
            <outline text="WIFI状态跟踪：更改请求状态：搜索中-&amp;gt;匹配中">
              <outline text="V/WifiStateTracker( 1201): Changing supplicant state: SCANNING ==&amp;gt; ASSOCIATING" />
            </outline>
            <outline text="网络状态跟踪：更新显示为正在连接状态">
              <outline text="D/NetworkStateTracker( 1201): setDetailed state, ld =SCANNING and new state=CONNECTING" />
            </outline>
            <outline text="连接管理服务：改变WIFI连接状态：正在连接/正在连接">
              <outline text="D/ConnectivityService( 1201): ConnectivityChange for WIFI: CONNECTING/CONNECTING" />
            </outline>
            <outline text="WIFI状态跟踪：更改请求状态：匹配中-&amp;gt;已匹配">
              <outline text="V/WifiStateTracker( 1201): Changing supplicant state: ASSOCIATING ==&amp;gt; ASSOCIATED" />
            </outline>
            <outline text="网络状态跟踪：更新显示为正在连接状态">
              <outline text="D/NetworkStateTracker( 1201): setDetailed state, ld =CONNECTING and new state=CONNECTING" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：已和1c:bd:b9:f6:a7:9f匹配">
              <outline text="I/wpa_supplicant( 2490): Associated with 1c:bd:b9:f6:a7:9f" />
            </outline>
            <outline text="WifiMonitor接收wpa_supplicant的事件">
              <outline text="V/WifiMonitor( 1201): Event [Associated with 1c:bd:b9:f6:a7:9f]" />
            </outline>
            <outline text="WIFI状态跟踪：更改请求状态：已匹配-&amp;gt;TCP中断连接">
              <outline text="V/WifiStateTracker( 1201): Changing supplicant state: ASSOCIATED ==&amp;gt; FOUR_WAY_HANDSHAKE" />
            </outline>
            <outline text="网络状态跟踪：更新显示为鉴定中">
              <outline text="D/NetworkStateTracker( 1201): setDetailed state, ld =CONNECTING and new state=AUTHENTICATING" />
            </outline>
            <outline text="连接管理服务：抛出WIFI连接状态改变：已连接/鉴定中">
              <outline text="D/ConnectivityService( 1201): Dropping ConnectivityChange for WIFI: CONNECTING/AUTHENTICATING" />
            </outline>
            <outline text="WIFI状态跟踪：更改请求状态：TCP中断连接-&amp;gt;确认标志位">
              <outline text="V/WifiStateTracker( 1201): Changing supplicant state: FOUR_WAY_HANDSHAKE ==&amp;gt; GROUP_HANDSHAKE" />
            </outline>
            <outline text="网络状态跟踪：更新显示为鉴定中">
              <outline text="D/NetworkStateTracker( 1201): setDetailed state, ld =AUTHENTICATING and new state=AUTHENTICATING" />
            </outline>
            <outline text="WiFi状态跟踪：更新显示为搜索状态">
              <outline text="D/NetworkStateTracker( 1201): setDetailed state, ld =IDLE and new state=SCANNING" />
            </outline>
            <outline text="WIFI状态跟踪：更改请求状态：搜索中-&amp;gt;不活动">
              <outline text="V/WifiStateTracker( 1201): Changing supplicant state: SCANNING ==&amp;gt; INACTIVE" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：WPA:与1c:bd:b9:f6:a7:9f确定标志位">
              <outline text="I/wpa_supplicant( 2490): WPA: Key negotiation completed with 1c:bd:b9:f6:a7:9f [PTK=CCMP GTK=TKIP]" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：">
              <outline text="I/wpa_supplicant( 2490): CTRL-EVENT-STATE-CHANGE id=0 state=7" />
            </outline>
            <outline text="wpa_supplicant发出事件通知：连接完成">
              <outline text="I/wpa_supplicant( 2490): CTRL-EVENT-CONNECTED - Connection to 1c:bd:b9:f6:a7:9f completed (auth) [id=0 id_str=]" />
            </outline>
            <outline text="WifiMonitor接收wpa_supplicant事件">
              <outline text="V/WifiMonitor( 1201): Event [WPA: Key negotiation completed with 1c:bd:b9:f6:a7:9f [PTK=CCMP GTK=TKIP]]" />
            </outline>
            <outline text="WifiMonitor接收wpa_supplicant事件">
              <outline text="V/WifiMonitor( 1201): Event [CTRL-EVENT-STATE-CHANGE id=0 state=7]" />
            </outline>
            <outline text="WifiMonitor接收wpa_supplicant事件">
              <outline text="V/WifiMonitor( 1201): Event [CTRL-EVENT-CONNECTED - Connection to 1c:bd:b9:f6:a7:9f completed (auth) [id=0 id_str=]]" />
            </outline>
            <outline text="WIFI状态跟踪：更改请求状态：确认标志位-&amp;gt;完成">
              <outline text="V/WifiStateTracker( 1201): Changing supplicant state: GROUP_HANDSHAKE ==&amp;gt; COMPLETED" />
            </outline>
            <outline text="WIFI状态跟踪：新网络状态为已连接">
              <outline text="V/WifiStateTracker( 1201): New network state is CONNECTED" />
            </outline>
            <outline text="网络状态跟踪：更新显示为获取IP地址">
              <outline text="D/NetworkStateTracker( 1201): setDetailed state, ld =AUTHENTICATING and new state=OBTAINING_IPADDR" />
            </outline>
            <outline text="连接管理服务：取消该WIFI连接">
              <outline text="D/ConnectivityService( 1201): Dropping ConnectivityChange for WIFI: CONNECTING/OBTAINING_IPADDR" />
            </outline>
          </outline>
          <outline text="中国电信c+w功能">
            <outline text="中国电信部署了3种热点，" />
            <outline text="要求支持c+w功能的手机在搜ap时，按照 latest ssid &amp;gt; customized ssid（电信热点）&amp;gt; normal ssid 的优先级来连接。" />
          </outline>
          <outline text="BT和wifi共用天线的问题">
            <outline text="共用天线时，一旦芯片发现wifi beacon包有丢失，会调高优先级保证wifi数据." />
            <outline text="此时BT连接很容易失败。" />
          </outline>
        </outline>
        <outline text="BT">
          <outline text="蓝牙芯片一般使用博通的。" />
          <outline text="频段">
            <outline text="使用2.4G的频段。" />
            <outline text="这个频段在全球都是免费的，包括 wifi/微波炉也用它。" />
          </outline>
          <outline text="网络结构">
            <outline text="蓝牙设备分主从，拓扑结构为树状，即一个从设备只有一个主设备，但一个主设备可以有多个从设备。" />
            <outline text="从设备只能和主设备通讯, 而不能和同一个主设备的其它从设备通讯。" />
            <outline text="一个主设备及其从设备构成一个“&lt;b&gt;微微网&lt;/b&gt;”。" />
            <outline text="一个设备可以同时是主设备和另一个微微网的从设备。" />
            <outline text="主从可以变换关系。根据蓝牙协议，从设备可以发出“role switch”命令，并得到主设备同意，就可以完成关系切换。这个地方经常出问题。" />
            <outline text="主从一体。" />
          </outline>
          <outline text="代码结构">
            <outline text="代码分为 core 和 profile 两部分。" />
            <outline text="core 即协议部分，一般很少出问题。" />
            <outline text="profile即业务逻辑部分。为新需求和bug的高发区。">
              <outline text="profile非常多，常用的有如下3种：" />
              <outline text="传文件">
                <outline text="OPP是对外传输。" />
                <outline text="FTP是主动索取（华为手机不支持）。" />
              </outline>
              <outline text="打电话：即蓝牙耳机" />
              <outline text="听音乐">
                <outline text="有多种协议，包括AIDP、AVDTP（音频视频分发传输协议）。" />
                <outline text="蓝牙听音乐的一个特殊地方是对音频的解码是放在蓝牙芯片上的。" />
                <outline text="耳机上的音频控制经常会失效。" />
              </outline>
            </outline>
          </outline>
          <outline text="低功耗蓝牙">
            <outline text="工作状态: " />
            <outline text="待机状态: " />
          </outline>
          <outline text="蓝牙拉距测试的指标：10米。" />
          <outline text="问题定位:">
            <outline text="先抓包. 看两边的指令序列是否是按规范来, 时间间隔是否OK." />
            <outline text="有专门的软件看日志." />
          </outline>
        </outline>
        <outline text="NFC">
          <outline text="功能">
            <outline text="读卡：做pos机用，卡刷手机。简称别人刷它。" />
            <outline text="卡模拟：做nfc卡用，刷别的pos机。简称它刷别人。" />
            <outline text="P2P：两个手机互传文件或电话本。简称互刷。" />
          </outline>
          <outline text="NFC芯片的管脚">
            <outline text="VEnable（使能）" />
            <outline text="INT（中断）" />
            <outline text="DATA（数据）接到CPU上。" />
            <outline text="clk_req（时钟请求）" />
            <outline text="clk（时钟）接到PMU上。" />
          </outline>
          <outline text="NFC电源">
            <outline text="VBAT（电源）接到电池引脚上，所以没有电池nfc就无法使用。" />
          </outline>
          <outline text="clk模式">
            <outline text="分动态模式和静态模式，根据clk_req来调整。这部分稳定性比较差。" />
          </outline>
          <outline text="代码">
            <outline text="java应用层：nfc Service。" />
            <outline text="JNI和fw层：核心是libnfc.so，为nxp协议的实现。代码在 extern/libnfc_hxp/ 下。" />
            <outline text="nfc模块没有hal层。fw之下直接就是drv了，代码在 /kernel/../nxp544.c。" />
            <outline text="nfc参数表放在 /data/misc/nfc/eedata.cfg。nfc模块启动后将其写入寄存器。">
              <outline text="参数格式：一行一字段，字段前三行为地址，第4项为值。" />
            </outline>
          </outline>
        </outline>
      </outline>
      <outline text="37-Power">
        <outline text="充电芯片">
          <outline text="双回路机制">
            <outline text="充电时，充电芯片有两个回路，一路给电池充电，一路给手机供电。" />
            <outline text="一般充电过程中, 电池不给手机供电。" />
            <outline text="如果手机有大电流需求，则用充电器和电池一起供电。" />
          </outline>
        </outline>
        <outline text="充电器">
          <outline text="智能手机电池一般都在3000毫安以上. " />
          <outline text="为适应大电池，充电器都切换为1A/5V, 或者2A/5V的大功率充电器。" />
          <outline text="第三方PD充电器更高, 达到18W、30W甚至65W。" />
        </outline>
        <outline text="电池指标">
          <outline text="循环放电400次后，满充容量不少于标称的80%。" />
          <outline text="倍率放电测试，要求放电电流和放电时间满足倍率关系。" />
          <outline text="高温测试，要求在-30到130度测试下，电池不燃烧。" />
          <outline text="60度存放7天，剩余电量大于90%；70度存放一天，剩余电量大于90%。" />
          <outline text="过充测试，要求4.6V充电保持7小时电池不燃烧。" />
        </outline>
        <outline text="电池校准">
          <outline text="电量表、温度曲线。一个产品一套." />
          <outline text="如果使用多种电芯，就需要多种电量表（同时需要提供识别它们的方法）。" />
          <outline text="校准方法: ">
            <outline text="电池校准发生在产线步骤CT中." />
            <outline text="程控电源设定n个电压（3.4v、3.7v、4.2v），分别读取ADC值5次，取平均值，保持到nv中。" />
            <outline text="测试: 在BT和MT中，对电压校准值进行测试，如果差距大于0.03V（一个ADC raw值的偏差），则认为电池校准失败。" />
          </outline>
        </outline>
        <outline text="充电类型">
          <outline text="标充">
            <outline text="5V2A, 2.5-3小时充满." />
          </outline>
          <outline text="快速充电">
            <outline text="9V2A, 1.5小时充满." />
          </outline>
          <outline text="超级快充">
            <outline text="低压: 5V 4.5A, 1.5小时充满." />
            <outline text="高压: 10V 4A, 1小时充满." />
          </outline>
          <outline text="无线充电">
            <outline text="无线充电芯片, 负责从电磁波中获取能量." />
            <outline text="功率一般7.5瓦." />
            <outline text="2020-01-14, 功率最高27瓦." />
            <outline text="90%以上是有效能量." />
          </outline>
          <outline text="反向无线充电">
            <outline text="5V 1A, 可支持非华为手机" />
            <outline text="15瓦. 最大40瓦(2020-01-14). " />
          </outline>
        </outline>
        <outline text="&lt;b&gt;充电方案（充电步骤）  **&lt;/b&gt;">
          <outline text="设计充电方案的主要考虑点  #经验总结 ">
            <outline text="确保绝对安全. 锂电池是存在安全风险的, 所以必须留够buffer." />
            <outline text="在安全的前提下，最大限度充满电，物尽其用;" />
            <outline text="在1和2都满足的前提下，充电时间尽可能短。" />
          </outline>
          <outline text="充电过程中，充电电压不变，保持5v;" />
          <outline text="充电电流一直在变化。" />
          <outline text="电池电压一直在升高, 通过电压估计电池电量。电池电压作为充电流程控制的主变量。" />
          <outline text="充电基本步骤">
            <outline text="1. 涓流充电">
              <outline text="开始充电时，如果电池电压低，必须用小电流充电，即涓流充电。" />
              <outline text="因为电池电压低的情况下，大电流充电，电池内阻会急剧升高，结果一是充不进去，二是发热伤害电池。" />
              <outline text="涓流充电门限">
                <outline text="充电电压5V，电流100mA；" />
                <outline text="电池电压2.8v-3.2v（3，2v相当于电池电量0%）。" />
              </outline>
              <outline text="涓流充电时间一般为10分钟。" />
            </outline>
            <outline text="2. 恒流充电">
              <outline text="电池电压在3.2v以上，开始用大电流充电，即采用允许的最大电流充，以节省时间。" />
              <outline text="恒流是充电的主要区间。" />
              <outline text="充电电压5v，恒流充电电流门限：">
                <outline text="标准充电器800mA-1A;" />
                <outline text="usb充电器450mA；" />
                <outline text="非标充电器450-500mA。" />
              </outline>
              <outline text="恒流充电在1-3个小时左右。" />
            </outline>
            <outline text="3. 恒压充电">
              <outline text="电池电压到了4.2v时，电池接近充满，此时转入恒压充电，保持电池电压基本不变，逐步减小充电电流，以避免过充。" />
              <outline text="恒压充电门限: 充电电压5v，充电电流逐步减小。电池电压由4.2v-》4.25v。" />
              <outline text="恒压充电时间一般在1个小时左右。" />
            </outline>
          </outline>
          <outline text="限流处理">
            <outline text="华为标配充电器限流1A或800mA，标配的条件是D+、D-短接；" />
            <outline text="非标充电器限流400-500mA。" />
            <outline text="USB充电限流: 按spec规定，USB充电必须限流。其中USB插入协商阶段，限流100mA，正常充电时限流400-450mA。" />
            <outline text="USB充电时，不能进入tx_wait状态. 原因是防止电流倒灌，在usb睡眠时可能发生。" />
          </outline>
          <outline text="LDO充电模式（传统）">
            <outline text="充电器变大后，传统LDO充电的问题就暴露了：电流容易过载、发热量大、充电时间过长。" />
            <outline text="取而代之的是DCDC方式。" />
          </outline>
          <outline text="DCDC充电模式">
            <outline text="DCDC充电管理芯片；" />
            <outline text="通过I2C总线进行参数设置和状态输出。" />
            <outline text="支持涓流、恒流、恒压三种模式;" />
            <outline text="当输入电压过高或过低时自动进入保护模式，停止充电。" />
          </outline>
        </outline>
        <outline text="放电过程和电量显示  **">
          <outline text="容量为3200毫安时（简称毫安）的电池，满电情况下以160mA的电流放电，可持续工作20小时。" />
          <outline text="另一个电量单位是瓦时（wH）。">
            <outline text="由于手机锂电池的标准发电电压是3.7v，所以瓦时和毫安时等价。" />
            <outline text="换算公式为：1wH = 3.6AH。" />
          </outline>
          <outline text="电池的放电区间">
            <outline text="区间在 3.4v-4.2v，其中大部分电流分布在 3.5v-3.6v 之间。" />
            <outline text="低于3.4v，电量极少。" />
            <outline text="低于3.2v，手机会自动关机。" />
          </outline>
          <outline text="当前充电流程控制中，通过&lt;b&gt;电池电压&lt;/b&gt;估计电量。">
            <outline text="电池电压从哪里来？ 通过ADC采样获得。" />
            <outline text="更优的方法是使用库仑计（电量计），直接测量电池电荷量，精度高，没有增压问题。但是电量计贵，只有iPhone用得起。" />
          </outline>
          <outline text="在非充电状态下，这种方案精度有保障。" />
          <outline text="但在充电模式下，则有增压问题。">
            <outline text="在充电时，由于电池内阻，电压上升得比较快，电压和电量的关系变得非线性，精度偏差较大。" />
            <outline text="一般会采用经验值做一定的平滑，即&lt;b&gt;电量表&lt;/b&gt;。" />
            <outline text="电量表是一个数组，第一个数据是1%电量对应的电压值，第二个是2%电量的电压值，如此类推。" />
            <outline text="一般有四张电量表，分别对应放电、充电器充电、usb充电、非标充电器充电。" />
          </outline>
          <outline text="电池电压读取周期">
            <outline text="当电量为0、1、2格时，15秒读一次；" />
            <outline text="3、4、5格时，30秒读一次；" />
            <outline text="开机时，第5秒读第一次。" />
          </outline>
          <outline text="0格电压门限： 3.46V" />
          <outline text="电池放电平滑算法： 本次结果 = 0.875 *上次结果 + 0.125 * 本次ADC采样值" />
          <outline text="开机时特殊处理： 电池电压读数不准，所以把前两次都丢弃掉。只使用第65秒的值。" />
          <outline text="电量显示：满格占40%电量，1格占的极少。其它基本均分。" />
          <outline text="电量显示存在学习过程. 因为电池容量是变化的, 要根据充放电的数据进行学习." />
          <outline text="启动学习的条件:">
            <outline text="电量在20%以下;" />
            <outline text="充电时间在半小时以上;" />
            <outline text="电池温度在10-45度之间." />
          </outline>
        </outline>
        <outline text="关机充电">
          <outline text="关机充电时，手机启动到recovery（即kernel），但不进Android。" />
          <outline text="而modem侧都启动了。所以不做处理的话，是可以被打通电话的，只是无法接。" />
          <outline text="进关机充电条件的判断是在oemsbl中。什么条件:">
            <outline text="电池和充电器是否都在位；" />
            <outline text="是否为正常开机，包括闹钟开机、按power键开机、用户重启开机；" />
            <outline text="是否为异常开机，包括watchdog reset开机和瞬间掉电开机；" />
            <outline text="misc分区中的充电使能标志的值。" />
          </outline>
          <outline text="关机充电动画处理">
            <outline text="recovery中有一套基于framebuffer的图形接口，在 bootable/recovery/miniui/graphices 中。" />
          </outline>
          <outline text="misc分区中的充电使能标志的功能: ">
            <outline text="给app使用. " />
            <outline text="当他们想重启，而不是关机时，去使能这个标志，以避免不开机而进关机充电界面。" />
            <outline text="可通过 cat /proc/app_info/charge_flag 来查看。" />
          </outline>
          <outline text="按键处理: 进入充电前，recovery启动一个叫 charge_input_thread 的线程处理按键，其中音量上下键只起唤醒作用，power键起关机作用。" />
        </outline>
        <outline text="充电过程的常见异常  #经验总结 ">
          <outline text="涓流无法转恒流;" />
          <outline text="恒流无法转恒压；" />
          <outline text="充电不截止；" />
          <outline text="零星脉冲充电；" />
          <outline text="二次充电（已经充满停止充电后, 再自动开始充电. 和增压问题有关）." />
        </outline>
        <outline text="" />
        <outline text="功耗管理">
          <outline text="android的功耗管理只要通过锁和定时器来切换系统状态，使功耗降低到最低。" />
          <outline text="应用层的两种 wakelock.">
            <outline text="一种是 partial wakeup，申请了这种，即使按power键，系统也不进sleep，比如music player。" />
            <outline text="其它类型的 wakeup，按power键，系统进sleep。" />
            <outline text="各自锁的定义常见 newWakeLock.c。" />
          </outline>
          <outline text="fwk client端代码在：frameworks/base/core/java/android/os/PowerManager.java">
            <outline text="它定义了一个wakelock基类，有两个成员，acquire 和 release。" />
            <outline text="需要进行睡眠控制的类，会定义 wakelock成员. ">
              <outline text="通过qcquire接口来禁止睡眠，" />
              <outline text="通过release接口来允许睡眠。" />
              <outline text="要成对使用，否则导致系统无法进睡眠。" />
            </outline>
          </outline>
          <outline text="fwk service端的代码在 powermanager_service.java, 是核心。">
            <outline text="power.java 为接口io层，访问jni层。" />
            <outline text="jni层代码主要是 android_os_power.cpp。" />
          </outline>
          <outline text="hal层代码是 power.c，通过sys文件系统，syscall， 调用driver。" />
          <outline text="driver层代码在 kernel/kernel/power">
            <outline text="wakelock模块主要维护两个链表。应用申请lock，在调用wakelock()中插入active_wake_locks链表。" />
            <outline text="被释放的 lock ，调用 wakeunlock(),会将其移动到 inactive_locks 队列中去。" />
            <outline text="在调用 wakeunlock() 中，以及定时器到时间时，会调用 has_wake_lock_locked()来看是否有active的lock，如果没有，则启动 suspend_unlock 工作队列，执行睡眠流程。" />
            <outline text="有3个suspend_work_queue队列">
              <outline text="睡眠准备：early_suspend_work">
                <outline text="通常会把LCD和背光驱动注册为early_suspend_work，以便第一阶段被关闭。" />
              </outline>
              <outline text="睡眠：suspend_work" />
              <outline text="睡眠恢复：late_resume_work" />
            </outline>
            <outline text="kernel会去查看 wakelock是否全部释放，如果是，则启动suspend_work队列，让所有设备进入suspend状态，并停止时钟。" />
          </outline>
          <outline text="应用如果要保持屏幕亮， 调用链是：">
            <outline text="TimerOutTask(screen) " />
            <outline text="setPowerState() " />
            <outline text="Power.setScreenState()" />
            <outline text="set_screen_state() // jni" />
            <outline text="write(&quot;/sys/power/state&quot;) " />
            <outline text="state_store()   // driver" />
            <outline text="state_store()；后面分为两支，MEM 则进入 early_syspend(), ON 则进入 late_resueme()." />
          </outline>
          <outline text="应用如果要禁止进待机，调用链是：">
            <outline text="PowerManagerService.java" />
            <outline text="Power.java" />
            <outline text="acquire_wake_lock()" />
            <outline text="write &quot;/sys/power/wake_lock&quot;" />
            <outline text="wake_lock_store()" />
            <outline text="wake_lock() " />
            <outline text="wake_lock_time_out()" />
          </outline>
        </outline>
        <outline text="待机：DRX周期">
          <outline text="非连续接收周期。进入睡眠后，大约每2.56秒，手机会醒来查看是否有呼入。此时也会检查是否有用户输入。" />
          <outline text="手机用这个机制来省电。" />
          <outline text="比如 GSM drx周期为1.18秒，WCDMA为2.56秒。" />
        </outline>
        <outline text="手机器件的典型功耗（不是太准确）  #经验总结 ">
          <outline text="SDRAM读写刷新：60-65mA（＊2，有两块）；静态电流：200uA（＊2）" />
          <outline text="Nand flash工作：10-20mA；静态：&amp;lt;1mA" />
          <outline text="camera工作：100mA；静态：uA级" />
          <outline text="LCD工作：50mA；静态：30uA" />
          <outline text="LCD背灯工作：75mA；静态：uA级" />
          <outline text="EL灯片工作：70mA；静态：uA级" />
          <outline text="RF+PA发射（高通套片）工作（GSM）2.35mA；静态：nil" />
          <outline text="RF+PA接受（高通套片）工作（GSM）2.15mA；静态：nil" />
        </outline>
        <outline text="驱动整机功耗优化的思路  #经验总结 ">
          <outline text="临区测量对待机的影响；" />
          <outline text="搜网时间间隔；小区切换频繁的定位方案、优化方案；" />
          <outline text="通话和待机时CPU主频的优化；" />
          <outline text="周期位置更新周期和每次时长的记录，及优化方案；" />
          <outline text="背光、马达等的设置，功耗和业界方案对比。" />
          <outline text="声音播放过程中的优化。" />
        </outline>
        <outline text="驱动整机功耗调试经验  #经验总结 ">
          <outline text="BT电源是功耗大户，拔器件看功耗有没有改善。" />
          <outline text="board id相关的gpio要细调，有时候会有四五mA的漏电。" />
          <outline text="常见问题包括：PA开关、TF卡电源、mac bias电源。" />
          <outline text="rf电源如果有问题，功耗会差很多。包括rftx、rfrx1、rfrx2、s2、s3、wlan等。先看能不能关，不能关看有没有省电模式。" />
          <outline text="调整好软件流程。系统有中断马上会启动tcxo，电流起码40mA。" />
          <outline text="上拉电阻的阻值要尽量大一些，保证静态电流尽量小。" />
          <outline text="慎用三极管做开关，因为管子本身电流大。" />
          <outline text="外围芯片中，对于提供shutdown状态的芯片要尽量提供控制电路，软件要确保待机前使之进入shutdown。" />
          <outline text="射频发射功耗大，尽量做到高效率，减少不必要的延迟和重传，当然要懂这块之后再调。" />
          <outline text="I2C关闭时，要作为GPIO来关，否则关不彻底。" />
        </outline>
        <outline text="应用功耗管理">
          <outline text="功耗精灵之类." />
          <outline text="考虑要素:">
            <outline text="系统状态: 开屏, 锁屏3分钟, 锁屏10分钟, 锁屏1小时." />
            <outline text="应用状态: 前台, 后台." />
            <outline text="应用优先级: 超级应用, 比如 微信. QQ." />
          </outline>
          <outline text="对应用的处理措施">
            <outline text="冻结. " />
            <outline text="kill, 进程杀掉, 但是资源还在." />
            <outline text="stop" />
          </outline>
          <outline text="应用功耗排行">
            <outline text="实时统计 CPU, 基带, WiFi, GPS 等设备的功耗, 然后按应用对器件的使用占比来计算功耗排行." />
          </outline>
        </outline>
        <outline text="" />
        <outline text="热方案">
          <outline text="充电时用电池的热敏电阻，放电时用cpu的热敏电阻。" />
          <outline text="放电时，通过CPU旁边的热敏电阻监控CPU温度，超过门限（43℃左右）就降频。" />
          <outline text="充电时，通过充电芯片旁边的热敏电阻监控充电芯片的温度，超过门限（48℃左右）就限流。" />
          <outline text="充电时，如果用户玩大型游戏，或者长时间通话，CPU温升可能超过充电芯片，导致方案（2）失效。所以在充电时需要监控两个数据。" />
          <outline text="CPU有过热保护，高通平台是85℃手机就自动关机。" />
          <outline text="从业界看环境温度25度下，要求不超过43度是一个业界基本采用的标准（刚好温升18度）。" />
          <outline text="从人体接触体验来说，40度以上温度刺激明显，45度以上可能受伤。" />
        </outline>
        <outline text="power键处理">
          <outline text="power键直接接到PMIC的KPDPWR_IN脚上。" />
          <outline text="当它被拉低后，PM将启动，并给CPU供电，启动CPU。" />
        </outline>
      </outline>
      <outline text="38-Location">
        <outline text="谈谈室内定位技术  #TODO " />
        <outline text="定位方式的分类">
          <outline text="纯GPS定位">
            <outline text="定位数据来自GPS卫星。" />
            <outline text="优势是准确, 没有移动网络也可以使用。缺点是:" />
            <outline text="1. 比较耗电;" />
            <outline text="2. 绝大部分用户默认不开启GPS模块;" />
            <outline text="3. 首次定位, 一般需要较长时间, 甚至可能要几分钟." />
            <outline text="4. 室内基本无法使用." />
            <outline text="2和3比较致命." />
          </outline>
          <outline text="基站定位">
            <outline text="大致思路是采集手机上的基站ID(cell ID) 和其它的一些信息(MNC, MCC, LAC等), 然后通过网络访问一些定位服务. 比如百度或高德。" />
            <outline text="这些服务提供者有一些数据库, 提前做好了cell ID所在位置的经纬度等等信息, 通过查表以及简单算法(比如三点定位法), 获取设备位置. " />
            <outline text="其精度不如GPS;" />
            <outline text="但好处是比较快, 而且可以在室内用, 只要有网络即可使用." />
            <outline text="有两种：" />
            <outline text="cell-id，获取一个基站的信息即可完成定位，定位块，精度较差。" />
            <outline text="OTDOA定位。要求获取周围3个以上基站的信息，定位精度比cell-id高。" />
          </outline>
          <outline text="WIFI定位">
            <outline text="和基站定位类似, 通过收集设备周围的WIFI, 然后访问网络, 通过服务获取经纬度." />
          </outline>
          <outline text="Network Location">
            <outline text="基站定位和WIFI定位都需要网络, 所以在Android系统中统称为Network Location." />
          </outline>
          <outline text="AGPS">
            <outline text="即辅助GPS。在传统GPS基础上，采用基站和WIFI等辅助信息对GPS信息进行修正，以加快定位速度。" />
            <outline text="AGPS依赖数据业务，从数据业务中获取星历、频率、位码等信息，尽快确认当前位置可用的卫星。星历数据包括：">
              <outline text="轨道信息（天体坐标系）、时间、卫星状态等很多信息的。" />
              <outline text="这中间包括了天体坐标到空间坐标的转换。" />
              <outline text="手机的星历可以从GPS卫星数据中解析，也可以从AGPS服务器上下载。" />
              <outline text="星历也有很多种。" />
            </outline>
            <outline text="优势是速度快, 能将首次定位的时间缩减为7-8秒，而不是几十秒。而且准确度也略高于GPS。" />
          </outline>
          <outline text="其它">
            <outline text="CDMA网络下基站下发的系统参数消息SPM里面的BASE_LAT、BASE_LONG 2个值为基站天线的经纬度，可利用该信息来加速定位。" />
            <outline text="高通GPSone方案的多层次定位">
              <outline text="mcc/mnc，可获得National code；" />
              <outline text="Base lat/long broadcast；" />
              <outline text="cell -db；" />
              <outline text="A-gps server；" />
              <outline text="ODP GPS；" />
              <outline text="wifi ap" />
            </outline>
          </outline>
        </outline>
        <outline text="GPS卫星系统">
          <outline text="美国GPS卫星">
            <outline text="24颗" />
            <outline text="无源定位" />
            <outline text="定位精度：分米级" />
            <outline text="GPS对普通用户的设计精度为10米，结果实际精度达到了3米。">
              <outline text="从统计学角度，则意味着你的GPS位置，距离你的实际位置在30米内的概率是95%；对于高度读数，精度在45-100米的概率是95%。" />
            </outline>
            <outline text="2000年，美国总统宣布，普通用户精度升级为1米。" />
            <outline text="GPS地面监控部分（授时，必须；网维，非必须）">
              <outline text="授时中心采用铯原子钟，保持24颗卫星的时间高精度一致。" />
            </outline>
            <outline text="用户设备部分（GPS接收机）">
              <outline text="包含天线，射频单元，基带处理单元，存储单元。" />
              <outline text="主要目的是测量出GPS信号从卫星到接收机天线的传播时间，实时地计算出接收机的三维位置，三维速度和时间。" />
            </outline>
          </outline>
          <outline text="俄罗斯GLONASS卫星">
            <outline text="24颗" />
            <outline text="无源定位" />
            <outline text="定位精度：分米级" />
          </outline>
          <outline text="欧洲伽利略卫星">
            <outline text="30颗" />
            <outline text="无源定位" />
            <outline text="定位精度：米级" />
            <outline text="计划2020年完工。届时将向全球提供定位精度在1~2m的免费服务和1米以内的付费服务。" />
          </outline>
          <outline text="中国的“北斗”系统">
            <outline text="45颗" />
            <outline text="属于有源定位" />
            <outline text="定位精度：十米级" />
            <outline text="2019年4月20日，第44颗北斗导航卫星发射成功。标志北斗系统覆盖全球。" />
            <outline text="北斗系统属于静止卫星定位系统。" />
            <outline text="有源定位，用户终端应具有收发能力和应答功能。因此移动用户的数量将受限于系统的设计容量；终端也比较大。" />
          </outline>
        </outline>
        <outline text="定位原理">
          <outline text="简而言之就是3颗星可定位平面坐标，即3个3元2次方程可确定一个三元组（平面坐标，以及接收机的钟差）；4颗星可确定三维坐标，即4个4元2次方程可确定一个四元组（三维坐标，以及接收机的钟差）。" />
          <outline text="上述四个方程式中：">
            <outline text="x、y、z为待测点坐标，" />
            <outline text="Vto为接收机的钟差为未知参数，其中di=c△ti，(i=1、2、3、4)，" />
            <outline text="di分别为卫星ｉ到接收机之间的距离，" />
            <outline text="△ti 分别为卫星ｉ的信号到达接收机所经历的时间，" />
            <outline text="xi 、yi 、zi为卫星ｉ在t时刻的空间直角坐标，" />
            <outline text="Vti为卫星钟的钟差，" />
            <outline text="c为光速。" />
          </outline>
          <outline text="xi、yi（i=1-4）即卫星的三维位置，时间一定，这个值就是固定的。所谓星历的目的就是根据时间计算卫星位置三维坐标的。" />
          <outline text="关键点是di如何确定。每个gps信号自身都带有一个时间戳，告知接收方我这个信号何时从卫星发出。" />
          <outline text="因为接收方（比如手机）没有高精度时间，所以需要4颗卫星来定位，第四颗星负责校准钟差，即接收方和GPS时钟的时钟差异。" />
        </outline>
        <outline text="冷启动和热启动">
          <outline text="冷启动是指第一次定位。较慢，一般要几分钟。">
            <outline text="高通平台首次定位的要求：冷启动CN0值必须在28db以上，必须保持30s以上。" />
            <outline text="华为标准是50秒。" />
          </outline>
          <outline text="其它启动均为热启动，因为此时手机已经记忆了上次定位的信息，可以作为参考。" />
          <outline text="上次定位信息的参考价值随着时间的推移会逐步降低，因为人的活动的。">
            <outline text="有效期是2个小时。" />
          </outline>
          <outline text="华为“秒定”方案（HiGeo方案），可以缩短到2-3秒，但是精确度较差。" />
        </outline>
        <outline text="GPS误差的几个原因   #经验总结 ">
          <outline text="卫星星历误差">
            <outline text="在进行GPS定位时，计算在某时刻GPS卫星位置所需的卫星轨道参数是通过星历提供的，单通过星历所计算出的卫星位置都会与其真实位置有所差异，这就是所谓的星历误差。" />
          </outline>
          <outline text="卫星钟的时钟误差，是GPS卫星上所安装的原子钟的钟面时与GPS标准时间的误差。" />
          <outline text="卫星信号发射天线相位中心偏差，是GPS卫星上信号发射天线的标称相位中心与其真实相位中心之间的差异。" />
          <outline text="雾霾对卫星信号影响较大。" />
          <outline text="城市高楼对卫星信号的遮挡、多径效应，影响较大。" />
          <outline text="典型问题：CDMA下无法发起AGPS或者AGPS定位不成功。">
            <outline text="CDMA网络信令会提供基站坐标，GPSone会使用这个数据。" />
            <outline text="但是中国电信的大量使用假数据，导致用了比不用还差。" />
            <outline text="解决方法：关闭AGPS可解决。" />
          </outline>
        </outline>
        <outline text="地理围栏（Location Intelligence）的原理">
          <outline text="地理围栏算法解析： https://www.cnblogs.com/LBSer/p/4471742.html" />
          <outline text="用一个虚拟的栅栏围出一个虚拟地理边界。当手机进入、离开某个特定地理区域，或在该区域内活动时，手机可以接收自动通知和警告。" />
        </outline>
        <outline text="紧急定位方案（E911）">
          <outline text="由网络侧发起的强制定位。" />
          <outline text="可通过信令发起，也可通过数据业务发起。" />
          <outline text="反馈位置也可以通过信令，也可以通过数据业务。" />
        </outline>
        <outline text="代码结构">
          <outline text="app层有 location manager service 和 gps location provider，给应用提供gps相关api。" />
          <outline text="framework层有 libgps.so，app层通过jni调用。" />
          <outline text="kernel层就是kernel driver。" />
        </outline>
        <outline text="&lt;b&gt;应用层使用Location服务的例子（含优化思路）&lt;/b&gt;">
          <outline text="Android提供的定位接口是异步调用的, 大致流程如下:">
            <outline text="locManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);" />
            <outline text="// LocationListener包涵了几个成员函数，它们都是回调函数。" />
            <outline text="locListener = new LocationListener() {">
              <outline text="public void onStatusChanged(String provider, int status, Bundle extras) {">
                <outline text="// TODO Auto-generated method stub" />
              </outline>
              <outline text="}" />
              <outline text="public void onProviderEnabled(String provider) {">
                <outline text="// TODO Auto-generated method stub" />
              </outline>
              <outline text="}" />
              <outline text="public void onProviderDisabled(String provider) {">
                <outline text="// TODO Auto-generated method stub" />
              </outline>
              <outline text="}" />
              <outline text="// onLocationChanged是最重要的一个回调，这个函数是在Android获取了新的location信息之后调用的，你可以在这个函数内来实现自己想要的功能。" />
              <outline text="public void onLocationChanged(Location location) {">
                <outline text="// TODO Auto-generated method stub" />
                <outline text="mobileLocation = location;" />
              </outline>
              <outline text="}" />
            </outline>
            <outline text="};" />
            <outline text="// 将定义的locationListener注册到定位服务中去。" />
            <outline text="locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locListener);" />
          </outline>
          <outline text="当onLocationChanged()被调用时, 就可以获得设备的真正GPS位置。" />
          <outline text="问题来, 它什么时候会被调用？没人知道。可以写个小程序测试下. 大部分情况下, 可以在几十毫秒内就返回了，但也有一些时候，时间间隔长达几十秒。" />
          <outline text="这样的方案不应该直接提供给用户使用. 可以优化的几个点是:">
            <outline text="不要一直等待 onLocationChanged被调用, 要设置一个timeout机制。" />
            <outline text="如果timeout了，但onLocationChanged仍然没有返回，怎么办？难道只能提示用户无法定位吗？Android还提供了一个函数：getlastKnowLocation。这个函数会返回android平台最后一次获取到的位置信息。" />
          </outline>
          <outline text="getlastKnowLocation()的用法">
            <outline text="Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);" />
            <outline text="那么 这个的返回值值得信赖吗？" />
            <outline text="需要定义一个标准判断获取到的Location是否可信。Android的Location这个类除了包涵有latitude,longitude，还包含有很多其他的信息，比如何时获取到的，通过哪种方式获取到的，等等。程序员完全可以基于这些信息来判断获取到的Location是否过时或者是否可信。" />
          </outline>
          <outline text="Android的官方文档给出了推荐的方案：">
            <outline text="首先注册自己的LocationListener，让它同时监听GPS_PROVIDER和NETWORK_PROVIDER；" />
            <outline text="然后可以调用getLastKnownLocation获得一个Location值，这个值可以作为一个备选值；" />
            <outline text="然后在一段用户可接受的时间内，不断接收从onLocationChanged返回的位置，并同之前的值做比较，选取其中的最佳；" />
            <outline text="最后，会剩下一个筛选后的最优结果，你需要判断这个结果是否可接受。如果可以接受，返回给用户，如果不行，告诉用户无法定位。" />
            <outline text="整个过程你需要定义两个重要的函数：一个是比较两个Location信息，返回其中好的那个；另一个函数则用来判断Location信息是否可以被接受。" />
          </outline>
        </outline>
      </outline>
      <outline text="39-升级">
        <outline text="FTM模式">
          <outline text="开机进入recovery机器人界面，且屏幕中间显示“factory”。" />
          <outline text="是否进FTM在misc分区中设置。" />
          <outline text="FTM子模式有哪几种？">
            <outline text="NV 453=1，进纯FTM模式；" />
            <outline text="如果再加上NV 60003的值，进 FTM各子模式。">
              <outline text="=1，wifi 校准；" />
              <outline text="=2，wifi 环回测试；" />
              <outline text="=3，BT 校准。" />
            </outline>
          </outline>
        </outline>
        <outline text="recovery">
          <outline text="recovery是一种启动模式、一个分区、一个独立的运行单元，也是一个有main()入口的linux程序。" />
          <outline text="recovery有自己的kernel，以及运行其上的完成recovery各子功能的linux应用。" />
          <outline text="如何进入recovery？">
            <outline text="按音量上键开机, 进recovery菜单；" />
            <outline text="NV 453=1，进FTM模式；" />
            <outline text="NV 60002=1（UMTS），或NV 60009=1（CDMA），进快速注册模式；" />
            <outline text="NV 60004=1，settings菜单恢复出厂设置即是设置这个值后重启。" />
          </outline>
          <outline text="recovery的主要功能">
            <outline text="格式化data分区">
              <outline text="格式化前将 /data/dataapp 中的文件备份到cache分区，格式化后再恢复回来。" />
              <outline text="这个目录是放运营商定制apk, 不能删除了." />
            </outline>
            <outline text="格式化内置SD卡" />
            <outline text="格式化cache分区" />
            <outline text="格式化cache分区" />
            <outline text="备份数据恢复" />
          </outline>
        </outline>
        <outline text="misc分区作为模块间传递命令的载体">
          <outline text="好处是重启前后都在。大小一般为2M。" />
          <outline text="misc分区可以升级, 升级大包中有，以便初始化该分区。" />
          <outline text="misc分区中的数据">
            <outline text="第1个字段, 关机充电" />
            <outline text="第2个字段, recovery信息" />
            <outline text="第3个字段, recovery掉电保护" />
            <outline text="第4个字段, ota升级标志" />
            <outline text="第5个字段, kernel panic信息" />
          </outline>
        </outline>
        <outline text="cust升级">
          <outline text="cust 升级即定制升级. 定制需求一般来自运营商." />
          <outline text="方案设计原则">
            <outline text="cust分区是个全集, 包括全球所有定制的配置文件." />
            <outline text="系统运行时, 通过软链接方式将自己需要的子集载入系统, 并mount 到 /data/cust. " />
            <outline text="应用访问 /data/cust 来读取自己的配置信息, 完全透明访问. " />
            <outline text="从 /data/custom.bin 可读取当前使用的是哪个运营商." />
            <outline text="由此可做到代码和定制归一化。" />
          </outline>
          <outline text="cust包的内容">
            <outline text="cust分区">
              <outline text="所有定制信息，以“运营商信息/国家“为路径组织起来。" />
              <outline text="包括ap侧到的定制配置文件（主要是xml文件）、modem侧的logo和定制nv。" />
            </outline>
            <outline text="vendor_id包">
              <outline text="很小, 一般十几个字节." />
              <outline text="就是文本文件. 内容是 运营商信息 + 国家信息，比如vodafone/German。" />
            </outline>
          </outline>
          <outline text="cust包升级方式">
            <outline text="大包升级的最后一步, 自动升级cust包;" />
            <outline text="生产工位打背贴时，通过后台写入vendor_id. 会激活cust升级." />
            <outline text="在研发环境下, 通过diag命令, 切换运营商, 也会触发cust升级." />
          </outline>
          <outline text="升级流程">
            <outline text="aboot 从oeminfo中读vendor id, 写到 cmdline中。">
              <outline text="以通过如下命令查看： cat /proc/cmdline" />
            </outline>
            <outline text="init进程会对比 /proc/cmdline（A） 和 /data/custom.bin（B） 的值。会有几种场景:">
              <outline text="第一次开机，A与B都是空的。">
                <outline text="init 的做法是：写 hw/default 到B，然后激活 init.rc中的on cust，按默认值激活cust升级, 完成后然后重启。" />
              </outline>
              <outline text="第二次开机，A空B不空，则正常启动。" />
              <outline text="如果A&amp;lt;&amp;gt;B(原因是升级vendor信息后开机). 则:">
                <outline text="重启，先进行恢复出厂设置.">
                  <outline text="cust升级前为什么要recovery?" />
                  <outline text="因为要把data分区中的软链接都删除，如果删除失败则cust升级会失败。" />
                  <outline text="以防万一，就把data分区格式化一遍。" />
                </outline>
                <outline text="然后做on cust操作">
                  <outline text="on cust升级之init.rc中定义，完成三种功能：" />
                  <outline text="custcopy：copy一个文件；" />
                  <outline text="custsymlink：copy一个目录；" />
                  <outline text="load_oemlogo：copy logo。" />
                </outline>
                <outline text="最后停在recovery界面下。" />
                <outline text="以上就是所谓的cust升级流程." />
              </outline>
              <outline text="如果A=B（非首次开机），不做任何事。" />
              <outline text="如果是B不存在，说明刚升过级，且没有走cust升级流程, 则把A写入B，然后进入cust升级流程。" />
            </outline>
          </outline>
          <outline text="预置apk的安装位置">
            <outline text="系统apk 放在 /system/app下，不可删除，恢复出厂设置不会删除。" />
            <outline text="厂商预制apk 放在 /system/delapp，可删除，但是恢复出厂设置又会回来。" />
            <outline text="用户安装apk 放在 /data/app下，可删除，恢复出厂设置会删除。" />
          </outline>
        </outline>
        <outline text="hota升级">
          <outline text="ota升级: fireware over the air，无线补丁升级。" />
          <outline text="有三种方案：">
            <outline text="redband的fota方案">
              <outline text="该方案每台手机收费0.2美金。所以现在基本不用." />
            </outline>
            <outline text="google提供的ota方案">
              <outline text="部分运营商明确要使用google方案." />
              <outline text="升级包需要放在google的服务器上。" />
              <outline text="gota升级有如下规则：原始版本与目标版本的平台编译时间戳必须不同，如果相同则google服务器上无法检测到。" />
            </outline>
            <outline text="华为实现的hota方案. 常用." />
          </outline>
          <outline text="hota包下载到手机的方式">
            <outline text="通过settings下载hota升级包">
              <outline text="根据手机当前版本号或IMEI号找下载包." />
              <outline text="菜单中只能搜索到一个差分包。" />
            </outline>
            <outline text="自动下载">
              <outline text="默认自动下载周期是10天，周期可通过cust定制。" />
              <outline text="用户可在菜单中定制周期，也可以将自动检测关闭。" />
            </outline>
          </outline>
          <outline text="下载方式">
            <outline text="用android原生的DownloadProvider，支持断点续传。" />
          </outline>
          <outline text="差分包的保存位置">
            <outline text="升级包展开后，有sd卡的放在sd卡上，" />
            <outline text="无sd卡的放在内置卡，" />
            <outline text="内置卡空间不足，放在 /cache/fotapkg下。" />
          </outline>
          <outline text="data分区的问题">
            <outline text="hoto升级不会擦除/data分区，所以用户数据保留。" />
            <outline text="但升级过程中可以往 data分区添加文件。" />
          </outline>
          <outline text="升级过程">
            <outline text="ap侧下载升级包" />
            <outline text="调用hota_start_update()" />
            <outline text="设置misc信息">
              <outline text="写入misc的信息如下：update_package=SDCARD:文件名.zip " />
              <outline text="或者 CACHE:文件名.zip" />
              <outline text="取决于差分包的保存位置。" />
            </outline>
            <outline text="系统重启进入recovery模式" />
            <outline text="hota在recovery中完成">
              <outline text="recovery中，get_args()函数从misc分区或command文件中获取升级包位置。" />
              <outline text="调用ota_status_check()，读misc信息，确定是hota，还是fota。如果都不是，则清空misc和cache，然后重启。" />
              <outline text="调用do_hota_update()，完成第一阶段升级，即差分升级。" />
              <outline text="调用maybe_install_fireware_update()，将modem侧升级的update.app写入cache分区，设置misc信息为：hota_update_radio。" />
              <outline text="手机再次重启，oemsbl_dload_check()中读取misc信息，然后调用dload_sd()完成对aboot、boot、recovery和modem侧诸模块升级。" />
              <outline text="升级完成后，重启进入recovery，清除cache和misc对应字段，然后重启。" />
              <outline text="升级log放在 data/last.log中，注意进入recovery会被覆盖。" />
            </outline>
            <outline text="root过的手机不能进行hota升级。" />
            <outline text="hota升级可删除文件">
              <outline text="hota升级脚本为 /META-INF/com/google/android/updater-script, " />
              <outline text="在其中的delete字段中加一行：delete(&quot;/data/misc/wifi/load/ar6000.ko&quot;);" />
            </outline>
          </outline>
          <outline text="差分算法">
            <outline text="如果不一致, 拷贝a文件，生成备份文件，叫a.backup。" />
            <outline text="差分升级只支持 system、cust等ext4分区。" />
            <outline text="具体过程如下：" />
            <outline text="先检查新旧文件是否一致，一致就跳过；" />
            <outline text="如果system剩余空间小于a文件的1.5倍，则放到/cache分区，如果cache空间也不够，则报错。" />
            <outline text="对a.backup进行差分，升级完成后命名为a，拷贝到原处。这样做的目的是掉电保护。" />
            <outline text="其实是用google ota的算法。对ext4的文件系统来说，有专门的命令对比两个ext4文件系统的差异，因此极大的降低了方案的复杂程度。" />
          </outline>
        </outline>
        <outline text="升级安全方案">
          <outline text="升级包结构如下:" />
          <outline text="MD5-RSA">
            <outline text="存放: CRC模块经过MD5加密后，再经过私钥A加密后的数据，128B。" />
            <outline text="它的检验方式: oeminfo分区有公钥A，将密文解密为MD5数据，然后将明文进行MD5加密，两个对比，如一致则ok。" />
          </outline>
          <outline text="CRC">
            <outline text="升级包以下各模块的CRC值表。" />
            <outline text="按模块顺序，每32K数据算一个16位的CRC值，不足32K的也算一个CRC。" />
            <outline text="最大长度为128KB，对应升级包为1GB大小。(现在肯定改了)" />
          </outline>
          <outline text="AMSS_ECC">
            <outline text="目的是给amss加密。" />
            <outline text="它分为密文和明文两部分，明文为amss模块的ecc列表，每512B字节算16位的ecc数据；" />
            <outline text="密文为明文做md5，然后再rsa加密后的1024位数据。" />
            <outline text="amss的ecc检验方案在智能机上没有使用。原因是没有必要去保护。" />
          </outline>
        </outline>
      </outline>
      <outline text="&lt;b&gt;40-ARM&amp;amp;硬件&lt;/b&gt;">
        <outline text="芯片选型须关注的问题  #经验总结 ">
          <outline text="ap和modem两侧的通讯方式，响应速度、buffer size，以及可靠性、稳定性的实测数据。" />
          <outline text="emmc上分区管理方式，增减分区是否有限制，方便吗？" />
          <outline text="启动流程。是否支持安全启动。" />
          <outline text="升级方式，由哪些模块参与。" />
          <outline text="射频校准参数在哪里，如何管理，包括备份、恢复、新增、修改、删除的方案。" />
          <outline text="debug方法，包括死机dump（dump的速度也要注意），log导出。" />
          <outline text="外场现网测试，是否有支撑方法，比如如何抓现场log。" />
          <outline text="功耗管理，测试手段，是否提供优化支持。包括基底功耗和应用功耗（浏览、音乐、玩游戏等）。" />
          <outline text="主流器件、主流ID的支持情况，比如键盘、屏大小、TP、camera。" />
          <outline text="代码开放程度，哪些代码提供给我们，哪些不提供；不提供者如何维护，如何实现新增需求。" />
          <outline text="求助渠道，及响应速度。" />
          <outline text="是否有on side支持，国内有没有研发团队，地点、规模、支持方式、是否外包。" />
          <outline text="频段支持，几个关键点：北美AWS、日本1500/1700、拉美频段。" />
          <outline text="GPS是否支持俄罗斯的gloness。" />
          <outline text="内存支持情况，包括4G+3G的方案（内存768M）。读写速率是否有数据。" />
          <outline text="是否支持flash。" />
          <outline text="SD性能如何。" />
          <outline text="SMP系统的性能优化，CPU调度策略，以及和功耗。" />
          <outline text="平台做了多久，多少产品已经用了，有上市的吗？" />
          <outline text="运营商入网认证测试，全球做了多少，能不能帮我们做。" />
          <outline text="和google关系，是否是关键合作伙伴，是否可以提前拿到代码，能提前多少。" />
          <outline text="在原生系统上的做的修改，包括原因、规模、内聚程度等。" />
          <outline text="生产校准方案的具体细节。校准后台是谁做。" />
          <outline text="是否支持快速开机、关机闹钟等。" />
          <outline text="芯片选型思路总结">
            <outline text="第一次选，风险第一，不做小白鼠。只做业界已经做过的产品。" />
            <outline text="选择过程中，形成自己的套路。" />
            <outline text="第二次选，就要选业界没用过的平台，高风险高收益，风险控制能力也是核心竞争力。" />
          </outline>
        </outline>
        <outline text="Review软硬件接口文档的关注点  #经验总结">
          <outline text="review 电源部分">
            <outline text="电源设计经常出问题，为重中之重。" />
            <outline text="要关注电源和原始设计不一致的地方。比如各个电源的使用，默认为关的电源如何打开，有没有顺序，进待机时的电源管理。" />
            <outline text="关注A电源、E电源、WLAN电源。" />
          </outline>
          <outline text="review GPIO的修改">
            <outline text="GPIO的配置，为软硬件联调的主要工作。也是重中之重。" />
            <outline text="关注和原始设计不一直的" />
            <outline text="要严格禁止各模块直接用in或out接口控制GPIO，必须用BIO模块的宏来控制。review代码时要把关。" />
          </outline>
          <outline text="review 新增器件和新增特性">
            <outline text="硬件有自己的器件规划，会有选择的在多个产品中落地。" />
            <outline text="这部分容易出问题。" />
          </outline>
          <outline text="eview board id">
            <outline text="要重点review本产品的board id的规划。" />
          </outline>
          <outline text="review 和切换相关的设计是否有改变">
            <outline text="比如：usb和充电器的识别；" />
            <outline text="耳机插拔识别；" />
            <outline text="耳机线控的按下抬起；" />
            <outline text="不同LCD、不同camera、不同TP的识别；" />
            <outline text="LCD、camera的总线类型。" />
          </outline>
          <outline text="review 频段">
            <outline text="如果是公司从未使用的频段，调试射频nv的周期会很长，这个一定要有思想准备。" />
          </outline>
          <outline text="软硬件调试的一个教训">
            <outline text="最难发现的错误往往是在自己非常熟悉的代码中由于笔误引起的。" />
            <outline text="从零开始build有时候可以解决很多莫名其妙的问题。" />
          </outline>
          <outline text="" />
        </outline>
        <outline text="如何看懂硬件原理图？  #经验总结 ">
          <outline text="U401: cpu芯片" />
          <outline text="U201: pmic芯片" />
          <outline text="S1-S4: pmic提供的电源，软件不可控，手机上电就打开了，而且不可关闭。" />
          <outline text="U601: flash芯片" />
          <outline text="L201: L开头的都是电感，2.2uH。" />
          <outline text="C233: C开头的都是电容，2.2uF。" />
          <outline text="R1815: R开头的都是电阻，10kO。" />
          <outline text="SG205v: SG开头的是单点接地。" />
          <outline text="电池正负极图标: 表示接地。" />
          <outline text="GND: 也表示接地。" />
        </outline>
        <outline text="arm的7种处理器模式">
          <outline text="User：普通程序运行的模式." />
          <outline text="System：可以运行操作系统的特权指令." />
          <outline text="Superisor：操作系统保护模式." />
          <outline text="Abort：例外和异常。可用来实现虚存和内存保护." />
          <outline text="Undefied：未定义指令模型。可用于实现硬件协处理器的软件模拟." />
          <outline text="Interrupt：IRQ，中断处理." />
          <outline text="Fast interrupt：FIQ，快中断." />
          <outline text="除user外，其它6种模式称为特权模式；在特权模式中，除system外，其它5种称为异常模式." />
        </outline>
        <outline text="硬件寄存器">
          <outline text="硬件寄存器是软件与硬件的唯一接口；软件通过硬件寄存器来控制硬件。" />
          <outline text="r0: 返回值" />
          <outline text="r1-r4: 入参（入参超过4个, 前3个放在r1-r3, 其它参数组成对象放在其它位置, 对象地址放在r4）" />
          <outline text="r13: 堆栈指针" />
          <outline text="r14: 当前函数的返回地址.">
            <outline text="如果当前是异常模式，即为异常模式的返回地址；" />
          </outline>
          <outline text="r15: PC 指针，总是指向下一步要执行的代码。" />
          <outline text="CPSR: 当前arm模式" />
          <outline text="SPSR: 如果当前是异常模式，则保存着之前模式的CPSR。" />
        </outline>
        <outline text="硬件中断">
          <outline text="arm芯片支持的硬件中断是芯片规定死的，不可修改。" />
          <outline text="高通rex系统只支持硬中断，目前系统中有50几个中断源。" />
        </outline>
        <outline text="中断与异常">
          <outline text="中断来自cpu外部，终端发生时，cpu状态不可预测。所以，cpu只有在完成当前指令后才能处理中断。（原子操作会导致中断响应慢）" />
          <outline text="异常来自cpu内部。异常发生时，cpu状态可以预知，因此它可打断当前指令的执行而实时执行。即它的实时性强于中断。" />
          <outline text="中断向量表">
            <outline text="内存0地址放着系统的中断向量表。" />
            <outline text="arm9的向量表如下：" />
            <outline text="0x0是系统的reset" />
            <outline text="0x4是 Undefied instruction（未定义的指令）" />
            <outline text="0x8是软中断" />
            <outline text="0xc是P Abort（code区错误访问，即指针跑飞）" />
            <outline text="0x10是D Abort（data区错误访问，即内存错误）" />
            <outline text="0x18是 IRQ（中断，这个是系统稳定运行的基石）" />
            <outline text="0x1C是 FIQ（快中断）。" />
          </outline>
          <outline text="中断处理流程">
            <outline text="中断发生后，cpu改变模式为IRQ模式，切换寄存器bank，并从0x18取得RAM_FIQ_VECTOR的执行地址。" />
            <outline text="跳转到该地址后，会执行此处的b IRQ_Handler指令。后者完成CPU模式切换，进行压栈，然后执行isr处理函数(即 tramp_isr())。" />
          </outline>
          <outline text="中断处理入口: tramp_isr()">
            <outline text="tramp_isr()查中断向量表，即 isr_func_tbl[]分发中断isr。" />
          </outline>
          <outline text="判断当前是否在中断中: rex_is_in_irq_mode()" />
          <outline text="定义isr: tramp_set_isr(TRAMP_USB_ISR, usbotg_isr)，TRAMP_USB_ISR 即中断号为57，在 tramp.h 定义。 // usbotg_isr是函数指针, 为中断处理函数." />
          <outline text="FIQ的处理函数: rex_fiq_vector()" />
          <outline text="中断处理之前一定要锁中断">
            <outline text="进入isr处理后，如果不锁中断，新的中断来了，可能导致重入；如果是沿触发，则这个中断后面就不会再发。" />
          </outline>
          <outline text="中断返回的处理">
            <outline text="先进程恢复上下文（必须先恢复，因为此时压栈是压在中断栈中），检查是否要切换进程。" />
            <outline text="如果没有高优先级任务处在就绪态，或者进程切换被禁止，则恢复之前的进程上下文，并继续执行之。若需要进行任务切换，则切换到选中的任务运行。" />
          </outline>
          <outline text="中断之间是否允许抢占？">
            <outline text="中断之间允许；FIQ中断不允许，因为所有FIQ中断的优先级都一样。" />
          </outline>
        </outline>
        <outline text="arm汇编">
          <outline text="特殊标记">
            <outline text="立即数: 即常量，用#做前缀。如 #5即表示立即数5。" />
            <outline text="entry: 程序执行的入口点" />
            <outline text="area: 定义一个段" />
            <outline text="end: 标识源文件结束" />
            <outline text="SWI: 软中断指令" />
            <outline text="stmdb: 压栈动作" />
          </outline>
          <outline text="跳转">
            <outline text="B：跳转, 类似goto.">
              <outline text="B后面的地址是与r15的偏移量，24位长，即只支持向前/向后32M的跳转。" />
            </outline>
            <outline text="BL：函数跳转, 类似与call, 函数调用">
              <outline text="跳转之前，先把 r15-&amp;gt;r14." />
              <outline text="等调用完，将 r14 -&amp;gt; r15就可以返回原地址继续执行。" />
            </outline>
          </outline>
          <outline text="赋值">
            <outline text="MOV：赋值">
              <outline text="mov R0,R0,LSL#3  // 即R0=R0*8" />
              <outline text="mov pc,R14   // 即PC=R14" />
              <outline text="被move的可以是寄存器，或立即数。" />
            </outline>
            <outline text="MVN：反转赋值">
              <outline text="与mov的区别在于赋值前值会被反转，算法是+1，再取反。  " />
              <outline text="mvn R0,#4  // 即R0=-5。" />
            </outline>
          </outline>
          <outline text="计算">
            <outline text="ADD: 加法">
              <outline text="结果最高位如果溢出, 则不进位." />
              <outline text="ADD dest &amp;lt;value1&amp;gt; &amp;lt;value2&amp;gt;   // dest=value1+valve2；其它类似。" />
            </outline>
            <outline text="SUB: 减法" />
            <outline text="MUL: 乘法" />
            <outline text="ADC: 进位加法。add最高位不进位。" />
            <outline text="CMD：比较">
              <outline text="比较两个值，如果大，则执行GT指向的指令。" />
            </outline>
            <outline text="LSL: 逻辑左移" />
            <outline text="AND: 逻辑与" />
            <outline text="ORR: 逻辑或" />
          </outline>
          <outline text="读写内存">
            <outline text="LDR: 读内存">
              <outline text="LDR R1,R14   // 将R14中保存的地址写入R1" />
            </outline>
            <outline text="STR: 写内存">
              <outline text="STR R1,R14  // 将R14的值写入R1保存的内存地址里去" />
            </outline>
            <outline text="ADR：取内存地址放在寄存器中">
              <outline text="ADR r0,address" />
            </outline>
          </outline>
        </outline>
        <outline text="函数调用时的寄存器读写流程">
          <outline text="stmdb r13!,{r4-r6,r14}">
            <outline text="stmdb中的db表示decrease before，压栈时，r13 的值先减少，再压栈。" />
            <outline text="r4-r6, r14:显示压栈顺序为r14、r6、r5、r4。" />
          </outline>
          <outline text="sub r13,r13,#0x40。">
            <outline text="压栈后分配一块空间给局部变量。此处为64字节。" />
          </outline>
          <outline text="add r13,r13,#0x40。">
            <outline text="释放栈中用于局部变量的空间。" />
          </outline>
          <outline text="ldmia r13!,{r4-r6,pc}">
            <outline text="lamia中的ia表示increase after，出栈时，栈顶的内容先出栈，r13在增加。" />
            <outline text="然后r4、r5、r6、r14先后出栈（即写入各寄存器）" />
            <outline text="原来r14的值写入PC寄存器，从而达到跳转到返回地址的目的。" />
          </outline>
          <outline text="blx 函数名">
            <outline text="调用指定函数." />
          </outline>
        </outline>
        <outline text="GPIO">
          <outline text="GPIO的状态:">
            <outline text="输入还是输出:">
              <outline text="input" />
              <outline text="output" />
            </outline>
            <outline text="上拉还是下拉:">
              <outline text="上拉: pull_up" />
              <outline text="下拉: pull_down" />
              <outline text="不拉: nopull" />
            </outline>
          </outline>
          <outline text="何谓上拉?">
            <outline text="上拉是将不确定的信号通过一个电阻嵌位在高电平，电阻同时起限流作用。" />
            <outline text="具体做法是: 手机上通过电阻上拉到某一电源上，使之无法轻易放电, 从而维持一个高电平。" />
            <outline text="上拉时对外部电路注入电流，可起到供电作用。" />
            <outline text="GPIO上拉的驱动能力(即供电能力)取决于上拉电阻的阻值不同。">
              <outline text="电阻大，电流小，节约功耗；" />
              <outline text="电阻小，电流大，驱动能力强。" />
            </outline>
            <outline text="空悬管脚为何要接上拉？">
              <outline text="管脚空悬比较容易收外界电磁干扰，接一个上拉电阻可降低输入阻抗。" />
            </outline>
          </outline>
          <outline text="何谓下拉?">
            <outline text="下拉是将不确定的信号通过接地保持0v." />
            <outline text="具体做法是: 将电阻接到地，保持0v。这就是“嵌位”。" />
          </outline>
          <outline text="何谓不拉?">
            <outline text="高阻态，就是nopull，一般设置几M欧以上的电阻，以阻断电路。" />
          </outline>
          <outline text="漏电流">
            <outline text="直接将上拉电阻和下拉电阻连通，即产生漏电流，将导致功耗偏大。" />
          </outline>
          <outline text="如何看GPIO状态？">
            <outline text="gpio_configs[]可看到GPIO配置情况；">
              <outline text="寻找哪里修改GPIO状态的一个技巧 -&amp;gt; trace跟踪中，在gpio_configs[]处打写断点，就可以找到。" />
            </outline>
            <outline text="bio_gpio_image[]，对于输出的GPIO，可看到其值，每位对应一个GPIO。" />
            <outline text="对于配成输入的GPIO，只能使用标准接口实时读取其值。" />
          </outline>
          <outline text="GPIO的输出电流">
            <outline text="配置为输出时，arm默认的输出电流为5ma." />
            <outline text="但是高通做了扩张，驱动能力可配置为High和Normal两种，前者7ma，后者5ma。" />
            <outline text="配置为输入或不拉时，也有小的输出电流，不超过1ma。" />
            <outline text="由于GPIO有输出电流, 所以主板上的一些小器件由GPIO来&lt;b&gt;供电&lt;/b&gt;." />
          </outline>
          <outline text="GPIO的第二功能">
            <outline text="第二功能即在某种情况下的复用。两个功能不能同时用。" />
            <outline text="使用BIO_FUNC_SELECT()来设置。" />
            <outline text="硬件连线会接两根线到GPIO引脚上." />
          </outline>
          <outline text="代码中如何读写硬件寄存器？">
            <outline text="输入：hwio_inm(NAND_FLASH_ECC_0,,);" />
            <outline text="输出：gpio_out(camif_shdn_ins, GPIO_LOW_VALUE);" />
          </outline>
          <outline text="GPIO的level触发和沿触发">
            <outline text="level触发: 只要器件状态改变，中断一直会触发." />
            <outline text="沿触发（detect_edge）: 只有在改变发生时触发一次. 分为:">
              <outline text="上升沿触发" />
              <outline text="下降沿触发" />
            </outline>
          </outline>
          <outline text="GPIO中断源">
            <outline text="GPIO相关的中断源有两个（GPIO 0-38、67-105用一个，39-61用另外一个）。" />
            <outline text="任何GPIO状态变化，都会触发这两个中断源中的一个。" />
          </outline>
          <outline text="" />
        </outline>
        <outline text="ADC">
          <outline text="ADC: 模数转化器, analog to digital converter。负责采样." />
          <outline text="ADC的作用是通过硬件将一个模拟电平转换成0-255的一个数组（又叫raw值），软件通过算法将raw值转化为实际电平。" />
          <outline text="ADC的原理">
            <outline text="一些器件的测试单位就是电压，如电池电压、充电器电压，可直接转换。" />
            <outline text="某些指标不是电压，比如PA温度、电池温度等，则通过热敏电阻将温度转换为电压，其转换公式需要校准。" />
          </outline>
          <outline text="高通平台ADC的采样精度: 0.008mV。" />
          <outline text="代码: pm_adc_config_mux()，设置adc的三个属性，即通路控制、adc offset值和gain增益控制。" />
          <outline text="GPIO和ADC的关系和区别">
            <outline text="两者都是CPU引脚。" />
            <outline text="GPIO只有高和低两种状态，是典型的数字引脚." />
            <outline text="ADC是多值，可测量外围电路的电压（高通平台支持0-255种状态）。" />
            <outline text="GPIO有输入、删除两种模式。输出模式下，可控制外围电路，并可提供5mA的电流来驱动一些小器件。" />
            <outline text="ADC只有输入。" />
            <outline text="GPIO有中断和轮询两种访问方式." />
            <outline text="ADC只有轮询。" />
            <outline text="arm9有100多个GPIO引脚." />
            <outline text="arm9上ADC只有7个。其中一个接到PM上，又被分为10个，当然精度只有原来的1/10。一共可用的有16路。" />
          </outline>
        </outline>
        <outline text="硬件版本号方案">
          <outline text="1. 放在flash中的一个叫hwinfo的独立分区中。" />
          <outline text="2. 使用3-5个GPIO来识别.">
            <outline text="如果采用4个GPIO表示硬件版本, 则可以这样安排: " />
            <outline text="前2个表示主版本号，标识不同产品；" />
            <outline text="后2个表示子版本号，标识硬件改版、器件替代和延伸产品。" />
            <outline text="每个GPIO有三种内部状态：up、down、nopull（不拉）。即主版本号空间和子版本号空间各为9个。" />
          </outline>
          <outline text="3. 使用一个adc来识别." />
        </outline>
        <outline text="硬件时钟源">
          <outline text="手机上的硬件时钟源有哪些？">
            <outline text="睡眠是使用RTC时钟, ">
              <outline text="也叫睡眠时钟, 频率是32.768K。" />
              <outline text="它由纽扣电池供电，在系统掉电时还在跑。" />
            </outline>
            <outline text="PBL runs at TCXO；频率是19.2M。">
              <outline text="I2C用TCXO时钟。" />
            </outline>
            <outline text="BL runs at 48 MHz；" />
            <outline text="OSBL runs at 384 MHz；" />
            <outline text="android会按需运行中不同主频上。" />
          </outline>
          <outline text="设置外围设备的时钟: clk_regime_set_periph_clk()" />
          <outline text="锁相环">
            <outline text="sd卡时钟最高可为50M，比手机主晶振（19.2M）要高，是因为用了锁相环。" />
          </outline>
        </outline>
        <outline text="动态调整cpu速率">
          <outline text="申请提高CPU速率：clk_regime_register_for_cpu_resource()">
            <outline text="由task调用，只有部分task有权利。" />
          </outline>
          <outline text="申请恢复CPU速率: clk_regime_deregister_for_cpu_resource()" />
          <outline text="查看当前CPU频率">
            <outline text="cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies" />
            <outline text="显示的最后一个数字即是CPU速率，如 1152000即1.2G。" />
          </outline>
        </outline>
        <outline text="总线">
          <outline text="串口">
            <outline text="UART(TX,RX)就是两线，一根发送一根接收，可以全双工通信。" />
            <outline text="数据是异步传输的，对双方的时序要求比较严格。" />
            <outline text="通信速度不是很快。优势是实现简单。" />
            <outline text="用于蓝牙." />
          </outline>
          <outline text="SPI总线">
            <outline text="SPI，Serial Peripheral Interface：串行外设接口；是moto提出的串口总线标准。" />
            <outline text="SPI总线的优势">
              <outline text="和串口比，SPI多了一条同步时钟线。因此对通信双方的时序要求不严格，不同设备之间可以很容易结合，而且速度较快。" />
              <outline text="一般用在内部元件之间的高速数据通信上，如大容量存储器等。" />
            </outline>
            <outline text="SBI有三线，由3根GPIO实现。其中：">
              <outline text="SBST用于数据传输初始化；" />
              <outline text="SBDT用于双向数据传输，" />
              <outline text="SBCK提供时钟。" />
            </outline>
            <outline text="SBI 常用于CPU和其它外围芯片的通讯。" />
          </outline>
          <outline text="MDDI/并口">
            <outline text="Mobile Display Digital Interface，高通公司于2004年提出的，通过减少连线可提高可靠性并降低功耗。" />
            <outline text="物理结构">
              <outline text="host_data" />
              <outline text="host_strobe" />
              <outline text="client_data" />
              <outline text="client_strobe" />
              <outline text="power" />
              <outline text="GND（接地）" />
            </outline>
            <outline text="用于camera." />
          </outline>
          <outline text="I2C总线">
            <outline text="由80年代飞利浦发明。I2C占用的空间小，目前广泛用于系统内部。" />
            <outline text="物理结构：">
              <outline text="由数据线SDA和时钟线SCL构成，串行线。" />
              <outline text="各器件均并联在一条总线上。" />
              <outline text="总线的长度可最高25英尺，能以10Kbps的最大传输速率支持40个组件。" />
            </outline>
            <outline text="I2C的控制方式">
              <outline text="各器件均并联在一条总线上，但各有唯一地址。" />
              <outline text="在信息的传输过程中，每一器件既可能是主控器或被控器，也可能是发送器或接收器，这取决于它所要完成的功能。" />
              <outline text="支持多主控(multimastering)，其中任何能够进行收发的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。" />
              <outline text="在任何时间点上只能有一个主控。" />
            </outline>
            <outline text="I2C总线是慢速设备">
              <outline text="它不适用于需要高速刷新的器件，否则大部分CPU时间就会耗在读I2C上。一般刷新频率不能超过30Hz。" />
            </outline>
            <outline text="用于camera 控制、sensor、tp等." />
          </outline>
          <outline text="SDIO">
            <outline text="用于wifi、emmc、sd卡" />
          </outline>
          <outline text="USB总线">
            <outline text="用于USB设备." />
          </outline>
        </outline>
        <outline text="DMA传输">
          <outline text="DMA传输的条件：">
            <outline text="DMA用的内存必须4字节对齐">
              <outline text="让某个变量四字节对齐：__align(4)" />
              <outline text="让某个文件4字节对齐：# pragma pack(4)" />
            </outline>
            <outline text="DMA不能用cache">
              <outline text="所以为DMA传输分配的内存，要用专门内存分配接口。" />
              <outline text="普通接口分配的内存会被系统放进cache中。" />
            </outline>
          </outline>
        </outline>
        <outline text="熔丝">
          <outline text="熔丝都是一次性可写，将寄存器中熔丝对应的bit设置为1，则熔丝将被熔断，不再可写入。" />
          <outline text="熔丝的用法： 系统支持两个熔丝，硬件寄存器 config_lsb 和 config_msb。" />
          <outline text="熔丝相关的工具">
            <outline text="高通的写工具有QDART。" />
            <outline text="相关diag命令是：FTM_QFUSE_READ, FTM_QFUSE_WRITE。" />
          </outline>
        </outline>
        <outline text="电路常识">
          <outline text="几种电学单位的隐喻">
            <outline text="电量库仑是数量之总量值，本质是电子的数量，“微安时”等价于库仑；" />
            <outline text="电流安培是数量之流量值，即总量/时间，也即单位时间的通过量；" />
            <outline text="电压伏特是质量值，即电子个体的能量值的平均值；" />
            <outline text="功焦耳是效用之总量值，功率是效用之流量值（所谓效用是指对他者的作用）。" />
          </outline>
          <outline text="电平">
            <outline text="电平即电路中两点间的电量单位的相对比值，单位即为分贝。" />
            <outline text="电量单位包括功率、电压、电流。" />
          </outline>
          <outline text="欧姆定律">
            <outline text="I（电流）= U（电压）/ R（电阻）" />
          </outline>
          <outline text="电功率公式">
            <outline text="P（功率）= W（功率）/ t（时间）= I^2·R = I^2/R = I·U" />
          </outline>
          <outline text="手机接地的含义">
            <outline text="手机不可能真正接地。其接地是指接到电池负极。" />
            <outline text="一般电路板会规定一个“地”层，所有的地线都接到那里，然后再连接到电池负极。" />
          </outline>
          <outline text="如何防静电？">
            <outline text="暴露在外面的接口，电路都加了稳压管之内来防止静电；" />
            <outline text="还有就是加强接地，比如camera，外框要接地，否则静电导致混乱。" />
          </outline>
        </outline>
        <outline text="电源管理">
          <outline text="芯片的core电压和IO电压">
            <outline text="CPU的工作电压分为两个方面：CPU的核心电压与I/O电压。" />
            <outline text="核心电压即驱动CPU核心芯片的电压，I/O电压则指驱动I/O电路的电压。" />
            <outline text="通常CPU的核心电压小于等于I/O电压。" />
          </outline>
          <outline text="LDO电源">
            <outline text="PM芯片有多个LDO，用于提供不同的电压。" />
            <outline text="LDO特点是其电压受软件控制。" />
          </outline>
          <outline text="sdram电源的开关： 在上电时打开，关机是才能够下电。" />
          <outline text="MPP引脚">
            <outline text="多功能脚，主要用于电平转换。" />
            <outline text="可做电源用，其特点是软件可以通过控制其内部电阻来设定其通过的电流大小。" />
            <outline text="其它功能包括数字采用、模拟采样、数字输出、模拟输出。" />
            <outline text="常用的MPP管脚">
              <outline text="MPP4的电流区间是[40ma,150ma]" />
              <outline text="MPP3的电流区间为[150ma,600ma]" />
            </outline>
          </outline>
          <outline text="mic bias电源">
            <outline text="即mic的偏置电压，为mic供电。" />
            <outline text="在使用mic前必须把它拉高，不用时处在低电平。" />
          </outline>
          <outline text="软件寻址电源">
            <outline text="字符串与电源对象的对应关系，见全局变量 vreg vregs[]。" />
            <outline text="内容：&quot;msma”-id:0，“msmp”-id:1" />
            <outline text="api： vreg_get()，根据字符串获取电源对象vreg。" />
          </outline>
          <outline text="软件控制电源的接口：">
            <outline text="vreg_set_level(vreg_gp2, 1800); " />
            <outline text="vreg_gp2是电源对象；" />
            <outline text="1800是电压值，单位是毫伏。" />
            <outline text="实际上是通过rpc让modem侧配置。" />
          </outline>
        </outline>
        <outline text="电路元器件分类">
          <outline text="mos管：负责开关电源" />
          <outline text="电感">
            <outline text="滤波，平滑电流的波峰波谷，即所谓的毛刺。" />
            <outline text="电感通过电磁感应原理，暂存能量。" />
            <outline text="经过的电流越大，磁场越强；而磁场也会转成电流。" />
            <outline text="这样，波峰的电流的一部分能量将转成磁场，并传递给后续电流。" />
          </outline>
          <outline text="电阻">
            <outline text="电阻是耗能器件，通过将电能转化为热能，在电路中起分压分流作用。" />
            <outline text="并联时分压；串联时分流。" />
          </outline>
          <outline text="电容">
            <outline text="和电感类似，电容也用于滤波。" />
            <outline text="它通过内部的电解质（液体）暂存能量，将波峰的能量吸收，并补偿给波谷。" />
            <outline text="电路设计上，电容要尽量靠近地和供电管脚。" />
          </outline>
        </outline>
      </outline>
      <outline text="41-Camera">
        <outline text="相机系统框图">
          <outline text="用户态">
            <outline text="1. HAL">
              <outline text="(2) 原始的yuv数据和meta数据发给APP。" />
            </outline>
            <outline text="Binder通讯" />
            <outline text="2. APP">
              <outline text="(1) 拍照请求发给HAL。" />
              <outline text="(3) yuv数据和meta数据发给APS。" />
              <outline text="(5) yuv数据发给IPA." />
            </outline>
            <outline text="直接调用" />
            <outline text="3. IPA">
              <outline text="功能">
                <outline text="HDR" />
                <outline text="多帧合成" />
              </outline>
              <outline text="(6) 处理后的JPEG数据传给APP。" />
            </outline>
          </outline>
          <outline text="Binder通讯" />
          <outline text="核心态：4. APS">
            <outline text="功能">
              <outline text="美颜" />
              <outline text="滤镜" />
              <outline text="水印" />
              <outline text="贴纸" />
            </outline>
            <outline text="(4) 叠加效果的yuv数据传给APP。" />
          </outline>
        </outline>
        <outline text="模式">
          <outline text="拍照" />
          <outline text="录像" />
          <outline text="人像" />
          <outline text="全景" />
          <outline text="夜景" />
          <outline text="萌拍" />
          <outline text="更多模式方案，3K" />
        </outline>
        <outline text="功能">
          <outline text="预览" />
          <outline text="快门">
            <outline text="ZSL: Zero Shutter Lag, 零延迟快门" />
          </outline>
          <outline text="文件保存">
            <outline text="媒体数据库: /data/data/com.andorid.providers.media">
              <outline text="目录中, extend.db 是外部数据库, internal.db 是内部数据库." />
              <outline text="这两个数据库结构一样, 使用外部那个." />
              <outline text="其中表结构如下:" />
              <outline text="Images: 图片信息" />
              <outline text="thumbnails: 缩略图信息" />
              <outline text="Video: 录像" />
              <outline text="Videothumbnails: 录像缩略图" />
              <outline text="Andio: 音频信息, 比如一些音乐的专辑, 歌手等信息." />
              <outline text="db文件用 SQLite.exper.professianal 打开." />
            </outline>
          </outline>
          <outline text="缩略图">
            <outline text="预览界面的右下角，显示上一张照片的缩略图。" />
            <outline text="它是在上一次拍照时自动生成的。" />
            <outline text="如果缩略图文件找不到，则会找当前最晚一张照片自动生成." />
            <outline text="如果一张照片都没有，则显示空白框。" />
          </outline>
          <outline text="闪光灯" />
          <outline text="锁屏下相机">
            <outline text="相机是全功能的" />
            <outline text="照片和缩略图有隐私问题。 原则是仅可见本次锁屏拍的照片。" />
          </outline>
          <outline text="大数据">
            <outline text="大数据打点方案，1K" />
          </outline>
        </outline>
        <outline text="效果">
          <outline text="滤镜">
            <outline text="滤镜归一方案，3.5K" />
          </outline>
          <outline text="美颜" />
          <outline text="广角" />
          <outline text="微距" />
          <outline text="HDR">
            <outline text="硬件HDR方案， 1.5K" />
          </outline>
          <outline text="防抖">
            <outline text="软件防抖：减少曝光时间，加快成像速度。" />
            <outline text="物理防抖" />
            <outline text="数码防抖" />
          </outline>
          <outline text="虚化" />
          <outline text="水印" />
          <outline text="降噪" />
        </outline>
        <outline text="屏幕适配">
          <outline text="长宽比适配" />
          <outline text="挖孔屏适配" />
          <outline text="升降屏适配" />
        </outline>
        <outline text="第三方相机">
          <outline text="第一种方案: 使用Camera API定制相机">
            <outline text="适用于需要定制相机界面或者开发特殊相机功能的场景，如需要对照片做裁剪、滤镜处理，添加贴纸，表情，地点标签等。" />
            <outline text="一般使用 Camera API 2. 它可把 exif, rawdata, yuv, jpeg 等格式的数据传送给应用层. Camera API 1 只提供jpeg , 后期处理很受限." />
            <outline text="关键类">
              <outline text="Camera：最主要的类，用于管理和操作camera资源。它提供了完整的相机底层接口，主要方法有以下这些：">
                <outline text="&lt;b&gt;open&lt;/b&gt;()：获取camera实例。" />
                <outline text="setPrameters(): 设置相机参数，包括前后摄像头，闪光灯模式、聚焦模式、预览和拍照尺寸等。" />
                <outline text="&lt;b&gt;setPreviewDisplay&lt;/b&gt;(SurfaceHolder)：绑定绘制预览图像的surface。">
                  <outline text="surface是指向屏幕窗口原始图像缓冲区（raw buffer）的一个句柄，通过它可以获得这块屏幕上对应的 canvas，进而完成在屏幕上绘制View的工作。" />
                  <outline text="通过 surfaceHolder 可以将Camera和 surface连接起来." />
                  <outline text="连接后，camera获得的预览帧数据就可以通过surface显示在屏幕上了。" />
                </outline>
                <outline text="&lt;b&gt;startPreview&lt;/b&gt;(): 开始预览，将camera底层硬件传来的预览帧数据显示在绑定的surface上。" />
                <outline text="stopPreview(): 停止预览，关闭camra底层的帧数据传递以及surface上的绘制。" />
                <outline text="release(): 释放Camera实例" />
                <outline text="&lt;b&gt;takePicture&lt;/b&gt;(Camera.ShutterCallback shutter, Camera.PictureCallback raw, Camera.PictureCallback jpeg):这个是实现相机拍照的主要方法. 包含了三个回调参数: ">
                  <outline text="shutter 是快门按下时的回调，" />
                  <outline text="raw 是获取拍照原始数据的回调，" />
                  <outline text="jpeg 是获取经过压缩成jpg格式的图像数据的回调。" />
                </outline>
              </outline>
              <outline text="SurfaceView: 用于绘制相机预览图像的类，提供给用户实时的预览图像。">
                <outline text="普通的view以及派生类都是共享同一个surface的，所有的绘制都必须在UI线程中进行。" />
                <outline text="而surfaceview是一种比较特殊的view，它并不与其他普通view共享surface，而是在内部持有了一个独立的surface. 因此效率较高." />
              </outline>
              <outline text="Surface ：surfaceholder是控制surface的一个抽象接口，它能够控制surface的尺寸和格式，修改surface的像素，监视surface的变化等.">
                <outline text="surfaceview通过 getHolder() 方法获得surfaceholder 实例，通过后者管理监听surface 的状态。" />
                <outline text="SurfaceHolder.Callback接口：负责监听surface状态变化的接口，有三个方法：" />
                <outline text="&lt;b&gt;surfaceCreated&lt;/b&gt;(SurfaceHolder holder)：在surface创建后立即被调用。在开发自定义相机时，可以通过重载这个函数调用camera.open()、camera.setPreviewDisplay()，来实现获取相机资源、连接camera和surface等操作。" />
                <outline text="&lt;b&gt;surfaceChanged&lt;/b&gt;(SurfaceHolder holder, int format, int width, int height):在surface发生format或size变化时调用。在开发自定义相机时，可以通过重载这个函数调用camera.startPreview来开启相机预览，使得camera预览帧数据可以传递给surface，从而实时显示相机预览图像。" />
                <outline text="&lt;b&gt;surfaceDestroyed&lt;/b&gt;(SurfaceHolder holder)：在surface销毁之前被调用。在开发自定义相机时，可以通过重载这个函数调用camera.stopPreview()，camera.release()来实现停止相机预览及释放相机资源等操作。" />
              </outline>
            </outline>
            <outline text="自定义相机的步骤">
              <outline text="1: 创建相机">
                <outline text="private Camera getCamera() {">
                  <outline text="//获取Camera 注意导包正确 " />
                  <outline text="Camera camera = null; " />
                  <outline text="try {">
                    <outline text="camera = Camera.open();" />
                  </outline>
                  <outline text="} catch (Exception e) {">
                    <outline text="e.printStackTrace(); " />
                  </outline>
                  <outline text="} " />
                  <outline text="return camera;" />
                </outline>
                <outline text="} " />
                <outline text="private Camera mCamera;" />
              </outline>
              <outline text="2: 创建SurfaceView">
                <outline text="mSurface = (SurfaceView) findViewById(R.id.preview);" />
                <outline text="mHolder.addCallback(this);" />
              </outline>
              <outline text="3: 关联相机和SurfaceView">
                <outline text="mHolder = mSurface.getHolder();" />
              </outline>
              <outline text="4: 调整相机的显示效果">
                <outline text="public void capture(View v) {">
                  <outline text="// 获取当前照相机参数" />
                  <outline text="Camera.Parameters parameters = mCamera.getParameters();" />
                  <outline text="// 设置参数" />
                  <outline text="parameters.setPictureFormat(ImageFormat.JPEG);" />
                  <outline text="//设置照片格式" />
                  <outline text="parameters.setPictureSize(800, 400);" />
                  <outline text="//设置大小" />
                  <outline text="parameters.setFocusMode(Camera.Parameters.FLASH_MODE_AUTO);" />
                  <outline text="//设置对焦回调函数, 设置对焦模式" />
                  <outline text="mCamera.autoFocus(new Camera.AutoFocusCallback() {">
                    <outline text="public void onAutoFocus(boolean success, Camera camera) {">
                      <outline text="if (success) {">
                        <outline text="//当对焦成功时获取图片" />
                        <outline text="mCamera.takePicture(null, null, mPictureCallback);" />
                      </outline>
                      <outline text="}" />
                    </outline>
                    <outline text="}" />
                  </outline>
                  <outline text="});" />
                </outline>
                <outline text="}" />
              </outline>
            </outline>
            <outline text="微信、支付宝、美颜等头部应用用这种方案。三方适配问题由HAL负责。" />
          </outline>
          <outline text="第二种方案: 通过Intent调用系统相机">
            <outline text="这种方法快速方便，适用于直接获得照片的场景，如上传相册，微博、朋友圈发照片等。" />
            <outline text="启动Camera的两种方式">
              <outline text="直接在intent中指定应用程序的包名（前提是知道完整的包名）" />
              <outline text="使用隐式intent的方式来启动包名">
                <outline text="Intent camera = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);" />
                <outline text="startActivity(camera);" />
              </outline>
            </outline>
            <outline text="拍照完成之后获取图片">
              <outline text="第一种方式, 直接通过data中获取，但得到的照片是缩略图">
                <outline text="protected void onActivityResult(int requestCode, int resultCode, Intent data) { ">
                  <outline text="super.onActivityResult(requestCode, resultCode, data); " />
                </outline>
                <outline text="}" />
              </outline>
              <outline text="第二种方式">
                <outline text="step1: 获取文件保存路径" />
                <outline text="private String mFilePath; // 定义sd卡路径" />
                <outline text="protected void onCreate(Bundle savedInstanceState) {">
                  <outline text="super.onCreate(savedInstanceState);" />
                  <outline text="setContentView(R.layout.activity_main);" />
                  <outline text="mFilePath = Environment.getExternalStorageDirectory().getPath();  // 获得sd卡路径" />
                  <outline text="mFilePath = mFilePath + &quot;/&quot; + &quot;temp.png&quot;;" />
                  <outline text="init();" />
                </outline>
                <outline text="}" />
                <outline text="step2: 启动相机" />
                <outline text="Intent camera2 = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);" />
                <outline text="Uri photoUri = Uri.fromFile(new File(mFilePath));" />
                <outline text="camera2.putExtra(MediaStore.EXTRA_OUTPUT, photoUri);" />
                <outline text="startActivityForResult(camera2, REQ_2);  // 通过返回requestCode来读取相机照片" />
                <outline text="step3: 获取文件流，并转换为bitmap显示出来" />
                <outline text="FileInputStream fis = null;" />
                <outline text="try {">
                  <outline text="// 将文件转换成Bitmap " />
                  <outline text="fis = new FileInputStream(mFilePath); " />
                  <outline text="Bitmap bitmap = BitmapFactory.decodeStream(fis); " />
                  <outline text="iv_photo.setImageBitmap(bitmap); " />
                </outline>
                <outline text="} catch (FileNotFoundException e) {">
                  <outline text=" e.printStackTrace(); " />
                </outline>
                <outline text="} finally {">
                  <outline text="try { ">
                    <outline text="fis.close();" />
                  </outline>
                  <outline text="} catch (IOException e) {">
                    <outline text="e.printStackTrace(); " />
                  </outline>
                  <outline text="}" />
                </outline>
                <outline text="}" />
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="Tuning">
          <outline text="调整camera各个模块的参数，使其在当前的环境下能够获得一个比较好的成像效果。" />
          <outline text="Tuning主要有两大块：3A和ISP" />
          <outline text="3A: 即AWB, AE, AF的统称。">
            <outline text="AWB：自动白平衡">
              <outline text="百平衡的本质是使白色物体在任何光源下都显示白色。" />
              <outline text="一般的算法是通过调节白平衡增益，使拍照画面的颜色接近物体真实的颜色，增益调节的依据是环境光源的色温。" />
              <outline text="AWB算法的步骤：" />
              <outline text="1. 估计环境光色温。算法包括：">
                <outline text="灰度世界假设算法">
                  <outline text="假设一幅图片其颜色分量的均值G，R，B，趋向于同一灰度下。" />
                  <outline text="在图像色彩分布均匀时，该算法效果较好。" />
                </outline>
                <outline text="白色块假设算法">
                  <outline text="假设图像上最亮的点是白色的。以此为基准进行色温估计。" />
                  <outline text="实际效果不好。" />
                </outline>
              </outline>
              <outline text="2. 计算增益并调节">
                <outline text="最简单的方法是通过求取图像的平均颜色分量对应的增益：">
                  <outline text="α = G / R， β = G / B" />
                </outline>
                <outline text="然后对整幅图的RGB进行调整：">
                  <outline text="R = αR" />
                  <outline text="G = G" />
                  <outline text="B = βB" />
                </outline>
              </outline>
              <outline text="如何获得白平衡参数？">
                <outline text="在无自然光的实验室中，利用光源设备产生4种标准光源，" />
                <outline text="在光源下对标准色板进行拍照；再用软件分析照片的&lt;b&gt;色偏&lt;/b&gt;，就可以得到一组参数。" />
                <outline text="通过这种参数的校准，尽量将拍出的照片和标准照片一样。" />
              </outline>
            </outline>
            <outline text="AE：自动曝光">
              <outline text="自动曝光是为了使感光器件获得合适的曝光量。" />
              <outline text="一般的算法是通过获取图像的亮度调节调节相应的曝光参数，得到合适的曝光量。" />
              <outline text="曝光参数包括：">
                <outline text="光圈大小" />
                <outline text="快门速度" />
                <outline text="摄影头传感器的亮度增益" />
              </outline>
              <outline text="AE算法的步骤是：" />
              <outline text="1. 获取图像亮度。算法是：">
                <outline text="平均亮度" />
                <outline text="分区加权平均亮度： 加权即加大屏幕中心的权重，目的是把重点放在中心。" />
                <outline text="设置不同亮度门限，对背光、正光、强光区域进行区分。" />
                <outline text="对主要对象（比如人脸）进行曝光补偿。" />
              </outline>
              <outline text="2. 调整参数。算法有：">
                <outline text="查表法：系统预置一张曝光参数调整的步长和图像亮度之间的对应表。" />
                <outline text="迭代法" />
                <outline text="数值计算法" />
              </outline>
            </outline>
            <outline text="AF：自动对焦">
              <outline text="自动对焦即自动调节摄影头焦距以获得当前图像的最清晰图像的过程。" />
              <outline text="常见的AF算法是对焦深度法（DFF），主要步骤是：" />
              <outline text="1. 判断图像的模糊程度，通过模糊度评价函数得到每一帧的模糊值。评价函数有很多种，主要考虑因素是:">
                <outline text="图像频率。清晰的图像纹理多，高频分布较多；" />
                <outline text="图像的灰度分布。图像对应的灰度图的分量分布范围越大，说明图像细节越多，图像越清晰。" />
              </outline>
              <outline text="2. 通过检索算法得到一系列模糊值的峰值.">
                <outline text="爬山算法。检索窗口有黄金分割点、对焦嵌套窗口等。" />
              </outline>
              <outline text="3. 通过电机驱动镜头调节到峰值位置。" />
              <outline text="算法的关键是达到准确度和速度的平衡。" />
              <outline text="其它AF算法还有 对比度法和相位法。" />
              <outline text="自动对焦的关键是测距。测距首先要确认镜头中的主要对象。">
                <outline text="如何识别照片中的主要对象？" />
                <outline text="当我们把一个画面的光线数据通过傅里叶变换到向量空间时，会发现画面中有明显轮廓的位置都是一个高频区域。通过这点，我们就可以达到目标。" />
              </outline>
              <outline text="主动式自动对焦">
                <outline text="相机上的红外线发生器、超声波发生器发出红外光或超声波到被摄体。" />
                <outline text="可以用于细线条物体和动体，也可以在低反差，弱光下对焦。" />
              </outline>
              <outline text="被动式自动对焦">
                <outline text="接受景物自身的反光。" />
                <outline text="优点：不要发射系统，耗能小，易小型化。可以在逆光下或透过玻璃对焦。" />
              </outline>
            </outline>
          </outline>
          <outline text="ISP">
            <outline text="坏点校准和降噪">
              <outline text="坏点和噪点，都会在图像上产生错误的颜色点。" />
              <outline text="坏点是成像芯片上的物理损坏，会在每张图像上出现，一般不超过3个。" />
              <outline text="噪点则和芯片的稳定性有关，属于成像各环节出现的噪音信号，在图像上可能会成片出现。" />
              <outline text="噪点可以通过后期处理去掉。" />
            </outline>
            <outline text="颜色校正" />
            <outline text="伽马校正（Gamma Correction）">
              <outline text="非常复杂的概念。参见： 我理解的伽马校正： https://blog.csdn.net/candycat1992/article/details/46228771" />
            </outline>
            <outline text="边缘锐化（Edge Enhancement）">
              <outline text="加强影像的边缘对比度。" />
              <outline text="在视觉上，具有清晰边界的影像较受用户喜爱。" />
            </outline>
          </outline>
        </outline>
        <outline text="相机问题debug  #经验总结 ">
          <outline text="应用层能力基线：平均每人天闭环问题单数为1.5个。" />
          <outline text="花屏">
            <outline text="效果之间产生冲突导致. 比如HDR和滤镜" />
            <outline text="底层问题" />
          </outline>
          <outline text="裂屏">
            <outline text="LCD自身刷新（Refresh：从GRAM中读取数据往屏上刷）和MDP的数据刷新（update：将数据从EBI2送到GRAM中）没有同步。" />
            <outline text="分为两种情况：">
              <outline text="LCD的Refresh rate小于MDP的update rate时，可能出现数据丢失的现象，即LCD还没有刷新完一帧，MDP就已经将GRAM中的数据更新了。" />
              <outline text="LCD的Refresh rate大于MDP的update rate时，可能出现同一数据重复刷新的现象。">
                <outline text="当一帧的数据一部分是新的，一部分是旧的时，就可能出现裂屏。" />
                <outline text="这是主要情况。" />
              </outline>
            </outline>
          </outline>
          <outline text="偏红偏绿问题">
            <outline text="效果问题，找turning团队。" />
          </outline>
          <outline text="拉伸变形问题">
            <outline text="SurfaceView、PreviewSize、PictureSize三个尺寸不一致." />
          </outline>
          <outline text="闪烁问题">
            <outline text="一般是动画没处理好导致." />
            <outline text="切换分辨率等操作时, 蒙版消失得太早导致闪烁." />
          </outline>
          <outline text="预览性能低导致卡顿、拖影">
            <outline text="预览至少要达到30帧，最好达到60帧。" />
          </outline>
          <outline text="相机功耗高的解决方法">
            <outline text="降低帧率" />
            <outline text="通过OpenGL画预览界面。" />
          </outline>
          <outline text="Home键问题">
            <outline text="为了让用户感觉拍照快，现在手机相机都是缩略图生成后就提示用户拍照关闭。" />
            <outline text="这样就存在一个风险：用户看到拍照关闭，就按home键退出相机，而在Acticity的onPause中，会销毁相机资源，这样会导致大图没有生成。" />
            <outline text="解决办法是把大图生成放在 service中。可在后台慢慢保存。" />
          </outline>
          <outline text="管灯下的 flick 问题">
            <outline text="flick问题即照片上的明暗条纹。" />
            <outline text="原因是我们用的管灯一般以50hz或60hz的频率来闪烁。当sensor以行为定位曝光时，如果存在灯管的波峰位置，光强度大，就比较明亮。反之则暗淡。" />
            <outline text="解决方案: 保证每一次曝光都会在1/100的整数倍的话，则每部分的光能都一样，就不会有flick出现。">
              <outline text="代码：camera_antibanding_type。" />
            </outline>
          </outline>
        </outline>
        <outline text="手机相机各各摄影头是干啥的?">
          <outline text="双摄">
            <outline text="主摄: 广角" />
            <outline text="次摄: 长焦, 实现光学变焦." />
          </outline>
          <outline text="三摄">
            <outline text="主摄: 广角" />
            <outline text="黑白镜头" />
            <outline text="长焦, 实现景深, 虚化" />
          </outline>
          <outline text="四摄">
            <outline text="主摄" />
            <outline text="变焦镜头" />
            <outline text="超广角" />
            <outline text="景深辅助" />
          </outline>
          <outline text="五摄">
            <outline text="主摄" />
            <outline text="长焦" />
            <outline text="广角" />
            <outline text="深度" />
            <outline text="未知功能" />
          </outline>
        </outline>
        <outline text="颜色格式">
          <outline text="JPEG">
            <outline text="最常见的图像的有损压缩格式。" />
            <outline text="低分辨率sensor，一般自带JPEG engine，可以直接输出JPEG。" />
          </outline>
          <outline text="YUV">
            <outline text="uma (Y) + chroma (UV) 格式。" />
            <outline text="常见sensor都支持 YUV422格式，即数据格式是按Y-U-Y-V次序输出的。" />
            <outline text="一个像素占2B。如果像素太高可能芯片处理不过来。" />
            <outline text="YUV输出亮度信号没有任何损失，而色偏信号人眼并不是特别敏感，所以YUV图像质量和稳定性较好。" />
          </outline>
          <outline text="RGB">
            <outline text="传统的红绿蓝格式。" />
            <outline text="比如RGB565，其16-bit数据格式为5b R + 6b G + 5b B。G多一位，原因是人眼对绿色比较敏感。" />
            <outline text="RGB可直接往屏幕上刷。" />
            <outline text="RGB565 会丢掉很多原始信息，所以图像质量和稳定性较差。" />
          </outline>
          <outline text="Bayer">
            <outline text="也就是raw data。" />
            <outline text="sensor的每一像素对应一个彩色滤光片，滤光片按Bayer pattern分布。参见“Bayer阵列”。" />
            <outline text="将每一个像素的数据直接输出，即RAW RGB data." />
            <outline text="每个像素就1B，数据量要少很多。" />
            <outline text="一般5M以上sensor就只输出RAW数据，以保证比较快的输出速度，后端挂一个DSP来处理输出的数据。" />
          </outline>
        </outline>
      </outline>
      <outline text="42-CameraDriver">
        <outline text="模组硬件结构">
          <outline text="Lens(镜头）">
            <outline text="Lens一般有个Hold(座）作支撑。" />
            <outline text="镜头有玻璃和塑料两种。" />
            <outline text="玻璃的透光率高，折射率低，成像效果好，但比较贵；塑料则相反。" />
            <outline text="塑料还有个优势，它是非球面的，可校正畸变。" />
            <outline text="一般令两者组合，常见1G3P(1片玻璃 + 3片塑料）。" />
          </outline>
          <outline text="分色滤色片（2R Cut)">
            <outline text="为何要分色？" />
            <outline text="因为Sensor上每个像素只能识别一种颜色，所以需要把射入的光线过滤。有两种：" />
            <outline text="RGB原色分色法。" />
            <outline text="CMYK补色分色法，由青、洋红、黄、黑四种，但颜色不如RGB。" />
          </outline>
          <outline text="感光Sensor">
            <outline text="是一种半导体芯片，其表面含有几十万到几百万的光电二极管。有两种：" />
            <outline text="CCD">
              <outline text="工艺较成熟，生成稳定。" />
              <outline text="以G-R-G-B型CCD为例，4个感光单元的中心点构成一个“像素点”，每个感光单元的光值复用了4次（边缘单元除外），所以每4个感光单元计算出4个信号。" />
            </outline>
            <outline text="CMOS">
              <outline text="被认为是未来的成像器材。" />
              <outline text="成本低，速度快，功耗低。" />
              <outline text="但目前工艺不成熟，坏点率较高，无法满足高分辨率的要求。" />
              <outline text="其特点是一个感光单元对应一个像素。" />
            </outline>
            <outline text="光电二极管的原理">
              <outline text="P-N反向充电，在光照下放电，通过检测剩余电荷数量而得到光强信号。" />
            </outline>
            <outline text="Bayer阵列">
              <outline text="bayer格式图片是伊士曼·柯达公司科学家Bryce Bayer发明的，拜耳阵列被广泛运用数字图像。" />
              <outline text="如果每个像素都采样RGB3种颜色，则需要3块滤镜，且要保证滤镜严格对齐，代码非常大。" />
              <outline text="Bayer注意到人眼对彩色的响应带宽不高，精细度不够的特点，采用每个像素只采样一种颜色，其它颜色使用周围像素的颜色。" />
              <outline text="在采样时，奇数行分别采用R、G、R、G，偶数行分别采样G、B、G、B。">
                <outline text="G的采样数量是RB的和，因为人眼对绿光最敏感。" />
              </outline>
              <outline text="这样，一个像素的R、G、B数据将由相邻的4个感光单元构成。" />
              <outline text="这种采样方式，在基本不降低&lt;b&gt;感官图像质量&lt;/b&gt;的前提下，可以将数据量降低60%以上。" />
              <outline text="相机sensor基本上用的都是Bayer阵列。" />
            </outline>
          </outline>
          <outline text="FPC(柔板）">
            <outline text="连接器。一般手机camera分前后置，会有比较长的连接线。" />
            <outline text="CPU到camera的连线有：">
              <outline text="Vdd（供电）" />
              <outline text="mCLK（时钟源）">
                <outline text="设置为24M" />
              </outline>
            </outline>
            <outline text="camera到CPU的连线有：">
              <outline text="同步线有3根：">
                <outline text="pCLK">
                  <outline text="pCLK传输一个像素点后click一次" />
                </outline>
                <outline text="hsync">
                  <outline text="hsync传输1行click一次" />
                </outline>
                <outline text="vsync">
                  <outline text="vsync传输一帧click一次" />
                </outline>
              </outline>
              <outline text="data线有8或10根" />
            </outline>
          </outline>
          <outline text="vfe：图像前端处理">
            <outline text="camera同步线和数据线都直接连接vfe。这是一个关键的DSP芯片。" />
            <outline text="vfe主要功能是处理白平衡、去边、去坏点、调节锐度、插值。" />
            <outline text="驱动代码通过I2C总线给vfe传递camera配置参数。" />
          </outline>
          <outline text="Interface（总线）">
            <outline text="并口">
              <outline text="中低端相机用得多。" />
            </outline>
            <outline text="MIPI">
              <outline text="高像素camera中更常见。" />
            </outline>
            <outline text="I2C" />
            <outline text="Power" />
          </outline>
        </outline>
        <outline text="camera结构设计问题  #经验总结 ">
          <outline text="成像方向">
            <outline text="翻转90度" />
            <outline text="翻转180度" />
          </outline>
          <outline text="视场角" />
          <outline text="焦距" />
        </outline>
        <outline text="常见硬件问题  #经验总结 ">
          <outline text="驱动能力不足或过大；" />
          <outline text="上下电时序不满足规格，导致点不亮、裂屏、噪点多。" />
          <outline text="I2C地址冲突。不同型号camera用不同地址。" />
          <outline text="连接器选择和线序有问题。" />
        </outline>
        <outline text="PCB设计review要点  #经验总结 ">
          <outline text="AVDD和AGND走线要严格：同层包地，相邻层不能有高速线（clk、data、sync），AVDD线宽要保证150mA的过流能力。AVDD干扰易引起camera条纹。" />
          <outline text="pclk和mclk要全程包地，相邻层要避免影响射频信号。" />
          <outline text="mclk匹配电阻靠近平台芯片，pclk匹配电阻靠近camera。这叫源端匹配原理。" />
          <outline text="I2C两根线走在一起，外侧包地。" />
          <outline text="hsync和vsync尽量包地。" />
          <outline text="各电源的滤波电容应尽量靠近camera的电源引脚。" />
        </outline>
        <outline text="camera 点亮步骤">
          <outline text="按sensor spec的上电电压和时序上电，包括reset和shutdown配置。" />
          <outline text="建立I2C通讯，保证slave地址正确，保证地址和数据宽度正确。" />
          <outline text="初始化成功后，就应该有图像了。" />
        </outline>
        <outline text="数据处理过程">
          <outline text="sensor来的数据通过vfe的处理后，输出yuv格式的数据到内存中。" />
          <outline text="内存一般为系统开机就预分配的PMEM，大小一般为36MB。" />
          <outline text="后面的处理分为两条线：">
            <outline text="如果是预览，则数据会送给 mdsp，通过overlay技术显示在屏幕上。" />
            <outline text="如果是拍照，则送到 adsp（video core）编码为jpeg格式，然后送到文件系统保存。" />
            <outline text="如果是录像，则两条线都送。" />
          </outline>
        </outline>
        <outline text="Camera HAL代码">
          <outline text="托管代码通过jni接口调用本地代码的c interface 层。" />
          <outline text="interface 层通过IPC方式调用camera service层。" />
          <outline text="service层以下则为hal层，包括google hal和qcom hal两层。" />
          <outline text="qcom hal层通过syscall方式调用核心态代码，即camera driver。" />
          <outline text="由于相机涉及到知识产权较密集，所以核心代码都在HAL层。driver中的代码很少。" />
        </outline>
        <outline text="google native代码">
          <outline text="jni层代码">
            <outline text="framework/base/core_java/android/hardware/camera.java，../jni/android_hardware_camera.cpp。编译成 libandroid_runtime.so。" />
          </outline>
          <outline text="framework层">
            <outline text="framework/base/camera/libcameraservice/cameraservice.cpp。编译 libcameraservice.so。" />
          </outline>
          <outline text="HAL层">
            <outline text="framework/base/libs/ui/camera.cpp, ../ICamera.cpp, ../ICameraClient.cpp, ../ICameraService.cpp, 编译成 libui.so。" />
          </outline>
        </outline>
        <outline text="高通native代码">
          <outline text="代码位置： 也是按照camera型号组织的，比如：vendor/qcom/proprietany/mm_camera/targets/tgtcommon/sensor/ov5647_sunny/。" />
          <outline text="3A代码路径：vendor/.../tgtcommon/isp3a" />
          <outline text="效果代码路径：/chrometix_ov6547_sunny_preview.h" />
          <outline text="特效代码路径：vendor/.../futhers/bestshot/" />
          <outline text="闪光灯代码路径：vendor/.../flash/" />
          <outline text="变焦代码路径：vendor/.../zoom/" />
          <outline text="vfe代码路径：vendor/.../targets/vef31/7x30/vfe_porview.c, vfe_proc_msg_evt.c" />
          <outline text="接口层： hardware/qcom/camera/QualcommCameraHardware.cpp" />
          <outline text="初始化流程：">
            <outline text="open /dev/msm_camera；" />
            <outline text="load liboemcamera.so；" />
            <outline text="生成三个线程：control、config、frame。">
              <outline text="这个明显是和driver的三个内核设备对应。" />
              <outline text="容易出问题的是config线程，它负责配置3A。" />
            </outline>
          </outline>
          <outline text="预览流程">
            <outline text="注册pmem；" />
            <outline text="创建frame线程；" />
            <outline text="下发 start_preview命令；" />
            <outline text="唤醒config线程；" />
            <outline text="从frame线程获取数据，显示在overlay中。" />
          </outline>
        </outline>
        <outline text="Camera driver">
          <outline text="代码在kernel/drivers/media/video/msm。" />
          <outline text="文件按camera型号和总线类型排列，比如 ov5647_sunny.c等。接口在 msm_camera.h。" />
          <outline text="driver 代码包括如下3部分：" />
          <outline text="vfe driver" />
          <outline text="flash driver（闪光灯）" />
          <outline text="sensor driver（重点）">
            <outline text="camera驱动采用平台设备模型。初始化流程如下：" />
            <outline text="首先是platform_device结构，包括 name、data 等字段，然后放在devices[]数组中。">
              <outline text="可以通过adb cat /dev/platform/msm_camera_s5k4 看到其中的一些参数。" />
            </outline>
            <outline text="其次是 platform_driver结构，包括 name、open、probe等字段。camera_start()调用时，会将device和driver通过name字段对应上。" />
            <outline text="识别camera类型，加载对应driver过程。" />
            <outline text="初始化的重点是probe()函数，主要完成如下工作：">
              <outline text="alloc_chrdev_region：分配字符设备号，一次性分配15个；" />
              <outline text="置gpio、时钟；" />
              <outline text="驱动I2C；" />
              <outline text="上电、配置mclk；" />
              <outline text="通过I2C读取camera id；" />
              <outline text="申请三个内核设备节点：">
                <outline text="/dev/msm_camera/control、config、frame。如果有前后camera，则有6个，即control0和control1，config0和config1，frame0和frame1。" />
                <outline text="control节点负责提供命令接口，比如打开设备/关闭设备/拍照/预览。通过I2C发给vfe芯片，然后vfe芯片再按定义的方式转给sensor。" />
                <outline text="config节点负责提供配置camera的接口，主要是处理3A：AF（自动对焦）、AES（自动曝光）、AWB（自动白平衡）。" />
                <outline text="frame节点负责提供数据通道。注意这个点得到的数据是vfe输出的，格式为yuv。raw data数据软件是得不到的。" />
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="拍照相关的内存使用">
          <outline text="预览使用的是preview buffer；" />
          <outline text="拍照过程用两块">
            <outline text="缩略图用thumbail buffer" />
            <outline text="照片用 spark shot buffer" />
            <outline text="这两块都来自pmem。" />
          </outline>
        </outline>
        <outline text="Camera测试环境">
          <outline text="标准灯箱" />
          <outline text="色卡" />
          <outline text="测试分辨率的chart（可破插值算法）" />
          <outline text="软件photoshop" />
          <outline text="照度计" />
        </outline>
      </outline>
      <outline text="43-相机基础">
        <outline text="色彩变换的PS神器是怎样炼成的？  #TODO " />
        <outline text="曝光：控制光的亮度">
          <outline text="曝光控制主要用来调节景物整体亮度。分为自动曝光、手动曝光。" />
          <outline text="曝光的单位是：绝对曝光值（EV值，Exposure Values）。">
            <outline text="当感光度为ISO 100、光圈系数为F1、曝光时间为1秒时，曝光量定义为0。" />
            <outline text="&lt;b&gt;EV值越小，曝光量越大。&lt;/b&gt;具体是：" />
            <outline text="快门时间减少一半或者光圈缩小一档, 此时曝光量减半，EV+1" />
            <outline text="快门时间增加一倍或者光圈增加一档，此时曝光量加倍，EV-1" />
            <outline text="相对于正常曝光的图像，曝光过多叫过曝，曝光不足叫欠曝。" />
            <outline text="EV值与照度（Lux勒克斯）是一一对应的。" />
          </outline>
          <outline text="控制亮度的因素：">
            <outline text="1. 快门速度">
              <outline text="相机进行拍摄的时候快门保持开启状态的时间。除了能改变曝光外，快门速度还可以改变运动呈现的形式。" />
              <outline text="拍夜景要极慢的快门，比如2-16秒。快门越慢，对抖动越敏感。" />
              <outline text="快门的单位一般用秒。" />
              <outline text="单反一般会支持1、1/2、1/4、1/8、1/15、1/30、1/60、1/125、1/250、1/500、和1/1000秒." />
            </outline>
            <outline text="2. 光圈大小">
              <outline text="光圈，也叫焦比，是照相机上用来控制镜头孔径大小的部件，以控制景深、镜头成像质素、以及和快门协同控制进光量。" />
              <outline text="调整光圈大小也会改变物体清晰可见的范围，即景深。" />
              <outline text="光圈的单位:  光圈f值=镜头的焦距/光圈口径。&lt;b&gt;光圈越大，F值越小。&lt;/b&gt;" />
              <outline text="光圈与光圈之间相差根号2倍（或取其近似数1.4倍）。常用的镜头的光圈数序列为 1， 1.4， 2， 2.8， 4， 5.6， 8， 11， 16， 22， 32， 45， 64，90，128" />
            </outline>
            <outline text="以上两个因素决定外界光线达到摄影头传感器时的亮度，即进光量。最终成像的亮度还取决于传感器的一个因素：ISO" />
            <outline text="3. ISO: 感光度">
              <outline text="所谓感光度，其实就是感光元件对光线的敏感程度：感光度高的，对光敏感，你只要给它一点点光线，它也能感受到并且曝光充足；感光度低的，对光线不敏感，也许你给的光线完全不够曝光。" />
              <outline text="一般ISO100就算是低感光度，ISO6400算高感光度。" />
              <outline text="高的ISO使照片颗粒感很强的，低的ISO会是画面细腻。" />
            </outline>
            <outline text="1/250秒的快门与f/8的光圈、1/500秒与f/5.6、1/125秒与f/11这三个曝光组合都能达到相同的曝光。" />
            <outline text="还有一个因素是补光. 包括闪光灯和外界补光。" />
          </outline>
          <outline text="光圈优先模式：由用户先决定光圈的大小，然后相机根据环境光线和曝光设置等情况计算出光进入的多少，这种模式比较适合照静止物体。" />
          <outline text="快门优先模式：由用户先决定快门的速度，然后数码相机根据环境计算出合适的光圈大小来；适合拍摄移动的物体，或者相机抖动严重的情况下。" />
          <outline text="亮度的物理单位（和摄影无直接关系）：">
            <outline text="亮度：表示人对发光体或被照射物体表面的发光或反射光强度实际感受的物理量，亮度的符号是L，单位为尼特（nits）。" />
            <outline text="光强：用于表示光源给定方向上单位立体角内的光通量，用于描述光线强弱程度，国际单位为坎德拉，符号：cd。" />
            <outline text="光通量：即单位时间内由光源（/被照物）所发出（/吸收）的光能。单位是流明。" />
            <outline text="上面几个概念的关系：光能--时间--》光通量--空间（单位立体角）--》光强--人眼--》亮度" />
          </outline>
        </outline>
        <outline text="焦距：控制景物的清晰度">
          <outline text="焦距，也称为焦长，是光学系统中衡量光的聚集或发散的度量方式." />
          <outline text="凸透镜成像公式: 1/u + 1/v = 1/f，其中u是物距，v是像距，f是焦距" />
          <outline text="在相机中，是指从镜头中心到底片、CCD或CMOS等成像平面的距离。具有短焦距的光学系统比长焦距的光学系统有更佳聚集光的能力。" />
          <outline text="焦距通常使用毫米（mm）来标示，最大众化的是35mm规格。对标准镜头（50mm）、广角镜头（24mm）、望远镜头（500mm）视野都是不一样的。" />
          <outline text="变焦：改变焦距">
            <outline text="改变镜头的焦距f。也就是改变视野大小。" />
            <outline text="只有变焦镜头的焦距才能改变，定焦镜头的焦距是固定的。" />
            <outline text="变焦镜头的原理是在镜头中加一族活动透镜。" />
            <outline text="有用液体镜头来实现变焦的方案，但不稳定。" />
            <outline text="变焦倍数: 指变焦镜头最大焦距和最小焦距之比。例如，一支28mm-300mm的变焦镜头的变焦倍数为10.7。" />
            <outline text="类似28-200mm的变焦镜头由于其焦段的适用范围很广，有时被称作“旅游镜头”或“天涯镜(一镜走天下)”。" />
            <outline text="变焦倍数越大的镜头，因为其焦段覆盖很广，因此镜头的相对孔径（即镜头的F值）将会较小。" />
            <outline text="具有较大相对孔径、甚至恒定光圈的变焦镜头，如佳能 EF 70-200mm 镜头，一般价格都比较昂贵。" />
            <outline text="光圈有些会随变焦增加而缩小这些镜头被称为“变光圈镜头”，一些则不会，这些镜头称为“恒定光圈镜头”。" />
            <outline text="光学变焦">
              <outline text="光学变焦英文名称为Optical Zoom，通过镜片组之间的移动来放大与缩小景物。" />
              <outline text="变焦倍数越大，能拍摄的景物就越远。变焦镜头因其快速拉近或拉远，能立即改变构图，以方便快捷见称。但图像质素一般较相同焦段的定焦镜头差。" />
            </outline>
            <outline text="数码变焦">
              <outline text="数码变焦是用数学算法对照片做局部放大。这种方法虽能有效的放大影像，但会降低画质并耗损分辨率。" />
              <outline text="数码变焦倍数取决于sensor size和 pic size。在空间有限的手机，基本都是提供数码变焦。" />
            </outline>
          </outline>
          <outline text="调焦/对焦：对准焦点">
            <outline text="这两个是同一个概念，指改变像距v，也就是改变镜头光心到底片平面的距离，以便得到清晰的影象。调焦的焦，是焦点的焦。" />
            <outline text="一般手机是改变sensor的位置，也有改变镜头位置的。" />
            <outline text="拍照时卡卡响即是对焦。" />
          </outline>
          <outline text="广角">
            <outline text="广角镜头就是焦距较短、视角较大的镜头。使用广角镜头目的是为了可以达对更加开扩的视野，以及宏伟壮观的艺术效果。广角镜头可以产生前景大远景小的效果。" />
            <outline text="用广角镜头产生的画面变形，令到前景的物体得到夸张地放大，更加突出前景物体，给予视觉上强烈的冲击。广角镜头的焦距一般为38-24毫米，视角为60-84度，超广角镜头的焦距为20-13毫米,视角为94-118度。" />
          </outline>
          <outline text="长焦">
            <outline text="指具有较大光学变焦倍数的机型。" />
            <outline text="光学变焦倍数越大，能拍摄的景物就越远。一般超过50mm的镜头就可以被认为是长焦镜头。" />
            <outline text="长焦的问题是成像质量差，焦距越大照片被扭曲得越厉害。" />
          </outline>
          <outline text="微距">
            <outline text="镜头的放大率要达至1:2甚至1:1，才称得上是微距镜头。" />
            <outline text="微距摄影的目的是力求将主体的细节纤毫毕现的表现出来。" />
          </outline>
        </outline>
        <outline text="光自身的属性">
          <outline text="白平衡">
            <outline text="物体的颜色取决于自身和照上去的光线。" />
            <outline text="为了正确界定颜色，规定白光为标准光源，即正午的日光。" />
            <outline text="所谓白平衡，就是在不同色温下，通过相机处理，让照片还原为白光下的颜色，以接近人的视觉习惯。" />
          </outline>
          <outline text="对比度">
            <outline text="对比度是画面黑与白的比值，也就是从黑到白的渐变层次。" />
            <outline text="比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富。" />
            <outline text="对比度对视觉效果的影响非常关键，一般来说对比度越大，图像越清晰醒目，色彩也越鲜明艳丽；而对比度小，则会让整个画面都灰蒙蒙的。" />
            <outline text="高对比度对于图像的清晰度、细节表现、灰度层次表现都有很大帮助。" />
          </outline>
          <outline text="锐度">
            <outline text="表示图像边缘的对比度。由于人类视觉系统的特性，高锐度的图像看起来更加清晰，但是实际上并没有提高真正的分辨率。" />
            <outline text="镜头的高锐度是一把双刃剑，一方面，它使得画面的视觉效果变得清晰." />
            <outline text="另一方面，由于对比的提高，又会将一些原本并不讨好的主要细节进行放大，并覆盖次要细节，造成实际细节的下降和层次的缺失" />
          </outline>
          <outline text="色温">
            <outline text="光源的色温是通过对比它的色彩和理论的热黑体辐射体来确定的。" />
            <outline text="热黑体辐射体的特征就是它受热发的光是连续光谱的，光谱分布仅由温度决定." />
            <outline text="黑体与某个光源的色彩相匹配时的开尔文温度就是那个光源的色温，它直接和普朗克黑体辐射定律相联系。" />
            <outline text="常见物体的色温">
              <outline text="1700 K：火柴光" />
              <outline text="1850 K：蜡烛" />
              <outline text="2800 K：钨灯（白炽灯)" />
              <outline text="4100 K：月光" />
              <outline text="5000 K：日光" />
              <outline text="5500 K：平均日光、电子闪光（因厂商而异）" />
              <outline text="5770 K：有效太阳温度" />
              <outline text="6420 K：氙弧灯" />
              <outline text="6500 K：日光灯" />
              <outline text="9300 K：电视屏幕（模拟）" />
            </outline>
            <outline text="暖色光">
              <outline text="暖色光的色温在3300K以下，暖色光与白炽灯相近，红光成分较多，能给人以温暖，健康，舒适，比较想睡的感受。" />
              <outline text="适用与家庭，住宅，宿舍，宾馆等场所或温度比较低的地方。" />
            </outline>
            <outline text="中性光">
              <outline text="又叫中性色，它的色温在3300K到5300K之间，中性色由于光线柔和，使人有愉快，舒适，安详的感受。" />
              <outline text="适用与商店，医院，办公室，饭店，餐厅，候车室等场所。" />
            </outline>
            <outline text="冷色光">
              <outline text="又叫日光色，它的色温在5300K以上，光源接近自然光，有明亮的感觉，使人精力集中及不容易睡着。" />
              <outline text="适用与办公室，会议室，教室，绘图室，设计室，图书馆的阅览室，展览橱窗等场所。" />
            </outline>
          </outline>
          <outline text="饱和度">
            <outline text="色度指得是色彩的纯度，也叫饱和度或彩度，是“色彩三属性”之一。用来描述某一色彩与纯色的差别。黑白灰是“色度=0”的颜色。" />
          </outline>
          <outline text="三原色">
            <outline text="“原色”并非是一种物理概念，反倒是一种生物学的概念，是基于人的肉眼对于光线的生理作用。" />
            <outline text="人的眼球内部有锥状细胞，能够感受到红光、绿光与蓝光，因此人类以及其他具有这三种感光受体的生物称为“三色感光体生物”。红绿蓝。" />
          </outline>
        </outline>
        <outline text="景深">
          <outline text="光圈、镜头、及拍摄物的距离是影响景深的重要因素：">
            <outline text="1，光圈越大景深越小，光圈越小景深越大。" />
            <outline text="2，镜头焦距越长景深越小、反之景深越大。" />
            <outline text="3，主体越近，景深越小，主体越远，景深越大。" />
          </outline>
          <outline text="英语：Depth of field，缩写DOF。在光学中，尤其是摄影录像中， 它描述在空间中，可以清楚成像的距离范围，即画面的纵深感。" />
          <outline text="虽然透镜只能够将光聚到某一固定的距离，远离此点则会逐渐模糊，但是在某一个特定的距离内，影像模糊的程度是肉眼无法察觉的，这是景深的原因。" />
          <outline text="对于某些影像，例如风景照，比较适合用较深的景深，然而在人像摄影时，则经常使用浅景深来构图。" />
          <outline text="景深通常由物距、镜头焦距，以及镜头的光圈值所决定，（相对于焦距的光圈大小）。除了在近距离时，一般来说景深是由物体的放大率以及透镜的光圈值决定。" />
          <outline text="采用“最大光圈＋尽可能缩短的摄距＋长焦距镜头”能获取最小景深的效果。采用“最小光圈＋最短焦距镜头＋超焦距聚焦”能获取最大景深效果。" />
          <outline text="如果固定放大率时，增加光圈值（缩小光圈）则会增加景深；减小光圈值（增大光圈）则会减少景深。" />
          <outline text="因为数位影像的进步，影像的锐利度可以由电脑后制而改变，因此也可以由后制的方式来改变景深。" />
        </outline>
        <outline text="相机">
          <outline text="单反:  单镜头反光照相机" />
          <outline text="微单：微型单反。微单没有反光板。" />
        </outline>
        <outline text="光的物理属性">
          <outline text="光是一种电磁波。" />
          <outline text="电磁波长范围很广，从10负14次方(米)到10正8次方。人眼可感觉到的只是其中一小部分。" />
          <outline text="取3.8的10负7次方到7.8的10负7次方(米)为可见光范围，即380nm到780nm。" />
          <outline text="不同波长的光，引起人眼的颜色感觉不同，大致：380-430nm为紫，430-470为蓝，470-500为青，500-530为绿，530-560为黄绿，560-590为黄，590-620为橙，620-780为红。" />
          <outline text="仅有一个波长的光叫激光。通常见到的光都是复合光。" />
          <outline text="太阳光中有很大的红外光成分. " />
          <outline text="地球上太阳辐射光谱的99%在波长0.15-4.0微米；大约50%的能量在可见光谱区（波长0.4-0.76微米）、7%在紫外（&amp;lt;0.4微米）、43%在红外区（&amp;gt;0.76微米）。最大能量在0.475微米处。" />
        </outline>
        <outline text="拍照时的用光">
          <outline text="光线的硬度，柔和还是硬朗，依赖于光线有没有经过散射。" />
          <outline text="平行光拍照最好, 比如日光。点光源容易造成阴影。" />
          <outline text="比较难拍好的静物: 手表，香水" />
          <outline text="比较好的光源: 蝴蝶光、鳄鱼光、三角光" />
        </outline>
      </outline>
      <outline text="45-射频协议">
        <outline text="通讯基础知识 #经验总结 ">
          <outline text="地球表面只有8%的地区覆盖有手机信号。而卫星信号则覆盖98%。" />
          <outline text="地球表面只有8%的地区覆盖有手机信号。" />
          <outline text="方波是一种非正弦曲线的波形（类似长城墙），通常在信号处理时出现.">
            <outline text="理想方波只有高和低两个值。" />
          </outline>
          <outline text="谐波">
            <outline text="谐波是点播中所含有的频率为基波的整数倍的电波。" />
            <outline text="广义上，所有与基波频率不同的成分都可以称之为谐波。" />
            <outline text="音乐上的泛音就是谐波。" />
            <outline text="在信号处理上，广义的谐波通常是噪音的来源。" />
          </outline>
          <outline text="带宽">
            <outline text="信道可以不失真的传输信号的频率范围。" />
            <outline text="对数字系统而言，它即波特率。" />
            <outline text="几种网络协议的速率:" />
            <outline text="GSM : 9K" />
            <outline text="GPRS : 42K" />
            <outline text="EDGE : 172K-384K" />
            <outline text="WCDMA : 364K" />
            <outline text="HSD/UPA : 14.4M" />
            <outline text="HSD/UPA+ : 42M" />
            <outline text="LTE : 150-300M" />
          </outline>
          <outline text="频率和带宽的关系">
            <outline text="带宽 = 频率 ＊ 信道数（频点数）。" />
            <outline text="举个例子，一个32条独立信道的66MHz，其带宽为66M＊32=2.1G。">
              <outline text="如果是有线的话，这32个信道可以是32根线." />
              <outline text="无线系统下，可以是32个频点。" />
            </outline>
            <outline text="从物理意义上讲，由于频率是连续的，所以可能的信道数是无限的，限制因素是收发两方的测量精度。" />
            <outline text="两个频点其实可以无限接近，只要收发的精度足够高。" />
          </outline>
          <outline text="通讯解决的最根本的问题">
            <outline text="根本问题是，通讯永远是多对多的." />
            <outline text="理论上必须每两个人之间接一根线。" />
            <outline text="但是实际上不可能，所以通讯渠道必须共享。" />
            <outline text="共享的前提是不能在同一时刻，所有人都打电话。这个前提很容易满足." />
            <outline text="完成线路共享，要解决两个问题：">
              <outline text="第一，如何区别不同的人. 有3种方式:">
                <outline text="频分">
                  <outline text="频分就是不同的人用不同的信道。这是最直观的方法（分车道，每人用一条）。" />
                  <outline text="相关的概念即频段、载波、频点（=信道）">
                    <outline text="以联通WCDMA为例，上行1940M-1955M，下行2130M-2145M。上下行间隔190M。" />
                    <outline text="而W规范要求每个载波的带宽是5M，故可用载波为3个，即载波1、2、3。" />
                    <outline text="频点间隔200KHz，即每个载波25个频点。" />
                  </outline>
                  <outline text="频分多址即FDMA。GSM就是频分多址。" />
                  <outline text="频分即把整个可分配的频谱划分为许多个无线信道，每个信道可以传输一路语音或控制信息。" />
                  <outline text="频分如何解决频谱资源不够的问题?">
                    <outline text="频分从感觉上肯定很不够用，其实不然。因为可以&lt;b&gt;频率复用&lt;/b&gt;。">
                      <outline text="指处在不同地址位置（不同小区）上的用户可以同时使用相同频率的信道。" />
                      <outline text="复用可以极大的提高频谱效率。" />
                    </outline>
                  </outline>
                  <outline text="手机用的频率是如何分配的?">
                    <outline text="手机用的频点是搜网过程中由基站分配的。" />
                  </outline>
                </outline>
                <outline text="时分">
                  <outline text="时分就是不同的人用不同的时段。" />
                  <outline text="将一个完整的通讯响应过程分为几个时隙，多个通讯就可以交叉进行。" />
                </outline>
                <outline text="码分">
                  <outline text="码分就是每个人分一个不同的名字，放在数据包的头上，然后就可以再同一个信道中同时的互不干扰的通讯了。" />
                  <outline text="相当于轨道交通, 每个货分一个号码进车厢。" />
                </outline>
                <outline text="结论: 码分真牛，高通真牛。码分才是王道。" />
              </outline>
              <outline text="第二，如何评估剩下的资源总是够分配。(属于网规和网优，不再展开)" />
            </outline>
            <outline text="LTE简介">
              <outline text="LTE即4G技术，采用DFDM和MIMO作为其核心技术." />
              <outline text="LTE在20mHz频谱下能提供326Mb下行和86Mb上行的带宽。" />
              <outline text="LTE有两种：">
                <outline text="FDD: 频分双工. FDD占上风，产业链已经成形。" />
                <outline text="TDD: 时分双工. TDD落后好几年。" />
              </outline>
              <outline text="这两套方案，都利用 OFDM 绕开高通公司的 CDMA 核心技术专利，4G时代高通的地位将下降。" />
              <outline text="LTE不再支持电路交换技术, 只能进行全IP网络下的包交换。那么如何支持语言业务呢？有三种方案：">
                <outline text="VOLTE" />
                <outline text="CSFB: 当有语言电话时，手机使用原有2G/3G网络。" />
                <outline text="SVLTE: 同CSFB。" />
              </outline>
              <outline text="LTE支持的语音编码">
                <outline text="AMR-NB编码">
                  <outline text="采样率是 3.5KHz." />
                  <outline text="适用于窄带." />
                </outline>
                <outline text="AMR-WB编码">
                  <outline text="采样率是 16KHz." />
                  <outline text="适用于宽带. 推荐使用." />
                </outline>
              </outline>
              <outline text="3G如何升级到4G？">
                <outline text="WCDMA 由HSPA 升级到 HSPA+，再升级到LTE-FDD，是最顺的。" />
                <outline text="TD-SCDMA 由 HSDPA 升级到 LTE-TDD，会非常痛苦。" />
                <outline text="CDMA由 EV-DO 升级到 LTE-FDD，非常痛苦。" />
              </outline>
              <outline text="LTE-TDD不是TD-SCDMA的后一代演进">
                <outline text="两者仅10%的物理层协议、以及帧结构能共用." />
                <outline text="而且演进较困难。" />
                <outline text="国内故意叫LTE-TDD为TD-LTE，心态奇怪。" />
              </outline>
            </outline>
            <outline text="中国移动的基站数">
              <outline text="近30万TD-SCDMA个基站，以及60万个GSM基站。" />
            </outline>
          </outline>
          <outline text="手机接收性能">
            <outline text="手机信号特点: 手机发射功率大，接收功率小. " />
            <outline text="接收性能是瓶颈. 影响因素有:" />
            <outline text="灵敏度">
              <outline text="手机灵敏度是手机全向接受灵敏度的简称，即TIS，用于度量手机接收性能。" />
              <outline text="灵敏度受制于如下因素:" />
              <outline text="天线质量" />
              <outline text="天线方向性" />
              <outline text="结构（金属结构件的分布）" />
              <outline text="高频信号干扰">
                <outline text="高频信号指3MHz以上的信号，手机中一般重点关注30MHz以上的。" />
                <outline text="高频信号具有如下特点:">
                  <outline text="波长短、功率大;" />
                  <outline text="对周围信号干扰大;" />
                  <outline text="易被周围信号干扰等。" />
                </outline>
                <outline text="手机中有哪些高频信号?">
                  <outline text="晶振信号不算特别高频，影响不大。" />
                  <outline text="camera、音频、wifi、sd卡等时钟在50M左右，对灵敏度一般影响都很大。" />
                </outline>
              </outline>
            </outline>
            <outline text="发射功率, 受制于天线性能和手机rf模块。" />
          </outline>
          <outline text="基带芯片">
            <outline text="用来合成即将发射的基带信号，或对接受到的基带信号进行解码的芯片。" />
            <outline text="基带芯片的组成部分">
              <outline text="CPU处理器" />
              <outline text="信道编码器" />
              <outline text="数字信号处理器" />
              <outline text="调制解调器" />
              <outline text="接口模块" />
            </outline>
          </outline>
        </outline>
        <outline text="长连接慢心跳">
          <outline text="一般当基带空闲超过一定时间后，运营商的IP网关会自动释放（关闭）连接。" />
          <outline text="前各家所使用PUSH通道的实现原理虽然同为『长连接慢心跳』，但这个『慢』字却有很大的文章。" />
          <outline text="Google在Android系统中使用无线网络连接GSM的PUSH通道时，默认采用的心跳周期是28分钟，这才是所谓“慢”的含义 —— 尽可能降低心跳的频度，以达到省电的目的。" />
          <outline text="但这个全球绝大部分地区都行得通的规则，到了中国大陆就出现了问题。" />
          <outline text="以中移动的2.5G网络为例，经过粗略测试，大约5分钟左右的基带空闲，连接就会被释放，这就是为什么微信选择以『5分钟』为周期发送连接心跳。" />
          <outline text="这也是为什么Google的PUSH通道经常『迟到』的原因。" />
          <outline text="当我们活跃使用手机时，由于基带往往并不会闲置，所以部分掩盖了问题的本质。" />
          <outline text="当连接到Wi-Fi时，宽带的网关一般没有空闲释放机制，所以长连接会得到保持，这也进一步减少了我们平时遭遇的PUSH迟到。" />
          <outline text="『5分钟』的心跳周期到底是什么概念？可以理解为，每部安装了微信的Android设备每天发送近300条短信（其实占用的信令资源还远超这个数量）。" />
          <outline text="还意味着每天你的手机将被从待机省电状态唤醒近300次，每次相当于打一个几秒钟的电话。" />
          <outline text="粗略测算，一般的Android手机每天有超过15-20%的电量被消耗在发送过度频繁的心跳上。" />
          <outline text="大陆行货渠道发售的Android手机都无法使用Google的PUSH通道，原本每个手机中只需要建立的唯一共享的PUSH通道，被人为分裂，以至于每一个声称为用户提供实时通知的国内App，基本都在重复上面微信所做的行为。" />
          <outline text="当你的手机中同时安装了多个这类App时，无论手机的耗电，还是运营商的信令负担，都要数倍于上述情形。" />
          <outline text="2G网络的基础结构和协议并未针对IP传输优化，其服务IP链路的信令承载能力相对较弱，而TD-SCDMA又长期得不到真正的发展，导致中移动的2.5G网络承受了超龄超载的负荷。" />
          <outline text="现在各个ROM厂商尝试自建PUSH通道, 统一心跳." />
        </outline>
        <outline text="高通双卡双待方案">
          <outline text="高通双卡双待方案的文档">
            <outline text="BB: 80-vm151-41" />
            <outline text="RF:80-vc467-47" />
          </outline>
          <outline text="双卡双待的两种方案">
            <outline text="双通，要求必须有两个基带芯片" />
            <outline text="单通，可以共享射频芯片、天线和协议栈" />
            <outline text="高通w+g方案, 只支持单通。" />
            <outline text="c+w双卡双待, 则不能共用RTR芯片，但可共用天线。" />
          </outline>
          <outline text="两个号码如何共享基带？">
            <outline text="主要是利用分时执行的方式，特定时间只给一个号码用." />
            <outline text="只要独占的时间片足够小，能确保两个卡的接通率。" />
          </outline>
          <outline text="天线使用情况: 高通方案只需要一个天线。" />
          <outline text="两个网络page侦听时隙的冲突处理方案">
            <outline text="假定A优先：" />
            <outline text="AB不同时，无影响；" />
            <outline text="A先B后，B的时隙cancel；" />
            <outline text="A后B先，B可得到时隙，但在A发生时cancel。" />
          </outline>
          <outline text="HyBird模式">
            <outline text="高通的双卡双待方案基于HyBird模式，可分时隙监听网络。" />
            <outline text="有明确的冲突处理流程。" />
          </outline>
        </outline>
        <outline text="双卡双待方案的关注点   #经验总结 ">
          <outline text="是两个modem芯片，还是一个;" />
          <outline text="支持哪两种网络；" />
          <outline text="内存如何管理，是各用各的，还是同用一个；" />
          <outline text="启动流程，谁启动谁； " />
          <outline text="射频参数如何管理，如何校准； " />
          <outline text="音频参数如何管理，如何校准；" />
          <outline text="关机流程，谁发起，如何互通状态，谁负责下电； " />
          <outline text="异常管理，异常等级，如何通知对方，谁负责复位系统；" />
          <outline text="快速进待机，快速注册；" />
          <outline text="音频codec如何用； " />
          <outline text="蓝牙耳机打电话如何用；" />
          <outline text="AT命令，如何识别目标modem； " />
          <outline text="DTMF音频管理；" />
          <outline text="USB口管理，和调试有关。" />
          <outline text="功耗数据。" />
        </outline>
        <outline text="频段调试步骤   #经验总结 ">
          <outline text="PA开关有没有电压，通路可不可以用；" />
          <outline text="能不能搜网注册；" />
          <outline text="搜网异常时的两个提示：（1）emergency only： 搜到其它网络；（2）no service： 没有搜到任何网络" />
          <outline text="能不能打电话。" />
          <outline text="使用屏蔽盒可以解决G1900的注册问题。（这个是已知问题，是高通的bug，如果现网中有1800，手机永远会先注册这个网，而不会注册1900）。" />
          <outline text="确认qcn是否ok。搞不定找高通人过来。" />
          <outline text="界定仪器无问题，做一下交换测试。" />
        </outline>
        <outline text="数据业务">
          <outline text="PS, packet switch（数据业务）, 指数据业务" />
          <outline text="CS, circuit switch（电路交换）, 指语音业务" />
        </outline>
        <outline text="手机上互联网的原理">
          <outline text="分别由如下几层完成：" />
          <outline text="PDP">
            <outline text="就是手机协议栈的data call的封装. " />
            <outline text="其中profile为配置信息，包括:">
              <outline text="接入点APN（网关）" />
              <outline text="连接类型（IP/PPP）" />
            </outline>
            <outline text="网络侧也可以激活PDP." />
          </outline>
          <outline text="PPP">
            <outline text="这一层负责完成IP地址，IP由网络侧负责分配，具体网元是GGSN，后者是GPRS网到互联网的网关。" />
            <outline text="PPP相当于数据链路层。" />
            <outline text="手机在移动过程, 为什么IP不会变? ">
              <outline text="只要不是长时间不掉线，就不会改变。" />
              <outline text="PPP就是处理这个事的。" />
            </outline>
          </outline>
          <outline text="TCP/IP">
            <outline text="就是互联网。" />
          </outline>
          <outline text="CTNET">
            <outline text="手机直接裸露在互联网当中，互联网中的服务器能够直接与手机进行数据传递." />
            <outline text="有些服务器会按照ip段逐一扫描发送数据请求，休眠的手机收到这种请求就会出现唤醒进行处理，导致功耗较高。" />
          </outline>
          <outline text="CTWAP">
            <outline text="手机通过代理进行数据业务，代理会为手机过滤掉互联网中服务器主动发送的数据请求，所以手机对于互联网中的服务器是透明的，服务器只看得到代理，因此手机端的数据处理会少一些。" />
          </outline>
        </outline>
        <outline text="中国电信需求">
          <outline text="电信要求，使用双模卡时，在海外如果没有cdma网络，手动/自动切为gsm网络，号码不变。只支持和电信签约的运营商，都是海外的，不包括移动联通。" />
          <outline text="全球漫游卡">
            <outline text="支持全球漫游功能的sim卡。" />
            <outline text="可支持cdma/gsm双模，又叫双模卡。" />
            <outline text="双卡手机中，两个卡槽都要能支持双模卡，但sim2上只支持gsm。" />
          </outline>
          <outline text="二次选网">
            <outline text="这个是中国电信的要求，只在海外能用。" />
            <outline text="指对于双模卡，在初次选网（手机开机后自主的搜网动作）的基础上，根据不同地区要求，重新进行第二次搜网。" />
            <outline text="初次选网相当于确定当前所在地区，知道所在地区后，如果发现初次选错网了，重新选网。" />
            <outline text="快速启动功会影响二次选网">
              <outline text="原因是快速启动时，手机并没有真正重启，就的协议相关的参数还是维持上次的，因此影响二次选网用例的测试。" />
            </outline>
          </outline>
          <outline text="电信对单卡和双卡手机的定位不一样">
            <outline text="单卡用户是电信固有客户，已经习惯电信的业务和要求，电信给的补贴多，要求也多；" />
            <outline text="双卡用户主要定位在争取其他运营商用户，所以很多要求要松一些。" />
          </outline>
        </outline>
        <outline text="卡和搜网">
          <outline text="ESN: CDMA手机的唯一序号，存在手机上。32位长。" />
          <outline text="MEID: cdma手机越来越多，ESN不够用，衍生MEID。它有56位长。" />
          <outline text="pESN: 但是很多网元还是使用ESN，所以通过SHA-1算法讲MEID压缩为24位，并加80为前缀，即为pESN。这叫pESN/MEID兼容性。" />
          <outline text="1x下上网无法接到来电? ">
            <outline text="cdma网络的固有问题。注意，来电没有任何提示。" />
            <outline text="原因是1x的是数据语音双通道的网络模式，在该模式下只能使用一种或者是上网或者是语音。" />
            <outline text="而3g的话是语音数据向分开的，通话不受影响。" />
          </outline>
          <outline text="1x下上网无法接到来电的解决办法">
            <outline text="号码开通呼叫等待。" />
            <outline text="操作办法：*74听到提示音确认后挂断即可，取消呼叫等待*740。" />
          </outline>
          <outline text="CDMA Ev-Do">
            <outline text="Do的意思是Data Only.也就是说电信的3G只能传输数据，不能传输语音。用户在打电话时会跳转到CDMA 1x网络，只能传输语音。" />
          </outline>
          <outline text="获取sim卡状态的命令行">
            <outline text="adb下输入命令： getprop gsm.sim.state 可获取sim卡状态，没有则为 ABSENT。" />
          </outline>
          <outline text="携号转网">
            <outline text="sim卡存的是imsi，手机号即msisdn，是保存在HLR中的。所以携号转网无技术难度。" />
          </outline>
        </outline>
        <outline text="随卡方案">
          <outline text="开机过程中根据sim卡的信息来确定国家和语言。" />
        </outline>
        <outline text="频点切换">
          <outline text="对于EVDO来说，只依据与信道的信号强度而不会去考虑信道的负载，当候选集里面的频点信号强度在一定时间内优于切换门限功率时，便会发生频点的切换。" />
          <outline text="同一个基站下的数据业务容量是有个上限的">
            <outline text="手机接入成功后，就会占据一定的容量。" />
            <outline text="同一个基站下，一般20-30左右同时在线，用户体验还可以，超过了30用户体验速度就会比较慢。" />
            <outline text="基站侧可以设定最多允许多少个用户接入，有的设置为90，根据运营商要求设置。超过的接入不进去了。" />
          </outline>
        </outline>
      </outline>
    </outline>
  </body>
</opml>