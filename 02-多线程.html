<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">02-多线程</span><ul><li><span class="name">Android 线程架构</span><ul><li><span class="name">当启动一个App的时候，Android系统会启动一个Linux Process，该Process包含一个Thread，称为UI Thread或Main Thread。</span></li><li><span class="name">通常一个应用的所有组件都运行在UI Thread中. 通过在Manifest.xml中的代码块(&lt;activity&gt;&lt;service&gt;&lt;provider&gt;&lt;receiver&gt;)中的android:process属性指定其运行在不同的process中。</span></li><li><span class="name">UI Thread中运行着许多重要的逻辑，如系统事件处理，用户输入事件处理，UI绘制，Service，Alarm等. </span></li><li><span class="name">UI线程5秒没有响应, 系统就会报ANR. 所以如果用户逻辑比较费时, 就应该放在子线程中.</span></li></ul></li><li><span class="name">Android Thread的生命周期</span><ul><li><span class="name">新建状态（new）：new实例化之后进入该状态, jvm为其分配内存，并初始化成员变量;</span></li><li><span class="name">就绪状态（Runnable）：线程调用start()之后就绪状态, jvm为其创建方法调用栈和PC计数器, 等待cpu执行. 注意这时只是表示可以运行并不代表已经运行；</span><ul><li><span class="name">还有一种方式进入就绪态:  yield()：线程让步，是Thread的静态方法，使得正在执行的线程暂停，但不会阻塞线程，只是交出CPU的控制权，将线程转为就绪状态，让系统调度器重新调度一次。</span></li><li><span class="name">当某个线程调用yield方法暂停后，只有优先级与当前线程相同，或者优先级比当前线程更高的线程才有可能获得执行机会。</span></li></ul></li><li><span class="name">运行状态（Running）：线程获得cpu的执行，开始执行run()方法的代码；</span></li><li><span class="name">阻塞状态（Blocked）：线程由于各种原因进入阻塞状态, 包括：</span><ul><li><span class="name">join(), 当前线程阻塞, 进入另外一个线程, 直到该线程执行完毕;</span></li><li><span class="name">sleep(), 睡眠指定微秒数, 线程主动放弃所占有的CPU资源。</span><ul><li><span class="name">注意使用sleep方法时需要捕捉InterruptedException或者抛出该异常。</span></li></ul></li><li><span class="name">wait(), 当前线程阻塞, 等待某个通知notify. 一般是和 notifyAll() 成对出现.</span></li><li><span class="name">线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞.</span></li><li><span class="name">线程试图获得一个同步锁，但是该锁被其他线程所持有.</span></li></ul></li><li><span class="name">死亡状态（Dead）：线程运行完毕或异常退出，可使用isAlive()获取状态。</span></li></ul></li><li><span class="name">Thread类</span><ul><li><span class="name">Thread有如下主要函数</span><ul><li><span class="name">run(): 线程运行时所执行的代码</span></li><li><span class="name">start(): 启动线程</span></li><li><span class="name">sleep()/sleep(long millis): 线程休眠，进入阻塞状态，sleep方法不会释放锁（其它线程不会进入synchronized方法体或方法块，不释放锁需要try/catch）</span></li><li><span class="name">yield(): 线程交出CPU，但是不会阻塞而是重置为就绪状态，不会释放锁</span></li><li><span class="name">join()/join(long millis)/join(long millis,int nanoseconds): 线程插队，当该子线程执行完毕后接着执行其它</span></li><li><span class="name">wait(): 进入阻塞状态，释放锁（其它线程可以进入synchronized方法体或方法块，释放锁不需要try/catch）</span></li><li><span class="name">interrupt(): 中断线程，注意只能中断阻塞状态的线程</span></li><li><span class="name">getId(): 获取当前线程的id</span></li><li><span class="name">getName()/setName(): 获取和设置线程的name</span></li><li><span class="name">getPriority()/setPriority(): 获取和设置线程的优先级，范围1-10，默认是5</span></li><li><span class="name">setDaemon()/isDaemo(): 设置和获取是否守护线程</span></li><li><span class="name">currentThread(): 静态函数获取当前线程</span></li></ul></li><li><span class="name">使用Thread的方法1: 继承Thread，重写run()方法</span><ul><li><span class="name">public class MyThread extends Thread{</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void run() {</span><ul><li><span class="name">super.run();</span></li><li><span class="name">// do something</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// Thread使用</span></li><li><span class="name">public void goThread(){</span><ul><li><span class="name">new MyThread().start();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">使用Thread的方法2: 实现Runnable，重写run()方法来执行任务</span><ul><li><span class="name">new Thread(new Runnable() {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void run() {</span></li><li><span class="name">}</span></li></ul></li><li><span class="name">}).start();</span></li></ul></li><li><span class="name">使用Thread的方法3: 通过Handler启动线程</span><ul><li><span class="name">// 定义Handler和Runnable</span></li><li><span class="name">private int count = 0;</span></li><li><span class="name">private Handler mHandler = new Handler();</span></li><li><span class="name">private Runnable runnable = new Runnable() {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void run() {</span><ul><li><span class="name">Log.i("download",Thread.currentThread().getName()+":"+count);</span></li><li><span class="name">count ++;</span></li><li><span class="name">mHandler.postDelayed(runnable,1000); // 执行后延迟1000毫秒再次执行，count已++</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">// 使用mHandler的post()方法执行线程。</span></li><li><span class="name">findViewById(R.id.btn_download).setOnClickListener(new View.OnClickListener() {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span><ul><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://mHandler.post">mHandler.post</a>(runnable); // handler运行runnable</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li></ul></li></ul></li><li><span class="name">线程安全和线程安全</span><ul><li><span class="name">线程安全问题是指多个线程访问同一代码或数据，造成结果和数据的错乱或与期望的结果不同所产生的问题。</span></li><li><span class="name">基本上所有的并发模式在解决线程安全问题的问题上，都采用“序列化访问临界资源”的方案，即在同一时刻只能有一个线程访问临界资源（多个线程可能同时访问的数据或资源），也称同步互斥访问。</span></li><li><span class="name">第一种方式, <b>synchronized&nbsp;</b>关键字，保证同时刻只有一个线程进入该方法或者代码块.</span><ul><li><span class="name">这种最方便, 但是效率最低.</span></li><li><span class="name">有两种形式. 第一种是作为前缀定义函数.</span><ul><li><span class="name">int count = 100;</span></li><li><span class="name">private <b>synchronized </b>void count() {</span><ul><li><span class="name">if (count &gt; 0) {</span><ul><li><span class="name">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">isRunning = false;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">另外一种是定义代码块.</span><ul><li><span class="name">private void count() {</span><ul><li><span class="name"><b>synchronized </b>(this) {</span><ul><li><span class="name">if (count &gt; 0) {</span><ul><li><span class="name">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">isRunning = false;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">第二种方式, 特殊域变量volatile修饰变量. 它告诉虚拟机该变量随时可能更新，因此使用时每次都会重新计算，而不是使用寄存器的值。</span><ul><li><span class="name">volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。不能完全保证线程安全.</span></li></ul></li><li><span class="name">第三种, 使用重入锁Lock类实现线程同步。</span><ul><li><span class="name">ReentrantLock() : 创建一个ReentrantLock实例</span></li><li><span class="name">lock() :获得锁</span></li><li><span class="name">unlock() : 释放锁</span></li><li><span class="name">private void count() {</span><ul><li><span class="name">private final ReentrantLock lock = new ReentrantLock();  // 创建可重入锁</span></li><li><span class="name">lock.lock();</span></li><li><span class="name">if (count &gt; 0) {</span><ul><li><span class="name">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">isRunning = false;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">lock.unlock();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">第四种方式, ThreadLocal管理变量。</span><ul><li><span class="name">如果一个变量使用ThreadLocal进行管理，每一个使用该变量的线程都会获得该变量的副本，副本之间相互独立，所以每个线程都可以修改变量而不会对其它线程造成影响。</span></li><li><span class="name">private static ThreadLocal&lt;Integer&gt; number = new ThreadLocal&lt;Integer&gt;(){</span><ul><li><span class="name">// 重写方法，设置默认值</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected Integer initialValue() {</span><ul><li><span class="name">return 1;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 自定义方法设置变量值</span></li><li><span class="name">public void saveNumber(int newNumber){</span><ul><li><span class="name">number.set(number.get() + newNumber);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 自定义方法获取变量值</span></li><li><span class="name">public int getNumber(){</span><ul><li><span class="name">return number.get();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li></ul></li><li><span class="name">线程安全是以牺牲程序运行效率为代价的，因此在注意线程安全的同时，也要注意不要滥用锁和同步方法，尽量只对那些会改变竞争资源的方法进行同步。</span></li></ul></li><li><span class="name">死锁</span><ul><li><span class="name">产生死锁的四个必要条件：</span><ul><li><span class="name">互斥条件：一个资源每次只能被一个进程使用。</span></li><li><span class="name">请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span></li><li><span class="name">不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span></li><li><span class="name">循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></li></ul></li><li><span class="name">目前处理死锁的方法可归结为4种：</span><ul><li><span class="name">预防死锁：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</span></li><li><span class="name">避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</span></li><li><span class="name">检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。</span></li><li><span class="name">解除死锁：这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</span></li></ul></li></ul></li><li><span class="name">Android提供了四种多线程方案: Handler+Thread, AsyncTask, ThreadPoolExecutor, IntentService.</span></li><li><span class="name"><b>Handler+Thread</b></span><ul><li><span class="name">Android主线程包含一个消息队列(MessageQueue)，该消息队列里面可以存入一系列的Message或Runnable对象。通过一个Handler你可以往这个消息队列发送Message或者Runnable对象，并且处理这些对象。</span></li><li><span class="name">Handler是一个胶水类. 它粘合两个线程, 所以它的代码分为两半, 一半在一个线程中发msg, 一半在另一个线程收msg. 看Handle代码, 要注意分清它运行在两个线程. </span></li><li><span class="name">创建一个Handle对象时，它会绑定于创建它的线程(也就是UI线程)以及该线程的消息队列. 从这时起，这个handler就会开始把Message或Runnable对象传递到消息队列中，并在它们出队列的时候执行它们。</span></li><li><span class="name">Handler可以把一个Message对象或者Runnable对象压入到消息队列中，进而在UI线程中获取Message或者执行Runnable对象，Handler把压入消息队列有两类方式，Post和sendMessage：</span></li><li><span class="name">Post方式: 把一个Runnable对象入队到消息队列中. 有:</span><ul><li><span class="name">post(Runnable) </span></li><li><span class="name">postAtTime(Runnable,long)   // 指定时间</span></li><li><span class="name">postDelayed(Runnable,long)   // 延迟post</span></li></ul></li><li><span class="name">Runnable对象: 用于封装一段要运行于子线程的代码. 这段代码放在 Runnable对象中的run() 方法中. </span></li><li><span class="name">sendMessage方式: 允许把一个包含消息数据的Message对象压入到消息队列中。有:</span><ul><li><span class="name">sendEmptyMessage(int)</span></li><li><span class="name">sendMessage(Message)</span></li><li><span class="name">sendMessageAtTime(Message,long)</span></li><li><span class="name">sendMessageDelayed(Message,long)</span></li></ul></li><li><span class="name">接受msg的代码在Handler类的 handleMessage() 方法.</span></li><li><span class="name">优缺点: </span><ul><li><span class="name">Handler用法简单明了，可以将多个异步任务更新UI的代码放在一起，清晰明了</span></li><li><span class="name">处理单个异步任务时代码略多.</span></li></ul></li><li><span class="name">适用范围: 多个异步任务的更新UI.</span></li></ul></li><li><span class="name"><b>AsyncTask</b></span><ul><li><span class="name">AsyncTask是android提供的轻量级的异步类,可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新)，最后反馈执行的结果给UI主线程。</span></li><li><span class="name">AsyncTask通过一个阻塞队列BlockingQuery&lt;Runnable&gt;存储待执行的任务，利用静态线程池THREAD_POOL_EXECUTOR提供一定数量的线程，默认128个。</span></li><li><span class="name">默认采用串行任务执行器，循环取出任务交给THREAD_POOL_EXECUTOR中的线程执行，执行完一个，再执行下一个。</span></li><li><span class="name">用法是:</span></li><li><span class="name">class DownloadTask extends AsyncTask&lt;Integer, Integer, String&gt;{</span><ul><li><span class="name">// AsyncTask&lt;Params, Progress, Result&gt;,  3个参数分别是参数（例子里是线程休息时间），进度(publishProgress用到)，返回值类型</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onPreExecute() {</span><ul><li><span class="name">//第一个执行方法</span></li><li><span class="name">super.onPreExecute();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected String doInBackground(Integer... params) {</span><ul><li><span class="name">// 第二个执行方法, onPreExecute() 执行完后执行</span></li><li><span class="name">for(int i=0; i&lt;=100; i++){</span><ul><li><span class="name">publishProgress(i);</span></li><li><span class="name">try {</span><ul><li><span class="name">Thread.sleep(params[0]);</span></li></ul></li><li><span class="name">} catch (InterruptedException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">return "执行完毕";</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onProgressUpdate(Integer... progress) {</span><ul><li><span class="name">// 这个函数在doInBackground调用publishProgress时触发，虽然调用时只有一个参数, 但是这里取到的是一个数组, 所以要用 progesss[0]来取值, 第n个参数就用progress[n]来取值.</span></li><li><span class="name"><b>// 它是被主线程调用执行的, 因此这里可以有UI操作.</b></span></li><li><span class="name">tv.setText(progress[0]+"%");</span></li><li><span class="name">super.onProgressUpdate(progress);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onPostExecute(String result) {</span><ul><li><span class="name">// doInBackground返回时触发，换句话说，就是doInBackground执行完后触发. 这里的result就是上面 doInBackground 执行后的返回值，所以这里是"执行完毕"</span></li><li><span class="name">setTitle(result);</span></li><li><span class="name">super.onPostExecute(result);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">AsyncTask的使用注意事项：</span><ul><li><span class="name">AsyncTask的类必须在主线程中加载，这一点已经在Android4.1以上版本上自动完成</span></li><li><span class="name">AsyncTask 对象必须在主线程中创建</span></li><li><span class="name">execute方法必须在主线程中调用</span></li><li><span class="name">一个AsyncTask对象只能执行一次，否则会运行报错。</span></li></ul></li><li><span class="name">优缺点:</span><ul><li><span class="name">处理单个异步任务简单，可以获取到异步任务的进度</span></li><li><span class="name">可以通过cancel方法取消还没执行完的AsyncTask</span></li><li><span class="name">处理多个异步任务代码显得较多</span></li></ul></li><li><span class="name">适用范围: 单个异步任务的处理.</span></li></ul></li><li><span class="name"><b>ThreadPoolExecutor: 线程池</b></span><ul><li><span class="name">ThreadPoolExecutor提供了一组线程池，可以管理多个线程并行执行。这样一方面减少了每个并行任务独自建立线程的开销，另一方面可以管理多个并发线程的公共资源，从而提高了多线程的效率。所以ThreadPoolExecutor比较适合一组任务的执行。</span></li><li><span class="name">Executors利用工厂模式对ThreadPoolExecutor进行了封装，使用起来更加方便。有4种工厂:</span><ul><li><span class="name">Executors.newFixedThreadPool():  创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化</span></li><li><span class="name">Executors.newCachedThreadPool():  创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制.</span></li><li><span class="name">Executors.newScheduledThreadPool(): 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer.</span></li><li><span class="name">Executors.newSingleThreadExecutor(): 创建一个单线程化的executor，它只创建唯一的worker线程来执行任务.</span></li><li><span class="name">newSingleThreadScheduledExecutor(): 创建一个延迟执行的单线程线程池</span></li><li><span class="name">newWorkingStealingPool(int parallelism): 创建持有足够的线程的线程池来支持给定的并行级别，以充分支持多CPU并行能力。</span></li><li><span class="name">newWorkingStealingPool(): 根据CPU个数设置并行级别。</span></li></ul></li><li><span class="name">使用线程池的步骤</span><ul><li><span class="name">调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。</span></li><li><span class="name">创建Runnable实现类或者Callable实现类的实例，作为线程的执行任务。</span></li><li><span class="name">调用ExecutorService对象的submit方法来提交Runnable或者Callable实例。</span></li><li><span class="name">当没有任务时，使用shutdown()方法来关闭线程池。</span></li><li><span class="name">public class TestTreadPool{</span><ul><li><span class="name">public static void main(String[] args)</span></li><li><span class="name">throws Exception{</span><ul><li><span class="name">ExecutorService pool = Executors.newFixedThreadPool(6);</span></li><li><span class="name">Runnable target = ()-&gt;{</span><ul><li><span class="name">for(int i=0;i&lt;100;i++) {</span></li><li><span class="name">System.out.println(Thread.currentThread().getName()</span><ul><li><span class="name">+ "的i值为："+ i);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">// 向线程池中提交两个线程</span></li><li><span class="name">pool.submit(target);</span></li><li><span class="name">pool.submit(target);</span></li><li><span class="name">pool.shutdown();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">适用范围: 批处理任务</span></li></ul></li><li><span class="name"><b>IntentService</b></span><ul><li><span class="name">IntentService继承自Service，是一个经过包装的轻量级的Service，用来接收并处理通过Intent传递的异步请求。客户端通过调用 startService(Intent) 启动一个IntentService，利用一个work线程依次处理顺序过来的请求，处理完成后自动结束Service。</span></li><li><span class="name">优缺点: 它是Service，比起其他线程来说具有更高的优先级，不容易被系统杀死，而能够保证任务的执行。</span></li><li><span class="name">特点: IntentService的优先级比单纯线程要高，所以适合执行一些高优先级的后台任务。</span></li></ul></li></ul>
  </body>
</html>