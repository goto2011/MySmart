<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">02-多线程</span><ul><li><span class="name">Android线程架构</span><ul><li><span class="name">当启动一个App的时候，Android系统会启动一个Linux Process，该Process包含一个Thread，称为UI Thread, 即主线程。系统在创建UI线程的时候会初始化一个Looper对象,同时也会创建一个与其关联的MessageQueue;</span></li><li><span class="name">通常一个应用的所有组件都运行在UI Thread中. 通过在Manifest.xml中的代码块(&lt;activity&gt;&lt;service&gt;&lt;provider&gt;&lt;receiver&gt;)中的android:process属性指定其运行在不同的process中。</span></li><li><span class="name">UI Thread中运行着许多重要的逻辑，如系统事件处理，用户输入事件处理，UI绘制，Service，Alarm等. </span></li><li><span class="name">UI线程5秒没有响应, 系统就会报ANR. 所以如果用户逻辑比较费时, 就应该放在子线程中.</span></li></ul></li><li><span class="name"><b>Android线程的生命周期</b></span><ul><li><span class="name">新建状态（New）：new实例化之后进入该状态, jvm为其分配内存，并初始化成员变量;</span></li><li><span class="name">就绪状态（<b>Runnable</b>）：线程调用start()之后就绪状态. jvm会为其创建方法调用栈和PC计数器, 等待cpu执行. 注意这时线程还没开始运行, 但已获得除CPU之外的所有资源.</span><ul><li><span class="name"><b>还有一种方式进入就绪态:  yield()：线程把自己暂停, 主动释放CPU资源. 但是, 这里很关键, yield() 只会将线程转为就绪态, 而不是阻塞态. 而且它会强制调用系统调度器重新调度一次。</b></span></li><li><span class="name">当某个线程调用 <b>yield</b>() 暂停后，只要下一次系统调度时, 其优先级与当前运行线程相同，或更高时, 就会重新获得执行机会。</span></li><li><span class="name">其它线程调用notify() / notifyAll() 唤醒本线程. 调用前需要获取对象锁.</span></li></ul></li><li><span class="name">运行状态（Running）：经过系统调度, 线程获得CPU时间片，开始执行 run()方法的代码；</span></li><li><span class="name">阻塞状态（<b>Blocked</b>）：线程由于各种原因进入阻塞状态, 包括：</span><ul><li><span class="name"><b>join</b>(), 当前线程阻塞, 进入另外一个线程, 直到后者执行完毕;</span></li><li><span class="name"><b>sleep</b>(), 线程主动放弃所占有的CPU资源。</span><ul><li><span class="name">通过参数指定睡眠的微秒数.</span></li><li><span class="name">注意使用sleep方法时需要捕捉 InterruptedException, 或者抛出该异常。</span></li></ul></li><li><span class="name"><b>wait</b>(), 当前线程阻塞, 等待某个通知notify. 调用前需要获取对象锁.</span><ul><li><span class="name">一般是和 <b>notifyAll</b>() 成对出现. </span></li></ul></li><li><span class="name">线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞.</span></li><li><span class="name">线程试图获得一个同步锁，但是该锁被其他线程所持有.</span></li><li><span class="name"><b>阻塞条件被消除后, 线程会进入就绪态. </b></span></li></ul></li><li><span class="name">死亡状态（Dead）：线程运行完毕或异常退出，可使用 isAlive()获取状态。有三种死亡类型:</span><ul><li><span class="name">正常终止: 执行完所有工作, 正常结束.</span></li><li><span class="name">强制终止: 线程调用 stop() 或 destory() 结束. LMK即是这种.</span></li><li><span class="name">异常终止: 执行过程中发生异常, 或者被系统强制杀死.</span></li></ul></li></ul></li><li><span class="name">Thread类</span><ul><li><span class="name">Thread有如下主要函数</span><ul><li><span class="name">run(): 线程运行时所执行的代码</span></li><li><span class="name">start(): 启动线程</span></li><li><span class="name">sleep()/sleep(long millis): 线程休眠，进入阻塞状态，sleep方法不会释放锁（其它线程不会进入synchronized方法体或方法块，不释放锁需要try/catch）</span></li><li><span class="name">yield(): 线程交出CPU，但是不会阻塞而是重置为就绪状态，不会释放锁</span></li><li><span class="name">join()/join(long millis)/join(long millis,int nanoseconds): 线程插队，当该子线程执行完毕后接着执行其它</span></li><li><span class="name">wait(): 进入阻塞状态，释放锁（其它线程可以进入synchronized代码块）</span></li><li><span class="name">interrupt(): 中断线程，注意只能中断阻塞状态的线程</span></li><li><span class="name">getId(): 获取当前线程的id</span></li><li><span class="name">getName()/setName(): 获取和设置线程的name</span></li><li><span class="name">getPriority()/setPriority(): 获取和设置线程的优先级，范围1-10，默认是5</span></li><li><span class="name">setDaemon()/isDaemo(): 设置和获取是否守护线程</span></li><li><span class="name">currentThread(): 静态函数获取当前线程</span></li></ul></li><li><span class="name">方法1: 继承Thread，重写run()方法</span><ul><li><span class="name">public class MyThread extends Thread{</span><ul><li><span class="name"><span class="contentTag" title="Filter @Overrid">@<span class="contentTagText">Overrid</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void run() {</span><ul><li><span class="name">super.run();</span></li><li><span class="name">// do something</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// Thread使用</span></li><li><span class="name">public void goThread(){</span><ul><li><span class="name">new MyThread().start();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name"><b>方法2: 实现Runnable，重写run()方法来执行任务. 比较常见.</b></span><ul><li><span class="name">new Thread(new Runnable() {</span><ul><li><span class="name">public void run() {...}</span></li></ul></li><li><span class="name">}).start();</span></li></ul></li><li><span class="name">方法3: 通过Handler启动线程</span><ul><li><span class="name">// 定义Handler和Runnable</span></li><li><span class="name">private int count = 0;</span></li><li><span class="name">private Handler mHandler = new Handler();</span></li><li><span class="name">private Runnable runnable = new Runnable() {</span><ul><li><span class="name">public void run() {</span><ul><li><span class="name">Log.i("download",Thread.currentThread().getName()+":"+count);</span></li><li><span class="name">count ++;</span></li><li><span class="name">mHandler.postDelayed(runnable,1000); // 执行后延迟1000毫秒再次执行，count已++</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">// 使用mHandler的post()方法执行线程。</span></li><li><span class="name">findViewById(R.id.btn_download).setOnClickListener(new View.OnClickListener() {</span><ul><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="http://mHandler.post">mHandler.post</a>(runnable); // handler运行runnable</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li></ul></li><li><span class="name">创建线程的方式有两种: </span><ul><li><span class="name">（1）继承Thread类</span></li><li><span class="name">（2）实现Runnable接口</span></li><li><span class="name">至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</span></li></ul></li><li><span class="name">start()方法和run()方法的区别</span><ul><li><span class="name">只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。</span></li><li><span class="name">如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</span></li></ul></li><li><span class="name">Runnable接口和Callable接口的区别</span><ul><li><span class="name">Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</span></li><li><span class="name">Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</span></li><li><span class="name">Callable是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</span></li></ul></li><li><span class="name">volatile关键字的作用</span><ul><li><span class="name">volatile关键字的作用主要有两个：</span></li><li><span class="name">（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</span></li><li><span class="name">（2）代码底层执行不像我们看到的Java代码这么简单，它的执行是Java代码--&gt;字节码--&gt;根据字节码执行对应的C/C++代码--&gt;C/C++代码被编译成汇编语言--&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</span></li><li><span class="name">从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</span></li></ul></li><li><span class="name">线程安全和线程安全</span><ul><li><span class="name">线程安全问题是指多个线程访问同一代码或数据，造成结果和数据的错乱或与期望的结果不同所产生的问题。</span></li><li><span class="name">如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</span></li><li><span class="name">线程安全有几个级别:</span><ul><li><span class="name">（1）不可变. 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</span></li><li><span class="name">（2）绝对线程安全. 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</span></li><li><span class="name">（3）相对线程安全. 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</span></li><li><span class="name">（4）线程非安全. ArrayList、LinkedList、HashMap等都是线程非安全的类</span></li></ul></li><li><span class="name">基本上所有的并发模式在解决线程安全问题的问题上，都采用“序列化访问临界资源”的方案，即在同一时刻只能有一个线程访问临界资源（多个线程可能同时访问的数据或资源），也称同步互斥访问。</span></li><li><span class="name">第一种方式, <b>synchronized&nbsp;</b>关键字，保证同时刻只有一个线程进入该方法或者代码块.</span><ul><li><span class="name">这种最方便, 但是效率最低.</span></li><li><span class="name">有两种形式. 第一种是作为前缀定义函数.</span><ul><li><span class="name">int count = 100;</span></li><li><span class="name">private <b>synchronized </b>void count() {</span><ul><li><span class="name">if (count &gt; 0) {</span><ul><li><span class="name">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">isRunning = false;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">另外一种是定义代码块.</span><ul><li><span class="name">private void count() {</span><ul><li><span class="name"><b>synchronized </b>(this) {</span><ul><li><span class="name">if (count &gt; 0) {</span><ul><li><span class="name">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">isRunning = false;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">第二种方式, 特殊域变量 volatile修饰变量. 它告诉虚拟机该变量随时可能更新，因此使用时每次都会重新计算，而不是使用寄存器的值。</span><ul><li><span class="name">volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。不能完全保证线程安全.</span></li></ul></li><li><span class="name">第三种, 使用重入锁Lock类实现线程同步。</span><ul><li><span class="name">ReentrantLock() : 创建一个ReentrantLock实例</span></li><li><span class="name">lock() :获得锁</span></li><li><span class="name">unlock() : 释放锁</span></li><li><span class="name">private void count() {</span><ul><li><span class="name">private final ReentrantLock lock = new ReentrantLock();  // 创建可重入锁</span></li><li><span class="name">lock.lock();</span></li><li><span class="name">if (count &gt; 0) {</span><ul><li><span class="name">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">isRunning = false;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">lock.unlock();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">第四种方式, ThreadLocal管理变量。</span><ul><li><span class="name">如果一个变量使用ThreadLocal进行管理，每一个使用该变量的线程都会获得该变量的副本，副本之间相互独立，所以每个线程都可以修改变量而不会对其它线程造成影响。</span></li><li><span class="name">数据不共享，自然就没有线程安全问题了.</span></li><li><span class="name">private static ThreadLocal&lt;Integer&gt; number = new ThreadLocal&lt;Integer&gt;(){</span><ul><li><span class="name">// 重写方法，设置默认值</span></li><li><span class="name">protected Integer initialValue() {</span><ul><li><span class="name">return 1;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 自定义方法设置变量值</span></li><li><span class="name">public void saveNumber(int newNumber){</span><ul><li><span class="name">number.set(number.get() + newNumber);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 自定义方法获取变量值</span></li><li><span class="name">public int getNumber(){</span><ul><li><span class="name">return number.get();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li></ul></li><li><span class="name">线程安全是以牺牲程序运行效率为代价的，因此在注意线程安全的同时，也要注意不要滥用锁和同步方法，尽量只对那些会改变竞争资源的方法进行同步。</span></li></ul></li><li><span class="name">sleep方法和wait方法有什么区别?</span><ul><li><span class="name">sleep方法和wait方法都可以用来放弃CPU一定的时间.</span></li><li><span class="name">不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器.</span></li></ul></li><li><span class="name">死锁</span><ul><li><span class="name">产生死锁的四个必要条件：</span><ul><li><span class="name">互斥条件：一个资源每次只能被一个进程使用。</span></li><li><span class="name">请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span></li><li><span class="name">不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span></li><li><span class="name">循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></li></ul></li><li><span class="name">目前处理死锁的方法可归结为4种：</span><ul><li><span class="name">预防死锁：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</span></li><li><span class="name">避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</span></li><li><span class="name">检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。</span></li><li><span class="name">解除死锁：这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</span></li></ul></li></ul></li><li><span class="name">Android应用的多线程的主要问题是<b>在子线程中刷新界面</b>. </span><ul><li><span class="name">因为Android规定, 只有主线程才可以刷新界面. 但是又不可能把所有的逻辑都放在主线程. </span></li><li><span class="name">有子线程就有子线程刷新界面的需求, 怎么刷?</span></li><li><span class="name">最简的办法: 利用 Activity.<b>runOnUiThread</b>(Runnable)把更新ui的代码创建在Runnable中,更新 UI时，把Runnable 对象传进来即可.</span></li><li><span class="name">复杂一些的方法见下面:</span></li></ul></li><li><span class="name">Android提供了5种多线程方案: Handler+Thread, HandlerThread<b>, </b>AsyncTask, ThreadPoolExecutor, IntentService.</span></li><li><span class="name"><b>Handler+Thread</b></span><ul><li><span class="name">Android主线程包含一个消息队列(MessageQueue)，该消息队列里面可以存入一系列的Message或Runnable对象。通过一个Handler你可以往这个消息队列发送Message或者Runnable对象，并且处理这些对象。</span></li><li><span class="name"><b>Handler是一个胶水类. 它粘合两个线程, 所以它的代码分为两半, 一半在一个线程中发msg, 一半在另一个线程收msg. 看Handle代码, 要注意分清它运行在两个线程. </b></span></li><li><span class="name">创建一个Handle对象时，它会绑定于创建它的线程(一般就是UI线程)以及该线程的消息队列. 从这时起，这个handler就会开始把Message或Runnable对象传递到消息队列中，并在它们出队列的时候执行它们。</span></li><li><span class="name">Handler可以把一个Message对象或者Runnable对象压入到消息队列中，进而在UI线程中获取Message或者执行Runnable对象，Handler把压入消息队列有两类方式，Post和sendMessage：</span></li><li><span class="name">Post方式: 把一个Runnable对象入队到消息队列中. 有:</span><ul><li><span class="name">post(Runnable) </span></li><li><span class="name">postAtTime(Runnable,long)   // 指定时间</span></li><li><span class="name">postDelayed(Runnable,long)   // 延迟post</span></li><li><span class="name">其实1和3都是调用2, post 即定时为now, postDelayed 即定时为 now+指定延时.</span></li><li><span class="name">注意: 时间是不准的.</span></li></ul></li><li><span class="name">Runnable对象: 用于封装一段要运行于子线程的代码. 这段代码放在 Runnable对象中的run() 方法中. </span></li><li><span class="name">sendMessage方式: 允许把一个包含消息数据的Message对象压入到消息队列中。有:</span><ul><li><span class="name">sendEmptyMessage(int)   // 发送空消息</span></li><li><span class="name">sendMessage(Message)   // 发送消息</span></li><li><span class="name">sendMessageAtTime(Message,long)   // 发送定时生效的消息</span></li><li><span class="name">sendMessageDelayed(Message,long)    // 指定延时多少毫秒后发送消息</span></li></ul></li><li><span class="name">无论是sendMessage 还是 post 一个 Runable, 最终都是sendMessage. 对于后者, 只是把 Runable对象放到message的 Runables属性中而已.</span></li><li><span class="name"><b>接受msg的代码在Handler类的 handleMessage() 方法. 需要重写.</b></span><ul><li><span class="name">Message.obtain(): 从message池中取一个对象, 使用池是为了不每次new, 消费内存.</span></li></ul></li><li><span class="name">如果是Handler写在了子线程中的话,我们就需要自己创建一个Looper对象. 创建流程如下:</span><ul><li><span class="name">直接调用Looper.prepare()方法即可为当前线程创建Looper对象,而它的构造器会创建配套的MessageQueue;&nbsp;</span></li><li><span class="name">创建Handler对象,重写 handleMessage( )方法就可以处理来自于其他线程的信息了!</span></li><li><span class="name">调用Looper.loop()方法启动Looper.</span></li></ul></li><li><span class="name">public class CalPrime extends Activity {</span><ul><li><span class="name">static final String UPPER_NUM = "upper";</span></li><li><span class="name">EditText etNum;</span></li><li><span class="name">CalThread calThread;</span></li><li><span class="name">// 定义一个线程类</span></li><li><span class="name">class CalThread extends Thread {</span><ul><li><span class="name">public Handler mHandler;</span></li><li><span class="name">public void run() {</span><ul><li><span class="name">Looper.prepare();</span></li><li><span class="name">mHandler = new Handler() {</span><ul><li><span class="name">// 定义处理消息的方法</span></li><li><span class="name">public void handleMessage(Message msg) {</span><ul><li><span class="name">if(msg.what == 0x123) {</span><ul><li><span class="name">int upper = msg.getData().getInt(UPPER_NUM);</span></li><li><span class="name">List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();</span></li><li><span class="name">// 计算从2开始、到upper的所有质数</span></li><li><span class="name">outer:</span></li><li><span class="name">for (int i = 2 ; i &lt;= upper ; i++) {</span><ul><li><span class="name">// 用i处于从2开始、到i的平方根的所有数</span></li><li><span class="name">for (int j = 2 ; j &lt;= Math.sqrt(i) ; j++) {</span><ul><li><span class="name">// 如果可以整除，表明这个数不是质数</span></li><li><span class="name">if(i != 2 &amp;&amp; i % j == 0) {</span><ul><li><span class="name">continue outer;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">nums.add(i);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 使用Toast显示统计出来的所有质数</span></li><li><span class="name">Toast.makeText(CalPrime.this , nums.toString()</span><ul><li><span class="name">, Toast.LENGTH_LONG).show();</span></li></ul></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">Looper.loop();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.main);</span></li><li><span class="name">etNum = (EditText)findViewById(R.id.etNum);</span></li><li><span class="name">calThread = new CalThread();</span></li><li><span class="name">// 启动新线程</span></li><li><span class="name">calThread.start();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 为按钮的点击事件提供事件处理函数</span></li><li><span class="name">public void cal(View source){</span><ul><li><span class="name">// 创建消息</span></li><li><span class="name">Message msg = new Message();</span></li><li><span class="name">msg.what = 0x123;</span></li><li><span class="name">Bundle bundle = new Bundle();</span></li><li><span class="name">bundle.putInt(UPPER_NUM , Integer.parseInt(etNum.getText().toString()));</span></li><li><span class="name">msg.setData(bundle);</span></li><li><span class="name">// 向新线程中的Handler发送消息</span></li><li><span class="name">calThread.mHandler.sendMessage(msg);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><b>Handler的</b>优缺点: </span><ul><li><span class="name">Handler用法简单明了，可以将多个异步任务更新UI的代码放在一起，清晰明了</span></li><li><span class="name">处理单个异步任务时代码略多.</span></li></ul></li><li><span class="name">适用范围: 多个异步任务的更新UI.</span></li><li><span class="name">Looper.loop为什么不会阻塞掉UI线程？</span><ul><li><span class="name">loop()开启死循环后，会命令MessageQueue通过next()方法取出之前储存的消息，如果有立刻被拿出来执行msg.target.dispatchMessage(msg);</span></li><li><span class="name">如果此时MessageQueue中已经没有消息了（大部分时候都没有），MessageQueue就会无限期的阻塞下去nativePollOnce(ptr,nextPollTimeoutMillis)，释放cpu资源，这时候并不会造成UI线程卡顿;</span></li><li><span class="name">直到有新的消息存入队列enqueueMessage(Messagemsg, long when)，唤醒之前阻塞的线程 nativeWake(mPtr)，继续执行next()方法.</span></li></ul></li></ul></li><li><span class="name"><b>HandlerThread: 封装Handler+Thread</b></span><ul><li><span class="name"><b>HandlerThread</b>通过继承Thread类和封装Handler类的使用，从而使得创建新线程和与其他线程进行通信变得更加方便易用.</span><ul><li><span class="name">通过继承Thread类，快速地创建1个带有Looper对象的新工作线程.</span></li><li><span class="name">通过封装Handler类，快速创建Handler&nbsp;&amp; 与其他线程进行通信.</span></li></ul></li><li><span class="name">HandlerThread的使用步骤分为5步:</span><ul><li><span class="name">// step1：创建HandlerThread实例对象</span></li><li><span class="name">// 传入参数 = 线程名字，作用 = 标记该线程</span><ul><li><span class="name">HandlerThread mHandlerThread = new HandlerThread("handlerThread");</span></li></ul></li><li><span class="name">// step2：启动线程</span><ul><li><span class="name">mHandlerThread.start();</span></li></ul></li><li><span class="name">// step3：创建工作线程Handler &amp; 复写handleMessage（）</span></li><li><span class="name">// 关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></li><li><span class="name">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span><ul><li><span class="name">Handler workHandler = new Handler( handlerThread.getLooper() ) {</span><ul><li><span class="name"></span></li><li><span class="name">public boolean handleMessage(Message msg) {</span><ul><li><span class="name">...//消息处理</span></li><li><span class="name">return true;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li><li><span class="name">// step4：使用工作线程Handler向工作线程的消息队列发送消息</span></li><li><span class="name">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span><ul><li><span class="name">// a. 定义要发送的消息</span></li><li><span class="name">Message msg = Message.obtain();</span></li><li><span class="name">msg.what = 2; //消息的标识</span></li><li><span class="name">msg.obj = "B"; // 消息的存放</span></li><li><span class="name">// b. 通过Handler发送消息到其绑定的消息队列</span></li><li><span class="name">workHandler.sendMessage(msg);</span></li></ul></li><li><span class="name">//  step5：结束线程，即停止线程的消息循环</span><ul><li><span class="name">mHandlerThread.quit();</span></li></ul></li></ul></li></ul></li><li><span class="name"><b>AsyncTask</b></span><ul><li><span class="name">AsyncTask是android提供的轻量级的异步类, 可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的状态(常用于实现UI进度更新)，最后反馈执行的结果给UI主线程。</span></li><li><span class="name">AsyncTask通过一个阻塞队列BlockingQuery&lt;Runnable&gt;存储待执行的任务，利用静态线程池THREAD_POOL_EXECUTOR提供一定数量的线程，默认128个。</span></li><li><span class="name">默认采用串行任务执行器，循环取出任务交给THREAD_POOL_EXECUTOR中的线程执行，执行完一个，再执行下一个。</span></li><li><span class="name">不要手动调用onPreExecute()，doInBackground(Params... params)，onProgressUpdate(Progress... values)，onPostExecute(Result result)这几个方法。</span></li><li><span class="name">例子: </span></li><li><span class="name">// <b>自定义AsyncTask</b></span></li><li><span class="name">public class MyAsyncTask extends AsyncTask&lt;Integer,Integer,String&gt; {</span><ul><li><span class="name">private TextView txt;</span></li><li><span class="name">private ProgressBar pgbar;</span></li><li><span class="name">public MyAsyncTask(TextView txt,ProgressBar pgbar) {</span><ul><li><span class="name">super();</span></li><li><span class="name">this.txt = txt;</span></li><li><span class="name">this.pgbar = pgbar;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 在调用耗时操作前被调用, 常用于初始化, 比如进度条的显示. 该方法运行在UI线程.</span></li><li><span class="name">protected void <b>onPreExecute</b>() {</span><ul><li><span class="name">txt.setText("开始执行异步线程");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 在onPreExecute<b>()执行后马上执行. </b>该方法不运行在UI线程,主要用于异步操作.</span></li><li><span class="name">// 可调用 publishProgress()方法实时更新进度, 或者更新UI.</span></li><li><span class="name">protected String <b>doInBackground</b>(Integer... params) {</span><ul><li><span class="name">DelayOperator dop = new DelayOperator();</span></li><li><span class="name">int i = 0;</span></li><li><span class="name">for (i = 10;i &lt;= 100;i+=10) {</span><ul><li><span class="name">dop.delay();</span></li><li><span class="name"><b>publishProgress</b>(i);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">return  i + params[0].intValue() + "";</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 在doBackground方法中,每次调用publishProgress方法都会触发该方法</span></li><li><span class="name">// 运行在UI线程中,可对UI控件进行操作</span></li><li><span class="name">protected void <b>onProgressUpdate</b>(Integer... values) {</span><ul><li><span class="name">int value = values[0];</span></li><li><span class="name">pgbar.setProgress(value);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 在<b>doInBackground()执行完后, 该方法会被UI线程调用. 后台的处理结果将通过该方法传递给UI线程.</b></span></li><li><span class="name">protected void <b>onPostExecute</b>(String result) {</span><ul><li><span class="name">txt.setText("异步线程执行完毕");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 用于在取消执行中的任务时更改UI</span></li><li><span class="name">protected void <b>onCancelled</b>() {</span><ul><li><span class="name">txt.setText("异步线程被终止");</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// MainActivity.java</span></li><li><span class="name">public class MyActivity extends ActionBarActivity {</span><ul><li><span class="name">private TextView txttitle;</span></li><li><span class="name">private ProgressBar pgbar;</span></li><li><span class="name">private Button btnupdate;</span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">txttitle = (TextView)findViewById(R.id.txttitle);</span></li><li><span class="name">pgbar = (ProgressBar)findViewById(R.id.pgbar);</span></li><li><span class="name">btnupdate = (Button)findViewById(R.id.btnupdate);</span></li><li><span class="name">btnupdate.setOnClickListener(new View.OnClickListener() {</span><ul><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name">MyAsyncTask myTask = new MyAsyncTask(txttitle,pgbar);</span></li><li><span class="name">myTask.execute(1000);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">AsyncTask的使用注意事项：</span><ul><li><span class="name">AsyncTask的类必须在主线程中加载，这一点已经在Android4.1以上版本上自动完成</span></li><li><span class="name">AsyncTask 对象必须在主线程中创建</span></li><li><span class="name">execute方法必须在主线程中调用</span></li><li><span class="name">一个AsyncTask对象只能执行一次，否则会运行报错。</span></li></ul></li><li><span class="name">优缺点:</span><ul><li><span class="name">处理单个异步任务时代码简单，而且能获取到异步任务的进度.</span></li><li><span class="name">可通过cancel方法取消还没执行完的AsyncTask.</span></li><li><span class="name">处理多个异步任务代码显得较多.</span></li></ul></li><li><span class="name">适用范围: 单个异步任务的处理.</span></li></ul></li><li><span class="name"><b>ThreadPoolExecutor: 线程池</b></span><ul><li><span class="name">ThreadPoolExecutor提供了一组线程池，可以管理多个线程并行执行。比较适合一组任务的执行。</span></li><li><span class="name">优势: 避免频繁地创建和销毁线程，达到线程对象的重用。其次使用线程池还可以根据项目灵活地控制并发的数目。</span></li><li><span class="name">Executors利用工厂模式对ThreadPoolExecutor进行了封装，使用起来更加方便。有4种工厂:</span><ul><li><span class="name">Executors.newFixedThreadPool():  创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化</span></li><li><span class="name">Executors.newCachedThreadPool():  创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制.</span></li><li><span class="name">Executors.newScheduledThreadPool(): 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer.</span></li><li><span class="name">Executors.newSingleThreadExecutor(): 创建一个单线程化的executor，它只创建唯一的worker线程来执行任务.</span></li><li><span class="name">newSingleThreadScheduledExecutor(): 创建一个延迟执行的单线程线程池</span></li><li><span class="name">newWorkingStealingPool(int parallelism): 创建持有足够的线程的线程池来支持给定的并行级别，以充分支持多CPU并行能力。</span></li><li><span class="name">newWorkingStealingPool(): 根据CPU个数设置并行级别。</span></li></ul></li><li><span class="name">使用线程池的步骤</span><ul><li><span class="name">调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。</span></li><li><span class="name">创建Runnable实现类或者Callable实现类的实例，作为线程的执行任务。</span></li><li><span class="name">调用ExecutorService对象的submit方法来提交Runnable或者Callable实例。</span></li><li><span class="name">当没有任务时，使用shutdown()方法来关闭线程池。</span></li><li><span class="name">public class TestTreadPool{</span><ul><li><span class="name">public static void main(String[] args)</span></li><li><span class="name">throws Exception{</span><ul><li><span class="name">ExecutorService pool = Executors.newFixedThreadPool(6);</span></li><li><span class="name">Runnable target = ()-&gt;{</span><ul><li><span class="name">for(int i=0;i&lt;100;i++) {</span></li><li><span class="name">System.out.println(Thread.currentThread().getName()</span><ul><li><span class="name">+ "的i值为："+ i);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">// 向线程池中提交两个线程</span></li><li><span class="name">pool.submit(target);</span></li><li><span class="name">pool.submit(target);</span></li><li><span class="name">pool.shutdown();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">适用范围: 批处理任务</span></li></ul></li><li><span class="name"><b>IntentService</b></span><ul><li><span class="name">IntentService继承自Service，是一个经过包装的轻量级的Service，用来接收并处理通过Intent传递的异步请求。客户端通过调用 startService(Intent) 启动一个IntentService，利用一个work线程依次处理顺序过来的请求，处理完成后自动结束Service。</span></li><li><span class="name">优缺点: 它是Service，比起其他线程来说具有更高的优先级，不容易被系统杀死，而能够保证任务的执行。</span></li><li><span class="name">特点: IntentService的优先级比单纯线程要高，所以适合执行一些高优先级的后台任务。</span></li></ul></li><li><span class="name">信号量: Semaphore</span><ul><li><span class="name">信号量维护了一个计数器. 如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</span></li><li><span class="name">Semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得。</span></li></ul></li><li><span class="name">Java中如何获取到线程dump文件?</span><ul><li><span class="name">死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</span></li><li><span class="name">（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</span></li><li><span class="name">（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</span></li><li><span class="name">另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈.</span></li></ul></li><li><span class="name">生产者消费者模型的作用是什么?</span><ul><li><span class="name">（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</span></li><li><span class="name">（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约.</span></li></ul></li></ul>
  </body>
</html>