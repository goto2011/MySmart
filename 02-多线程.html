<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>02-多线程</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android线程架构</span></span><ul><li><span class="name"><span class="innerContentContainer">当启动一个App的时候，Android系统会启动一个Linux Process，该Process包含一个Thread，称为UI Thread, 即主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">系统在创建UI线程的时候会初始化一个Looper对象, 以及与其关联的MessageQueue对象;</span></span></li><li><span class="name"><span class="innerContentContainer">通常一个应用的所有组件都运行在UI Thread中.  </span></span></li><li><span class="name"><span class="innerContentContainer">通过在Manifest.xml中的代码块(&lt;activity&gt;&lt;service&gt;&lt;provider&gt;&lt;receiver&gt;)中的 android:process 属性可指定其运行在不同的process中。</span></span></li><li><span class="name"><span class="innerContentContainer">UI Thread中运行着许多重要的逻辑，如系统事件处理，用户输入事件处理，UI绘制，Service，Alarm等. </span></span></li><li><span class="name"><span class="innerContentContainer">UI线程5秒没有响应, 系统就会报ANR. 所以费时的逻辑应该放在子线程里.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Android线程的生命周期 <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">新建状态（New）：new实例化之后进入该状态, jvm为其分配内存，并初始化成员变量;</span></span></li><li><span class="name"><span class="innerContentContainer">就绪状态（<b>Runnable</b>）：线程调用start()之后就绪状态. jvm会为其创建方法调用栈和PC计数器, 等待cpu执行. 注意这时线程还没开始运行, 但已获得除CPU之外的所有资源.</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>还有一种方式进入就绪态:  yield()：线程把自己暂停, 主动释放CPU资源. 但是, 这里很关键, yield() 只会将线程转为就绪态, 而不是阻塞态. 而且它会强制调用系统调度器重新调度一次。</b></span></span></li><li><span class="name"><span class="innerContentContainer">当某个线程调用 <b>yield</b>() 暂停后，只要下一次系统调度时, 其优先级与当前运行线程相同或更高时, 就会重新获得执行机会。</span></span></li><li><span class="name"><span class="innerContentContainer">其它线程调用 notify() / notifyAll() 唤醒本线程. 调用前需要获取对象锁.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运行状态（Running）：经过系统调度, 线程获得CPU时间，开始执行 run()方法的代码；</span></span></li><li><span class="name"><span class="innerContentContainer">阻塞状态（<b>Blocked</b>）：线程由于各种原因进入阻塞状态, 包括：</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>join</b>(), 当前线程阻塞, 进入另外一个线程, 直到后者执行完毕;</span></span></li><li><span class="name"><span class="innerContentContainer"><b>sleep</b>(), 线程主动放弃CPU资源。</span></span><ul><li><span class="name"><span class="innerContentContainer">通过参数指定睡眠的微秒数.</span></span></li><li><span class="name"><span class="innerContentContainer">注意使用sleep方法时需要捕捉 InterruptedException, 或者抛出该异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>wait</b>(), 当前线程阻塞, 等待某个通知notify. 调用前需要获取对象锁.</span></span><ul><li><span class="name"><span class="innerContentContainer">一般是和 <b>notifyAll</b>() 成对出现. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞.</span></span></li><li><span class="name"><span class="innerContentContainer">线程试图获得一个同步锁，但是该锁被其他线程所持有.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>阻塞条件被消除后, 线程会进入就绪态. </b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">死亡状态（Dead）：线程运行完毕或异常退出，可使用 isAlive()获取状态。有三种死亡类型:</span></span><ul><li><span class="name"><span class="innerContentContainer">正常终止: 执行完所有工作, 正常结束.</span></span></li><li><span class="name"><span class="innerContentContainer">强制终止: 线程调用 stop() 或 destory() 结束. LMK即是这种.</span></span></li><li><span class="name"><span class="innerContentContainer">异常终止: 执行过程中发生异常, 或者被系统强制杀死.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Thread类</span></span><ul><li><span class="name"><span class="innerContentContainer">Thread有如下主要函数：</span></span><ul><li><span class="name"><span class="innerContentContainer">run(): 线程运行时所执行的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">start(): 启动线程。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>sleep</b>() / sleep(long millis): 线程休眠，进入<b>阻塞</b>状态，sleep方法不会释放锁（其它线程不会进入synchronized方法体或方法块，不释放锁需要try/catch）</span></span></li><li><span class="name"><span class="innerContentContainer"><b>yield</b>(): 线程交出CPU，但是不会阻塞而是重置为<b>就绪</b>状态，不会释放锁。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>join</b>() / join(long millis) / join(long millis, int nanoseconds): 线程插队，执行完join()后, 主线程阻塞, 进入子线程执行; 等子线程执行完后, 再返回主线程join()后一行继续执行.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>wait</b>(): 进入阻塞状态，释放锁（其它线程可以进入synchronized代码块）</span></span></li><li><span class="name"><span class="innerContentContainer">interrupt(): 中断线程，注意只能中断阻塞状态的线程</span></span></li><li><span class="name"><span class="innerContentContainer">getId(): 获取当前线程的id</span></span></li><li><span class="name"><span class="innerContentContainer">getName() / setName(): 获取和设置线程的name</span></span></li><li><span class="name"><span class="innerContentContainer">getPriority() / setPriority(): 获取和设置线程的优先级，范围1-10，默认是5</span></span></li><li><span class="name"><span class="innerContentContainer">setDaemon() / isDaemo(): 设置为守护线程 / 是否是守护线程</span></span></li><li><span class="name"><span class="innerContentContainer">currentThread(): 静态函数获取当前线程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">start() 和 run()的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">只有调用了start()方法，才会启动新线程，start() 会在新线程中调用 run()。</span></span></li><li><span class="name"><span class="innerContentContainer">如果只是调用run()方法，那么代码还是在本线程中执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sleep() 和 wait()的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">sleep方法和wait方法都可以用来放弃CPU一定的时间.</span></span></li><li><span class="name"><span class="innerContentContainer">不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">创建子线程的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 继承Thread，重写run()方法</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MyThread extends Thread{</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Overrid">@<span class="contentTagText">Overrid</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.run();</span></span></li><li><span class="name"><span class="innerContentContainer">// do something</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// Thread使用</span></span></li><li><span class="name"><span class="innerContentContainer">public void goThread(){</span></span><ul><li><span class="name"><span class="innerContentContainer">new MyThread().start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. <b>创建</b>Thread 匿名类，传入<b>Runnable接口，重写其中的run()方法来执行任务. 常见的做法。</b></span></span><ul><li><span class="name"><span class="innerContentContainer">new Thread(new Runnable() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run() {...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).start();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Runnable 接口和 Callable 接口的区别 <b>  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">Runnable接口中的 run() 方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已;</span></span></li><li><span class="name"><span class="innerContentContainer">Callable接口中的 call() 方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</span></span></li><li><span class="name"><span class="innerContentContainer">多线程执行充满着未知性，某条线程是否执行了？执行了多久？某条线程执行的时候期望的数据是否已经赋值完毕？很难及时知道，能做的只是等待任务执行完毕而已。</span></span></li><li><span class="name"><span class="innerContentContainer">而 Callable + Future/FutureTask 却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，所以非常有用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Android多线程实现方式  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">1. runOnUiThread<b>， 最简单。一般用于刷新界面</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android规定只有主线程才可以刷新界面. 那么如果子线程需要刷新界面？</span></span></li><li><span class="name"><span class="innerContentContainer">把更新ui的代码放在 Runnable对象的 run() 中。</span></span></li><li><span class="name"><span class="innerContentContainer">子线程需要更新 UI时，把Runnable 对象传给 Activity.<b>runOnUiThread</b>(Runnable) 即可。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果当前线程是UI线程，那么会被立即执行。</span></span></li><li><span class="name"><span class="innerContentContainer">如果当前线程不是UI线程, 操作是发布事件到UI线程的队列中去。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">this.runOnUiThread(new Runnable() {   // 在 activity 类中调用</span></span><ul><li><span class="name"><span class="innerContentContainer">void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Do something …</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>2. Thread  + Handler + Looper</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Handler是一个胶水类. 它粘合两个线程, 所以它的代码分为两半。</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>一半在一个线程中发</b>Message或者Runnable对象；</span></span></li><li><span class="name"><span class="innerContentContainer"><b>另外一半在另一个线程处理收到的</b>Message或者Runnable对象<b>. </b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>看Handle代码, 要注意这个关系.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。</b></span></span></li><li><span class="name"><span class="innerContentContainer">Handler的同步原理</span></span><ul><li><span class="name"><span class="innerContentContainer">使用MessageQueue维护一个消息队列（实际上是链表）。</span></span></li><li><span class="name"><span class="innerContentContainer">当队列中没有Message时调用nativePollOnce挂起当前线程。</span></span></li><li><span class="name"><span class="innerContentContainer">当有新的任务时调用nativeWake唤起被挂起的线程，继续循环消息队列。</span></span></li><li><span class="name"><span class="innerContentContainer">对链表的操作使用synchronized关键字进行了代码块的加锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在子线程中创建一个Handle对象时，它会自动绑定创建它的线程。这部分是隐含的。</span></span></li><li><span class="name"><span class="innerContentContainer">在主线程中，可以通过 Thread.mHandler.<b>sendMessage</b>(msg) 或者 <a class="contentLink" target="_blank" rel="noreferrer" href="http://Thread.mHandler.post">Thread.mHandler.post</a>(Runnable)&nbsp;往子线程的消息队列发送事件，通知子线程某些事情发生。</span></span><ul><li><span class="name"><span class="innerContentContainer">sendMessage: 允许把一个包含消息数据的Message对象压入到消息队列中。有:</span></span><ul><li><span class="name"><span class="innerContentContainer">sendEmptyMessage(int)   // 发送空消息</span></span></li><li><span class="name"><span class="innerContentContainer">sendMessage(Message)   // 发送消息</span></span></li><li><span class="name"><span class="innerContentContainer">sendMessageAtTime(Message,long)   // 发送定时生效的消息</span></span></li><li><span class="name"><span class="innerContentContainer">sendMessageDelayed(Message,long)    // 指定延时多少毫秒后发送消息</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">post: 把一个Runnable对象入队到消息队列中. 有:</span></span><ul><li><span class="name"><span class="innerContentContainer">post(Runnable) </span></span></li><li><span class="name"><span class="innerContentContainer">postAtTime(Runnable,long)   // 指定时间</span></span></li><li><span class="name"><span class="innerContentContainer">postDelayed(Runnable,long)   // 延迟post</span></span></li><li><span class="name"><span class="innerContentContainer">其实1和3都是调用2, post 即定时为now, postDelayed 即定时为 now+指定延时.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无论是 sendMessage 还是 post, 最终都是sendMessage. 对于后者, 只是把 Runable对象放到message的 Runables属性中而已.</span></span></li><li><span class="name"><span class="innerContentContainer">创建msg对象时， 建议使用 Message.obtain(): 从message池中取一个对象。</span></span><ul><li><span class="name"><span class="innerContentContainer">使用池是为了不每次new, 浪费内存.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>子线程在 Handler.handleMessage() 中处理收到的事件。</b></span></span></li><li><span class="name"><span class="innerContentContainer">在做这件事之前，还需要Looper对象帮忙。</span></span><ul><li><span class="name"><span class="innerContentContainer">Looper对象的目的是保持持有它的线程处于存活状态。</span></span></li><li><span class="name"><span class="innerContentContainer">一个线程如果不持有Looper，则它的run()方法执行完就自然销毁了。这种肯定适合接受事件、处理事件的场景。</span></span></li><li><span class="name"><span class="innerContentContainer">Looper对象有几个要点：</span></span><ul><li><span class="name"><span class="innerContentContainer">线程默认没有 Looper；</span></span></li><li><span class="name"><span class="innerContentContainer">可以创建一个 Looper 并将它绑定到一个线程；</span></span></li><li><span class="name"><span class="innerContentContainer">每一个线程只能绑定一个 Looper。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建Looper</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 Looper.prepare() 即可。</span></span></li><li><span class="name"><span class="innerContentContainer">创建时会自动创建配套的MessageQueue。这部分是隐含的。</span></span></li><li><span class="name"><span class="innerContentContainer">调用Looper.<b>loop</b>()方法启动Looper.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UI线程的Looper</span></span><ul><li><span class="name"><span class="innerContentContainer">UI线程默认会创建Looper对象，相关代码在 ActivityThread.main() 中。</span></span></li><li><span class="name"><span class="innerContentContainer">所有的view.postDelay()都会走到UI线程的Looper的消息循环体中，Looper配合viewRootImpl 视图树的 handler 将所有的消息追加到主线程消息队列后面。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">例子：</span></span></li><li><span class="name"><span class="innerContentContainer">public class CalPrime extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">static final String UPPER_NUM = "upper";</span></span></li><li><span class="name"><span class="innerContentContainer">EditText etNum;</span></span></li><li><span class="name"><span class="innerContentContainer">CalThread calThread;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义一个线程类</span></span></li><li><span class="name"><span class="innerContentContainer">class CalThread extends Thread {</span></span><ul><li><span class="name"><span class="innerContentContainer">public Handler mHandler;</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>run</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Looper.<b>prepare</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">mHandler = new <b>Handler</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 定义处理消息的方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>handleMessage</b>(Message msg) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if(msg.what == 0x123) {</span></span><ul><li><span class="name"><span class="innerContentContainer">int upper = msg.getData().getInt(UPPER_NUM);</span></span></li><li><span class="name"><span class="innerContentContainer">List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();</span></span></li><li><span class="name"><span class="innerContentContainer">// 计算从2开始、到upper的所有质数</span></span></li><li><span class="name"><span class="innerContentContainer">for (int i = 2 ; i &lt;= upper ; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 用i处于从2开始、到i的平方根的所有数</span></span></li><li><span class="name"><span class="innerContentContainer">for (int j = 2 ; j &lt;= Math.sqrt(i) ; j++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 如果可以整除，表明这个数不是质数</span></span></li><li><span class="name"><span class="innerContentContainer">if(i != 2 &amp;&amp; i % j == 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">continue outer;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">nums.add(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 使用Toast显示统计出来的所有质数</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(CalPrime.this , nums.toString()</span></span><ul><li><span class="name"><span class="innerContentContainer">, Toast.LENGTH_LONG).show();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">Looper.<b>loop</b>();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.main);</span></span></li><li><span class="name"><span class="innerContentContainer">etNum = (EditText)findViewById(R.id.etNum);</span></span></li><li><span class="name"><span class="innerContentContainer">calThread = new CalThread();</span></span></li><li><span class="name"><span class="innerContentContainer">// 启动新线程</span></span></li><li><span class="name"><span class="innerContentContainer">calThread.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 为按钮的点击事件提供事件处理函数</span></span></li><li><span class="name"><span class="innerContentContainer">public void cal(View source){</span></span><ul><li><span class="name"><span class="innerContentContainer">// 创建消息</span></span></li><li><span class="name"><span class="innerContentContainer">Message msg = Message.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">msg.what = 0x123;</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle bundle = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">bundle.putInt(UPPER_NUM , Integer.parseInt(etNum.getText().toString()));</span></span></li><li><span class="name"><span class="innerContentContainer">msg.setData(bundle);</span></span></li><li><span class="name"><span class="innerContentContainer">// 向新线程中的Handler发送消息</span></span></li><li><span class="name"><span class="innerContentContainer">calThread.mHandler.<b>sendMessage</b>(msg);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Handler的</b>优缺点: </span></span><ul><li><span class="name"><span class="innerContentContainer">Handler用法简单明了，可以将多个异步任务更新UI的代码放在一起，清晰明了。</span></span></li><li><span class="name"><span class="innerContentContainer">如果仅处理单个异步任务，代码显得冗余.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适用范围: 多个异步任务的更新UI.</span></span></li><li><span class="name"><span class="innerContentContainer">Looper.loop为什么不会阻塞掉UI线程？ <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">loop()开启死循环后，会命令MessageQueue通过next()方法取出之前储存的消息，如果有立刻被拿出来执行msg.target.dispatchMessage(msg);</span></span></li><li><span class="name"><span class="innerContentContainer">如果此时 MessageQueue中已经没有消息了，MessageQueue就会无限期的阻塞下去 <b>nativePollOnce</b>(ptr, nextPollTimeoutMillis)，同时释放cpu资源，这时候并不会造成UI线程卡顿;</span></span></li><li><span class="name"><span class="innerContentContainer">直到有新的消息存入队列enqueueMessage(Messagemsg, long when)，唤醒之前阻塞的线程 nativeWake(mPtr)，继续执行next()方法.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>3. HandlerThread: 封装 Handler+Thread</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>HandlerThread</b>通过继承Thread类和封装Handler类的使用，从而使得创建新线程和与其他线程进行通信变得更加方便易用.</span></span><ul><li><span class="name"><span class="innerContentContainer">通过继承Thread类，快速地创建1个带有Looper对象的新工作线程.</span></span></li><li><span class="name"><span class="innerContentContainer">通过封装Handler类，快速创建Handler&nbsp;&amp; 与其他线程进行通信.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">HandlerThread的使用步骤分为5步:</span></span><ul><li><span class="name"><span class="innerContentContainer">// step1：创建HandlerThread实例对象</span></span></li><li><span class="name"><span class="innerContentContainer">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><ul><li><span class="name"><span class="innerContentContainer">HandlerThread mHandlerThread = new HandlerThread("handlerThread");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// step2：启动线程</span></span><ul><li><span class="name"><span class="innerContentContainer">mHandlerThread.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// step3：创建工作线程Handler &amp; 复写handleMessage（）</span></span></li><li><span class="name"><span class="innerContentContainer">// 关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span></li><li><span class="name"><span class="innerContentContainer">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><ul><li><span class="name"><span class="innerContentContainer">Handler workHandler = new Handler( handlerThread.getLooper() ) {</span></span><ul><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">public boolean handleMessage(Message msg) {</span></span><ul><li><span class="name"><span class="innerContentContainer">...//消息处理</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// step4：使用工作线程Handler向工作线程的消息队列发送消息</span></span></li><li><span class="name"><span class="innerContentContainer">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><ul><li><span class="name"><span class="innerContentContainer">// a. 定义要发送的消息</span></span></li><li><span class="name"><span class="innerContentContainer">Message msg = Message.obtain();</span></span></li><li><span class="name"><span class="innerContentContainer">msg.what = 2; //消息的标识</span></span></li><li><span class="name"><span class="innerContentContainer">msg.obj = "B"; // 消息的存放</span></span></li><li><span class="name"><span class="innerContentContainer">// b. 通过Handler发送消息到其绑定的消息队列</span></span></li><li><span class="name"><span class="innerContentContainer">workHandler.sendMessage(msg);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">//  step5：结束线程，即停止线程的消息循环</span></span><ul><li><span class="name"><span class="innerContentContainer">mHandlerThread.quit();</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>4. </b>AsyncTask</span></span><ul><li><span class="name"><span class="innerContentContainer">AsyncTask是android提供的轻量级的异步类, 可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的状态(常用于实现UI进度更新)，最后反馈执行的结果给UI主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask通过一个阻塞队列BlockingQuery&lt;Runnable&gt;存储待执行的任务，利用静态线程池THREAD_POOL_EXECUTOR提供一定数量的线程，默认128个。</span></span></li><li><span class="name"><span class="innerContentContainer">默认采用串行任务执行器，循环取出任务交给THREAD_POOL_EXECUTOR中的线程执行，执行完一个，再执行下一个。</span></span></li><li><span class="name"><span class="innerContentContainer">不要手动调用onPreExecute()，doInBackground(Params... params)，onProgressUpdate(Progress... values)，onPostExecute(Result result)这几个方法。</span></span></li><li><span class="name"><span class="innerContentContainer">例子: </span></span></li><li><span class="name"><span class="innerContentContainer">// <b>自定义AsyncTask</b></span></span></li><li><span class="name"><span class="innerContentContainer">public class MyAsyncTask extends AsyncTask&lt;Integer,Integer,String&gt; {</span></span><ul><li><span class="name"><span class="innerContentContainer">private TextView txt;</span></span></li><li><span class="name"><span class="innerContentContainer">private ProgressBar pgbar;</span></span></li><li><span class="name"><span class="innerContentContainer">public MyAsyncTask(TextView txt,ProgressBar pgbar) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super();</span></span></li><li><span class="name"><span class="innerContentContainer">this.txt = txt;</span></span></li><li><span class="name"><span class="innerContentContainer">this.pgbar = pgbar;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在调用耗时操作前被调用, 常用于初始化, 比如进度条的显示. 该方法运行在UI线程.</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onPreExecute</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">txt.setText("开始执行异步线程");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在onPreExecute<b>()执行后马上执行. </b>该方法不运行在UI线程,主要用于异步操作.</span></span></li><li><span class="name"><span class="innerContentContainer">// 可调用 publishProgress()方法实时更新进度, 或者更新UI.</span></span></li><li><span class="name"><span class="innerContentContainer">protected String <b>doInBackground</b>(Integer... params) {</span></span><ul><li><span class="name"><span class="innerContentContainer">DelayOperator dop = new DelayOperator();</span></span></li><li><span class="name"><span class="innerContentContainer">int i = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">for (i = 10;i &lt;= 100;i+=10) {</span></span><ul><li><span class="name"><span class="innerContentContainer">dop.delay();</span></span></li><li><span class="name"><span class="innerContentContainer"><b>publishProgress</b>(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return  i + params[0].intValue() + "";</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在doBackground方法中,每次调用publishProgress方法都会触发该方法</span></span></li><li><span class="name"><span class="innerContentContainer">// 运行在UI线程中,可对UI控件进行操作</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onProgressUpdate</b>(Integer... values) {</span></span><ul><li><span class="name"><span class="innerContentContainer">int value = values[0];</span></span></li><li><span class="name"><span class="innerContentContainer">pgbar.setProgress(value);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 在<b>doInBackground()执行完后, 该方法会被UI线程调用. 后台的处理结果将通过该方法传递给UI线程.</b></span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onPostExecute</b>(String result) {</span></span><ul><li><span class="name"><span class="innerContentContainer">txt.setText("异步线程执行完毕");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 用于在取消执行中的任务时更改UI</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onCancelled</b>() {</span></span><ul><li><span class="name"><span class="innerContentContainer">txt.setText("异步线程被终止");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// MainActivity.java</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyActivity extends ActionBarActivity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private TextView txttitle;</span></span></li><li><span class="name"><span class="innerContentContainer">private ProgressBar pgbar;</span></span></li><li><span class="name"><span class="innerContentContainer">private Button btnupdate;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">txttitle = (TextView)findViewById(R.id.txttitle);</span></span></li><li><span class="name"><span class="innerContentContainer">pgbar = (ProgressBar)findViewById(R.id.pgbar);</span></span></li><li><span class="name"><span class="innerContentContainer">btnupdate = (Button)findViewById(R.id.btnupdate);</span></span></li><li><span class="name"><span class="innerContentContainer">btnupdate.setOnClickListener(new View.OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">MyAsyncTask myTask = new MyAsyncTask(txttitle,pgbar);</span></span></li><li><span class="name"><span class="innerContentContainer">myTask.execute(1000);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask的使用注意事项：</span></span><ul><li><span class="name"><span class="innerContentContainer">AsyncTask的类必须在主线程中加载，这一点已经在Android4.1以上版本上自动完成</span></span></li><li><span class="name"><span class="innerContentContainer">AsyncTask 对象必须在主线程中创建</span></span></li><li><span class="name"><span class="innerContentContainer">execute方法必须在主线程中调用</span></span></li><li><span class="name"><span class="innerContentContainer">一个AsyncTask对象只能执行一次，否则会运行报错。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优缺点:</span></span><ul><li><span class="name"><span class="innerContentContainer">处理单个异步任务时代码简单，而且能获取到异步任务的进度.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过cancel方法取消还没执行完的AsyncTask.</span></span></li><li><span class="name"><span class="innerContentContainer">处理多个异步任务代码显得较多.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适用范围: 单个异步任务的处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>5. ThreadPoolExecutor: 线程池</b></span></span><ul><li><span class="name"><span class="innerContentContainer">ThreadPoolExecutor提供了一组线程池，可以管理多个线程并行执行。比较适合一组任务的执行。</span></span></li><li><span class="name"><span class="innerContentContainer">优势: </span></span><ul><li><span class="name"><span class="innerContentContainer">避免频繁地创建和销毁线程，达到线程对象的重用。</span></span></li><li><span class="name"><span class="innerContentContainer">使用线程池还可以根据项目灵活地控制并发的数目。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Executors利用工厂模式对ThreadPoolExecutor进行了封装，使用起来更加方便。</span></span><ul><li><span class="name"><span class="innerContentContainer">有4种工厂: </span></span><ul><li><span class="name"><span class="innerContentContainer">Executors.newFixedThreadPool():  创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化。</span></span></li><li><span class="name"><span class="innerContentContainer">Executors.newCachedThreadPool():  创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制.</span></span></li><li><span class="name"><span class="innerContentContainer">Executors.newScheduledThreadPool(): 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer.</span></span></li><li><span class="name"><span class="innerContentContainer">Executors.newSingleThreadExecutor(): 创建一个单线程化的executor，它只创建唯一的worker线程来执行任务.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">newSingleThreadScheduledExecutor(): 创建一个延迟执行的单线程线程池</span></span></li><li><span class="name"><span class="innerContentContainer">newWorkingStealingPool(int parallelism): 创建持有足够的线程的线程池来支持给定的并行级别，以充分支持多CPU并行能力。</span></span></li><li><span class="name"><span class="innerContentContainer">newWorkingStealingPool(): 根据CPU个数设置并行级别。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用线程池的步骤</span></span><ul><li><span class="name"><span class="innerContentContainer">调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。</span></span></li><li><span class="name"><span class="innerContentContainer">创建Runnable实现类或者Callable实现类的实例，作为线程的执行任务。</span></span></li><li><span class="name"><span class="innerContentContainer">调用ExecutorService对象的 submit() 来提交 Runnable 或者 Callable 实例。</span></span></li><li><span class="name"><span class="innerContentContainer">当没有任务时，使用shutdown()方法来关闭线程池。</span></span></li><li><span class="name"><span class="innerContentContainer">public class TestTreadPool{</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void main(String[] args)</span></span></li><li><span class="name"><span class="innerContentContainer">throws Exception{</span></span><ul><li><span class="name"><span class="innerContentContainer">ExecutorService pool = Executors.newFixedThreadPool(6);</span></span></li><li><span class="name"><span class="innerContentContainer">Runnable target = ()-&gt;{</span></span><ul><li><span class="name"><span class="innerContentContainer">for(int i=0;i&lt;100;i++) {</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println(Thread.currentThread().getName()</span></span><ul><li><span class="name"><span class="innerContentContainer">+ "的i值为："+ i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">// 向线程池中提交两个线程</span></span></li><li><span class="name"><span class="innerContentContainer">pool.submit(target);</span></span></li><li><span class="name"><span class="innerContentContainer">pool.submit(target);</span></span></li><li><span class="name"><span class="innerContentContainer">pool.shutdown();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适用范围: 批处理任务</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>6. </b>IntentService</span></span><ul><li><span class="name"><span class="innerContentContainer">IntentService继承自Service，是一个经过包装的轻量级的Service，用来接收并处理通过Intent传递的异步请求。客户端通过调用 startService(Intent) 启动一个IntentService，利用一个work线程依次处理顺序过来的请求，处理完成后自动结束Service。</span></span></li><li><span class="name"><span class="innerContentContainer">优缺点: 它是Service，比起其他线程来说具有更高的优先级，不容易被系统杀死，而能够保证任务的执行。</span></span></li><li><span class="name"><span class="innerContentContainer">特点: IntentService的优先级比单纯线程要高，所以适合执行一些高优先级的后台任务。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>线程安全和锁</b> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">当有一个线程在对临界资源(内存, 代码块等)进行操作时，其他线程都不可以对这个临界资源进行操作，直到该线程完成操作。</span></span></li><li><span class="name"><span class="innerContentContainer">线程安全有几个级别:</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 可变. 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 绝对线程安全. 不管运行时环境如何，调用者都不需要额外的同步措施。</span></span><ul><li><span class="name"><span class="innerContentContainer">要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">不过绝对线程安全的类也有，比如说 CopyOnWriteArrayList、CopyOnWriteArraySet。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 相对线程安全. </span></span><ul><li><span class="name"><span class="innerContentContainer">相对线程安全也就是我们通常意义上所说的线程安全。</span></span></li><li><span class="name"><span class="innerContentContainer">像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此。</span></span></li><li><span class="name"><span class="innerContentContainer">如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是 fail-fast 机制。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. 线程非安全. ArrayList、LinkedList、HashMap等都是线程非安全的类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本上所有的并发模式在解决线程安全问题的问题上，都采用“序列化访问临界资源”的方案，即在同一时刻只能有一个线程访问临界资源（多个线程可能同时访问的数据或资源），也称同步互斥访问。</span></span></li><li><span class="name"><span class="innerContentContainer">线程安全是以牺牲程序运行效率为代价的，因此在注意线程安全的同时，也要注意不要滥用锁和同步方法，尽量只对那些会改变竞争资源的方法进行同步。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>偏向锁/轻量级锁/重量级锁   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">偏向锁（Biased Lock ）: 几乎无竞争的条件下使用.</span></span><ul><li><span class="name"><span class="innerContentContainer">偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。这是最常见的情况. 因此偏向锁是 <b>Synchronized 的默认状态.</b></span></span></li><li><span class="name"><span class="innerContentContainer">偏向锁是通过对象头实现。</span></span><ul><li><span class="name"><span class="innerContentContainer">对象头指Java对象的头信息, 每个对象都有, 占2个字长. </span></span></li><li><span class="name"><span class="innerContentContainer">第一个字叫Mark Word, 可唯一表示一个对象, 因此可用于做锁.</span></span></li><li><span class="name"><span class="innerContentContainer">第二个字保存类元信息（class metadata）的指针.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">偏向锁的获取方式是将对象头的&nbsp;MarkWord&nbsp;部分中， 标记上线程ID， 以表示哪一个线程获得了偏向锁。</span></span></li><li><span class="name"><span class="innerContentContainer">当同一个线程反复获取同步块时, 不再需要进行加锁和解锁的操作, 效率非常高. </span></span></li><li><span class="name"><span class="innerContentContainer">这也就要求, 当线程退出同步块时, 并不修改对象头的&nbsp;MarkWord&nbsp;字段. 只有在其它线程也访问同步块时再改.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">轻量级锁（ Lightweight Lock）: 轻度竞争的条件下使用.</span></span><ul><li><span class="name"><span class="innerContentContainer">在偏向锁的获取过程中， 发现有竞争时，会直接把所升级到轻量级锁上. </span></span></li><li><span class="name"><span class="innerContentContainer">其他线程会通过<b>自旋</b>的形式尝试获取锁，不会阻塞，提高性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重量级锁（Heavyweight Lock）: 重度竞争的情况下使用.</span></span><ul><li><span class="name"><span class="innerContentContainer">重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁升级为重量级锁。</span></span></li><li><span class="name"><span class="innerContentContainer">重量级锁会让他申请的线程进入<b>阻塞</b>，性能降低。</span></span></li><li><span class="name"><span class="innerContentContainer">重量级锁依赖于操作系统的互斥量（mutex） 实现，切换到重量级锁开销较大.</span></span></li><li><span class="name"><span class="innerContentContainer">重量级锁是通过对象的Monitor实现，monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>独享锁(互斥锁) / 共享锁(读写锁) <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">独享锁是指该锁一次只能被一个线程所持有. 也叫互斥锁.</span></span></li><li><span class="name"><span class="innerContentContainer">共享锁是指该锁可被多个线程所持有。也叫读写锁.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Synchronized</b> 是独享锁。</span></span></li><li><span class="name"><span class="innerContentContainer">而 Java的 <b>ReentrantLock</b> 是独享锁。</span></span></li><li><span class="name"><span class="innerContentContainer">对于Lock的另一个实现类 <b>ReadWriteLock</b>，其读锁是共享锁，其写锁是独享锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">读锁的共享锁可保证并发读是非常高效的.</span></span></li><li><span class="name"><span class="innerContentContainer">写锁是独享锁, 保证读写，写读，写写的过程是互斥的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>乐观锁 / 悲观锁</span></span><ul><li><span class="name"><span class="innerContentContainer">乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。</span></span></li><li><span class="name"><span class="innerContentContainer">悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语 <b>Synchronized </b>关键字的实现就是悲观锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>公平锁 / 非公平锁</span></span><ul><li><span class="name"><span class="innerContentContainer">公平锁是指多个线程按照申请锁的顺序来获取锁。</span></span></li><li><span class="name"><span class="innerContentContainer">非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</span></span></li><li><span class="name"><span class="innerContentContainer">非公平锁的优点在于吞吐量比公平锁大。</span></span></li><li><span class="name"><span class="innerContentContainer">Java <b>ReetrantLock</b>，可通过构造函数指定该锁是否是公平锁，默认是非公平锁。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Synchronized </b>也是一种非公平锁。由于其并不像 ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>可重入锁</span></span><ul><li><span class="name"><span class="innerContentContainer">可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。可重入锁的一个好处是可一定程度避免死锁。</span></span></li><li><span class="name"><span class="innerContentContainer">对于Java <b>ReetrantLock</b>而言，从名字就可以看出是一个重入锁。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Synchronized</b> 也是一个可重入锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>分段锁</span></span><ul><li><span class="name"><span class="innerContentContainer">分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</span></span></li><li><span class="name"><span class="innerContentContainer">我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</span></span></li><li><span class="name"><span class="innerContentContainer">当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</span></span></li><li><span class="name"><span class="innerContentContainer">但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</span></span></li><li><span class="name"><span class="innerContentContainer">分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>锁的种类: </b>自旋锁</span></span><ul><li><span class="name"><span class="innerContentContainer">在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用轮询的方式去尝试获取锁.</span></span></li><li><span class="name"><span class="innerContentContainer">这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</span></span></li><li><span class="name"><span class="innerContentContainer">自旋锁适用于能很快取到锁的场景下. 这是较常见的情况.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>加锁的方法</b> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>synchronized&nbsp;</b>关键字，修饰代码块. 保证同时刻只有一个线程进入该方法或者代码块. </span></span><ul><li><span class="name"><span class="innerContentContainer">这种最方便, 但是对性能影响也最高. 所以不能到处加 <b>synchronized</b>.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>原理: synchronized是从偏向锁开始，根据需要逐步升级到轻量级锁, 最后达到重量级锁.</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>synchronized </b>有两种形式: </span></span></li><li><span class="name"><span class="innerContentContainer">第一种是作为前缀定义函数.</span></span><ul><li><span class="name"><span class="innerContentContainer">int count = 100;</span></span></li><li><span class="name"><span class="innerContentContainer">private <b>synchronized </b>void count() {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (count &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">isRunning = false;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二种是定义代码块.</span></span><ul><li><span class="name"><span class="innerContentContainer">private void count() {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>synchronized </b>(this) {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (count &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">isRunning = false;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">volatile 关键字, 修饰变量</span></span><ul><li><span class="name"><span class="innerContentContainer">用volatile来定义变量，可以保证此变量对所有线程的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">它告诉虚拟机该变量随时可能更新，因此使用时每次都会重新计算，而不是使用寄存器的值。当一条线程修改了这个值，新值对于其他所有线程来说是立即得知的。</span></span></li><li><span class="name"><span class="innerContentContainer">volatile会降低性能。</span></span></li><li><span class="name"><span class="innerContentContainer">Volatile修饰的变量只能保证可见性, 不一定是线程安全的，比如 ii++。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重入锁Lock类(ReentrantLock), 实现线程同步</span></span><ul><li><span class="name"><span class="innerContentContainer">ReentrantLock 是 java.util.concurrent.Lock的实现类. </span></span></li><li><span class="name"><span class="innerContentContainer">提供了如下接口:</span></span><ul><li><span class="name"><span class="innerContentContainer">lock(): 获得锁</span></span></li><li><span class="name"><span class="innerContentContainer">unlock(): 释放锁</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:  </span></span></li><li><span class="name"><span class="innerContentContainer">private void count() {</span></span><ul><li><span class="name"><span class="innerContentContainer">private final ReentrantLock lock = new ReentrantLock();  // 创建可重入锁</span></span></li><li><span class="name"><span class="innerContentContainer">lock.lock();</span></span></li><li><span class="name"><span class="innerContentContainer">if (count &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.e(TAG, Thread.currentThread().getName() + "---&gt;" + count--);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">isRunning = false;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">lock.unlock();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ThreadLocal, 管理变量</span></span><ul><li><span class="name"><span class="innerContentContainer">如果一个变量使用ThreadLocal进行管理，每一个使用该变量的线程都会获得该变量的副本，副本之间相互独立，所以每个线程都可以修改变量而不会对其它线程造成影响。</span></span></li><li><span class="name"><span class="innerContentContainer">数据不共享，自然就没有线程安全问题了.</span></span></li><li><span class="name"><span class="innerContentContainer">private static ThreadLocal&lt;Integer&gt; number = new ThreadLocal&lt;Integer&gt;(){</span></span><ul><li><span class="name"><span class="innerContentContainer">// 重写方法，设置默认值</span></span></li><li><span class="name"><span class="innerContentContainer">protected Integer initialValue() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return 1;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 自定义方法设置变量值</span></span></li><li><span class="name"><span class="innerContentContainer">public void saveNumber(int newNumber){</span></span><ul><li><span class="name"><span class="innerContentContainer">number.set(number.get() + newNumber);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 自定义方法获取变量值</span></span></li><li><span class="name"><span class="innerContentContainer">public int getNumber(){</span></span><ul><li><span class="name"><span class="innerContentContainer">return number.get();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Semaphore, 信号量</span></span><ul><li><span class="name"><span class="innerContentContainer">信号量维护了一个计数器. 如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</span></span></li><li><span class="name"><span class="innerContentContainer">Semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">死锁问题</span></span><ul><li><span class="name"><span class="innerContentContainer">产生死锁的四个必要条件： <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">互斥条件：一个资源每次只能被一个进程使用。</span></span></li><li><span class="name"><span class="innerContentContainer">请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span></span></li><li><span class="name"><span class="innerContentContainer">不剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。</span></span></li><li><span class="name"><span class="innerContentContainer">循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">目前处理死锁的方法可归结为4种 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">预防死锁：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</span></span></li><li><span class="name"><span class="innerContentContainer">避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</span></span></li><li><span class="name"><span class="innerContentContainer">检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。</span></span></li><li><span class="name"><span class="innerContentContainer">解除死锁：这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Java中如何获取到线程dump文件?</span></span><ul><li><span class="name"><span class="innerContentContainer">死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</span></span></li><li><span class="name"><span class="innerContentContainer">（1）获取到线程的pid，可以通过使用 jps 命令，在Linux环境下还可以使用 ps -ef | grep java</span></span></li><li><span class="name"><span class="innerContentContainer">（2）打印线程堆栈，可以通过使用 jstack pid命令，在Linux环境下还可以使用kill -3 pid</span></span></li><li><span class="name"><span class="innerContentContainer">另外提一点，Thread类提供了一个 getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">生产者消费者模型的作用是什么?</span></span><ul><li><span class="name"><span class="innerContentContainer">通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。</span></span></li><li><span class="name"><span class="innerContentContainer">解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。</span></span></li></ul></li></ul>
  </body>
</html>