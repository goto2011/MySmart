<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">12-Service</span><ul><li><span class="name">Service 启动后会常驻内存, 不顺定义的app的退出而退出. 而且如果挂了, 系统会自动重新启动.</span></li><li><span class="name">Service不是一个单独的进程,它和它的应用程序在同一个进程中. 我们应该避免在Service中进行耗时操作. </span></li><li><span class="name"><b>Service生命周期. 非常重要.</b></span><ul><li><span class="name">分两种:</span></li><li><span class="name">非绑定service, 用 startService() 启动的service.</span><ul><li><span class="name">onCreate: 当客户端第一次调用 startService()被调, 在整个生命周期中只会调用一次.</span></li><li><span class="name"><b>onStartCommand </b>/ onStart: <b>当客户端每次调用 startService()时会回调.</b> 一个客户端可多次调用StartService(), 多个客户端分别调用StartService(), 也不会有负面影响.  onStart() 和 onStartCommand()的关系见后.</span></li><li><span class="name">onDestory: 当Service被销毁时会回调，只会回调一次.</span></li><li><span class="name">非绑定service, Service的生命周期与它的客户端的生命周期无绑定关系. 当客户端结束自己的生命周期时, 只要不调用 stopService(), 那么Service还会继续运行.</span></li></ul></li><li><span class="name">绑定service, 用 bindService() 启动的service.</span><ul><li><span class="name">onCreate: 同上.</span></li><li><span class="name"><b>onBind</b>: 该方法是Service都必须实现的方法，该方法会返回一个 IBinder对象，app通过该对象与Service组件进行通信.</span></li><li><span class="name"><b>onUnbind</b>: 当该Service上绑定的所有客户端都断开时会回调该方法.</span></li><li><span class="name">onDestory: 同上.</span></li><li><span class="name">当首次使用 bindService()绑定一个Service时, 默认情况下, 系统会实例化一个Service实例,并调用其onCreate()和onBind()方法, 然后客户端就可以通过IBinder和Service进行交互了.</span></li><li><span class="name">此后如果再次使用bindService()绑定Service,系统不会创建新的Sevice实例,也不会再调用onBind()方法,只会直接把IBinder对象传递给后来的客户端.</span></li><li><span class="name">如果我们解除与服务的绑定,只需调用 unbindService(), 此时 onUnbind()会被调用. 如果只有这一个客户端, 则接着 onDestory()方法也会被调用. 如果是多个客户端, 只有最后一个客户端都调用了 unbindService(),  onDestory()才会被调用.  --按逻辑行事.</span></li><li><span class="name"><b>bindService模式下, Service是与客户端是绑定关系. 在bindService后, 如果客户端在onUnbind()前异常退出, 那么Service也会被终止.</b></span></li></ul></li><li><span class="name">onStartCommand 和 onStart的关系: 后者不建议使用. 如果使用, 则相当于重写了 onStartCommand, 而且返回值是 START_STICKY.</span></li><li><span class="name"><b>onStartCommand </b>返回值. 非常重要.</span><ul><li><span class="name">START_STICKY: 系统在调用完onStartCommand()方法后，如果当前服务被终止了，系统会使该服务保持在启动状态，不过它不会保留之前传递的Intent对象。但是由于它保持启动状态，随后系统会尝试重新创建service，但之前的Intent对象没有被保存。在这个情况下，如果期间没有任何启动命令被传递到Service，那么参数Intent将为null。因此使用START_STICKY作为返回值，适用于不执行命令的媒体播放器（或类似的服务），它只是无限期的运行着并等待工作的到来.</span></li><li><span class="name">START_NOT_STICKY: 系统在调用完onStartCommand方法后，如果当前服务被终止了并且在此期间没有任何启动命令被传递到Service，那么系统将是使当前服务退出启动状态，并且除非重新调用Context.startService(Intent)，否则不会重新被创建（即不会重新调用onCreate方法）。因为当前服务退出了启动状态，所以除非在此期间启动命令被传递到Service，否则也不会调用。这是最安全的选项，用来避免在不需要的时候运行你的服务。</span></li><li><span class="name">START_REDELIVER_INTENT: 如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。并且在在该服务调用stopSelf方法之前，能够一直保留intent对象数据。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。</span></li><li><span class="name">START_STICKY_COMPATIBILITY: START_STICKY的兼容版本，但不保证服务被终止后一定能重启。被异常kill后, 服务虽然被重建，但没有重启.</span></li></ul></li><li><span class="name">无论启动了多少次Service,只需调用一次StopService即可停掉Service. </span></li><li><span class="name"><b>bindService() </b>的函数原型:</span><ul><li><span class="name">bindService(Intent Service, ServiceConnection conn, int flags); 其中参数是: </span></li><li><span class="name">service: 通过该intent指定要启动的Service.</span></li><li><span class="name">conn: ServiceConnection对象,用户监听访问者与Service间的连接情况.</span><ul><li><span class="name">连接成功回调该对象中的onServiceConnected(ComponentName,IBinder)方法; </span></li><li><span class="name">如果Service所在的宿主由于异常终止或者其他原因终止,导致Service与访问者间断开 连接时调用onServiceDisconnected(CompanentName)方法.</span></li><li><span class="name">客户端主动调用unBindService()&nbsp;方法断开, 不会收到 onServiceDisconnected()回调.</span></li></ul></li><li><span class="name">flags: 指定绑定时是否自动创建Service(如果Service还未创建), 参数值域是: </span><ul><li><span class="name">0(不自动创建).</span></li><li><span class="name">BIND_AUTO_CREATE(自动创建). 默认值.</span></li></ul></li></ul></li><li><span class="name">StartService启动Service后, 再bindService绑定的情况 (TM真复杂)</span><ul><li><span class="name">如果Service已经由某个客户端通过 StartService()启动,接下来其他客户端再调用bindService() 绑定到该Service后, 再调用 unbindService()解除绑定, 最后再调用bindService() 绑定到 Service的话, 此时所触发的生命周期方法如下:</span></li><li><span class="name">onCreate() -&gt; onStartCommand() -&gt; onBind() -&gt; onUnbind() -&gt; onRebind()</span></li><li><span class="name"><b>注意:  如果你需要在有新客户端连接上时获得onRebind()回调, 则必须在onUnbind()中返回true. 返回false 则收不到. Android就是这么约定的. </b></span></li><li><span class="name">这里或许部分读者有疑惑了,调用了unbindService后Service不是应该调用 onDistory()方法么?</span></li><li><span class="name">其实这是因为这个Service是由我们的StartService来启动的 ,所以你调用onUnbind()方法取消绑定,Service也是不会终止的.</span></li><li><span class="name">得出的结论:&nbsp;假如我们使用bindService来绑定一个启动的Service,注意是已经启动的Service. 系统只是将Service的内部IBinder对象传递给Activity,并不会将Service的生命周期与此Activity绑定,因此调用unBindService( )方法取消绑定时, Service也不会被销毁！</span></li></ul></li></ul></li><li><span class="name">Service例子:</span><ul><li><span class="name">public class TestService2 extends Service {</span><ul><li><span class="name">private final String TAG = "TestService2";</span></li><li><span class="name">private int count;</span></li><li><span class="name">private boolean quit;</span></li><li><span class="name">// 定义onBinder方法所返回的对象</span></li><li><span class="name">private MyBinder binder = new MyBinder();</span></li><li><span class="name">public class MyBinder extends Binder {</span><ul><li><span class="name">public int getCount() {</span><ul><li><span class="name">return count;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//必须实现的方法,绑定改Service时回调该方法</span></li><li><span class="name">public IBinder onBind(Intent intent) {</span><ul><li><span class="name">Log.i(TAG, "onBind方法被调用!");</span></li><li><span class="name">return binder;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//Service被创建时回调</span></li><li><span class="name">public void onCreate() {</span><ul><li><span class="name">super.onCreate();</span></li><li><span class="name">Log.i(TAG, "onCreate方法被调用!");</span></li><li><span class="name">//创建一个线程动态地修改count的值</span></li><li><span class="name">new Thread() {</span><ul><li><span class="name">public void run() {</span><ul><li><span class="name">while(!quit) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">Thread.sleep(1000);</span></li></ul></li><li><span class="name">} catch(InterruptedException e) { e.printStackTrace(); }</span></li><li><span class="name">count++;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li></ul></li><li><span class="name">}.start();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//Service断开连接时回调</span></li><li><span class="name">public boolean onUnbind(Intent intent) {</span><ul><li><span class="name">Log.i(TAG, "onUnbind方法被调用!");</span></li><li><span class="name">return true;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//Service被关闭前回调</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onDestroy() {</span><ul><li><span class="name">super.onDestroy();</span></li><li><span class="name">this.quit = true;</span></li><li><span class="name">Log.i(TAG, "onDestroyed方法被调用!");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onRebind(Intent intent) {</span><ul><li><span class="name">Log.i(TAG, "onRebind方法被调用!");</span></li><li><span class="name">super.onRebind(intent);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"></span></li><li><span class="name">// 在AndroidManifest.xml中对Service组件进行注册</span></li><li><span class="name">&lt;service android:name=".TestService2" android:exported="false"&gt;</span><ul><li><span class="name">&lt;intent-filter&gt;</span><ul><li><span class="name">&lt;action android:name="com.jay.example.service.TEST_SERVICE2"/&gt;</span></li></ul></li><li><span class="name">&lt;/intent-filter&gt;</span></li></ul></li><li><span class="name">&lt;/service&gt;</span></li><li><span class="name"></span></li><li><span class="name">// 在 MainActivity.java 中使用service.</span></li><li><span class="name">public class MainActivity extends Activity {</span><ul><li><span class="name">TestService2.MyBinder <b>binder</b>;</span></li><li><span class="name">// 定义ServiceConnection对象</span></li><li><span class="name">private <b>ServiceConnection conn </b>= new ServiceConnection() {</span><ul><li><span class="name">// Activity与Service断开连接时回调该方法</span></li><li><span class="name">public void onServiceDisconnected(ComponentName name) {</span><ul><li><span class="name">System.out.println("------Service DisConnected-------");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// Activity与Service连接成功时回调该方法</span></li><li><span class="name">public void onServiceConnected(ComponentName name, IBinder service) {</span><ul><li><span class="name">System.out.println("------Service Connected-------");</span></li><li><span class="name">binder = (TestService2.MyBinder) service;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">};</span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">final Intent <b>intent </b>= new Intent();</span></li><li><span class="name">intent.setAction("com.jay.example.service.TEST_SERVICE2");</span></li><li><span class="name">// btnbind 和 btncancel <b>是两个 </b>Button, 不重要.</span></li><li><span class="name">btnbind.<b>setOnClickListener</b>(new OnClickListener() {</span><ul><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name"><b>bindService</b>(<b>intent</b>, <b>conn</b>, Service.BIND_AUTO_CREATE);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li><li><span class="name">btncancel.setOnClickListener(new OnClickListener() {</span><ul><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name"><b>unbindService</b>(conn);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">IntentService: 耗时操作放在这里</span><ul><li><span class="name">IntentService是继承与Service并处理异步请求的一个类. 在 IntentService中有一个工作线程来处理耗时操作,请求的Intent记录会加入队列.</span></li><li><span class="name">客户端通过 startService(Intent)来启动IntentService.</span></li><li><span class="name">可以启动 IntentService 多次, 每个操作以工作队列的方式在 IntentService的 onHandleIntent回调方法中执行,并且每次只会执行一个工作线程.</span></li><li><span class="name">并不需要手动地区控制  IntentService, 当任务执行完后会自动停止.</span></li><li><span class="name">当一个后台的任务需要分成几个子任务, 再按先后顺序执行子任务 (简单的说就是异步操作). 此时如果我们还是定义一个普通Service, 然后在onStart方法中开辟线程, 然后又要去控制线程, 这样显得非常的繁琐; 此时就应该自定义一个 IntentService, 然后在 onHandleIntent() 方法中完成相关任务. </span></li><li><span class="name">例子:</span></li><li><span class="name">// IntentService 就是 Service.</span></li><li><span class="name">public class TestService3 extends IntentService {</span><ul><li><span class="name">private final String TAG = "hehe";</span></li><li><span class="name">public TestService3() {</span><ul><li><span class="name">super("TestService3");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// onHandleIntent是核心方法, 重视.</span></li><li><span class="name">protected void <b>onHandleIntent</b>(Intent intent) {</span><ul><li><span class="name">// Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务</span></li><li><span class="name">String action = intent.getExtras().getString("param");</span></li><li><span class="name">if(action.equals("s1")) { Log.i(TAG,"启动service1"); }</span></li><li><span class="name">else if(action.equals("s2")) { Log.i(TAG,"启动service2"); }</span></li><li><span class="name">else if(action.equals("s3")) { Log.i(TAG,"启动service3"); }</span></li><li><span class="name">// 让服务休眠2秒</span></li><li><span class="name">try { </span><ul><li><span class="name">Thread.sleep(2000);</span></li></ul></li><li><span class="name">} catch (InterruptedException e) { e.printStackTrace(); }</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public IBinder onBind(Intent intent) {</span><ul><li><span class="name">Log.i(TAG,"onBind");</span></li><li><span class="name">return super.onBind(intent);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public void onCreate() {</span><ul><li><span class="name">Log.i(TAG,"onCreate");</span></li><li><span class="name">super.onCreate();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public int onStartCommand(Intent intent, int flags, int startId) {</span><ul><li><span class="name">Log.i(TAG,"onStartCommand");</span></li><li><span class="name">return super.onStartCommand(intent, flags, startId);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public void setIntentRedelivery(boolean enabled) {</span><ul><li><span class="name">super.setIntentRedelivery(enabled);</span></li><li><span class="name">Log.i(TAG,"setIntentRedelivery");</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public void onDestroy() {</span><ul><li><span class="name">Log.i(TAG,"onDestroy");</span></li><li><span class="name">super.onDestroy();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// AndroidManifest.xml注册下Service</span></li><li><span class="name">&lt;service android:name=".TestService3" android:exported="false"&gt;</span><ul><li><span class="name">&lt;intent-filter &gt;</span><ul><li><span class="name">&lt;action android:name="com.test.intentservice"/&gt;</span></li></ul></li><li><span class="name">&lt;/intent-filter&gt;</span></li></ul></li><li><span class="name">&lt;/service&gt;</span></li><li><span class="name">// 在MainActivity启动三次服务</span></li><li><span class="name">public class MainActivity extends Activity {</span><ul><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">Intent it1 = new Intent("com.test.intentservice");</span></li><li><span class="name">Bundle b1 = new Bundle();</span></li><li><span class="name">b1.putString("param", "s1");</span></li><li><span class="name">it1.putExtras(b1);</span></li><li><span class="name">Intent it2 = new Intent("com.test.intentservice");</span></li><li><span class="name">Bundle b2 = new Bundle();</span></li><li><span class="name">b2.putString("param", "s2");</span></li><li><span class="name">it2.putExtras(b2);</span></li><li><span class="name">Intent it3 = new Intent("com.test.intentservice");</span></li><li><span class="name">Bundle b3 = new Bundle();</span></li><li><span class="name">b3.putString("param", "s3");</span></li><li><span class="name">it3.putExtras(b3);</span></li><li><span class="name">// 接着启动多次IntentService,每次启动,都会新建一个工作线程. 但始终只有一个IntentService实例</span></li><li><span class="name">startService(it1);</span></li><li><span class="name">startService(it2);</span></li><li><span class="name">startService(it3);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">Activity与Service通信</span><ul><li><span class="name">假如我们启动的是一个下载的后台Service，而我们想知道Service中下载任务的进度. 这涉及 Service 与Activity进行通信. 其基本流程如下：</span></li><li><span class="name">在Service中自定义一个 Binder类，然后将需要暴露的方法写到该类中.</span></li><li><span class="name">Service类中，实例化这个自定义 Binder类，然后重写 onBind()方法，将这个Binder对象返回.</span></li><li><span class="name">Activity类中实例化一个 ServiceConnection对象，重写 onServiceConnected()方法，然后获取Binder对象，然后调用相关方法即可.</span></li></ul></li><li><span class="name">前台服务</span><ul><li><span class="name">Service默认是后台服务. 后台服务的缺点是优先级较低, 当内存不足时会优先回收后台服务. 方法是:</span></li><li><span class="name">在自定义的Service类中，重写onCreate()，然后根据自己的需求定制Notification； 定制完毕后，调用 startForeground(1,notification对象)即可.</span></li><li><span class="name">public void onCreate() {</span><ul><li><span class="name">super.onCreate();</span></li><li><span class="name">Notification.Builder localBuilder = new Notification.Builder(this);</span></li><li><span class="name">localBuilder.setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0));</span></li><li><span class="name">localBuilder.setAutoCancel(false);</span></li><li><span class="name">localBuilder.setSmallIcon(R.mipmap.ic_cow_icon);</span></li><li><span class="name">localBuilder.setTicker("Foreground Service Start");</span></li><li><span class="name">localBuilder.setContentTitle("Socket服务端");</span></li><li><span class="name">localBuilder.setContentText("正在运行...");</span></li><li><span class="name">startForeground(1, localBuilder.getNotification());</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">定时后台线程</span><ul><li><span class="name">Android中给我们提供的定时方式有两种: Timer类 与 Alarm机制.</span></li><li><span class="name">前者不适合于需要长期在后台运行的定时任务，CPU一旦休眠，Timer中的定时任务就无法运行.</span></li><li><span class="name">Alarm则不存在这种情况，具有唤醒CPU的功能. 另外，要区分CPU唤醒与屏幕唤醒.</span></li><li><span class="name">方法是:</span></li><li><span class="name">1, 获得Service:&nbsp;</span><ul><li><span class="name">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span></li></ul></li><li><span class="name">2, 通过set方法设置定时任务:</span><ul><li><span class="name">int anHour = 2 * 1000; </span></li><li><span class="name">long triggerAtTime = SystemClock.elapsedRealtime() + anHour; </span></li><li><span class="name">manager.<b>set</b>(AlarmManager.RTC_WAKEUP,triggerAtTime,pendingIntent);</span></li></ul></li><li><span class="name">3, 定义一个Service&nbsp;在onStartCommand中开辟一条事务线程,用于处理一些定时逻辑.</span></li><li><span class="name">4, 定义一个Broadcast(广播)，用于启动Service&nbsp;最后别忘了，在AndroidManifest.xml中对这Service与Boradcast进行注册.</span></li><li><span class="name">参数详解：&nbsp;<b>set</b>(int type,long startTime,PendingIntent pi);</span></li><li><span class="name"><b>type</b>的值域是:</span><ul><li><span class="name">ELAPSED_REALTIME:&nbsp;闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3;</span></li><li><span class="name">ELAPSED_REALTIME_WAKEUP&nbsp;闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；</span></li><li><span class="name">RTC&nbsp;闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；</span></li><li><span class="name">RTC_WAKEUP&nbsp;表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0;</span></li><li><span class="name">POWER_OFF_WAKEUP&nbsp;表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一， 该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</span></li></ul></li><li><span class="name"><b>startTime</b>: type决定startTime的含义.</span><ul><li><span class="name">如果是 ELAPSED_REALTIME 和 ELAPSED_REALTIME_WAKEUP, 就用: SystemClock.elapsedRealtime()方法可以获得系统开机到现在经历的毫秒数;</span></li><li><span class="name">如果是RTC、RTC_WAKEUP、POWER_OFF_WAKEUP的就用: System.currentTimeMillis() 可获得从1970.1.1 0点到现在做经历的毫秒数.</span></li></ul></li><li><span class="name"><b>PendingIntent</b>:&nbsp;绑定了闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent 是Intent的封装类。</span><ul><li><span class="name">如果是通过启动服务来实现闹钟提示的话， PendingIntent对象的获取就应该采用Pending.getService (Context c,int i,Intent intent,int j)方法；</span></li><li><span class="name">如果是通过广播来实现闹钟提示的话， PendingIntent对象的获取就应该采用 PendingIntent.getBroadcast (Context c,int i,Intent intent,int j)方法；</span></li><li><span class="name">如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取 就应该采用 PendingIntent.getActivity(Context c,int i,Intent intent,int j) 方法。</span></li></ul></li><li><span class="name">从4.4版本后(API 19),Alarm任务的触发时间可能变得不准确,有可能会延时,是系统 对于耗电性的优化,如果需要准确无误可以调用 setExtra()方法.</span></li><li><span class="name">例子:</span></li><li><span class="name">public class LongRunningService extends Service {</span><ul><li><span class="name">public IBinder onBind(Intent intent) {</span><ul><li><span class="name">return null;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public int onStartCommand(Intent intent, int flags, int startId) {</span><ul><li><span class="name">//这里开辟一条线程,用来执行具体的逻辑操作:</span></li><li><span class="name">new Thread(new Runnable() {</span><ul><li><span class="name">public void run() {</span><ul><li><span class="name">Log.d("BackService", new Date().toString());</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}).start();</span></li><li><span class="name">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span></li><li><span class="name">// 这里是定时的,这里设置的是每隔两秒打印一次时间=-=,自己改</span></li><li><span class="name">int anHour = 2 * 1000;</span></li><li><span class="name">long triggerAtTime = SystemClock.elapsedRealtime() + anHour;</span></li><li><span class="name">Intent i = new Intent(this,AlarmReceiver.class);</span></li><li><span class="name">PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0);</span></li><li><span class="name">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);</span></li><li><span class="name">return super.onStartCommand(intent, flags, startId);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public class AlarmReceiver extends BroadcastReceiver {</span><ul><li><span class="name">public void onReceive(Context context, Intent intent) {</span><ul><li><span class="name">Intent i = new Intent(context,LongRunningService.class);</span></li><li><span class="name">context.startService(i);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul>
  </body>
</html>