<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">12-Service</span></span><ul><li><span class="name"><span class="innerContentContainer">Service(服务)</span></span><ul><li><span class="name"><span class="innerContentContainer">是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。</span></span></li><li><span class="name"><span class="innerContentContainer">启动后会常驻内存。即使启动服务的组件（Activity）已销毁也不受影响。</span></span></li><li><span class="name"><span class="innerContentContainer">如果Service挂了, 系统会自动重新启动.</span></span></li><li><span class="name"><span class="innerContentContainer">Service不是一个单独的进程, 而是和所在应用程序在同一个进程中. 应避免在Service中进行耗时操作. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定义Service</span></span><ul><li><span class="name"><span class="innerContentContainer">Service都是通过继承Service基类自定义而来的。也都需要在AndroidManifest.xml中声明。</span></span></li><li><span class="name"><span class="innerContentContainer">Service在清单文件中的声明</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;service android:enabled=["true" | "false"]</span></span><ul><li><span class="name"><span class="innerContentContainer">android:exported=["true" | "false"]</span></span></li><li><span class="name"><span class="innerContentContainer">android:icon="drawable resource"</span></span></li><li><span class="name"><span class="innerContentContainer">android:isolatedProcess=["true" | "false"]</span></span></li><li><span class="name"><span class="innerContentContainer">android:label="string resource"</span></span></li><li><span class="name"><span class="innerContentContainer">android:name="string"</span></span></li><li><span class="name"><span class="innerContentContainer">android:permission="string"</span></span></li><li><span class="name"><span class="innerContentContainer">android:process="string" &gt;</span></span></li><li><span class="name"><span class="innerContentContainer">. . .</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/service&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span></li><li><span class="name"><span class="innerContentContainer">android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。</span></span></li><li><span class="name"><span class="innerContentContainer">android:permission：是权限声明</span></span></li><li><span class="name"><span class="innerContentContainer">android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思。</span></span></li><li><span class="name"><span class="innerContentContainer">前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">重写类的如下方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">onBind()。当使用方通过调用 bindService() 与服务绑定时被系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">onCreate()。首次创建服务时被系统调用。仅调用一次。</span></span></li><li><span class="name"><span class="innerContentContainer">onStartCommand()。当使用者通过调用 startService() 请求启动服务时被系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">onDestroy()。服务被销毁时被调用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Service的生命周期  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">非绑定service, 用 <b>startService</b>() 启动的service.</span></span><ul><li><span class="name"><span class="innerContentContainer">onCreate: 当客户端第一次调用 startService()被调, 在整个生命周期中只会调用一次.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onStartCommand </b>/ onStart: <b>当客户端每次调用 startService()时会回调.</b> 一个客户端可多次调用StartService(), 多个客户端分别调用StartService(), 也不会有负面影响.  onStart() 和 onStartCommand()的关系见后.</span></span></li><li><span class="name"><span class="innerContentContainer">onDestory: 当Service被销毁时会回调，只会回调一次.</span></span></li><li><span class="name"><span class="innerContentContainer">非绑定service, Service的生命周期与它的客户端的生命周期无绑定关系. 当客户端结束自己的生命周期时, 只要不调用 stopService(), 那么Service还会继续运行.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">绑定service, 用 <b>bindService</b>() 启动的service.</span></span><ul><li><span class="name"><span class="innerContentContainer">onCreate: 同上.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onBind</b>: 该方法是Service都必须实现的方法，该方法会返回一个 IBinder对象，app通过该对象与Service组件进行通信.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onUnbind</b>: 当该Service上绑定的所有客户端都断开时会回调该方法.</span></span></li><li><span class="name"><span class="innerContentContainer">onDestory: 同上.</span></span></li><li><span class="name"><span class="innerContentContainer">当首次使用 bindService()绑定一个Service时, 默认情况下, 系统会实例化一个Service实例,并调用其onCreate()和onBind()方法, 然后客户端就可以通过IBinder和Service进行交互了.</span></span></li><li><span class="name"><span class="innerContentContainer">此后如果再次使用bindService()绑定Service,系统不会创建新的Sevice实例,也不会再调用onBind()方法,只会直接把IBinder对象传递给后来的客户端.</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们解除与服务的绑定,只需调用 unbindService(), 此时 onUnbind()会被调用. 如果只有这一个客户端, 则接着 onDestory()方法也会被调用. 如果是多个客户端, 只有最后一个客户端都调用了 unbindService(),  onDestory()才会被调用.  --按逻辑行事.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>bindService模式下, Service是与客户端是绑定关系. 在bindService后, 如果客户端在onUnbind()前异常退出, 那么Service也会被终止.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">onStartCommand 和 onStart的关系: 后者不建议使用. 如果使用, 则相当于重写了 onStartCommand, 而且返回值是 START_STICKY.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>onStartCommand：</b>返回值. 非常重要.</span></span><ul><li><span class="name"><span class="innerContentContainer">START_STICKY: 系统在调用完onStartCommand()方法后，如果当前服务被终止了，系统会使该服务保持在启动状态，不过它不会保留之前传递的Intent对象。但是由于它保持启动状态，随后系统会尝试重新创建service，但之前的Intent对象没有被保存。在这个情况下，如果期间没有任何启动命令被传递到Service，那么参数Intent将为null。因此使用START_STICKY作为返回值，适用于不执行命令的媒体播放器（或类似的服务），它只是无限期的运行着并等待工作的到来.</span></span></li><li><span class="name"><span class="innerContentContainer">START_NOT_STICKY: 系统在调用完onStartCommand方法后，如果当前服务被终止了并且在此期间没有任何启动命令被传递到Service，那么系统将是使当前服务退出启动状态，并且除非重新调用Context.startService(Intent)，否则不会重新被创建（即不会重新调用onCreate方法）。因为当前服务退出了启动状态，所以除非在此期间启动命令被传递到Service，否则也不会调用。这是最安全的选项，用来避免在不需要的时候运行你的服务。</span></span></li><li><span class="name"><span class="innerContentContainer">START_REDELIVER_INTENT: 如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。并且在在该服务调用stopSelf方法之前，能够一直保留intent对象数据。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。</span></span></li><li><span class="name"><span class="innerContentContainer">START_STICKY_COMPATIBILITY: START_STICKY的兼容版本，但不保证服务被终止后一定能重启。被异常kill后, 服务虽然被重建，但没有重启.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无论启动了多少次Service,只需调用一次StopService即可停掉Service. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>bindService() </b>的函数原型:</span></span><ul><li><span class="name"><span class="innerContentContainer">bindService(Intent Service, ServiceConnection conn, int flags); 其中参数是: </span></span></li><li><span class="name"><span class="innerContentContainer">service: 通过该intent指定要启动的Service.</span></span></li><li><span class="name"><span class="innerContentContainer">conn: ServiceConnection对象,用户监听访问者与Service间的连接情况.</span></span><ul><li><span class="name"><span class="innerContentContainer">连接成功回调该对象中的onServiceConnected(ComponentName,IBinder)方法; </span></span></li><li><span class="name"><span class="innerContentContainer">如果Service所在的宿主由于异常终止或者其他原因终止,导致Service与访问者间断开 连接时调用onServiceDisconnected(CompanentName)方法.</span></span></li><li><span class="name"><span class="innerContentContainer">客户端主动调用unBindService()&nbsp;方法断开, 不会收到 onServiceDisconnected()回调.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">flags: 指定绑定时是否自动创建Service(如果Service还未创建), 参数值域是: </span></span><ul><li><span class="name"><span class="innerContentContainer">0(不自动创建).</span></span></li><li><span class="name"><span class="innerContentContainer">BIND_AUTO_CREATE(自动创建). 默认值.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">StartService启动Service后, 再bindService绑定的情况</span></span><ul><li><span class="name"><span class="innerContentContainer">如果Service已经由某个客户端通过 StartService()启动,接下来其他客户端再调用bindService() 绑定到该Service后, 再调用 unbindService()解除绑定, 最后再调用bindService() 绑定到 Service的话, 此时所触发的生命周期方法如下:</span></span></li><li><span class="name"><span class="innerContentContainer">onCreate() -&gt; onStartCommand() -&gt; onBind() -&gt; onUnbind() -&gt; onRebind()</span></span></li><li><span class="name"><span class="innerContentContainer"><b>注意:  如果你需要在有新客户端连接上时获得onRebind()回调, 则必须在onUnbind()中返回true. 返回false 则收不到. Android就是这么约定的. </b></span></span></li><li><span class="name"><span class="innerContentContainer">这里或许部分读者有疑惑了,调用了unbindService后Service不是应该调用 onDistory()方法么?</span></span></li><li><span class="name"><span class="innerContentContainer">其实这是因为这个Service是由我们的StartService来启动的 ,所以你调用onUnbind()方法取消绑定,Service也是不会终止的.</span></span></li><li><span class="name"><span class="innerContentContainer">得出的结论:&nbsp;假如我们使用bindService来绑定一个启动的Service,注意是已经启动的Service. 系统只是将Service的内部IBinder对象传递给Activity,并不会将Service的生命周期与此Activity绑定, 因此调用unBindService( )方法取消绑定时, Service也不会被销毁。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Service例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">public class TestService2 extends Service {</span></span><ul><li><span class="name"><span class="innerContentContainer">private final String TAG = "TestService2";</span></span></li><li><span class="name"><span class="innerContentContainer">private int count;</span></span></li><li><span class="name"><span class="innerContentContainer">private boolean quit;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义onBinder方法所返回的对象</span></span></li><li><span class="name"><span class="innerContentContainer">private MyBinder binder = new MyBinder();</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyBinder extends Binder {</span></span><ul><li><span class="name"><span class="innerContentContainer">public int getCount() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return count;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//必须实现的方法,绑定改Service时回调该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public IBinder onBind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onBind方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">return binder;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Service被创建时回调</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onCreate方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">//创建一个线程动态地修改count的值</span></span></li><li><span class="name"><span class="innerContentContainer">new Thread() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">while(!quit) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Thread.sleep(1000);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch(InterruptedException e) { e.printStackTrace(); }</span></span></li><li><span class="name"><span class="innerContentContainer">count++;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}.start();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Service断开连接时回调</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onUnbind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onUnbind方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Service被关闭前回调</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void onDestroy() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onDestroy();</span></span></li><li><span class="name"><span class="innerContentContainer">this.quit = true;</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onDestroyed方法被调用!");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">public void onRebind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onRebind方法被调用!");</span></span></li><li><span class="name"><span class="innerContentContainer">super.onRebind(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 在AndroidManifest.xml中对Service组件进行注册</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;service android:name=".TestService2" android:exported="false"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;intent-filter&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;action android:name="com.jay.example.service.TEST_SERVICE2"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/intent-filter&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/service&gt;</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">// 在 MainActivity.java 中使用service.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">TestService2.MyBinder <b>binder</b>;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义ServiceConnection对象</span></span></li><li><span class="name"><span class="innerContentContainer">private <b>ServiceConnection conn </b>= new ServiceConnection() {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Activity与Service断开连接时回调该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onServiceDisconnected(ComponentName name) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println("------Service DisConnected-------");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// Activity与Service连接成功时回调该方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onServiceConnected(ComponentName name, IBinder service) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println("------Service Connected-------");</span></span></li><li><span class="name"><span class="innerContentContainer">binder = (TestService2.MyBinder) service;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">};</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">final Intent <b>intent </b>= new Intent();</span></span></li><li><span class="name"><span class="innerContentContainer">intent.setAction("com.jay.example.service.TEST_SERVICE2");</span></span></li><li><span class="name"><span class="innerContentContainer">// btnbind 和 btncancel <b>是两个 </b>Button, 不重要.</span></span></li><li><span class="name"><span class="innerContentContainer">btnbind.<b>setOnClickListener</b>(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>bindService</b>(<b>intent</b>, <b>conn</b>, Service.BIND_AUTO_CREATE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li><li><span class="name"><span class="innerContentContainer">btncancel.setOnClickListener(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>unbindService</b>(conn);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IntentService: 多线程的一种实现方式。耗时操作放在这里</span></span><ul><li><span class="name"><span class="innerContentContainer">IntentService是继承与Service并处理异步请求的一个类. 在 IntentService中有一个工作线程来处理耗时操作, 请求的Intent记录会加入队列.</span></span></li><li><span class="name"><span class="innerContentContainer">客户端通过 startService(Intent)来启动IntentService.</span></span></li><li><span class="name"><span class="innerContentContainer">可以启动 IntentService 多次, 每个操作以工作队列的方式在 IntentService的 onHandleIntent回调方法中执行,并且每次只会执行一个工作线程.</span></span></li><li><span class="name"><span class="innerContentContainer">并不需要手动地区控制  IntentService, 当任务执行完后会自动停止.</span></span></li><li><span class="name"><span class="innerContentContainer">当一个后台的任务需要分成几个子任务, 再按先后顺序执行子任务 (简单的说就是异步操作). 此时如果我们还是定义一个普通Service, 然后在onStart方法中开辟线程, 然后又要去控制线程, 这样显得非常的繁琐; 此时就应该自定义一个 IntentService, 然后在 onHandleIntent() 方法中完成相关任务. </span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">// IntentService 就是 Service.</span></span></li><li><span class="name"><span class="innerContentContainer">public class TestService3 extends IntentService {</span></span><ul><li><span class="name"><span class="innerContentContainer">private final String TAG = "hehe";</span></span></li><li><span class="name"><span class="innerContentContainer">public TestService3() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super("TestService3");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// onHandleIntent是核心方法, 重视.</span></span></li><li><span class="name"><span class="innerContentContainer">protected void <b>onHandleIntent</b>(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务</span></span></li><li><span class="name"><span class="innerContentContainer">String action = intent.getExtras().getString("param");</span></span></li><li><span class="name"><span class="innerContentContainer">if(action.equals("s1")) { Log.i(TAG,"启动service1"); }</span></span></li><li><span class="name"><span class="innerContentContainer">else if(action.equals("s2")) { Log.i(TAG,"启动service2"); }</span></span></li><li><span class="name"><span class="innerContentContainer">else if(action.equals("s3")) { Log.i(TAG,"启动service3"); }</span></span></li><li><span class="name"><span class="innerContentContainer">// 让服务休眠2秒</span></span></li><li><span class="name"><span class="innerContentContainer">try { </span></span><ul><li><span class="name"><span class="innerContentContainer">Thread.sleep(2000);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (InterruptedException e) { e.printStackTrace(); }</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public IBinder onBind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onBind");</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onBind(intent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onCreate");</span></span></li><li><span class="name"><span class="innerContentContainer">super.onCreate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public int onStartCommand(Intent intent, int flags, int startId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onStartCommand");</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onStartCommand(intent, flags, startId);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void setIntentRedelivery(boolean enabled) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.setIntentRedelivery(enabled);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"setIntentRedelivery");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onDestroy() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onDestroy");</span></span></li><li><span class="name"><span class="innerContentContainer">super.onDestroy();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// AndroidManifest.xml注册下Service</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;service android:name=".TestService3" android:exported="false"&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;intent-filter &gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt;action android:name="com.test.intentservice"/&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/intent-filter&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/service&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 在MainActivity启动三次服务</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it1 = new Intent("com.test.intentservice");</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle b1 = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">b1.putString("param", "s1");</span></span></li><li><span class="name"><span class="innerContentContainer">it1.putExtras(b1);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it2 = new Intent("com.test.intentservice");</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle b2 = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">b2.putString("param", "s2");</span></span></li><li><span class="name"><span class="innerContentContainer">it2.putExtras(b2);</span></span></li><li><span class="name"><span class="innerContentContainer">Intent it3 = new Intent("com.test.intentservice");</span></span></li><li><span class="name"><span class="innerContentContainer">Bundle b3 = new Bundle();</span></span></li><li><span class="name"><span class="innerContentContainer">b3.putString("param", "s3");</span></span></li><li><span class="name"><span class="innerContentContainer">it3.putExtras(b3);</span></span></li><li><span class="name"><span class="innerContentContainer">// 接着启动多次IntentService,每次启动,都会新建一个工作线程. 但始终只有一个IntentService实例</span></span></li><li><span class="name"><span class="innerContentContainer">startService(it1);</span></span></li><li><span class="name"><span class="innerContentContainer">startService(it2);</span></span></li><li><span class="name"><span class="innerContentContainer">startService(it3);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity与Service通信</span></span><ul><li><span class="name"><span class="innerContentContainer">假如我们启动的是一个下载的后台Service，而我们想知道Service中下载任务的进度. 这涉及 Service 与Activity进行通信. 其基本流程如下：</span></span></li><li><span class="name"><span class="innerContentContainer">在Service中自定义一个 Binder类，然后将需要暴露的方法写到该类中.</span></span></li><li><span class="name"><span class="innerContentContainer">Service类中，实例化这个自定义 Binder类，然后重写 onBind()方法，将这个Binder对象返回.</span></span></li><li><span class="name"><span class="innerContentContainer">Activity类中实例化一个 ServiceConnection对象，重写 onServiceConnected()方法，然后获取Binder对象，然后调用相关方法即可.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">前台服务</span></span><ul><li><span class="name"><span class="innerContentContainer">Service默认是后台服务. 后台服务的缺点是优先级较低, 当内存不足时会优先回收后台服务. 方法是:</span></span></li><li><span class="name"><span class="innerContentContainer">在自定义的Service类中，重写onCreate()，然后根据自己的需求定制Notification； 定制完毕后，调用 startForeground(1,notification对象)即可.</span></span></li><li><span class="name"><span class="innerContentContainer">public void onCreate() {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate();</span></span></li><li><span class="name"><span class="innerContentContainer">Notification.Builder localBuilder = new Notification.Builder(this);</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0));</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setAutoCancel(false);</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setSmallIcon(R.mipmap.ic_cow_icon);</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setTicker("Foreground Service Start");</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setContentTitle("Socket服务端");</span></span></li><li><span class="name"><span class="innerContentContainer">localBuilder.setContentText("正在运行...");</span></span></li><li><span class="name"><span class="innerContentContainer">startForeground(1, localBuilder.getNotification());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定时后台线程</span></span><ul><li><span class="name"><span class="innerContentContainer">Android中给我们提供的定时方式有两种: Timer类 与 Alarm机制.</span></span></li><li><span class="name"><span class="innerContentContainer">前者不适合于需要长期在后台运行的定时任务，CPU一旦休眠，Timer中的定时任务就无法运行.</span></span></li><li><span class="name"><span class="innerContentContainer">Alarm则不存在这种情况，具有唤醒CPU的功能. 另外，要区分CPU唤醒与屏幕唤醒.</span></span></li><li><span class="name"><span class="innerContentContainer">方法是:</span></span></li><li><span class="name"><span class="innerContentContainer">1, 获得Service:&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2, 通过set方法设置定时任务:</span></span><ul><li><span class="name"><span class="innerContentContainer">int anHour = 2 * 1000; </span></span></li><li><span class="name"><span class="innerContentContainer">long triggerAtTime = SystemClock.elapsedRealtime() + anHour; </span></span></li><li><span class="name"><span class="innerContentContainer">manager.<b>set</b>(AlarmManager.RTC_WAKEUP,triggerAtTime,pendingIntent);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3, 定义一个Service&nbsp;在onStartCommand中开辟一条事务线程,用于处理一些定时逻辑.</span></span></li><li><span class="name"><span class="innerContentContainer">4, 定义一个Broadcast(广播)，用于启动Service&nbsp;最后别忘了，在AndroidManifest.xml中对这Service与Boradcast进行注册.</span></span></li><li><span class="name"><span class="innerContentContainer">参数详解：&nbsp;<b>set</b>(int type,long startTime,PendingIntent pi);</span></span></li><li><span class="name"><span class="innerContentContainer"><b>type</b>的值域是:</span></span><ul><li><span class="name"><span class="innerContentContainer">ELAPSED_REALTIME:&nbsp;闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3;</span></span></li><li><span class="name"><span class="innerContentContainer">ELAPSED_REALTIME_WAKEUP&nbsp;闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；</span></span></li><li><span class="name"><span class="innerContentContainer">RTC&nbsp;闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；</span></span></li><li><span class="name"><span class="innerContentContainer">RTC_WAKEUP&nbsp;表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0;</span></span></li><li><span class="name"><span class="innerContentContainer">POWER_OFF_WAKEUP&nbsp;表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一， 该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>startTime</b>: type决定startTime的含义.</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是 ELAPSED_REALTIME 和 ELAPSED_REALTIME_WAKEUP, 就用: SystemClock.elapsedRealtime()方法可以获得系统开机到现在经历的毫秒数;</span></span></li><li><span class="name"><span class="innerContentContainer">如果是RTC、RTC_WAKEUP、POWER_OFF_WAKEUP的就用: System.currentTimeMillis() 可获得从1970.1.1 0点到现在做经历的毫秒数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>PendingIntent</b>:&nbsp;绑定了闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent 是Intent的封装类。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是通过启动服务来实现闹钟提示的话， PendingIntent对象的获取就应该采用Pending.getService (Context c,int i,Intent intent,int j)方法；</span></span></li><li><span class="name"><span class="innerContentContainer">如果是通过广播来实现闹钟提示的话， PendingIntent对象的获取就应该采用 PendingIntent.getBroadcast (Context c,int i,Intent intent,int j)方法；</span></span></li><li><span class="name"><span class="innerContentContainer">如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取 就应该采用 PendingIntent.getActivity(Context c,int i,Intent intent,int j) 方法。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从4.4版本后(API 19),Alarm任务的触发时间可能变得不准确,有可能会延时,是系统 对于耗电性的优化,如果需要准确无误可以调用 setExtra()方法.</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class LongRunningService extends Service {</span></span><ul><li><span class="name"><span class="innerContentContainer">public IBinder onBind(Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public int onStartCommand(Intent intent, int flags, int startId) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//这里开辟一条线程,用来执行具体的逻辑操作:</span></span></li><li><span class="name"><span class="innerContentContainer">new Thread(new Runnable() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void run() {</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.d("BackService", new Date().toString());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}).start();</span></span></li><li><span class="name"><span class="innerContentContainer">AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span></span></li><li><span class="name"><span class="innerContentContainer">// 这里是定时的,这里设置的是每隔两秒打印一次时间=-=,自己改</span></span></li><li><span class="name"><span class="innerContentContainer">int anHour = 2 * 1000;</span></span></li><li><span class="name"><span class="innerContentContainer">long triggerAtTime = SystemClock.elapsedRealtime() + anHour;</span></span></li><li><span class="name"><span class="innerContentContainer">Intent i = new Intent(this,AlarmReceiver.class);</span></span></li><li><span class="name"><span class="innerContentContainer">PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);</span></span></li><li><span class="name"><span class="innerContentContainer">return super.onStartCommand(intent, flags, startId);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public class AlarmReceiver extends BroadcastReceiver {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onReceive(Context context, Intent intent) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Intent i = new Intent(context,LongRunningService.class);</span></span></li><li><span class="name"><span class="innerContentContainer">context.startService(i);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul>
  </body>
</html>