<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>LinuxBash <span class="contentTag" title="Filter #Work">#<span class="contentTagText">Work</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>常用命令</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>查找文件名： find -name *.cpp</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>查找文件内容： grep</b></span></span><ul><li><span class="name"><span class="innerContentContainer">命令格式: grep -参数 "待检索字符串" "待检索文件路径".  参数如下:</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>-*: *是个数字, 比如-5, -8, 指定显示目标前后的行数. </b></span></span></li><li><span class="name"><span class="innerContentContainer">-r: 递归检索所有子目录下的文件</span></span></li><li><span class="name"><span class="innerContentContainer">-c：只输出匹配行的计数。</span></span></li><li><span class="name"><span class="innerContentContainer">-I：不区分大 小写(只适用于单字符)。</span></span></li><li><span class="name"><span class="innerContentContainer">-h：查询多文件时不显示文件名。</span></span></li><li><span class="name"><span class="innerContentContainer">-l：查询多文件时只输出包含匹配字符的文件名。</span></span></li><li><span class="name"><span class="innerContentContainer">-n：显示匹配行及行号。</span></span></li><li><span class="name"><span class="innerContentContainer">-s：不显示不存在或无匹配文本的错误信息。</span></span></li><li><span class="name"><span class="innerContentContainer">-v：显示不包含匹配文本的所有行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实例: </span></span><ul><li><span class="name"><span class="innerContentContainer">grep ‘test’ d*      // 显示所有以d开头的文件中包含 test的行。</span></span></li><li><span class="name"><span class="innerContentContainer">grep ‘test’ aa bb cc    // 显示在aa，bb，cc文件中匹配test的行。</span></span></li><li><span class="name"><span class="innerContentContainer">grep ‘[a-z]\{5\}’ aa     // 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span></span></li><li><span class="name"><span class="innerContentContainer">grep ‘w\(es\)t.*\1′ aa   // 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成 ’w(es)t.*\1′ 就可以了。</span></span></li><li><span class="name"><span class="innerContentContainer">grep magic /usr/src/Linux/Doc/*     // 在’/usr/src/Linux/Doc’目录下搜索带字符 串’magic’的文件</span></span></li><li><span class="name"><span class="innerContentContainer">grep "sort" *.doc       // 显示包含sort 且扩展名是doc文件.</span></span></li><li><span class="name"><span class="innerContentContainer">grep -vn "48" data.doc   // 显示所有不包含48的行</span></span></li><li><span class="name"><span class="innerContentContainer">grep '[239].' data.doc&nbsp; &nbsp;&nbsp; // 输出所有含有以2,3或9开头的，并且是两个数字的行</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">回车换行符</span></span><ul><li><span class="name"><span class="innerContentContainer">0D:  即 \n，ASC码是13, 回车.</span></span></li><li><span class="name"><span class="innerContentContainer">0A:  即 \r,  ASC码是10, 换行.</span></span></li><li><span class="name"><span class="innerContentContainer">\n\r: window 系统行末结束符</span></span></li><li><span class="name"><span class="innerContentContainer">\n:&nbsp; UNIX 系统行末结束符</span></span></li><li><span class="name"><span class="innerContentContainer">\r:&nbsp; MAC OS 系统行末结束符</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时间戳和 epoch</span></span><ul><li><span class="name"><span class="innerContentContainer">时间戳 to 时间: date -d @***(去掉后3位)</span></span></li><li><span class="name"><span class="innerContentContainer">假设我们要将时间表示成毫秒数，比方说1000000毫秒，那有一个问题必须解决，这个1000000毫秒的起点是什么时间，也就是我们的时间基准点是什么时间？</span></span></li><li><span class="name"><span class="innerContentContainer">这个时间基准点就是epoch.</span></span></li><li><span class="name"><span class="innerContentContainer">在Unix系统中，这个基准点就是 1970年1月1日0点整 那个时间点。</span></span></li><li><span class="name"><span class="innerContentContainer">linux的时间戳</span></span><ul><li><span class="name"><span class="innerContentContainer">是一个32位的数字，记录从1970-1-1 0:0:0（UTC）到系统当前时间的秒数。</span></span></li><li><span class="name"><span class="innerContentContainer">该时间是unix诞生的时间，通常被称为POSIX_TIME。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2038年问题</span></span><ul><li><span class="name"><span class="innerContentContainer">unix采用32位保存时间戳，到2038-1-19 11:14:07（UTC）会翻转，这就是“2038年问题”。</span></span></li><li><span class="name"><span class="innerContentContainer">为避免这个问题，最新系统将时间戳改为64位。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows的时间戳</span></span><ul><li><span class="name"><span class="innerContentContainer">微软windows的时间戳为64位，开始时间从1601-1-1 0:0:0开始。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">fs_time_jnl_from_secs()。获取的时间格式为julian历，即年-月-日-时-分-秒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">清屏: clear</span></span></li><li><span class="name"><span class="innerContentContainer">暂停脚本执行, 等待按键:   read -n1 -p "Press and key to continue ..."</span></span></li><li><span class="name"><span class="innerContentContainer">管道: a|b, a的正确输出作为b的输入.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>变量</b></span></span><ul><li><span class="name"><span class="innerContentContainer">定义变量:  export ANDROID_PRODUCT_OUT=/home/{builddirectory}/out/target/product/{target}&nbsp; &nbsp;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">使用变量:  echo $ANDROID_PRODUCT_OUT</span></span></li><li><span class="name"><span class="innerContentContainer">打印变量：echo $PATH</span></span></li><li><span class="name"><span class="innerContentContainer">更新PATH: export PATH="$PATH:$GRADLE_HOME/bin"</span></span><ul><li><span class="name"><span class="innerContentContainer">linux 上是分号分割, mac上是冒号分割.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">持久化PATH: vim ~/.bash_profile</span></span><ul><li><span class="name"><span class="innerContentContainer">添加新行: export PATH="$PATH:$GRADLE_HOME/bin"</span></span></li><li><span class="name"><span class="innerContentContainer">输入source ~/.bash_profile, 使修改生效.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用变量保存命令的输出: 使用``（非引号）&nbsp; eg：echo `date`</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>处理文本</b></span></span><ul><li><span class="name"><span class="innerContentContainer">sed</span></span><ul><li><span class="name"><span class="innerContentContainer">一次处理一行内容. 支持正则表达式.</span></span></li><li><span class="name"><span class="innerContentContainer">语法: sed -nr "***" ./</span></span></li><li><span class="name"><span class="innerContentContainer">参数:</span></span><ul><li><span class="name"><span class="innerContentContainer">-n: 使用安静模式. 输出内容到屏幕, 原文不会被修改.</span></span></li><li><span class="name"><span class="innerContentContainer">-i: 直接修改原文, 不输出屏幕.</span></span></li><li><span class="name"><span class="innerContentContainer">-r: 使用扩展的正则表达式语法(默认是正规语法)</span></span></li><li><span class="name"><span class="innerContentContainer">-e: </span></span></li><li><span class="name"><span class="innerContentContainer">-f: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动作参数:</span></span><ul><li><span class="name"><span class="innerContentContainer">动作参数一定要用单引号括起来.</span></span></li><li><span class="name"><span class="innerContentContainer">动作参数有前缀, 是两个数字, 含义是起止行号, 比如: sed -i '1, 30s/old/new/q'</span></span></li><li><span class="name"><span class="innerContentContainer">a: 在新行新增</span></span></li><li><span class="name"><span class="innerContentContainer">c: 取代指定行</span></span></li><li><span class="name"><span class="innerContentContainer">d: 删除</span></span></li><li><span class="name"><span class="innerContentContainer">i: 插入</span></span></li><li><span class="name"><span class="innerContentContainer">p: 打印内容到屏幕</span></span></li><li><span class="name"><span class="innerContentContainer">s: 替换. 将旧字符串替换为新字符串.</span></span></li><li><span class="name"><span class="innerContentContainer">q: 退出</span></span></li><li><span class="name"><span class="innerContentContainer">各个动作可以串联在一起, 用 ; 号分割.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">wc: 对文本内容进行统计</span></span><ul><li><span class="name"><span class="innerContentContainer">-l: 统计行数. 使用管道和其它命令组合在一起, 这个非常有用.</span></span></li><li><span class="name"><span class="innerContentContainer">-c: 字节数.</span></span></li><li><span class="name"><span class="innerContentContainer">-m: 字符串.</span></span></li><li><span class="name"><span class="innerContentContainer">-w: 字数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">awk</span></span><ul><li><span class="name"><span class="innerContentContainer">Awk（Aho、Weinberger 和 Kernighan） — 一种编程语言，因其模式匹配语法而特别有用，通常用于数据检索和数据转换。</span></span></li><li><span class="name"><span class="innerContentContainer">它从（文件、程序输出或命令行输入）读取数据作为输入，根据一组预定义条件处理输入（如按字母顺序排序），然后输出处理过的数据。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">文件和目录</span></span><ul><li><span class="name"><span class="innerContentContainer">返回文件夹大小： du -sh * , 执行时间稍长。</span></span></li><li><span class="name"><span class="innerContentContainer">绝对路径由 / 开始，如/usr/test/</span></span></li><li><span class="name"><span class="innerContentContainer">相对路径有如下几种:</span></span><ul><li><span class="name"><span class="innerContentContainer">. 表示当前目录,  .. 表示上级目录</span></span></li><li><span class="name"><span class="innerContentContainer">- ：表示上一次用的工作目录</span></span></li><li><span class="name"><span class="innerContentContainer">~ ：表示当前用户的 home 目录</span></span></li><li><span class="name"><span class="innerContentContainer">~user： 表示user用户的 home 目录</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">列出当前目录的文件:  ls</span></span><ul><li><span class="name"><span class="innerContentContainer">-a：全部文件;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">-l：显示详细信息</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">切换目录: cd</span></span></li><li><span class="name"><span class="innerContentContainer">显示当前目录: pwd</span></span></li><li><span class="name"><span class="innerContentContainer">建立新目录: mkdir</span></span><ul><li><span class="name"><span class="innerContentContainer">-p：目录递归建立</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">删除空目录: rmdir&nbsp;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">删除文件和目录: rm</span></span><ul><li><span class="name"><span class="innerContentContainer">-f：强制删除；</span></span></li><li><span class="name"><span class="innerContentContainer">-r：删除目录</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复制文件和目录: cp</span></span><ul><li><span class="name"><span class="innerContentContainer">复制文件夹： &nbsp;cp -avx /home/aosp/aosp_code/android-10.0.0_r14  /mnt/newhome</span></span></li><li><span class="name"><span class="innerContentContainer">-a: 相当于-dpr，拷贝文件夹时使用。</span></span></li><li><span class="name"><span class="innerContentContainer">-r: 递归调用，即拷贝子文件夹</span></span></li><li><span class="name"><span class="innerContentContainer">-i: 覆盖既有文件时先提示</span></span></li><li><span class="name"><span class="innerContentContainer">-n: 自动通过已存在的文件</span></span></li><li><span class="name"><span class="innerContentContainer">-S: 文件已存在时，使用suffix后缀来命名。</span></span></li><li><span class="name"><span class="innerContentContainer">-p: 保留原有属性</span></span></li><li><span class="name"><span class="innerContentContainer">-v: 显示执行过程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">移动文件，重命名文件:  mv</span></span><ul><li><span class="name"><span class="innerContentContainer">-f：强制；</span></span></li><li><span class="name"><span class="innerContentContainer">-i：如果目标文件已经存在，则询问是否覆盖.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建立空文件: touch+文件名</span></span></li><li><span class="name"><span class="innerContentContainer">测试文件（文件夹）相关属性: test.&nbsp; </span></span><ul><li><span class="name"><span class="innerContentContainer">-e：测试文件是否存在;&nbsp; </span></span></li><li><span class="name"><span class="innerContentContainer">-f：测试指定名称是否为文件;&nbsp; </span></span></li><li><span class="name"><span class="innerContentContainer">-d：测试指定名称是否为文件夹;&nbsp; </span></span></li><li><span class="name"><span class="innerContentContainer">-n：判断字符串是否非空，非空返回ture&nbsp;&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">修改文件或文件夹的权限: chmod</span></span><ul><li><span class="name"><span class="innerContentContainer">-r：支持子目录</span></span></li><li><span class="name"><span class="innerContentContainer">rg：chmod 777 /dev/pcui；其中：</span></span></li><li><span class="name"><span class="innerContentContainer">数字7表示权限，r=4,w=2,x=1, 7表示r+w+x, 即权限全开。</span></span></li><li><span class="name"><span class="innerContentContainer">三个值分别对应：owner、owner主、other组三类用户。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">解压缩: </span></span><ul><li><span class="name"><span class="innerContentContainer">bzip2 格式的(.bz2), 使用: tar xvjf 文件</span></span></li><li><span class="name"><span class="innerContentContainer">zip格式(.gz), 使用: tar xvzf 文件名</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建立软链接（符号链接）&nbsp;: ln -s /usr/local/bin/ctags /usr/bin/ctags</span></span></li><li><span class="name"><span class="innerContentContainer">寻找并批量删除文件: find ./ -name .git | xargs rm -rvf</span></span></li><li><span class="name"><span class="innerContentContainer">寻找并改变文件编码: </span></span><ul><li><span class="name"><span class="innerContentContainer">find -type f -exec sh -c 'iconv -f utf8 -t GBK -c $1&gt;$1.tmp; mv $1.temp ../gbk_txt/$1' -{} /,</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将utf8编码转化为gbk编码:</span></span><ul><li><span class="name"><span class="innerContentContainer">find -type f -exec sh -c 'iconv -f utf-8 -t GBK -c $1 &gt; $1.tmp ; mv $1.tmp ../gbk-txt/$1' _ {} \;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印目录及子目录中的所有有后缀的文件名:</span></span><ul><li><span class="name"><span class="innerContentContainer">find ./ -type f |egrep&nbsp; "*.[a-z]*" &gt; readme.txt&nbsp;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">磁盘管理</span></span><ul><li><span class="name"><span class="innerContentContainer">挂载emmc分区（要root权限）</span></span><ul><li><span class="name"><span class="innerContentContainer">mount -t vfat /dev/block/mmcblk0p3 /sdcard/fat</span></span></li><li><span class="name"><span class="innerContentContainer">linux的 mountpoint 真的是任意一个目录就可以!</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">显示硬盘空间配额大小： quota -s</span></span><ul><li><span class="name"><span class="innerContentContainer">含文件数量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">显示分区情况: df&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">-a：显示特殊分区</span></span></li><li><span class="name"><span class="innerContentContainer">-h：以GB、MB、KB来显示size</span></span></li><li><span class="name"><span class="innerContentContainer">-T：显示分区的文件系统类型</span></span></li><li><span class="name"><span class="innerContentContainer">-i：显示inode数量</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印硬盘分区结构（如主引导区、分区表等）: dumpe2fs</span></span></li><li><span class="name"><span class="innerContentContainer">查看分区信息: mount</span></span></li><li><span class="name"><span class="innerContentContainer">按fat32 mount: mount -t vfat /dev/block/mmcblk0p1 /sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">按ext3 mount, 且加rw权限: mount -t ext3 -o rw,remount /dev/block/mmcblk0p12 /system</span></span></li><li><span class="name"><span class="innerContentContainer">卸载分区: umount /sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">fat分区扫描1: /system/bin/fsck_msdos -p -f /mnt/sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">fat分区扫描2: fsck -t msdos -a /dev/block/mmcblk0p14</span></span></li><li><span class="name"><span class="innerContentContainer">扫描ext3 文件系统: /system/bin/e2fsck -p /dev/block/mmcblk0p6</span></span></li><li><span class="name"><span class="innerContentContainer">格式化为fat32: /system/bin/newfs_msdos -F 32 -O android -c 8 -s 1024 /dev/block/mmcblk0p14</span></span></li><li><span class="name"><span class="innerContentContainer">格式化为 ext3: mke2fs -j -L "logical" /dev/block/mmcblk0p6</span></span></li><li><span class="name"><span class="innerContentContainer">格式化u盘: mkfs.vfat -I /dev/sde（先用mount查看u盘挂在那个点上）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络</span></span><ul><li><span class="name"><span class="innerContentContainer">网络拷贝</span></span><ul><li><span class="name"><span class="innerContentContainer">scp依赖ssh</span></span></li><li><span class="name"><span class="innerContentContainer">命令: scp -r 用户名@IP地址:文件路径  本地地址</span></span></li><li><span class="name"><span class="innerContentContainer">然后输入网络侧密码。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">访问windows共享: 打开主文件夹，按Ctrl+L,输入 <a class="contentLink" target="_blank" rel="noreferrer" href="smb://ip">smb://ip</a>，输入用户名、密码</span></span></li><li><span class="name"><span class="innerContentContainer">获取本机ip: ifconfig</span></span></li><li><span class="name"><span class="innerContentContainer">跟踪网络路由: traceroute + ping</span></span></li><li><span class="name"><span class="innerContentContainer">查看当前网络联机状态: netstat -a</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统 / 用户</span></span><ul><li><span class="name"><span class="innerContentContainer">确定Linux版本号及是否为64位系统： uname  -a</span></span></li><li><span class="name"><span class="innerContentContainer">显示谁在线: who</span></span></li><li><span class="name"><span class="innerContentContainer">切换为超级用户: su</span></span></li><li><span class="name"><span class="innerContentContainer">切换为指定用户: su 用户名</span></span></li><li><span class="name"><span class="innerContentContainer">使用sudo运行当前命令: sudo + 命令, 其效力只限于当前命令。</span></span></li><li><span class="name"><span class="innerContentContainer">进入sudo模式: sudo su</span></span></li><li><span class="name"><span class="innerContentContainer">退出sudo模式: exit</span></span></li><li><span class="name"><span class="innerContentContainer">建立用户: useradd + 用户名</span></span></li><li><span class="name"><span class="innerContentContainer">删除用户: userdel + 用户名</span></span></li><li><span class="name"><span class="innerContentContainer">设置用户口令: passwd + 用户名</span></span></li><li><span class="name"><span class="innerContentContainer">重启系统: reboot</span></span></li><li><span class="name"><span class="innerContentContainer">重启系统: shutdown -r now   // 对iPhone也有效.</span></span></li><li><span class="name"><span class="innerContentContainer">ubuntu的root用户密码是什么？</span></span><ul><li><span class="name"><span class="innerContentContainer">ubuntu默认安装情况下root密码不确定，以防止用户用root权限破坏系统。安装过程中新建的账号是system权限的，可拥有sudo。但是有时候还是需要用root，此时可以用如下命令：sudo passwd root。</span></span></li><li><span class="name"><span class="innerContentContainer">先输入用户密码，再输入（两次）新的root密码，然后就可以使用root了！</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">进程和内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux进程的堆栈</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux每个用户进程都有自己的堆栈，而且有两个，一个为系统堆栈，除1K的进程控制块外，还有7K的空间供内核进程调度时用于保存进程上下文。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">列出进程: top, 其输出如下:</span></span><ul><li><span class="name"><span class="innerContentContainer">前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</span></span></li><li><span class="name"><span class="innerContentContainer">01:06:48 当前时间</span></span></li><li><span class="name"><span class="innerContentContainer">up 1:22 系统运行时间，格式为时:分</span></span></li><li><span class="name"><span class="innerContentContainer">1 user 当前登录用户数</span></span></li><li><span class="name"><span class="innerContentContainer">load average: 0.06, 0.60, 0.48 系统负载，即任务队列的平均长度。</span></span></li><li><span class="name"><span class="innerContentContainer">三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</span></span></li><li><span class="name"><span class="innerContentContainer">第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">Tasks: 29 total 进程总数</span></span></li><li><span class="name"><span class="innerContentContainer">1 running 正在运行的进程数</span></span></li><li><span class="name"><span class="innerContentContainer">28 sleeping 睡眠的进程数</span></span></li><li><span class="name"><span class="innerContentContainer">0 stopped 停止的进程数</span></span></li><li><span class="name"><span class="innerContentContainer">0 zombie 僵尸进程数</span></span></li><li><span class="name"><span class="innerContentContainer">Cpu(s): 0.3% us 用户空间占用CPU百分比</span></span></li><li><span class="name"><span class="innerContentContainer">1.0% sy 内核空间占用CPU百分比</span></span></li><li><span class="name"><span class="innerContentContainer">0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比</span></span></li><li><span class="name"><span class="innerContentContainer">98.7% id 空闲CPU百分比</span></span></li><li><span class="name"><span class="innerContentContainer">0.0% wa 等待输入输出的CPU时间百分比</span></span></li><li><span class="name"><span class="innerContentContainer">0.0% hi</span></span></li><li><span class="name"><span class="innerContentContainer">0.0% si</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">最后两行为内存信息。内容如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">Mem: 191272k total 物理内存总量</span></span></li><li><span class="name"><span class="innerContentContainer">173656k used 使用的物理内存总量</span></span></li><li><span class="name"><span class="innerContentContainer">17616k free 空闲内存总量</span></span></li><li><span class="name"><span class="innerContentContainer">22052k buffers 用作内核缓存的内存量</span></span></li><li><span class="name"><span class="innerContentContainer">Swap: 192772k total 交换区总量</span></span></li><li><span class="name"><span class="innerContentContainer">0k used 使用的交换区总量</span></span></li><li><span class="name"><span class="innerContentContainer">192772k free 空闲交换区总量</span></span></li><li><span class="name"><span class="innerContentContainer">123988k cached 缓冲的交换区总量。</span></span><ul><li><span class="name"><span class="innerContentContainer">内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，</span></span></li><li><span class="name"><span class="innerContentContainer">该数值即为这些内容已存在于内存中的交换区的大小。</span></span></li><li><span class="name"><span class="innerContentContainer">相应的内存再次被换出时可不必再对交换区写入。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">进程信息区</span></span></li><li><span class="name"><span class="innerContentContainer">统计信息区域的下方显示了各个进程的详细信息。首先来认识一下各列的含义。</span></span><ul><li><span class="name"><span class="innerContentContainer">PID 进程id</span></span></li><li><span class="name"><span class="innerContentContainer">PPID 父进程id</span></span></li><li><span class="name"><span class="innerContentContainer">RUSER Real user name</span></span></li><li><span class="name"><span class="innerContentContainer">UID 进程所有者的用户id</span></span></li><li><span class="name"><span class="innerContentContainer">USER 进程所有者的用户名</span></span></li><li><span class="name"><span class="innerContentContainer">GROUP 进程所有者的组名</span></span></li><li><span class="name"><span class="innerContentContainer">TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?</span></span></li><li><span class="name"><span class="innerContentContainer">PR 优先级</span></span></li><li><span class="name"><span class="innerContentContainer">NI nice值。负值表示高优先级，正值表示低优先级</span></span></li><li><span class="name"><span class="innerContentContainer">P 最后使用的CPU，仅在多CPU环境下有意义</span></span></li><li><span class="name"><span class="innerContentContainer">%CPU 上次更新到现在的CPU时间占用百分比</span></span></li><li><span class="name"><span class="innerContentContainer">TIME 进程使用的CPU时间总计，单位秒</span></span></li><li><span class="name"><span class="innerContentContainer">TIME+ 进程使用的CPU时间总计，单位1/100秒</span></span></li><li><span class="name"><span class="innerContentContainer">%MEM 进程使用的物理内存百分比</span></span></li><li><span class="name"><span class="innerContentContainer">VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span></span></li><li><span class="name"><span class="innerContentContainer">SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。</span></span></li><li><span class="name"><span class="innerContentContainer">RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span></span></li><li><span class="name"><span class="innerContentContainer">CODE 可执行代码占用的物理内存大小，单位kb</span></span></li><li><span class="name"><span class="innerContentContainer">DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</span></span></li><li><span class="name"><span class="innerContentContainer">SHR 共享内存大小，单位kb</span></span></li><li><span class="name"><span class="innerContentContainer">nFLT 页面错误次数</span></span></li><li><span class="name"><span class="innerContentContainer">nDRT 最后一次写入到现在，被修改过的页面数。</span></span></li><li><span class="name"><span class="innerContentContainer">S 进程状态。</span></span><ul><li><span class="name"><span class="innerContentContainer">D=不可中断的睡眠状态</span></span></li><li><span class="name"><span class="innerContentContainer">R=运行</span></span></li><li><span class="name"><span class="innerContentContainer">S=睡眠</span></span></li><li><span class="name"><span class="innerContentContainer">T=跟踪/停止</span></span></li><li><span class="name"><span class="innerContentContainer">Z=僵尸进程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">COMMAND 命令名/命令行</span></span></li><li><span class="name"><span class="innerContentContainer">WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名</span></span></li><li><span class="name"><span class="innerContentContainer">Flags 任务标志，参考 sched.h。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。</span></span></li><li><span class="name"><span class="innerContentContainer">可以通过各快捷键来更改显示内容。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看后台执行的程序: ps -aux</span></span></li><li><span class="name"><span class="innerContentContainer">输出当前运行进程。可以获取进程号: ps：ps -x: 显示进程的运行时间</span></span></li><li><span class="name"><span class="innerContentContainer">杀掉进程: kill+进程号。注意，系统进程杀掉后会马上重启。</span></span></li><li><span class="name"><span class="innerContentContainer">查每个进程的内存使用: </span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys meminfo + 进程名。对单个进程的内存有很细节的说明，包括object和sql。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同时看所有进程的内存使用: procrank</span></span></li><li><span class="name"><span class="innerContentContainer">给出系统内存的大致使用情况: cat /proc/meminfo，注意数据的含义要辨别.</span></span></li><li><span class="name"><span class="innerContentContainer">给出各进程的vsize和rss: ps-x</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux应用市场 / 包管理</span></span><ul><li><span class="name"><span class="innerContentContainer">apt-get</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux 脚本无法运行的原因  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">脚本文件如果是在 windows侧编辑的，那么就需要看一下换行符是否为0d0a，如果是，要改成linux的0a格式。&nbsp;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">检查一下命令的拼写和大小写；</span></span></li><li><span class="name"><span class="innerContentContainer">是否目录错误, 使用ls 查看当前目录；</span></span></li><li><span class="name"><span class="innerContentContainer">是否没有运行权限, 使用 chmod 777 修改；</span></span></li></ul></li></ul>
  </body>
</html>