<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">编程-全景图</span><ul><li><span class="name">数据结构</span><ul><li><span class="name">链表、数组</span><ul><li><span class="name">数组的特点是访问很快，但是元素的插入和删除很慢。</span></li><li><span class="name">List主要分为3类，ArrayList， LinkedList和Vector。</span></li><li><span class="name">Vector是ArrayList的线程安全版，它的方法前都加了synchronized锁，其他实现逻辑都相同。</span></li><li><span class="name">List是一个有序的集合, 允许有空值, 也允许等值.</span></li></ul></li><li><span class="name">集合</span></li><li><span class="name">队列</span><ul><li><span class="name">队列是一个先入先出（FIFO）的数据结构.</span></li><li><span class="name">Java中用Queue类. Queue接口与List、Set同一级别，都是继承了Collection接口。</span></li><li><span class="name">非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</span></li><li><span class="name">阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</span></li></ul></li><li><span class="name">字典、关联数组</span></li><li><span class="name">栈</span><ul><li><span class="name">java中 Stack 是线程安全的。</span></li><li><span class="name">内部使用数组保存数据，不够时翻倍。</span></li></ul></li><li><span class="name">树</span><ul><li><span class="name">二叉树</span><ul><li><span class="name">每个节点最多有两个叶子节点。</span></li><li><span class="name">每个节点最多有两个叶子节点。</span></li></ul></li><li><span class="name">完全二叉树</span><ul><li><span class="name">叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</span></li><li><span class="name">叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</span></li></ul></li><li><span class="name">平衡二叉树</span><ul><li><span class="name">左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</span></li><li><span class="name">左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</span></li></ul></li><li><span class="name">二叉查找树（BST）</span><ul><li><span class="name">二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</span></li><li><span class="name">二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</span></li></ul></li><li><span class="name">红黑树</span><ul><li><span class="name">红黑树是一个平衡的二叉树，但不完美。虽然我们希望一个所有查找都能在~lgN次比较内结束，但是这样在动态插入中保持树的完美平衡代价太高，所以我们稍微放松逛一下限制，希望找到一个能在对数时间内完成查找的数据结构。</span></li><li><span class="name">红黑树需要满足的五条性质：</span><ul><li><span class="name">1. 节点是红色或者是黑色；</span></li><li><span class="name">2. 根节点是黑色；</span></li><li><span class="name">3. 每个叶节点（NIL或空节点）是黑色；</span></li><li><span class="name">4. 每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）</span></li><li><span class="name">5. 从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点.</span></li></ul></li><li><span class="name">可以通过数学来证明，满足这五条性质的二叉树可以将查找删除维持在对数时间内。</span></li><li><span class="name">添加阶段后，左旋或者右旋从而再次达到平衡。</span></li></ul></li><li><span class="name">B，B+，B*树</span><ul><li><span class="name">B-树是一种平衡的多路搜索树（并不一定是二叉的）.</span></li><li><span class="name">B+树是应文件系统所需而出的一种B-树的变型树。B+树在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</span></li><li><span class="name">B*书: 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3.</span></li><li><span class="name">B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。</span></li><li><span class="name">MySQL是基于B+树聚集索引组织表.</span></li></ul></li><li><span class="name">LSM 树</span><ul><li><span class="name">LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</span></li><li><span class="name">B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</span></li><li><span class="name">LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</span></li><li><span class="name">极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</span></li><li><span class="name">优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</span></li><li><span class="name">Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</span></li></ul></li></ul></li><li><span class="name">BitSet</span><ul><li><span class="name">经常用于大规模数据的排重检查。</span></li></ul></li><li><span class="name">图</span><ul><li><span class="name">连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</span></li><li><span class="name">强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</span></li><li><span class="name">连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</span></li><li><span class="name">生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</span></li><li><span class="name">最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</span></li></ul></li></ul></li><li><span class="name">常用算法</span><ul><li><span class="name">排序、查找算法</span><ul><li><span class="name">排序大的分类可以分为两种：内排序和外排序。</span><ul><li><span class="name">在排序过程中，全部记录存放在内存，则称为内排序.</span></li><li><span class="name">如果排序过程中需要使用外存，则称为外排序。</span></li><li><span class="name">下面讲的排序都是属于内排序。</span></li></ul></li><li><span class="name">插入排序</span><ul><li><span class="name">每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。分为: </span></li><li><span class="name">直接插入排序</span><ul><li><span class="name">时间复杂度: O(n2)</span></li><li><span class="name">稳定.</span></li></ul></li><li><span class="name">二分法插入排序</span><ul><li><span class="name">找合适的插入位置时, 采用二分法查找. 因为已排序子集是有序的.</span></li></ul></li><li><span class="name">希尔排序</span><ul><li><span class="name">先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序.</span></li><li><span class="name">时间复杂度: O(nlog2n)</span></li></ul></li></ul></li><li><span class="name">选择排序</span><ul><li><span class="name">每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。</span></li><li><span class="name">直接选择排序</span><ul><li><span class="name">在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</span></li><li><span class="name">时间复杂度: O(n2)</span></li></ul></li><li><span class="name">堆排序</span><ul><li><span class="name">堆排序是一种树形选择排序，是对直接选择排序的有效改进。</span></li><li><span class="name">初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。</span></li><li><span class="name">时间复杂度: O(nlog2n)</span></li></ul></li></ul></li><li><span class="name">交换排序</span><ul><li><span class="name">冒泡排序</span><ul><li><span class="name">在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。</span></li><li><span class="name">时间复杂度: O(n2)</span></li><li><span class="name">稳定.</span></li></ul></li><li><span class="name">快速排序</span><ul><li><span class="name">选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</span></li><li><span class="name">时间复杂度: O(nlog2n)</span></li></ul></li></ul></li><li><span class="name">归并排序</span><ul><li><span class="name">归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</span></li><li><span class="name">时间复杂度: O(nlog2n)</span></li><li><span class="name">稳定</span></li></ul></li><li><span class="name">桶排序</span><ul><li><span class="name">直接桶排序</span><ul><li><span class="name">将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</span></li><li><span class="name">然后对每个桶内的元素进行排序。可以选择任意一种排序算法。</span></li><li><span class="name">最后将将各个桶中的元素合并成一个大的有序序列。</span></li><li><span class="name">假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为 O(n)+O(m)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk 。当 k 接近于 n 时，桶排序的时间复杂度就可以认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</span></li></ul></li><li><span class="name">计数排序</span><ul><li><span class="name">计数排序本质上是一种特殊的桶排序，当桶的个数取最大( maxV-minV+1 )的时候，就变成了计数排序。</span></li><li><span class="name">和桶排序过程比较像，差别在于桶的数量。</span></li></ul></li><li><span class="name">基数排序</span><ul><li><span class="name">将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，按照个位、十位、百位、...依次来排。</span></li><li><span class="name">时间复杂度: O(d(n+r))</span></li><li><span class="name">稳定.</span></li></ul></li></ul></li><li><span class="name">二分查找</span></li><li><span class="name">Java 中的排序</span><ul><li><span class="name">Collections.sort算法调用的是归并排序。</span></li><li><span class="name">Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。</span></li></ul></li></ul></li><li><span class="name">布隆过滤器</span><ul><li><span class="name">常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。</span></li><li><span class="name">注意：会有一定的错误率。</span></li><li><span class="name">优点：空间和时间效率都很高。 </span></li><li><span class="name">缺点：随着存入的元素数量增加，误算率随之增加。</span></li></ul></li><li><span class="name">字符串比较</span><ul><li><span class="name">KMP 算法</span><ul><li><span class="name">KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</span></li></ul></li></ul></li><li><span class="name">深度优先</span><ul><li><span class="name">一条路走到黑, 到黑再回头重走.</span></li></ul></li><li><span class="name">广度优先</span><ul><li><span class="name">先遍历完所有邻居, 再找邻居的邻居.</span></li></ul></li><li><span class="name">动态规划</span><ul><li><span class="name">动态规划是一个广泛的概念. 它的基本理念是把一个复杂问题分解为多个简单问题, 然后按照一定的顺序解决这些简单问题, 并把它们的解组合成复杂问题的解.</span></li><li><span class="name">动态规划算法有如下几种:</span></li><li><span class="name">贪心算法</span><ul><li><span class="name">贪心算法每次取当前最佳的，期望通过所有的局部最优解的总和来产生一个全局最优解。</span></li><li><span class="name">设计贪心算法的步骤:</span><ul><li><span class="name">1. 将优化问题转换成多个子问题, 先基于当前之问题做出最优选择，然后再解决下一个子问题。</span></li><li><span class="name">2. 证明原问题总是有一个最优解是贪心选择的得到的，从而说明贪心选择的安全。</span></li><li><span class="name">3. 说明在做出贪心选择后，剩下的子问题具有这样一个性质, 即如果将子问题的最优解和我们所做的贪心选择联合起来，可以得到一个更加负责的动态规划解。</span></li></ul></li><li><span class="name">背包问题</span><ul><li><span class="name">问题: 给定N个物品和一个容量为C的背包,物品i的重量为Wi，其价值为Vi，背包问题是如何选择装入背包的物品，使得装入背包中物品的总价值最大。</span></li><li><span class="name">三种贪心思想：</span><ul><li><span class="name">选择价值最大的物品</span></li><li><span class="name">选择重量最轻的物品</span></li><li><span class="name">选择单位重量价值最大的物品</span></li></ul></li><li><span class="name">毫无疑问，我们当然选择第三种。先把性价比最高的全部装入，最后不足全部装入的部分装入。</span></li></ul></li><li><span class="name">贪心算法的优势是简单高效, 一步到位, 没有"回溯"过程. 但是缺点就是往往找不到全局最优解, 而且差距甚大.</span></li></ul></li><li><span class="name">回溯算法</span><ul><li><span class="name">许多复杂的，规模较大的问题都可以使用回溯法，所以它有“通用解题方法”的美称。</span></li><li><span class="name">回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。走不通就退回再走.</span></li><li><span class="name">满足回溯条件的某个状态的点称为“回溯点”。</span></li><li><span class="name">在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</span></li></ul></li><li><span class="name">剪枝算法</span><ul><li><span class="name">一种基于剪枝（ α-βcut-off）的深度优先搜索（depth-first search）。</span></li><li><span class="name">将走棋方定为MAX方，因为它选择着法时总是对其子节点的评估值取极大值，即选择对自己最为有利的着法；</span></li><li><span class="name">将应对方定为MIN方，因为它走棋时需要对其子节点的评估值取极小值，即选择对走棋方最为不利的、最有钳制作用的着法。</span></li><li><span class="name">α-β剪枝是根据极大-极小搜索规则的进行的，虽然它没有遍历某些子树的大量节点，但它仍不失为穷尽搜索的本性。</span></li></ul></li><li><span class="name">经典动态规划</span><ul><li><span class="name">可以采用动态规划算法进行解决的一个重要性质即是该问题必须具备最优子结构性质.</span></li><li><span class="name">最优子结构性质, 指原问题的最优解必然包含了原问题的子问题的一个最优解。</span></li><li><span class="name">最短路径规划问题</span><ul><li><span class="name">解决步骤是: </span></li><li><span class="name">从终点开始, 从终点的邻居开始, 计算每个点到终点的最短距离. </span></li><li><span class="name">一直延伸到始点, 此时的最短距离即为答案.</span></li></ul></li><li><span class="name">动态规划算法每一次都会保留所有可能的选择策略中的最优者，因为总体的最优必然包含某个局部最优解.</span></li></ul></li></ul></li><li><span class="name">朴素贝叶斯</span><ul><li><span class="name">贝叶斯定理: P(B|A)=P(A|B)P(B) / P(A)</span><ul><li><span class="name">换个形式就是: P(类别|特征)=P(特征|类别)P(类别) / P(特征)</span></li><li><span class="name">P(A)称为"先验概率"（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。</span></li><li><span class="name">P(A|B)称为"后验概率"（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。</span></li><li><span class="name">P(B|A)/P(B)称为"可能性函数"（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。</span></li><li><span class="name">后验概率　＝　先验概率 ｘ 调整因子</span></li><li><span class="name">这就是贝叶斯推断的含义。我们先预估一个"先验概率"，然后加入实验结果，看这个实验到底是增强还是削弱了"先验概率"，由此得到更接近事实的"后验概率"。</span></li></ul></li><li><span class="name">贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故称.</span></li><li><span class="name">朴素贝叶斯分类是其中最简单的, 也是较常见的.</span></li><li><span class="name">举例, 假定姑娘们判断嫁不嫁, 会考虑4个特征: 帅不帅, 性格好不好, 高不高, 上进不上进</span><ul><li><span class="name">现在有个男生, 4个特征分别是不帅，性格不好，身高矮，不上进, 那么女生是嫁还是不嫁？</span></li><li><span class="name">即比较 p(嫁|(不帅、性格不好、身高矮、不上进))与 p(不嫁|(不帅、性格不好、身高矮、不上进)), 哪个概率大? </span></li><li><span class="name">直接求p(嫁|(不帅、性格不好、身高矮、不上进)) 不容易, 但是可以应用贝叶斯定理, 将其转化为好求的3个量:</span><ul><li><span class="name">p (不帅、性格不好、身高矮、不上进|嫁)</span><ul><li><span class="name">它等于 p(不帅|嫁)*p(性格不好|嫁)*p(身高矮|嫁)*p(不上进|嫁). 分别统计这几个概率, 就可以得出结果.</span></li><li><span class="name">不过这个等式要成立, 要求各特征之间相互独立.</span></li><li><span class="name">这就是朴素的来历, 朴素贝叶斯算法是假设各个特征之间相互独立.</span></li><li><span class="name">这一假设使得朴素贝叶斯法变得简单，但有时会牺牲分类准确率。</span></li></ul></li><li><span class="name">p (不帅、性格不好、身高矮、不上进)</span></li><li><span class="name">p(嫁)</span></li></ul></li></ul></li></ul></li><li><span class="name">推荐算法</span><ul><li><span class="name">推荐算法通常被分为如下4类:</span></li><li><span class="name">协同过滤推荐算法</span><ul><li><span class="name">简介：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐</span></li><li><span class="name">输入：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）</span></li><li><span class="name">类型：</span><ul><li><span class="name">基于邻域的协同过滤（基于用户和基于项）</span></li><li><span class="name">基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）</span></li></ul></li><li><span class="name">优点：</span><ul><li><span class="name">需要最小域</span></li><li><span class="name">不需要用户和项</span></li><li><span class="name">大部分场景中能够产生足够好的结果</span></li></ul></li><li><span class="name">缺点：</span><ul><li><span class="name">冷启动问题</span></li><li><span class="name">需要标准化产品</span></li><li><span class="name">需要很高的用户和项的比例（1：10）</span></li><li><span class="name">流行度偏见（有长尾的时候表现不够好）</span></li><li><span class="name">难于提供解释</span></li></ul></li></ul></li><li><span class="name">基于内容的推荐算法</span><ul><li><span class="name">简介：向用户推荐和其过去喜欢项的内容（例如元数据、描述、话题等等）相似的项</span></li><li><span class="name">输入：仅仅依赖于项和用户的内容 / 描述（除了惯用数据）</span></li><li><span class="name">类型：</span><ul><li><span class="name">信息检索（例如 tf-idf 和 Okapi BM25）</span></li><li><span class="name">机器学习（例如朴素贝叶斯、支持向量机、决策树等等）</span></li></ul></li><li><span class="name">优点：</span><ul><li><span class="name">没有冷启动问题</span></li><li><span class="name">不需要惯用数据</span></li><li><span class="name">没有流行度偏见，可以推荐有罕见特性的项</span></li><li><span class="name">可以使用用户内容特性来提供解释</span></li></ul></li><li><span class="name">缺点：</span><ul><li><span class="name">项内容必须是机器可读的和有意义的</span></li><li><span class="name">容易归档用户</span></li><li><span class="name">很难有意外，缺少多样性</span></li><li><span class="name">很难联合多个项的特性</span></li></ul></li></ul></li><li><span class="name">混合推荐算法</span><ul><li><span class="name">简介：综合利用协同过滤推荐算法和基于内容的推荐算法各自的优点同时抵消各自的缺点</span></li><li><span class="name">输入：同时使用用户和项的内容特性与惯用数据，同时从两种输入类型中获益</span></li><li><span class="name">类型：</span><ul><li><span class="name">加权</span></li><li><span class="name">交换</span></li><li><span class="name">混合</span></li><li><span class="name">特性组合</span></li><li><span class="name">案列</span></li><li><span class="name">特征增强</span></li><li><span class="name">元层次</span></li></ul></li><li><span class="name">优点：</span><ul><li><span class="name">由于单独使用协同过滤推荐算法和基于内容的推荐算法</span></li><li><span class="name">没有冷启动问题</span></li><li><span class="name">没有流行度偏见，可推荐有罕见特性的项</span></li><li><span class="name">可产生意外，实现多样性</span></li></ul></li><li><span class="name">缺点：</span><ul><li><span class="name">需要通过大量的工作才能得到正确的平衡</span></li></ul></li></ul></li><li><span class="name">流行度推荐算法</span><ul><li><span class="name">简介：这是一种推荐流行项的方法 (例如最多下载、最多看过、最大影响的项)</span></li><li><span class="name">输入：使用惯用数据和项的内容（例如类目）</span></li><li><span class="name">优点：</span><ul><li><span class="name">相对容易实现</span></li><li><span class="name">良好的基准算法</span></li><li><span class="name">有助于解决新用户冷启动问题</span></li></ul></li><li><span class="name">缺点：</span><ul><li><span class="name">需要标准化产品</span></li><li><span class="name">经常需要一些项的类型进行分类</span></li><li><span class="name">不会推荐新项（很少有机会被观测到）</span></li><li><span class="name">推荐列表不会改变太大</span></li></ul></li></ul></li><li><span class="name">高级非传统推荐算法</span><ul><li><span class="name">类型：</span><ul><li><span class="name">深度学习</span></li><li><span class="name">学习等级</span></li><li><span class="name">Multi-armed bandits（探索 / 开发）</span></li><li><span class="name">上下文感知推荐</span></li><li><span class="name">张量分解</span></li><li><span class="name">分解机</span></li><li><span class="name">社会推荐</span></li></ul></li><li><span class="name">优点：</span><ul><li><span class="name">利于勉强维持最终性能百分点</span></li><li><span class="name">你可以说你正在使用渐进的方式</span></li></ul></li><li><span class="name">缺点：</span><ul><li><span class="name">难于理解</span></li><li><span class="name">缺乏推荐工具支持</span></li><li><span class="name">没有为你的首个推荐系统提供推荐的方式</span></li></ul></li></ul></li></ul></li><li><span class="name">最小生成树算法</span><ul><li><span class="name">Kruskal算法</span><ul><li><span class="name">此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</span></li><li><span class="name">1. 把图中的所有边按代价从小到大排序；</span></li><li><span class="name">2. 把图中的n个顶点看成独立的n棵树组成的森林；</span></li><li><span class="name">3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</span></li><li><span class="name">4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</span></li></ul></li><li><span class="name">Prim算法</span><ul><li><span class="name">此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</span></li><li><span class="name">图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</span></li><li><span class="name">在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</span></li><li><span class="name">重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</span></li><li><span class="name">由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息.</span></li></ul></li></ul></li><li><span class="name">最短路径算法</span><ul><li><span class="name">从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径. 解决问题的算法：</span></li><li><span class="name">迪杰斯特拉算法（Dijkstra算法）</span><ul><li><span class="name">迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</span></li><li><span class="name">Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。</span></li><li><span class="name">然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，</span></li><li><span class="name">然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。</span></li><li><span class="name">然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</span></li></ul></li><li><span class="name">弗洛伊德算法（Floyd算法）</span></li><li><span class="name">SPFA算法</span></li></ul></li></ul></li><li><span class="name">并发</span><ul><li><span class="name">Java 并发</span></li><li><span class="name">多线程</span><ul><li><span class="name">缺点</span><ul><li><span class="name">线程安全：由于统一进程下的多个线程是共享同样的地址空间和数据的，又由于线程执行顺序的不可预知性，一个线程可能会修改其他线程正在使用的变量，这一方面是给数据共享带来了便利；另一方面，如果处理不当，会产生脏读，幻读等问题，好在Java提供了一系列的同步机制来帮助解决这一问题，例如内置锁。</span></li><li><span class="name">活跃性问题。可能会发生长时间的等待锁，甚至是死锁。</span></li><li><span class="name">性能问题。 线程的频繁调度切换会浪费资源，同步机制会导致内存缓冲区的数据无效，以及增加同步流量。</span></li></ul></li></ul></li><li><span class="name">线程安全</span><ul><li><span class="name">定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，则称这个类时线程安全的。线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</span></li><li><span class="name">线程安全产生的原因：正确性取决于多个线程的交替执行时序，产生了竞态条件。</span></li><li><span class="name">原子类： 应尽量使用原子类，这样会让你分析线程安全时更加方便，但需要注意的是用线程安全类构建的类并不能保证线程安全。例如，一个AtomicInteger get() 和&nbsp;AtomicInteger set() 是线程安全的，在一个类的一个方法 f()中同时用到了这两个方法，此时的f()就是线程不安全的，因为你不能保证这个复合操作中的get 和 set同时更新。</span></li><li><span class="name">达到线程安全的措施</span><ul><li><span class="name">加锁</span><ul><li><span class="name">锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。</span></li><li><span class="name">加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。</span></li><li><span class="name">加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。</span></li></ul></li><li><span class="name">不共享状态</span><ul><li><span class="name">无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。</span></li><li><span class="name">线程关闭： 仅在单线程环境下使用。</span></li></ul></li><li><span class="name">不可变对象</span><ul><li><span class="name">可以使用 final 修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。</span></li></ul></li></ul></li></ul></li><li><span class="name">一致性、事务</span><ul><li><span class="name">事务是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）</span></li><li><span class="name">事务的 ACID 特性</span><ul><li><span class="name">数据库管理系统中事务(transaction)的四个特性：</span><ul><li><span class="name">原子性（Atomicity）</span><ul><li><span class="name">原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。可采用“A向B转账”这个例子来说明.</span></li><li><span class="name">在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</span></li></ul></li><li><span class="name">一致性（Consistency）</span><ul><li><span class="name">一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</span></li><li><span class="name">如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</span></li><li><span class="name">保障机制：</span><ul><li><span class="name">业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</span></li><li><span class="name">数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；</span></li><li><span class="name">数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</span></li></ul></li></ul></li><li><span class="name">隔离性（Isolation）</span><ul><li><span class="name">多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</span></li><li><span class="name">在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</span></li><li><span class="name">事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。</span></li></ul></li><li><span class="name">持久性（Durability）</span><ul><li><span class="name">持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）</span></li><li><span class="name">write ahead logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</span></li></ul></li></ul></li></ul></li><li><span class="name">事务的隔离级别</span><ul><li><span class="name">未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</span></li><li><span class="name">读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</span></li><li><span class="name">可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</span></li><li><span class="name">序列化：所有事物串行处理（牺牲了效率）</span></li></ul></li><li><span class="name">MVCC</span><ul><li><span class="name">MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能.</span></li><li><span class="name">读锁：也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</span></li><li><span class="name">写锁：又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</span></li><li><span class="name">表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</span></li><li><span class="name">行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</span></li><li><span class="name">MVCC 会产生幻读问题（更新时异常）.</span></li></ul></li></ul></li><li><span class="name">锁</span><ul><li><span class="name">Java中的锁和同步类</span></li><li><span class="name">公平锁 &amp; 非公平锁</span></li><li><span class="name">悲观锁</span></li><li><span class="name">乐观锁 &amp; CAS</span></li><li><span class="name">ABA 问题</span></li><li><span class="name">CopyOnWrite容器</span></li><li><span class="name">RingBuffer</span></li><li><span class="name">可重入锁 &amp; 不可重入锁</span></li><li><span class="name">互斥锁 &amp; 共享锁</span></li><li><span class="name">死锁</span></li></ul></li></ul></li><li><span class="name">操作系统</span><ul><li><span class="name">计算机原理</span></li><li><span class="name">CPU</span><ul><li><span class="name">多级缓存</span></li></ul></li><li><span class="name">进程</span></li><li><span class="name">线程</span></li><li><span class="name">协程</span></li><li><span class="name">Linux</span></li></ul></li><li><span class="name">设计模式</span><ul><li><span class="name">设计模式的六大原则</span></li><li><span class="name">23种常见设计模式</span></li><li><span class="name">应用场景</span></li><li><span class="name">单例模式</span></li><li><span class="name">责任链模式</span></li><li><span class="name">MVC</span></li><li><span class="name">IOC</span></li><li><span class="name">AOP</span></li><li><span class="name">UML</span></li><li><span class="name">微服务思想</span><ul><li><span class="name">康威定律</span></li></ul></li></ul></li><li><span class="name">运维 &amp; 统计 &amp; 技术支持</span><ul><li><span class="name">常规监控</span></li><li><span class="name">APM</span></li><li><span class="name">统计分析</span></li><li><span class="name">持续集成(CI/CD)</span><ul><li><span class="name">Jenkins</span></li><li><span class="name">环境分离</span></li></ul></li><li><span class="name">自动化运维</span><ul><li><span class="name">Ansible</span></li><li><span class="name">puppet</span></li><li><span class="name">chef</span></li></ul></li><li><span class="name">测试</span><ul><li><span class="name">TDD 理论</span></li><li><span class="name">单元测试</span></li><li><span class="name">压力测试</span></li><li><span class="name">全链路压测</span></li><li><span class="name">A/B 、灰度、蓝绿测试</span></li></ul></li><li><span class="name">虚拟化</span><ul><li><span class="name">KVM</span></li><li><span class="name">Xen</span></li><li><span class="name">OpenVZ</span></li></ul></li><li><span class="name">容器技术</span><ul><li><span class="name">Docker</span></li></ul></li><li><span class="name">云技术</span><ul><li><span class="name">OpenStack</span></li></ul></li><li><span class="name">DevOps</span></li><li><span class="name">文档管理</span></li></ul></li><li><span class="name">中间件</span><ul><li><span class="name">Web Server</span><ul><li><span class="name">Nginx</span></li><li><span class="name">OpenResty</span></li><li><span class="name">Tengine</span></li><li><span class="name">Apache Httpd</span></li><li><span class="name">Tomcat</span><ul><li><span class="name">架构原理</span></li><li><span class="name">调优方案</span></li></ul></li><li><span class="name">Jetty</span></li></ul></li><li><span class="name">缓存</span><ul><li><span class="name">本地缓存</span></li></ul></li><li><span class="name">客户端缓存</span></li><li><span class="name">服务端缓存</span><ul><li><span class="name">Web缓存</span></li><li><span class="name">Memcached</span></li><li><span class="name">Redis</span><ul><li><span class="name">架构</span></li><li><span class="name">回收策略</span></li></ul></li><li><span class="name">Tair</span></li></ul></li><li><span class="name">消息队列</span><ul><li><span class="name">消息总线</span></li><li><span class="name">消息的顺序</span></li><li><span class="name">RabbitMQ</span></li><li><span class="name">RocketMQ</span></li><li><span class="name">ActiveMQ</span></li><li><span class="name">Kafka</span></li><li><span class="name">Redis 消息推送</span></li><li><span class="name">ZeroMQ</span></li></ul></li><li><span class="name">定时调度</span><ul><li><span class="name">单机定时调度</span></li><li><span class="name">分布式定时调度</span></li></ul></li><li><span class="name">RPC</span><ul><li><span class="name">Dubbo</span></li><li><span class="name">Thrift</span></li><li><span class="name">gRPC</span></li></ul></li><li><span class="name">数据库中间件</span><ul><li><span class="name">Sharding Jdbc</span></li></ul></li><li><span class="name">日志系统</span><ul><li><span class="name">日志搜集</span></li></ul></li><li><span class="name">配置中心</span></li><li><span class="name">API 网关</span></li></ul></li><li><span class="name">网络</span><ul><li><span class="name">协议</span><ul><li><span class="name">OSI 七层协议</span></li><li><span class="name">TCP/IP</span></li><li><span class="name">HTTP</span></li><li><span class="name">HTTP2.0</span></li><li><span class="name">HTTPS</span></li></ul></li><li><span class="name">网络模型</span><ul><li><span class="name">Epoll</span></li><li><span class="name">Java NIO</span></li><li><span class="name">kqueue</span></li></ul></li><li><span class="name">连接和短连接</span></li><li><span class="name">框架</span></li><li><span class="name">零拷贝（Zero-copy）</span></li><li><span class="name">序列化(二进制协议)</span><ul><li><span class="name">Hessian</span></li><li><span class="name">Protobuf</span></li></ul></li></ul></li><li><span class="name">数据库</span><ul><li><span class="name">基础理论</span><ul><li><span class="name">关系数据库设计的三大范式</span></li></ul></li><li><span class="name">MySQL</span><ul><li><span class="name">原理</span></li><li><span class="name">InnoDB</span></li><li><span class="name">优化</span></li><li><span class="name">索引</span><ul><li><span class="name">聚集索引, 非聚集索引</span></li><li><span class="name">复合索引</span></li><li><span class="name">自适应哈希索引(AHI)</span></li></ul></li><li><span class="name">explain</span></li></ul></li><li><span class="name">NoSQL</span><ul><li><span class="name">MongoDB</span></li><li><span class="name">Hbase</span></li></ul></li></ul></li><li><span class="name">搜索引擎</span><ul><li><span class="name">搜索引擎原理</span></li><li><span class="name">Lucene</span></li><li><span class="name">Elasticsearch</span></li><li><span class="name">Solr</span></li><li><span class="name">sphinx</span></li></ul></li><li><span class="name">性能</span><ul><li><span class="name">性能优化方法论</span></li><li><span class="name">容量评估</span></li><li><span class="name">CDN 网络</span></li><li><span class="name">连接池</span></li><li><span class="name">性能调优</span></li></ul></li><li><span class="name">大数据</span><ul><li><span class="name">流式计算</span><ul><li><span class="name">Storm</span></li><li><span class="name">Flink</span></li><li><span class="name">Kafka Stream</span></li><li><span class="name">应用场景</span></li></ul></li><li><span class="name">Hadoop</span><ul><li><span class="name">HDFS</span></li><li><span class="name">MapReduce</span></li><li><span class="name">Yarn</span></li></ul></li><li><span class="name">Spark</span></li></ul></li><li><span class="name">安全</span><ul><li><span class="name">web 安全</span><ul><li><span class="name">XSS</span></li><li><span class="name">CSRF</span></li><li><span class="name">SQL 注入</span></li><li><span class="name">Hash Dos</span></li><li><span class="name">脚本注入</span></li><li><span class="name">漏洞扫描工具</span></li><li><span class="name">验证码</span></li></ul></li><li><span class="name">DDoS 防范</span></li><li><span class="name">用户隐私信息保护</span></li><li><span class="name">序列化漏洞</span></li><li><span class="name">加密解密</span><ul><li><span class="name">对称加密</span></li><li><span class="name">哈希算法</span></li><li><span class="name">非对称加密</span></li></ul></li><li><span class="name">服务器安全</span></li><li><span class="name">数据安全</span><ul><li><span class="name">数据备份</span></li></ul></li><li><span class="name">网络隔离</span><ul><li><span class="name">内外网分离</span></li><li><span class="name">登录跳板机</span></li></ul></li><li><span class="name">授权、认证</span><ul><li><span class="name">RBAC</span></li><li><span class="name">OAuth2.0</span></li><li><span class="name">双因素认证（2FA）</span></li><li><span class="name">单点登录(SSO)</span></li></ul></li></ul></li><li><span class="name">常用开源框架</span><ul><li><span class="name">开源协议</span></li><li><span class="name">日志框架</span><ul><li><span class="name">Log4j、Log4j2</span></li><li><span class="name">Logback</span></li></ul></li><li><span class="name">ORM</span></li><li><span class="name">网络框架</span></li><li><span class="name">Web 框架</span><ul><li><span class="name">Spring 家族</span></li></ul></li><li><span class="name">工具框架</span></li></ul></li><li><span class="name">分布式设计</span><ul><li><span class="name">扩展性设计</span></li><li><span class="name">稳定性 &amp; 高可用</span><ul><li><span class="name">硬件负载均衡</span></li><li><span class="name">软件负载均衡</span></li><li><span class="name">限流</span></li><li><span class="name">应用层容灾</span></li><li><span class="name">跨机房容灾</span></li><li><span class="name">容灾演练流程</span></li><li><span class="name">平滑启动</span></li></ul></li><li><span class="name">数据库扩展</span><ul><li><span class="name">读写分离模式</span></li><li><span class="name">分片模式</span></li></ul></li><li><span class="name">服务治理</span><ul><li><span class="name">服务注册与发现</span></li><li><span class="name">服务路由控制</span></li></ul></li><li><span class="name">分布式一致</span><ul><li><span class="name">CAP 与 BASE 理论</span></li><li><span class="name">分布式锁</span></li><li><span class="name">分布式一致性算法</span><ul><li><span class="name">PAXOS</span></li><li><span class="name">Zab</span></li><li><span class="name">Raft</span></li><li><span class="name">Gossip</span></li><li><span class="name">两阶段提交、多阶段提交</span></li></ul></li><li><span class="name">幂等</span></li><li><span class="name">分布式一致方案</span></li><li><span class="name">分布式 Leader 节点选举</span></li><li><span class="name">TCC(Try/Confirm/Cancel) 柔性事务</span></li></ul></li><li><span class="name">分布式文件系统</span></li><li><span class="name">唯一ID 生成</span><ul><li><span class="name">全局唯一ID</span></li></ul></li><li><span class="name">一致性Hash算法</span></li></ul></li><li><span class="name">设计思想 &amp; 开发模式</span><ul><li><span class="name">DDD(Domain-driven Design - 领域驱动设计)</span><ul><li><span class="name">命令查询职责分离(CQRS)</span></li><li><span class="name">贫血，充血模型</span></li></ul></li><li><span class="name">Actor 模式</span></li><li><span class="name">响应式编程</span><ul><li><span class="name">Reactor</span></li><li><span class="name">RxJava</span></li><li><span class="name">Vert.x</span></li></ul></li><li><span class="name">DODAF2.0</span></li><li><span class="name">Serverless</span></li><li><span class="name">Service Mesh</span></li></ul></li><li><span class="name">项目管理</span><ul><li><span class="name">架构评审</span></li><li><span class="name">重构</span></li><li><span class="name">代码规范</span></li><li><span class="name">代码 Review</span></li><li><span class="name">RUP</span></li><li><span class="name">看板管理</span></li><li><span class="name">SCRUM</span></li><li><span class="name">敏捷开发</span></li><li><span class="name">极限编程（XP）</span></li><li><span class="name">结对编程</span></li><li><span class="name">PDCA 循环质量管理</span></li><li><span class="name">FMEA管理模式</span></li></ul></li></ul>
  </body>
</html>