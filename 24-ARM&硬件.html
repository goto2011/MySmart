<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">24-ARM&amp;硬件</span></span><ul><li><span class="name"><span class="innerContentContainer">芯片选型须关注的问题  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ap和modem两侧的通讯方式，响应速度、buffer size，以及可靠性、稳定性的实测数据。</span></span></li><li><span class="name"><span class="innerContentContainer">emmc上分区管理方式，增减分区是否有限制，方便吗？</span></span></li><li><span class="name"><span class="innerContentContainer">启动流程。是否支持安全启动。</span></span></li><li><span class="name"><span class="innerContentContainer">升级方式，由哪些模块参与。</span></span></li><li><span class="name"><span class="innerContentContainer">射频校准参数在哪里，如何管理，包括备份、恢复、新增、修改、删除的方案。</span></span></li><li><span class="name"><span class="innerContentContainer">debug方法，包括死机dump（dump的速度也要注意），log导出。</span></span></li><li><span class="name"><span class="innerContentContainer">外场现网测试，是否有支撑方法，比如如何抓现场log。</span></span></li><li><span class="name"><span class="innerContentContainer">功耗管理，测试手段，是否提供优化支持。包括基底功耗和应用功耗（浏览、音乐、玩游戏等）。</span></span></li><li><span class="name"><span class="innerContentContainer">主流器件、主流ID的支持情况，比如键盘、屏大小、TP、camera。</span></span></li><li><span class="name"><span class="innerContentContainer">代码开放程度，哪些代码提供给我们，哪些不提供；不提供者如何维护，如何实现新增需求。</span></span></li><li><span class="name"><span class="innerContentContainer">求助渠道，及响应速度。</span></span></li><li><span class="name"><span class="innerContentContainer">是否有on side支持，国内有没有研发团队，地点、规模、支持方式、是否外包。</span></span></li><li><span class="name"><span class="innerContentContainer">频段支持，几个关键点：北美AWS、日本1500/1700、拉美频段。</span></span></li><li><span class="name"><span class="innerContentContainer">GPS是否支持俄罗斯的gloness。</span></span></li><li><span class="name"><span class="innerContentContainer">内存支持情况，包括4G+3G的方案（内存768M）。读写速率是否有数据。</span></span></li><li><span class="name"><span class="innerContentContainer">是否支持flash。</span></span></li><li><span class="name"><span class="innerContentContainer">SD性能如何。</span></span></li><li><span class="name"><span class="innerContentContainer">SMP系统的性能优化，CPU调度策略，以及和功耗。</span></span></li><li><span class="name"><span class="innerContentContainer">平台做了多久，多少产品已经用了，有上市的吗？</span></span></li><li><span class="name"><span class="innerContentContainer">运营商入网认证测试，全球做了多少，能不能帮我们做。</span></span></li><li><span class="name"><span class="innerContentContainer">和google关系，是否是关键合作伙伴，是否可以提前拿到代码，能提前多少。</span></span></li><li><span class="name"><span class="innerContentContainer">在原生系统上的做的修改，包括原因、规模、内聚程度等。</span></span></li><li><span class="name"><span class="innerContentContainer">生产校准方案的具体细节。校准后台是谁做。</span></span></li><li><span class="name"><span class="innerContentContainer">是否支持快速开机、关机闹钟等。</span></span></li><li><span class="name"><span class="innerContentContainer">芯片选型思路总结</span></span><ul><li><span class="name"><span class="innerContentContainer">第一次选，风险第一，不做小白鼠。只做业界已经做过的产品。</span></span></li><li><span class="name"><span class="innerContentContainer">选择过程中，形成自己的套路。</span></span></li><li><span class="name"><span class="innerContentContainer">第二次选，就要选业界没用过的平台，高风险高收益，风险控制能力也是核心竞争力。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Review软硬件接口文档的关注点  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">review 电源部分</span></span><ul><li><span class="name"><span class="innerContentContainer">电源设计经常出问题，为重中之重。</span></span></li><li><span class="name"><span class="innerContentContainer">要关注电源和原始设计不一致的地方。比如各个电源的使用，默认为关的电源如何打开，有没有顺序，进待机时的电源管理。</span></span></li><li><span class="name"><span class="innerContentContainer">关注A电源、E电源、WLAN电源。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">review GPIO的修改</span></span><ul><li><span class="name"><span class="innerContentContainer">GPIO的配置，为软硬件联调的主要工作。也是重中之重。</span></span></li><li><span class="name"><span class="innerContentContainer">关注和原始设计不一直的</span></span></li><li><span class="name"><span class="innerContentContainer">要严格禁止各模块直接用in或out接口控制GPIO，必须用BIO模块的宏来控制。review代码时要把关。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">review 新增器件和新增特性</span></span><ul><li><span class="name"><span class="innerContentContainer">硬件有自己的器件规划，会有选择的在多个产品中落地。</span></span></li><li><span class="name"><span class="innerContentContainer">这部分容易出问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">eview board id</span></span><ul><li><span class="name"><span class="innerContentContainer">要重点review本产品的board id的规划。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">review 和切换相关的设计是否有改变</span></span><ul><li><span class="name"><span class="innerContentContainer">比如：usb和充电器的识别；</span></span></li><li><span class="name"><span class="innerContentContainer">耳机插拔识别；</span></span></li><li><span class="name"><span class="innerContentContainer">耳机线控的按下抬起；</span></span></li><li><span class="name"><span class="innerContentContainer">不同LCD、不同camera、不同TP的识别；</span></span></li><li><span class="name"><span class="innerContentContainer">LCD、camera的总线类型。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">review 频段</span></span><ul><li><span class="name"><span class="innerContentContainer">如果是公司从未使用的频段，调试射频nv的周期会很长，这个一定要有思想准备。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软硬件调试的一个教训</span></span><ul><li><span class="name"><span class="innerContentContainer">最难发现的错误往往是在自己非常熟悉的代码中由于笔误引起的。</span></span></li><li><span class="name"><span class="innerContentContainer">从零开始build有时候可以解决很多莫名其妙的问题。</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何看懂硬件原理图？  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">U401: cpu芯片</span></span></li><li><span class="name"><span class="innerContentContainer">U201: pmic芯片</span></span></li><li><span class="name"><span class="innerContentContainer">S1-S4: pmic提供的电源，软件不可控，手机上电就打开了，而且不可关闭。</span></span></li><li><span class="name"><span class="innerContentContainer">U601: flash芯片</span></span></li><li><span class="name"><span class="innerContentContainer">L201: L开头的都是电感，2.2uH。</span></span></li><li><span class="name"><span class="innerContentContainer">C233: C开头的都是电容，2.2uF。</span></span></li><li><span class="name"><span class="innerContentContainer">R1815: R开头的都是电阻，10kO。</span></span></li><li><span class="name"><span class="innerContentContainer">SG205v: SG开头的是单点接地。</span></span></li><li><span class="name"><span class="innerContentContainer">电池正负极图标: 表示接地。</span></span></li><li><span class="name"><span class="innerContentContainer">GND: 也表示接地。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">arm的7种处理器模式</span></span><ul><li><span class="name"><span class="innerContentContainer">User：普通程序运行的模式.</span></span></li><li><span class="name"><span class="innerContentContainer">System：可以运行操作系统的特权指令.</span></span></li><li><span class="name"><span class="innerContentContainer">Superisor：操作系统保护模式.</span></span></li><li><span class="name"><span class="innerContentContainer">Abort：例外和异常。可用来实现虚存和内存保护.</span></span></li><li><span class="name"><span class="innerContentContainer">Undefied：未定义指令模型。可用于实现硬件协处理器的软件模拟.</span></span></li><li><span class="name"><span class="innerContentContainer">Interrupt：IRQ，中断处理.</span></span></li><li><span class="name"><span class="innerContentContainer">Fast interrupt：FIQ，快中断.</span></span></li><li><span class="name"><span class="innerContentContainer">除user外，其它6种模式称为特权模式；在特权模式中，除system外，其它5种称为异常模式.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件寄存器</span></span><ul><li><span class="name"><span class="innerContentContainer">硬件寄存器是软件与硬件的唯一接口；软件通过硬件寄存器来控制硬件。</span></span></li><li><span class="name"><span class="innerContentContainer">r0: 返回值</span></span></li><li><span class="name"><span class="innerContentContainer">r1-r4: 入参（入参超过4个, 前3个放在r1-r3, 其它参数组成对象放在其它位置, 对象地址放在r4）</span></span></li><li><span class="name"><span class="innerContentContainer">r13: 堆栈指针</span></span></li><li><span class="name"><span class="innerContentContainer">r14: 当前函数的返回地址.</span></span><ul><li><span class="name"><span class="innerContentContainer">如果当前是异常模式，即为异常模式的返回地址；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">r15: PC 指针，总是指向下一步要执行的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">CPSR: 当前arm模式</span></span></li><li><span class="name"><span class="innerContentContainer">SPSR: 如果当前是异常模式，则保存着之前模式的CPSR。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件中断</span></span><ul><li><span class="name"><span class="innerContentContainer">arm芯片支持的硬件中断是芯片规定死的，不可修改。</span></span></li><li><span class="name"><span class="innerContentContainer">高通rex系统只支持硬中断，目前系统中有50几个中断源。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断与异常</span></span><ul><li><span class="name"><span class="innerContentContainer">中断来自cpu外部，终端发生时，cpu状态不可预测。所以，cpu只有在完成当前指令后才能处理中断。（原子操作会导致中断响应慢）</span></span></li><li><span class="name"><span class="innerContentContainer">异常来自cpu内部。异常发生时，cpu状态可以预知，因此它可打断当前指令的执行而实时执行。即它的实时性强于中断。</span></span></li><li><span class="name"><span class="innerContentContainer">中断向量表</span></span><ul><li><span class="name"><span class="innerContentContainer">内存0地址放着系统的中断向量表。</span></span></li><li><span class="name"><span class="innerContentContainer">arm9的向量表如下：</span></span></li><li><span class="name"><span class="innerContentContainer">0x0是系统的reset</span></span></li><li><span class="name"><span class="innerContentContainer">0x4是 Undefied instruction（未定义的指令）</span></span></li><li><span class="name"><span class="innerContentContainer">0x8是软中断</span></span></li><li><span class="name"><span class="innerContentContainer">0xc是P Abort（code区错误访问，即指针跑飞）</span></span></li><li><span class="name"><span class="innerContentContainer">0x10是D Abort（data区错误访问，即内存错误）</span></span></li><li><span class="name"><span class="innerContentContainer">0x18是 IRQ（中断，这个是系统稳定运行的基石）</span></span></li><li><span class="name"><span class="innerContentContainer">0x1C是 FIQ（快中断）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断处理流程</span></span><ul><li><span class="name"><span class="innerContentContainer">中断发生后，cpu改变模式为IRQ模式，切换寄存器bank，并从0x18取得RAM_FIQ_VECTOR的执行地址。</span></span></li><li><span class="name"><span class="innerContentContainer">跳转到该地址后，会执行此处的b IRQ_Handler指令。后者完成CPU模式切换，进行压栈，然后执行isr处理函数(即 tramp_isr())。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断处理入口: tramp_isr()</span></span><ul><li><span class="name"><span class="innerContentContainer">tramp_isr()查中断向量表，即 isr_func_tbl[]分发中断isr。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">判断当前是否在中断中: rex_is_in_irq_mode()</span></span></li><li><span class="name"><span class="innerContentContainer">定义isr: tramp_set_isr(TRAMP_USB_ISR, usbotg_isr)，TRAMP_USB_ISR 即中断号为57，在 tramp.h 定义。 // usbotg_isr是函数指针, 为中断处理函数.</span></span></li><li><span class="name"><span class="innerContentContainer">FIQ的处理函数: rex_fiq_vector()</span></span></li><li><span class="name"><span class="innerContentContainer">中断处理之前一定要锁中断</span></span><ul><li><span class="name"><span class="innerContentContainer">进入isr处理后，如果不锁中断，新的中断来了，可能导致重入；如果是沿触发，则这个中断后面就不会再发。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断返回的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">先进程恢复上下文（必须先恢复，因为此时压栈是压在中断栈中），检查是否要切换进程。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有高优先级任务处在就绪态，或者进程切换被禁止，则恢复之前的进程上下文，并继续执行之。若需要进行任务切换，则切换到选中的任务运行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断之间是否允许抢占？</span></span><ul><li><span class="name"><span class="innerContentContainer">中断之间允许；FIQ中断不允许，因为所有FIQ中断的优先级都一样。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">arm汇编</span></span><ul><li><span class="name"><span class="innerContentContainer">特殊标记</span></span><ul><li><span class="name"><span class="innerContentContainer">立即数: 即常量，用#做前缀。如 #5即表示立即数5。</span></span></li><li><span class="name"><span class="innerContentContainer">entry: 程序执行的入口点</span></span></li><li><span class="name"><span class="innerContentContainer">area: 定义一个段</span></span></li><li><span class="name"><span class="innerContentContainer">end: 标识源文件结束</span></span></li><li><span class="name"><span class="innerContentContainer">SWI: 软中断指令</span></span></li><li><span class="name"><span class="innerContentContainer">stmdb: 压栈动作</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">跳转</span></span><ul><li><span class="name"><span class="innerContentContainer">B：跳转, 类似goto.</span></span><ul><li><span class="name"><span class="innerContentContainer">B后面的地址是与r15的偏移量，24位长，即只支持向前/向后32M的跳转。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BL：函数跳转, 类似与call, 函数调用</span></span><ul><li><span class="name"><span class="innerContentContainer">跳转之前，先把 r15-&gt;r14.</span></span></li><li><span class="name"><span class="innerContentContainer">等调用完，将 r14 -&gt; r15就可以返回原地址继续执行。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">赋值</span></span><ul><li><span class="name"><span class="innerContentContainer">MOV：赋值</span></span><ul><li><span class="name"><span class="innerContentContainer">mov R0,R0,LSL#3  // 即R0=R0*8</span></span></li><li><span class="name"><span class="innerContentContainer">mov pc,R14&nbsp; &nbsp;// 即PC=R14</span></span></li><li><span class="name"><span class="innerContentContainer">被move的可以是寄存器，或立即数。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MVN：反转赋值</span></span><ul><li><span class="name"><span class="innerContentContainer">与mov的区别在于赋值前值会被反转，算法是+1，再取反。&nbsp; </span></span></li><li><span class="name"><span class="innerContentContainer">mvn R0,#4&nbsp; // 即R0=-5。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">计算</span></span><ul><li><span class="name"><span class="innerContentContainer">ADD: 加法</span></span><ul><li><span class="name"><span class="innerContentContainer">结果最高位如果溢出, 则不进位.</span></span></li><li><span class="name"><span class="innerContentContainer">ADD dest &lt;value1&gt; &lt;value2&gt;   // dest=value1+valve2；其它类似。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SUB: 减法</span></span></li><li><span class="name"><span class="innerContentContainer">MUL: 乘法</span></span></li><li><span class="name"><span class="innerContentContainer">ADC: 进位加法。add最高位不进位。</span></span></li><li><span class="name"><span class="innerContentContainer">CMD：比较</span></span><ul><li><span class="name"><span class="innerContentContainer">比较两个值，如果大，则执行GT指向的指令。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LSL: 逻辑左移</span></span></li><li><span class="name"><span class="innerContentContainer">AND: 逻辑与</span></span></li><li><span class="name"><span class="innerContentContainer">ORR: 逻辑或</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读写内存</span></span><ul><li><span class="name"><span class="innerContentContainer">LDR: 读内存</span></span><ul><li><span class="name"><span class="innerContentContainer">LDR R1,R14&nbsp;  // 将R14中保存的地址写入R1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">STR: 写内存</span></span><ul><li><span class="name"><span class="innerContentContainer">STR R1,R14&nbsp; // 将R14的值写入R1保存的内存地址里去</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ADR：取内存地址放在寄存器中</span></span><ul><li><span class="name"><span class="innerContentContainer">ADR r0,address</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">函数调用时的寄存器读写流程</span></span><ul><li><span class="name"><span class="innerContentContainer">stmdb r13!,{r4-r6,r14}</span></span><ul><li><span class="name"><span class="innerContentContainer">stmdb中的db表示decrease before，压栈时，r13 的值先减少，再压栈。</span></span></li><li><span class="name"><span class="innerContentContainer">r4-r6, r14:显示压栈顺序为r14、r6、r5、r4。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sub r13,r13,#0x40。</span></span><ul><li><span class="name"><span class="innerContentContainer">压栈后分配一块空间给局部变量。此处为64字节。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">add r13,r13,#0x40。</span></span><ul><li><span class="name"><span class="innerContentContainer">释放栈中用于局部变量的空间。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ldmia r13!,{r4-r6,pc}</span></span><ul><li><span class="name"><span class="innerContentContainer">lamia中的ia表示increase after，出栈时，栈顶的内容先出栈，r13在增加。</span></span></li><li><span class="name"><span class="innerContentContainer">然后r4、r5、r6、r14先后出栈（即写入各寄存器）</span></span></li><li><span class="name"><span class="innerContentContainer">原来r14的值写入PC寄存器，从而达到跳转到返回地址的目的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">blx 函数名</span></span><ul><li><span class="name"><span class="innerContentContainer">调用指定函数.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">GPIO</span></span><ul><li><span class="name"><span class="innerContentContainer">GPIO的状态:</span></span><ul><li><span class="name"><span class="innerContentContainer">输入还是输出:</span></span><ul><li><span class="name"><span class="innerContentContainer">input</span></span></li><li><span class="name"><span class="innerContentContainer">output</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">上拉还是下拉:</span></span><ul><li><span class="name"><span class="innerContentContainer">上拉: pull_up</span></span></li><li><span class="name"><span class="innerContentContainer">下拉: pull_down</span></span></li><li><span class="name"><span class="innerContentContainer">不拉: nopull</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">何谓上拉?</span></span><ul><li><span class="name"><span class="innerContentContainer">上拉是将不确定的信号通过一个电阻嵌位在高电平，电阻同时起限流作用。</span></span></li><li><span class="name"><span class="innerContentContainer">具体做法是: 手机上通过电阻上拉到某一电源上，使之无法轻易放电, 从而维持一个高电平。</span></span></li><li><span class="name"><span class="innerContentContainer">上拉时对外部电路注入电流，可起到供电作用。</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO上拉的驱动能力(即供电能力)取决于上拉电阻的阻值不同。</span></span><ul><li><span class="name"><span class="innerContentContainer">电阻大，电流小，节约功耗；</span></span></li><li><span class="name"><span class="innerContentContainer">电阻小，电流大，驱动能力强。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">空悬管脚为何要接上拉？</span></span><ul><li><span class="name"><span class="innerContentContainer">管脚空悬比较容易收外界电磁干扰，接一个上拉电阻可降低输入阻抗。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">何谓下拉?</span></span><ul><li><span class="name"><span class="innerContentContainer">下拉是将不确定的信号通过接地保持0v.</span></span></li><li><span class="name"><span class="innerContentContainer">具体做法是: 将电阻接到地，保持0v。这就是“嵌位”。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">何谓不拉?</span></span><ul><li><span class="name"><span class="innerContentContainer">高阻态，就是nopull，一般设置几M欧以上的电阻，以阻断电路。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">漏电流</span></span><ul><li><span class="name"><span class="innerContentContainer">直接将上拉电阻和下拉电阻连通，即产生漏电流，将导致功耗偏大。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何看GPIO状态？</span></span><ul><li><span class="name"><span class="innerContentContainer">gpio_configs[]可看到GPIO配置情况；</span></span><ul><li><span class="name"><span class="innerContentContainer">寻找哪里修改GPIO状态的一个技巧 -&gt; trace跟踪中，在gpio_configs[]处打写断点，就可以找到。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bio_gpio_image[]，对于输出的GPIO，可看到其值，每位对应一个GPIO。</span></span></li><li><span class="name"><span class="innerContentContainer">对于配成输入的GPIO，只能使用标准接口实时读取其值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPIO的输出电流</span></span><ul><li><span class="name"><span class="innerContentContainer">配置为输出时，arm默认的输出电流为5ma.</span></span></li><li><span class="name"><span class="innerContentContainer">但是高通做了扩张，驱动能力可配置为High和Normal两种，前者7ma，后者5ma。</span></span></li><li><span class="name"><span class="innerContentContainer">配置为输入或不拉时，也有小的输出电流，不超过1ma。</span></span></li><li><span class="name"><span class="innerContentContainer">由于GPIO有输出电流, 所以主板上的一些小器件由GPIO来<b>供电</b>.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPIO的第二功能</span></span><ul><li><span class="name"><span class="innerContentContainer">第二功能即在某种情况下的复用。两个功能不能同时用。</span></span></li><li><span class="name"><span class="innerContentContainer">使用BIO_FUNC_SELECT()来设置。</span></span></li><li><span class="name"><span class="innerContentContainer">硬件连线会接两根线到GPIO引脚上.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码中如何读写硬件寄存器？</span></span><ul><li><span class="name"><span class="innerContentContainer">输入：hwio_inm(NAND_FLASH_ECC_0,,);</span></span></li><li><span class="name"><span class="innerContentContainer">输出：gpio_out(camif_shdn_ins, GPIO_LOW_VALUE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPIO的level触发和沿触发</span></span><ul><li><span class="name"><span class="innerContentContainer">level触发: 只要器件状态改变，中断一直会触发.</span></span></li><li><span class="name"><span class="innerContentContainer">沿触发（detect_edge）: 只有在改变发生时触发一次. 分为:</span></span><ul><li><span class="name"><span class="innerContentContainer">上升沿触发</span></span></li><li><span class="name"><span class="innerContentContainer">下降沿触发</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">GPIO中断源</span></span><ul><li><span class="name"><span class="innerContentContainer">GPIO相关的中断源有两个（GPIO 0-38、67-105用一个，39-61用另外一个）。</span></span></li><li><span class="name"><span class="innerContentContainer">任何GPIO状态变化，都会触发这两个中断源中的一个。</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ADC</span></span><ul><li><span class="name"><span class="innerContentContainer">ADC: 模数转化器, analog to digital converter。负责采样.</span></span></li><li><span class="name"><span class="innerContentContainer">ADC的作用是通过硬件将一个模拟电平转换成0-255的一个数组（又叫raw值），软件通过算法将raw值转化为实际电平。</span></span></li><li><span class="name"><span class="innerContentContainer">ADC的原理</span></span><ul><li><span class="name"><span class="innerContentContainer">一些器件的测试单位就是电压，如电池电压、充电器电压，可直接转换。</span></span></li><li><span class="name"><span class="innerContentContainer">某些指标不是电压，比如PA温度、电池温度等，则通过热敏电阻将温度转换为电压，其转换公式需要校准。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">高通平台ADC的采样精度: 0.008mV。</span></span></li><li><span class="name"><span class="innerContentContainer">代码: pm_adc_config_mux()，设置adc的三个属性，即通路控制、adc offset值和gain增益控制。</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO和ADC的关系和区别</span></span><ul><li><span class="name"><span class="innerContentContainer">两者都是CPU引脚。</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO只有高和低两种状态，是典型的数字引脚.</span></span></li><li><span class="name"><span class="innerContentContainer">ADC是多值，可测量外围电路的电压（高通平台支持0-255种状态）。</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO有输入、删除两种模式。输出模式下，可控制外围电路，并可提供5mA的电流来驱动一些小器件。</span></span></li><li><span class="name"><span class="innerContentContainer">ADC只有输入。</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO有中断和轮询两种访问方式.</span></span></li><li><span class="name"><span class="innerContentContainer">ADC只有轮询。</span></span></li><li><span class="name"><span class="innerContentContainer">arm9有100多个GPIO引脚.</span></span></li><li><span class="name"><span class="innerContentContainer">arm9上ADC只有7个。其中一个接到PM上，又被分为10个，当然精度只有原来的1/10。一共可用的有16路。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件版本号方案</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 放在flash中的一个叫hwinfo的独立分区中。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 使用3-5个GPIO来识别.</span></span><ul><li><span class="name"><span class="innerContentContainer">如果采用4个GPIO表示硬件版本, 则可以这样安排: </span></span></li><li><span class="name"><span class="innerContentContainer">前2个表示主版本号，标识不同产品；</span></span></li><li><span class="name"><span class="innerContentContainer">后2个表示子版本号，标识硬件改版、器件替代和延伸产品。</span></span></li><li><span class="name"><span class="innerContentContainer">每个GPIO有三种内部状态：up、down、nopull（不拉）。即主版本号空间和子版本号空间各为9个。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 使用一个adc来识别.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件时钟源</span></span><ul><li><span class="name"><span class="innerContentContainer">手机上的硬件时钟源有哪些？</span></span><ul><li><span class="name"><span class="innerContentContainer">睡眠是使用RTC时钟, </span></span><ul><li><span class="name"><span class="innerContentContainer">也叫睡眠时钟, 频率是32.768K。</span></span></li><li><span class="name"><span class="innerContentContainer">它由纽扣电池供电，在系统掉电时还在跑。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PBL runs at TCXO；频率是19.2M。</span></span><ul><li><span class="name"><span class="innerContentContainer">I2C用TCXO时钟。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BL runs at 48 MHz；</span></span></li><li><span class="name"><span class="innerContentContainer">OSBL runs at 384 MHz；</span></span></li><li><span class="name"><span class="innerContentContainer">android会按需运行中不同主频上。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置外围设备的时钟: clk_regime_set_periph_clk()</span></span></li><li><span class="name"><span class="innerContentContainer">锁相环</span></span><ul><li><span class="name"><span class="innerContentContainer">sd卡时钟最高可为50M，比手机主晶振（19.2M）要高，是因为用了锁相环。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">动态调整cpu速率</span></span><ul><li><span class="name"><span class="innerContentContainer">申请提高CPU速率：clk_regime_register_for_cpu_resource()</span></span><ul><li><span class="name"><span class="innerContentContainer">由task调用，只有部分task有权利。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">申请恢复CPU速率: clk_regime_deregister_for_cpu_resource()</span></span></li><li><span class="name"><span class="innerContentContainer">查看当前CPU频率</span></span><ul><li><span class="name"><span class="innerContentContainer">cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies</span></span></li><li><span class="name"><span class="innerContentContainer">显示的最后一个数字即是CPU速率，如 1152000即1.2G。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">总线</span></span><ul><li><span class="name"><span class="innerContentContainer">串口</span></span><ul><li><span class="name"><span class="innerContentContainer">UART(TX,RX)就是两线，一根发送一根接收，可以全双工通信。</span></span></li><li><span class="name"><span class="innerContentContainer">数据是异步传输的，对双方的时序要求比较严格。</span></span></li><li><span class="name"><span class="innerContentContainer">通信速度不是很快。优势是实现简单。</span></span></li><li><span class="name"><span class="innerContentContainer">用于蓝牙.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SPI总线</span></span><ul><li><span class="name"><span class="innerContentContainer">SPI，Serial Peripheral Interface：串行外设接口；是moto提出的串口总线标准。</span></span></li><li><span class="name"><span class="innerContentContainer">SPI总线的优势</span></span><ul><li><span class="name"><span class="innerContentContainer">和串口比，SPI多了一条同步时钟线。因此对通信双方的时序要求不严格，不同设备之间可以很容易结合，而且速度较快。</span></span></li><li><span class="name"><span class="innerContentContainer">一般用在内部元件之间的高速数据通信上，如大容量存储器等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SBI有三线，由3根GPIO实现。其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">SBST用于数据传输初始化；</span></span></li><li><span class="name"><span class="innerContentContainer">SBDT用于双向数据传输，</span></span></li><li><span class="name"><span class="innerContentContainer">SBCK提供时钟。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SBI 常用于CPU和其它外围芯片的通讯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MDDI/并口</span></span><ul><li><span class="name"><span class="innerContentContainer">Mobile Display Digital Interface，高通公司于2004年提出的，通过减少连线可提高可靠性并降低功耗。</span></span></li><li><span class="name"><span class="innerContentContainer">物理结构</span></span><ul><li><span class="name"><span class="innerContentContainer">host_data</span></span></li><li><span class="name"><span class="innerContentContainer">host_strobe</span></span></li><li><span class="name"><span class="innerContentContainer">client_data</span></span></li><li><span class="name"><span class="innerContentContainer">client_strobe</span></span></li><li><span class="name"><span class="innerContentContainer">power</span></span></li><li><span class="name"><span class="innerContentContainer">GND（接地）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用于camera.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">I2C总线</span></span><ul><li><span class="name"><span class="innerContentContainer">由80年代飞利浦发明。I2C占用的空间小，目前广泛用于系统内部。</span></span></li><li><span class="name"><span class="innerContentContainer">物理结构：</span></span><ul><li><span class="name"><span class="innerContentContainer">由数据线SDA和时钟线SCL构成，串行线。</span></span></li><li><span class="name"><span class="innerContentContainer">各器件均并联在一条总线上。</span></span></li><li><span class="name"><span class="innerContentContainer">总线的长度可最高25英尺，能以10Kbps的最大传输速率支持40个组件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">I2C的控制方式</span></span><ul><li><span class="name"><span class="innerContentContainer">各器件均并联在一条总线上，但各有唯一地址。</span></span></li><li><span class="name"><span class="innerContentContainer">在信息的传输过程中，每一器件既可能是主控器或被控器，也可能是发送器或接收器，这取决于它所要完成的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">支持多主控(multimastering)，其中任何能够进行收发的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。</span></span></li><li><span class="name"><span class="innerContentContainer">在任何时间点上只能有一个主控。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">I2C总线是慢速设备</span></span><ul><li><span class="name"><span class="innerContentContainer">它不适用于需要高速刷新的器件，否则大部分CPU时间就会耗在读I2C上。一般刷新频率不能超过30Hz。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用于camera 控制、sensor、tp等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SDIO</span></span><ul><li><span class="name"><span class="innerContentContainer">用于wifi、emmc、sd卡</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB总线</span></span><ul><li><span class="name"><span class="innerContentContainer">用于USB设备.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">DMA传输</span></span><ul><li><span class="name"><span class="innerContentContainer">DMA传输的条件：</span></span><ul><li><span class="name"><span class="innerContentContainer">DMA用的内存必须4字节对齐</span></span><ul><li><span class="name"><span class="innerContentContainer">让某个变量四字节对齐：__align(4)</span></span></li><li><span class="name"><span class="innerContentContainer">让某个文件4字节对齐：# pragma pack(4)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DMA不能用cache</span></span><ul><li><span class="name"><span class="innerContentContainer">所以为DMA传输分配的内存，要用专门内存分配接口。</span></span></li><li><span class="name"><span class="innerContentContainer">普通接口分配的内存会被系统放进cache中。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">熔丝</span></span><ul><li><span class="name"><span class="innerContentContainer">熔丝都是一次性可写，将寄存器中熔丝对应的bit设置为1，则熔丝将被熔断，不再可写入。</span></span></li><li><span class="name"><span class="innerContentContainer">熔丝的用法： 系统支持两个熔丝，硬件寄存器 config_lsb 和 config_msb。</span></span></li><li><span class="name"><span class="innerContentContainer">熔丝相关的工具</span></span><ul><li><span class="name"><span class="innerContentContainer">高通的写工具有QDART。</span></span></li><li><span class="name"><span class="innerContentContainer">相关diag命令是：FTM_QFUSE_READ, FTM_QFUSE_WRITE。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">电路常识</span></span><ul><li><span class="name"><span class="innerContentContainer">几种电学单位的隐喻</span></span><ul><li><span class="name"><span class="innerContentContainer">电量库仑是数量之总量值，本质是电子的数量，“微安时”等价于库仑；</span></span></li><li><span class="name"><span class="innerContentContainer">电流安培是数量之流量值，即总量/时间，也即单位时间的通过量；</span></span></li><li><span class="name"><span class="innerContentContainer">电压伏特是质量值，即电子个体的能量值的平均值；</span></span></li><li><span class="name"><span class="innerContentContainer">功焦耳是效用之总量值，功率是效用之流量值（所谓效用是指对他者的作用）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电平</span></span><ul><li><span class="name"><span class="innerContentContainer">电平即电路中两点间的电量单位的相对比值，单位即为分贝。</span></span></li><li><span class="name"><span class="innerContentContainer">电量单位包括功率、电压、电流。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">欧姆定律</span></span><ul><li><span class="name"><span class="innerContentContainer">I（电流）= U（电压）/ R（电阻）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电功率公式</span></span><ul><li><span class="name"><span class="innerContentContainer">P（功率）= W（功率）/ t（时间）= I^2·R = I^2/R = I·U</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">手机接地的含义</span></span><ul><li><span class="name"><span class="innerContentContainer">手机不可能真正接地。其接地是指接到电池负极。</span></span></li><li><span class="name"><span class="innerContentContainer">一般电路板会规定一个“地”层，所有的地线都接到那里，然后再连接到电池负极。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何防静电？</span></span><ul><li><span class="name"><span class="innerContentContainer">暴露在外面的接口，电路都加了稳压管之内来防止静电；</span></span></li><li><span class="name"><span class="innerContentContainer">还有就是加强接地，比如camera，外框要接地，否则静电导致混乱。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">电源管理</span></span><ul><li><span class="name"><span class="innerContentContainer">芯片的core电压和IO电压</span></span><ul><li><span class="name"><span class="innerContentContainer">CPU的工作电压分为两个方面：CPU的核心电压与I/O电压。</span></span></li><li><span class="name"><span class="innerContentContainer">核心电压即驱动CPU核心芯片的电压，I/O电压则指驱动I/O电路的电压。</span></span></li><li><span class="name"><span class="innerContentContainer">通常CPU的核心电压小于等于I/O电压。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LDO电源</span></span><ul><li><span class="name"><span class="innerContentContainer">PM芯片有多个LDO，用于提供不同的电压。</span></span></li><li><span class="name"><span class="innerContentContainer">LDO特点是其电压受软件控制。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sdram电源的开关： 在上电时打开，关机是才能够下电。</span></span></li><li><span class="name"><span class="innerContentContainer">MPP引脚</span></span><ul><li><span class="name"><span class="innerContentContainer">多功能脚，主要用于电平转换。</span></span></li><li><span class="name"><span class="innerContentContainer">可做电源用，其特点是软件可以通过控制其内部电阻来设定其通过的电流大小。</span></span></li><li><span class="name"><span class="innerContentContainer">其它功能包括数字采用、模拟采样、数字输出、模拟输出。</span></span></li><li><span class="name"><span class="innerContentContainer">常用的MPP管脚</span></span><ul><li><span class="name"><span class="innerContentContainer">MPP4的电流区间是[40ma,150ma]</span></span></li><li><span class="name"><span class="innerContentContainer">MPP3的电流区间为[150ma,600ma]</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">mic bias电源</span></span><ul><li><span class="name"><span class="innerContentContainer">即mic的偏置电压，为mic供电。</span></span></li><li><span class="name"><span class="innerContentContainer">在使用mic前必须把它拉高，不用时处在低电平。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软件寻址电源</span></span><ul><li><span class="name"><span class="innerContentContainer">字符串与电源对象的对应关系，见全局变量 vreg vregs[]。</span></span></li><li><span class="name"><span class="innerContentContainer">内容："msma”-id:0，“msmp”-id:1</span></span></li><li><span class="name"><span class="innerContentContainer">api： vreg_get()，根据字符串获取电源对象vreg。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软件控制电源的接口：</span></span><ul><li><span class="name"><span class="innerContentContainer">vreg_set_level(vreg_gp2, 1800); </span></span></li><li><span class="name"><span class="innerContentContainer">vreg_gp2是电源对象；</span></span></li><li><span class="name"><span class="innerContentContainer">1800是电压值，单位是毫伏。</span></span></li><li><span class="name"><span class="innerContentContainer">实际上是通过rpc让modem侧配置。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">电路元器件分类</span></span><ul><li><span class="name"><span class="innerContentContainer">mos管：负责开关电源</span></span></li><li><span class="name"><span class="innerContentContainer">电感</span></span><ul><li><span class="name"><span class="innerContentContainer">滤波，平滑电流的波峰波谷，即所谓的毛刺。</span></span></li><li><span class="name"><span class="innerContentContainer">电感通过电磁感应原理，暂存能量。</span></span></li><li><span class="name"><span class="innerContentContainer">经过的电流越大，磁场越强；而磁场也会转成电流。</span></span></li><li><span class="name"><span class="innerContentContainer">这样，波峰的电流的一部分能量将转成磁场，并传递给后续电流。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电阻</span></span><ul><li><span class="name"><span class="innerContentContainer">电阻是耗能器件，通过将电能转化为热能，在电路中起分压分流作用。</span></span></li><li><span class="name"><span class="innerContentContainer">并联时分压；串联时分流。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">电容</span></span><ul><li><span class="name"><span class="innerContentContainer">和电感类似，电容也用于滤波。</span></span></li><li><span class="name"><span class="innerContentContainer">它通过内部的电解质（液体）暂存能量，将波峰的能量吸收，并补偿给波谷。</span></span></li><li><span class="name"><span class="innerContentContainer">电路设计上，电容要尽量靠近地和供电管脚。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>