<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">46-SQL</span><ul><li><span class="name">MySQL 数据类型 详解  <span class="contentTag" title="Filter #档案">#<span class="contentTagText">档案</span><span class="contentTagNub"></span></span> </span></li><li><span class="name">处理时间</span><ul><li><span class="name">查询一天：</span><ul><li><span class="name">select * from table where to_days(column_time) = to_days(now());</span></li><li><span class="name">select * from table where date(column_time) = curdate();</span></li></ul></li><li><span class="name">查询一周：</span><ul><li><span class="name">select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time);</span></li></ul></li><li><span class="name">查询一个月：</span><ul><li><span class="name">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time);</span></li></ul></li><li><span class="name">查询一周：</span><ul><li><span class="name">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 WEEK) &lt;= date(column_time);</span></li></ul></li></ul></li><li><span class="name">跨表查询</span><ul><li><span class="name">左链接（left join）</span><ul><li><span class="name">指从左表中返回所有的值，即使右表中没有满足条件的行。</span></li><li><span class="name">select * from table1 left join table2 ON table1.col = table2.col</span></li></ul></li><li><span class="name">右链接（right join）:  和左链接正好相反。</span></li><li><span class="name">内链接（Inner&nbsp;join）:  即join，指两个表中满足条件的行进行链接。&nbsp;</span></li><li><span class="name">内链接去重复:  使用 distinct 。&nbsp;</span></li><li><span class="name">全链接（full join）</span><ul><li><span class="name">将两个表的所有行都返回。</span></li><li><span class="name">Mysql不支持Full join,不过可以通过UNION 关键字来合并 LEFT JOIN 与 RIGHT JOIN来模拟FULL join.</span></li></ul></li></ul></li><li><span class="name">巧用update和join、count()更新统计字段</span><ul><li><span class="name">UPDATE property u</span><ul><li><span class="name">LEFT JOIN thing_property u_m ON u_m.property_UUID=u.property_UUID</span></li><li><span class="name">SET u.hot_index=(SELECT COUNT(property_UUID) FROM thing_property WHERE property_UUID=u.property_UUID)</span></li><li><span class="name">WHERE u.property_UUID=u_m.property_UUID ;</span></li></ul></li></ul></li><li><span class="name">插入时判断是否重复: insert or ignore into</span></li><li><span class="name">统计字数: SELECT&nbsp;sum(char_length(thing))&nbsp;FROM&nbsp;`thing_time`</span></li><li><span class="name">mysql允许我们在一条sql语句中批量插入数据:</span><ul><li><span class="name">INSERT&nbsp;INTO&nbsp;example  (example_id,&nbsp;name,&nbsp;value,&nbsp;other_value)  VALUES</span><ul><li><span class="name">(100,&nbsp;'Name&nbsp;1',&nbsp;'Value&nbsp;1',&nbsp;'Other&nbsp;1'),</span></li><li><span class="name">(101,&nbsp;'Name&nbsp;2',&nbsp;'Value&nbsp;2',&nbsp;'Other&nbsp;2'),</span></li><li><span class="name">(102,&nbsp;'Name&nbsp;3',&nbsp;'Value&nbsp;3',&nbsp;'Other&nbsp;3'),</span></li></ul></li></ul></li><li><span class="name"><b>尽可能不用 in子句:  性能很差。不如用联合 inner。</b></span></li><li><span class="name">尽可能不用 distinct</span><ul><li><span class="name">大多数情况下，Distinct函数都会导致对最终结果集完成一次排序，因此，这就成为成本最昂贵的排序之一。Distinct一直是SQL语言中成本最高的函数之一。解决方法有两个：</span></li><li><span class="name">使用GroupBy（V9之前），这会利用关联索引来消除为确定唯一性所导致的排序。</span></li><li><span class="name">使用一个Exists子查询重写查询。如果某个表可能导致重复（由于是一对多关系），但是这个表中并不包含结果集将返回的数据，这种情况下这种方法就很适用。&nbsp;</span></li></ul></li><li><span class="name">3个常用的PHP访问数据的代码</span><ul><li><span class="name">返回一个数组的情况</span><ul><li><span class="name">$tag_uuids = array();</span></li><li><span class="name">$sql_string&nbsp;= "select property_UUID, hot_index from property";</span></li><li><span class="name">$result&nbsp;=&nbsp;mysql_query($sql_string);</span></li><li><span class="name">if ($result == FALSE) {</span><ul><li><span class="name">$GLOBALS['log']-&gt;error("error: re_calc_tag_hot_index() -- $sql_string 。");</span></li><li><span class="name">return&nbsp;0;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">while($row =&nbsp;mysql_fetch_array($result)) {</span><ul><li><span class="name">$tag_uuids[] = $row['property_UUID'];</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">返回一个值的情况</span><ul><li><span class="name">$sql_string = "select count(*) from thing_time ";</span></li><li><span class="name">$result = mysql_query($sql_string);</span></li><li><span class="name">if($result == FALSE) {</span><ul><li><span class="name">$GLOBALS['log']-&gt;error("error: get_thing_count_by_period() -- $sql_string 。");</span></li><li><span class="name">return -1;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">$row = mysql_fetch_row($result); &nbsp; &nbsp;// 返回一行.</span></li><li><span class="name">if ($row == NULL) {</span><ul><li><span class="name">return "";</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">return $row[0];</span></li></ul></li><li><span class="name">不需要返回值的情况</span><ul><li><span class="name">$sql_string = "update thing_time set year_order=time where time_type=2";</span></li><li><span class="name">if (!mysql_query($sql_string)) {</span><ul><li><span class="name">$GLOBALS['log']-&gt;error("error: re_calc_year_order() -- $sql_string 。");</span></li><li><span class="name">return 0;</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li></ul>
  </body>
</html>