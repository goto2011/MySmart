<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>20-FWK-Input   <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/categories/Android/View/">https://www.viseator.com/categories/Android/View/</a> , <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://gityuan.com/2016/12/31/input-ipc/">http://gityuan.com/2016/12/31/input-ipc/</a>,  <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="http://www.mysixue.com/?p=144">http://www.mysixue.com/?p=144</a>, <span class="contentTag" title="Filter @Good">@<span class="contentTagText">Good</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/2017/09/14/android_view_event_1/">https://www.viseator.com/2017/09/14/android_view_event_1/</a></span></span></li><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://blog.csdn.net/guolin_blog/article/details/9097463/">https://blog.csdn.net/guolin_blog/article/details/9097463/</a></span></span></li><li><span class="name"><span class="innerContentContainer">代码静态结构</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinputflinger.so">libinputflinger.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">InputDispatcher.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputManager.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">EventHub.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputListener.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/native/libs/input/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinput.so">libinput.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Input.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputDevice.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">Keyboard.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">KeyCharacterMap.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">IInputFlinger.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/base/services/core/  --  services. jar,  libandroid_services.so</span></span><ul><li><span class="name"><span class="innerContentContainer">java/com/android/server/input/InputManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">jni/com_android_server_input_InputManagerService.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">frameworks/base/libs/input/  --  <a class="contentLink" target="_blank" rel="noreferrer" href="http://libinputservice.so">libinputservice.so</a></span></span><ul><li><span class="name"><span class="innerContentContainer">PointerController.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">SpriteController.cpp</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">底层架构</span></span><ul><li><span class="name"><span class="innerContentContainer">用户空间可以用 linux/input.h 中定义的 EVIOCG* ioctls 来获得当前事件编码和参数的状态。</span></span></li><li><span class="name"><span class="innerContentContainer">设备的所支持的上报事件种类也可以通过 sysfs的 class/input/event*/device/capabilities/ 来获取. </span></span></li><li><span class="name"><span class="innerContentContainer">设备的特性和可以通过 class/input/event*/device/properties 来获取。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IMS初始化流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>开机过程中, systemserver.java, 调用</b>startOtherServices(), 创建InputManagerService 对象。</span></span></li><li><span class="name"><span class="innerContentContainer">为这个对象设置与 WindowManagerService相关的回调函数，然后调用InputManagerService的start()。</span></span></li><li><span class="name"><span class="innerContentContainer">start()通过JNI调用，进行native层初始化。</span></span></li><li><span class="name"><span class="innerContentContainer">在native层初始化的时候，创建 NativeInputMnager 的对象（重要）。</span></span><ul><li><span class="name"><span class="innerContentContainer">InputReader 和 InputDispatcher 和其他模块的交互由 NativeInputMnager&nbsp;负责中转。</span></span></li><li><span class="name"><span class="innerContentContainer">NativeInputMnager 持有 InputReaderPolicyInterface和 InputDispatcherPolicyInterface。</span></span></li><li><span class="name"><span class="innerContentContainer">负责创建 InputManager。</span></span><ul><li><span class="name"><span class="innerContentContainer">InputManager 创建 InputReader 和 InputDispatcher 两个线程。 代码在: InputManager::InputManager()</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader::InputReader() 构造时, mQueuedListener = new QueuedInputListener(listener);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">负责管理 EventHub，InputReader，InputReaderThread，InputDispatcher，InputDispatcherThread等对象。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件上报流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">EventHub</span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/EventHub.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">EventHub是事件的起源地，所有的事件都是它从驱动中读取出来的。</span></span></li><li><span class="name"><span class="innerContentContainer">负责监视  /dev/input/eventX 多个FD上产生的事件，包括设备添加，移除，以及触摸等事件, 然后把事件封装成 RawEvent 结构体供 InputReader 使用。</span></span></li><li><span class="name"><span class="innerContentContainer">此时的数据结构叫 RawEvent。数据类型参见 log打印。</span></span></li><li><span class="name"><span class="innerContentContainer">对设备节点的监听, 是通过Linux提供的epoll机制来实现。epoll机制简单地说就是 I/O多路复用.</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 epoll_wait()来监听所需要的文件描述符的变化。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>InputReader</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/InputReader.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">是 systemserver子线程。</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader 持有 EventHub 和 InputDispatcher , 是Input子系统的核心. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>loopOnce</b>() 是核心方式。在线程中死循环，循环一次处理一个事件。流程是：</span></span></li><li><span class="name"><span class="innerContentContainer"><b>1. 接受事件</b></span></span><ul><li><span class="name"><span class="innerContentContainer">mEventHub-&gt;getEvents()   // 通过 threadLoop，周期性的从EventHub中读取事件。</span></span><ul><li><span class="name"><span class="innerContentContainer">这些事件是 rawdata，即没有经过加工处理的事件；</span></span></li><li><span class="name"><span class="innerContentContainer">最终调用 epoll_wait() 来读取 /dev/input/input* 上的事件信息.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>2. 对事件信息进行数据封装</b></span></span><ul><li><span class="name"><span class="innerContentContainer">processEventLocked()</span></span></li><li><span class="name"><span class="innerContentContainer">device-&gt;process(rawEvents, count);   // InputDevice代表输入设备</span></span></li><li><span class="name"><span class="innerContentContainer">mapper-&gt;process(rawEvent);     // InputMapper, 负责定义每种键值事件是如何处理的。</span></span></li><li><span class="name"><span class="innerContentContainer">触摸屏有如下处理:</span></span><ul><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::process(const RawEvent* rawEvent)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::sync(nsecs_t when)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::processRawTouches(bool timeout)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::cookAndDispatch(nsecs_t when)</span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) </span></span></li><li><span class="name"><span class="innerContentContainer">void TouchInputMapper::<b>dispatchMotion</b>(nsecs_t when...)  // 封装 NotifyArgs事件</span></span></li><li><span class="name"><span class="innerContentContainer">void QueuedInputListener::notifyMotion(...)</span></span></li><li><span class="name"><span class="innerContentContainer">mArgsQueue.<b>push</b>();   // 事件数据保存到 QueuedInputListener的 mArgsQueue中.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>3. 事件分发</b></span></span><ul><li><span class="name"><span class="innerContentContainer">mQueuedListener-&gt;flush();   // QueuedInputListener, 事件监视器</span></span></li><li><span class="name"><span class="innerContentContainer">NotifyMotionArgs::notify()</span></span></li><li><span class="name"><span class="innerContentContainer">listener-&gt;<b>notifyMotion</b>(this);  // 按键是notifyKey()</span></span><ul><li><span class="name"><span class="innerContentContainer">listener 即 QueuedInputListener, 事件监视器, 持有 mInnerListener, 指向 InputDispatcher对象.</span></span></li><li><span class="name"><span class="innerContentContainer">这便是 InputReader跟 InputDispatcher交互的中转站。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputDispatcher::notifyMotion()   // 这里就是 InputDispatcher了.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">InputMapper</span></span><ul><li><span class="name"><span class="innerContentContainer">InputReader对原始输入事件的处理都是放在InputMapper 中去。</span></span></li><li><span class="name"><span class="innerContentContainer">每种输入设备都有一个InputMapper 类。比如触摸屏有两个，SigleTouchInputMapper 和 MultiTouchInputMapper。</span></span></li><li><span class="name"><span class="innerContentContainer">核心函数是sync。sync的含义是一个完整的事件接收完毕。因为很多事件是分多次上报。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>InputDispatcher</b></span></span><ul><li><span class="name"><span class="innerContentContainer">frameworks/native/services/inputflinger/InputDispatcher.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher为<b>systemserver子线程。</b></span></span></li><li><span class="name"><span class="innerContentContainer">有如下关键函数：</span></span></li><li><span class="name"><span class="innerContentContainer"><b>notifyMotion</b>()  // 将 NotifyArgs 构建成KeyEvent。</span></span></li><li><span class="name"><span class="innerContentContainer">事件在入队前(before enqueue)的处理：</span></span><ul><li><span class="name"><span class="innerContentContainer">NativeInputManager</span></span></li><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeQueueing</span></span></li><li><span class="name"><span class="innerContentContainer">InputManagerService.interceptKeyBeforeQueueing</span></span></li><li><span class="name"><span class="innerContentContainer">InputMonitor.interceptKeyBeforeQueueing </span></span></li><li><span class="name"><span class="innerContentContainer">PhoneWindowManager.<b>interceptKeyBeforeQueueing</b></span></span></li><li><span class="name"><span class="innerContentContainer">首先把事件都标记上 PASS_TO_USER，即这个事件要交给应用程序去处理，但是在处理过程中决定，有些事件是没必要传递给应用程序的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">enqueueInboundEventLocked(newEntry);  // 将事件entry 放入消息队列.</span></span></li><li><span class="name"><span class="innerContentContainer">dispatchOnce()   // 死循环执行事件分发. </span></span></li><li><span class="name"><span class="innerContentContainer">dispatchMotionLocked()&nbsp; // 分发触摸事件.</span></span><ul><li><span class="name"><span class="innerContentContainer">查找事件坐标所在的窗口，然后把事件分发给它。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dispatchKeyLocked()  // 分发按键事件</span></span><ul><li><span class="name"><span class="innerContentContainer">寻找当前焦点窗口，然后分发事件给它。</span></span></li><li><span class="name"><span class="innerContentContainer">根据每一个target（一个事件可以有多个）对应的inputChannel找到connection，</span></span></li><li><span class="name"><span class="innerContentContainer">然后&nbsp;prepareDispatchCycleLocked使用这个connection把事件逐个分发到target中。 </span></span></li><li><span class="name"><span class="innerContentContainer">在prepareDispatchCycleLocked方法中，主要就是根据事件是否可以分割，分别把事件放入队列。</span></span></li><li><span class="name"><span class="innerContentContainer">在入队列的之后，InputPublisher的发布事件的队列就不再为空，然后会调用&nbsp;startDispatchCycleLocked方法，通过InputPublisher开始发布事件。</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher 其它关键功能</span></span><ul><li><span class="name"><span class="innerContentContainer">检测事件处理超时，生成ANR。</span></span></li><li><span class="name"></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">开始事件的分发，通过InputChannel把事件分发给WindowManager或者应用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果是应用的话，可通过 registerInputChannel来定义输入事件的目标。</span></span></li><li><span class="name"><span class="innerContentContainer">将 KeyEvent传递给WindowManagerService去处理。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>InputChannel</b></span></span><ul><li><span class="name"><span class="innerContentContainer">InputChannel 负责管理IMS和各应用activity之间的socket通道。</span></span></li><li><span class="name"><span class="innerContentContainer">各活跃的activity都有自己的 InputChannel对象。在 ViewRootImpl.<b>setView</b>() 中创建。然后把 InputChannel 传递给 WindowManagerService。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 sendMessage() 发送事件。其流程是：</span></span><ul><li><span class="name"><span class="innerContentContainer">事件通过WMS建立的InputChannel的 sendMessage()函数发送.</span></span></li><li><span class="name"><span class="innerContentContainer">直接调用send()函数向fd表示的socket中写入数.</span></span></li><li><span class="name"><span class="innerContentContainer">在另一边的 epoll_wait()调用，会因fd数据的到来而唤醒，并通过fd找到注册好的request listener.</span></span></li><li><span class="name"><span class="innerContentContainer">进而调用 request中的 NativeInputEventReceiver的 handleEvent()方法，参数就是我们接收到的事件信息与数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过 receiveMessage() 接受事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputPublisher</span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp 的内部类.</span></span></li><li><span class="name"><span class="innerContentContainer">调用 InputChannel 发送事件, 并接受finish事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputConsumer</span></span><ul><li><span class="name"><span class="innerContentContainer">InputTransport.cpp 的内部类</span></span></li><li><span class="name"><span class="innerContentContainer">消费来自 inputChannel 的事件.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputFilter</span></span><ul><li><span class="name"><span class="innerContentContainer">这是一个java类，负责对事件进行拦截, 过滤. 比如手势识别, 辅助功能, 盲人模式等模块会用. </span></span></li><li><span class="name"><span class="innerContentContainer">AccessbilityManagerService 负责初始化 InputFilter.</span></span></li><li><span class="name"><span class="innerContentContainer">然后赋值给 InputManagerService. InputManagerService&nbsp;只支持一个InputFilter,&nbsp;新注册的InputFilter会把老的覆盖。</span></span></li><li><span class="name"><span class="innerContentContainer">filterInput()&nbsp;的调用是发生在Input Reader线程里，通过InputManagerService&nbsp;里的&nbsp;InputFilterHost&nbsp;对象通知另外一个线程里的InputFilter&nbsp;开始真正的解析工作。</span></span></li><li><span class="name"><span class="innerContentContainer">InputFilter&nbsp;的工作也分为两个步骤，首先由InputEventConsistencyVerifier&nbsp;对象（InputEventConsistencyVerifier.java）对输入事件的完整性做一个检查，检查事件的ACTION_DOWN&nbsp;和&nbsp;ACTION_UP&nbsp;是否一一配对。</span></span></li><li><span class="name"><span class="innerContentContainer">接下来，进入到 AccessibilityInputFilter&nbsp;的&nbsp;onInputEvent()，这里将把输入事件（主要是MotionEvent)进行处理，根据需要变成另外一个Event，然后通过sendInputEvent() 将事件发回给InputDispatcher。最终调用到injectInputEvent()&nbsp;将这个事件送入&nbsp;mInBoundQueue.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">com_android_server_input_InputManagerService.cpp</span></span><ul><li><span class="name"><span class="innerContentContainer">jni代码，负责承上启下。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">InputManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">InputMoniter.java</span></span></li><li><span class="name"><span class="innerContentContainer">WindowManagerPolicy.java</span></span></li><li><span class="name"><span class="innerContentContainer">PhoneWindowManager.java</span></span><ul><li><span class="name"><span class="innerContentContainer">核心函数是这两个：</span></span></li><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeQueueing() </span></span><ul><li><span class="name"><span class="innerContentContainer">inputDispatcher 中调用。负责入队列前的处理。包括：</span></span></li><li><span class="name"><span class="innerContentContainer">interceptPowerKeyDown(): power按下。处理逻辑较多，包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">调用 wakeUpFromPowerKey() 管理亮灭屏</span></span></li><li><span class="name"><span class="innerContentContainer">长按关机的定时器的启动</span></span></li><li><span class="name"><span class="innerContentContainer">来电来闹钟时按下power静音。</span></span></li><li><span class="name"><span class="innerContentContainer">钱包应用，双击付款。</span></span></li><li><span class="name"><span class="innerContentContainer">亮屏处理一般在100毫秒内处理完为正常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">interceptPowerKeyUp(): power抬起</span></span><ul><li><span class="name"><span class="innerContentContainer">调用 powerPress () 处理power键事件。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">interceptKeyBeforeDispatching()</span></span><ul><li><span class="name"><span class="innerContentContainer">inputDispatcher 中调用。负责事件分发前的处理。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层事件传递流程 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Activity -&gt; Windows -&gt; DecorView -&gt; ViewGroup -&gt; 各子View</span></span></li><li><span class="name"><span class="innerContentContainer">Activity中 InputEventReceiver的 <b>onInputEvent ()</b>被回调，开始 java层touch事件传递。</span></span></li><li><span class="name"><span class="innerContentContainer">InputStage的子类有: NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage、EarlyPostImeInputStage、NativePostImeInputStage、ViewPostImeInputStage、SyntheticInputStage.</span></span><ul><li><span class="name"><span class="innerContentContainer">它们构成一个输入事件处理链，如果本阶段对事件没有处理，则传递到下一个对象进行处理，直至事件被处理。</span></span></li><li><span class="name"><span class="innerContentContainer">NativePreImeInputStage、ViewPreImeInputStage、ImeInputStage三个类用来实现输入法的按键派发和处理，如果事件不传递到输入法服务中，这三个类可以跳过。</span></span></li><li><span class="name"><span class="innerContentContainer">EarlyPostImeInputStage对象开始处理，在 ViewPostImeInputStage 对象处理阶段调用了主View 对象（对应PhoneWindow中的DecorView对象）的事件提交函数如（dispatchTouchEvent）函数向视图对象提交输入事件, 在当前窗口的视图树中派发事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MainActivity.&nbsp;<b>DecorView</b> 在传递事件过程中首先将事件传给Activity的 dispatchTouchEvent()方法，所以我们可以重写这个方法来阻止事件继续传递。</span></span></li><li><span class="name"><span class="innerContentContainer">如果 onInterceptTouchEvent() 返回true，<b>ViewGroup </b>就会拦截touch事件，由自己的dispatchTouchEvent()  继续分发. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>ViewGroup.dispatchTouchEvent() 详解:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">TouchTarget链表保存了处理了初始触摸事件的子View，注意只有一系列触摸动作的初始事件（Down事件）才会找到对应的子View并生成TouchTarget的一个节点。后面的系列事件都会分发给TouchTarget链表中保存的子View，这也就意味着，如果一个子View没有处理初始的Down事件，那么它也就不会再接收到后面的move&nbsp;up等事件。</span></span></li><li><span class="name"><span class="innerContentContainer">如果onInterceptTouchEvent()返回true，当前ViewGroup拦截了该事件，那么该事件不会再向下面分发，并且会向TouchTarget中保存的所有子View发送cancel事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会移除分发记录，意味着后面的事件也不再会分发到子View。</span></span></li><li><span class="name"><span class="innerContentContainer">如果是辅助功能的事件，那么会优先分发给支持辅助功能的View，如果不存在这样的view，则进行一般的事件分发。</span></span></li><li><span class="name"><span class="innerContentContainer">1. 判断是否被拦截</span></span></li><li><span class="name"><span class="innerContentContainer">2. 如果未被拦截且为初始事件，找到可以处理事件的子View（在点击范围内且可被点击），分发事件后如果该子View处理了事件（dispatchTouchEvent()方法返回true）则存入TouchTarget链表并停止子View的遍历（后面的子View就没有机会再收到事件），如果该子View没有处理该事件，则继续遍历寻找</span></span></li><li><span class="name"><span class="innerContentContainer">3. 如果事件被拦截，向TouchTarget中的子View发送cancel事件</span></span></li><li><span class="name"><span class="innerContentContainer">4. 将未被2、3情况处理的事件分发给TouchTarget中的子View，如果TouchTarget为空，则交给ViewGroup本身父View的dispatchTouchEvent()方法处理. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">当一个触摸事件分发到一个非ViewGroup的View或者ViewGroup不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么View类的dispatchTouchEvent()将会被调用.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>View.dispatchTouchEvent() 详解:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">主要是先检查是否注册了onTouchListener，如果注册了监听并且调用返回了true消耗了该事件，那么说明该View处理了该事件，也会收到后续的事件，</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有注册监听或者没有消耗，就调用View本身的 onTouchEvent()，如果返回true则消耗事件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">View<b>.</b>onTouchEvent(), 按事件类型(up, down, move, cancel) 分别处理. 判断是否触发单击、长按、长按等, 并提供了默认的按下、点击、长按的视觉反馈。</span></span></li><li><span class="name"><span class="innerContentContainer">应用层事件封装成 MotionEvent。</span></span><ul><li><span class="name"><span class="innerContentContainer">mAction的低8位（也就是0-7位）是动作类型信息。</span></span></li><li><span class="name"><span class="innerContentContainer">mAction的8-15位，是触控点的索引信息。（即表示是哪一个触控点的事件）。</span></span></li><li><span class="name"><span class="innerContentContainer">MotionEvent有两个方法，一个是getAction(),另一个是getActionMasked(), 二个方法就是通过掩码的方式隐去触控点的索引信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">power 键的规格</span></span><ul><li><span class="name"><span class="innerContentContainer">0-500毫秒： 亮灭屏</span></span><ul><li><span class="name"><span class="innerContentContainer">亮屏时，抬起才灭屏。</span></span></li><li><span class="name"><span class="innerContentContainer">灭屏时，按下就亮屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">500-2500毫秒：语音助手</span></span></li><li><span class="name"><span class="innerContentContainer">2500毫秒以上： 关机</span></span></li><li><span class="name"><span class="innerContentContainer">来电来闹钟，按power静音。</span></span></li><li><span class="name"><span class="innerContentContainer">连按power两次，进支付界面。（from iOS）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟导航键</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟导航键由SystemUI处理。</span></span></li><li><span class="name"><span class="innerContentContainer">应用不需要刻意处理导航键。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化过程</span></span><ul><li><span class="name"><span class="innerContentContainer">导航栏实质是 NavigationBarView, 继承自 ViewGroup.</span></span></li><li><span class="name"><span class="innerContentContainer">在 PhoneStatusBar.java 中的 makeStatusBarView () 中初始化。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">键值模拟过程</span></span><ul><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">back键按下后的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">系统调用当前activity栈的top activity的 Destroy()，然后底下的activity自然就显示出来。</span></span></li><li><span class="name"><span class="innerContentContainer">back键事件会送到应用。</span></span></li><li><span class="name"><span class="innerContentContainer">应用调用 onBackPress() 可拦截back键。</span></span></li><li><span class="name"><span class="innerContentContainer">framework处理back键在 interceptKeyBeforeQueueing().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">home键按下后的处理</span></span><ul><li><span class="name"><span class="innerContentContainer">系统调用当前activity栈的top activity的 Stop(), 把整个应用都推到后台。</span></span></li><li><span class="name"><span class="innerContentContainer">home键事件不送给应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">recent键, 也叫 app_switch</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">手势导航</span></span><ul><li><span class="name"><span class="innerContentContainer">Android Q 手势导航   <a class="contentLink" target="_blank" rel="noreferrer" href="https://juejin.im/post/6844903853486260232">https://juejin.im/post/6844903853486260232</a> --这个是google宣传材料</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Input问题分类  <span class="contentTag" title="Filter #Input">#<span class="contentTagText">Input</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">器件和驱动问题</span></span><ul><li><span class="name"><span class="innerContentContainer">最方便方法： 打开小圆点，录屏，没有小圆点，就证明底层没有上报事件。</span></span><ul><li><span class="name"><span class="innerContentContainer">打开小圆点的方法： 开发人员选项 - 显示触摸操作</span></span></li><li><span class="name"><span class="innerContentContainer">小圆点代码： </span></span><ul><li><span class="name"><span class="innerContentContainer">显示小圆点： 在 TouchInputMapper.cookAndDispatch() 中画。</span></span></li><li><span class="name"><span class="innerContentContainer">要不要显示，在设置一路传下来。参见 nativeSetShowTouches().</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">为了确认是底层问题，在确认没有小圆点的同时，还要确认用户的确按了。方法就是第三方视觉录屏。</span></span></li><li><span class="name"><span class="innerContentContainer">通过查看器件上报的数据确认</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell getevent -l</span></span></li><li><span class="name"><span class="innerContentContainer">前提：研发现场可复现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过adb模拟事件，如果模拟的事件没问题，则可反向确认是bsp异常。</span></span><ul><li><span class="name"><span class="innerContentContainer">前提：研发现场可复现。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过查看 inputReader LOG打印确认上报的数据有没有问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Fwk policy错误</span></span><ul><li><span class="name"><span class="innerContentContainer">input policy主要是在pwm 中对一些按键和手势的拦截处理。涉及这方面要多考虑这块。</span></span></li><li><span class="name"><span class="innerContentContainer">主要逻辑在 interceptKeyBeforeQueueing() 和 interceptKeyBeforeDispatching()。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件分开过程中出现错误</span></span><ul><li><span class="name"><span class="innerContentContainer">事件有没有分发到inputdispatcher。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Input性能问题</span></span><ul><li><span class="name"><span class="innerContentContainer">一次事件上报过程分为4个环节： 硬件 - kernel - system server - app</span></span></li><li><span class="name"><span class="innerContentContainer">4个环节可划分5个时间点：</span></span><ul><li><span class="name"><span class="innerContentContainer">t1： 硬件中断时间。</span></span><ul><li><span class="name"><span class="innerContentContainer">这个可忽略不计。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t2： inputReader 从设备节点读出事件的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">事件时间戳在这里打上，所以看时间时间戳即可。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t3： inputDispatcher 向app进程发送时间的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">InputPublisher::publishMeyEvent(). 这里真正发消息了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t4： app开始事件处理的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">app通过 InputEventReceiver 接受事件，在 dispatchInputEvent()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">t5： app完成事件处理的时间</span></span><ul><li><span class="name"><span class="innerContentContainer">InputEventReceiver的 finishInputEvent()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">app处理耗时： t5 - t4</span></span></li><li><span class="name"><span class="innerContentContainer">system server耗时： t3 - t2</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">java 层消息机制</span></span><ul><li><span class="name"><span class="innerContentContainer">Java层的Looper是为了处理的消息队列中的消息.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">native 层消息机制</span></span><ul><li><span class="name"><span class="innerContentContainer">Native中的Looper是为了处理注册的自定义Fd引起的Request&nbsp;消息，这些消息一般来自于系统底层如触摸事件等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件通知机制: epoll (kernel)</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.viseator.com/categories/Android/Event/">https://www.viseator.com/categories/Android/Event/</a>  --相当不错</span></span></li><li><span class="name"><span class="innerContentContainer">Android系统本质上是一个事件驱动的系统. 消息机制在android系统中占据核心位置.&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">这里说的消息机制, 分为3个层面:</span></span><ul><li><span class="name"><span class="innerContentContainer">IO设备管理方面, 通过native层消息机制完成数据传输的同步控制. 比如Input;</span></span></li><li><span class="name"><span class="innerContentContainer">消息队列, Looper, 通过java层消息机制完成跨线程通讯.</span></span></li><li><span class="name"><span class="innerContentContainer">Binder机制也是通过java层消息机制完成的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">android的消息机制分为native与java两个部分.</span></span><ul><li><span class="name"><span class="innerContentContainer">java层消息机制, 是通过native层消息机制实现的.</span></span></li><li><span class="name"><span class="innerContentContainer">连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理.</span></span></li><li><span class="name"><span class="innerContentContainer">native层消息机制中, 最关键的超时与唤醒机制, 是通过kernel层epoll机制实现.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Epoll属于哪个领域的概念?</span></span><ul><li><span class="name"><span class="innerContentContainer">Epoll机制属于事件通知机制, 而事件通知机制看起来属于跨进程通讯的范畴, 但是它实际上属于设备管理的范畴.</span></span></li><li><span class="name"><span class="innerContentContainer">事件通知机制本质上要处理CPU和设备之间的不同步问题. 简言之, 就是CPU通知设备做点事, 设备不一定能马上处理完并返回的问题.&nbsp;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这里说的"事件"的含义是什么?</span></span><ul><li><span class="name"><span class="innerContentContainer">所谓"事件", 就其本质而言, 产生于设备的内核缓冲区, 当然最终是设备硬件中断产生的. </span></span></li><li><span class="name"><span class="innerContentContainer">事件和硬件中断不是一一对应的. 以网卡为例:</span></span><ul><li><span class="name"><span class="innerContentContainer">当数据量很少的时候，每来一个数据包网卡都回产生一个中断，os响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。</span></span></li><li><span class="name"><span class="innerContentContainer">当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。</span></span></li><li><span class="name"><span class="innerContentContainer">当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到<b>轮询</b>处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件包括4种:</span></span><ul><li><span class="name"><span class="innerContentContainer">内核读缓冲器非空.  (读方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 有人写入</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 事件未处理完.  (常用)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内核读缓冲区空. (读方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚空. (常用)</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 空.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写缓冲区满.  (写方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚满</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 满</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写缓冲区非满. (写方关注)</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发: 刚非满</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发: 非满</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件通知机制有三种: 阻塞, 轮询, IO 多路复用.</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞指读取数据时, 数据没有准备好, 读进程会停止运行, 等数据准备好再被系统唤醒.&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞是一种同步机制.</span></span></li><li><span class="name"><span class="innerContentContainer">缺点是一个线程只能处理一路IO. 原因是如果同时处理两路, 一路阻塞了, 另外一路就得不到处理了. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">轮询指轮流查询各路IO的状态. </span></span><ul><li><span class="name"><span class="innerContentContainer">缺点是浪费CPU时间.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IO多路复用机制是, 数据没有准备好, 也会阻塞, 但是系统会设置一个IO<b>代理</b>, 当若干路IO就绪时, 由代理唤醒线程, 并告诉它是哪路IO就绪, 从而提升处理效率.</span></span><ul><li><span class="name"><span class="innerContentContainer">IO多路复用机制相当于阻塞机制的改进.</span></span></li><li><span class="name"><span class="innerContentContainer">epoll即 I/O多路复用机制的实现.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">epoll背景知识</span></span><ul><li><span class="name"><span class="innerContentContainer">epoll机制于Linux 2.5.44首度登场.</span></span></li><li><span class="name"><span class="innerContentContainer">设计目的旨在取代既有POSIX&nbsp;select(2)与poll(2)系统函数.</span></span></li><li><span class="name"><span class="innerContentContainer">优势是处理多路IO事件时, 性能提升非常多. 旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n). (很多材料说是 O(1), 这是错误的).</span></span></li><li><span class="name"><span class="innerContentContainer">性能提升的原因是它能够只关注有数据的FD(文件描述符), 而不是所有FD都轮询一遍.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">epoll&nbsp;通过使用红黑树(RB-tree)搜索被监视的文件描述符(file descriptor, FD)。</span></span></li><li><span class="name"><span class="innerContentContainer">在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</span></span></li><li><span class="name"><span class="innerContentContainer">程序接口</span></span><ul><li><span class="name"><span class="innerContentContainer">接口实现在 /bionic/libc/bionic/sys_epoll.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">int epoll_create(int size);  // 在内核中创建epoll实例并返回一个epoll文件描述符。</span></span></li><li><span class="name"><span class="innerContentContainer">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  // 添加、修改或删除对 fd 上事件 event 的监听。</span></span><ul><li><span class="name"><span class="innerContentContainer">op 可以为&nbsp;EPOLL_CTL_ADD,&nbsp;添加新的事件</span></span></li><li><span class="name"><span class="innerContentContainer">EPOLL_CTL_MOD,&nbsp;修改文件描述符上监听的事件类型. 类型包括沿触发和状态触发. </span></span></li><li><span class="name"><span class="innerContentContainer">EPOLL_CTL_DEL, 从实例上删除一个事件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">int <b>epoll_wait</b>(int epfd, struct epoll_event *events, int maxevents, int timeout);   // 监听并阻塞, 等待唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">当 timeout 为 0 时，epoll_wait 永远会立即返回。</span></span></li><li><span class="name"><span class="innerContentContainer">而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。</span></span></li><li><span class="name"><span class="innerContentContainer">当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">唤醒</span></span><ul><li><span class="name"><span class="innerContentContainer">应用程序调用 <b>epoll_wait() 启动监听, 并阻塞自身后, 需要等待另一个进程唤醒.</b></span></span></li><li><span class="name"><span class="innerContentContainer">唤醒的机制是通过对event FD写入一个数据(一般是1, 显然在这个上下文下写入的内容无关紧要), epoll会监听这个FD, 发现有新数据了, 就把上面监听的进程逐一放入系统的就绪队列, 逐一处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">沿触发和状态触发</span></span><ul><li><span class="name"><span class="innerContentContainer">沿触发时，epoll_wait() 仅会在新的事件首次被加入epoll队列时返回.</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发时, epoll_wait在事件状态未变更前将不断被触发。</span></span></li><li><span class="name"><span class="innerContentContainer">状态触发模式是默认的模式。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>同步, 异步, 阻塞, 非阻塞, 轮询, 事件之间的关系  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">这几个概念之所以很混乱, 是因为汉语中把同步调用和跨线程的同步控制, 这两个几乎无关系的概念, 都缩写成"同步"这个词. 这导致了广泛的概念混淆.</span></span></li><li><span class="name"><span class="innerContentContainer">这几个概念不是并列的. 其关系如下:</span></span></li><li><span class="name"><span class="innerContentContainer">同步调用</span></span><ul><li><span class="name"><span class="innerContentContainer">同步就是同一个线程一直在跑, 函数调用返回的时候, 就拿到了调用结果. </span></span></li><li><span class="name"><span class="innerContentContainer">但是, 如果调用涉及到IO操作, 即对硬件的处理. 由于一般情况下面 硬件的访问速度比CPU和内存慢若干个数量级, 所以就存在调用了不能马上得到调用结果的问题. </span></span><ul><li><span class="name"><span class="innerContentContainer">反推回去, 同步之所以行得通, 仅仅因为CPU和内存的速度处在同一个数量级上的(当然, 这个话也不准确, 为了解决这个问题, 有无数的解决方案, 这个领域属于芯片设计, 不提), 由于它们的速度处在同一个数量级, 所以当我们的代码仅仅是读一个数, 做个计算, 再写一个数的时候, 所有这些事情都可以同步完成. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">面对这种不同步, <b>轮询</b>是最直接的解决办法. 轮询算同步.</span></span><ul><li><span class="name"><span class="innerContentContainer">轮询指调用一个函数, 如果不能马上得到结果, 就反复调用它, 直到得到结果为止. </span></span><ul><li><span class="name"><span class="innerContentContainer">一般情况下, 轮询是消费CPU资源的, 而且会引起界面卡顿等问题. </span></span></li><li><span class="name"><span class="innerContentContainer">当然也有特殊情况, 此时轮询效率更高.</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">异步</span></span><ul><li><span class="name"><span class="innerContentContainer">异步是轮询的一种改进, 改进的目的是节省CPU资源.</span></span></li><li><span class="name"><span class="innerContentContainer">异步的特点是, 调用结束时拿不到调用结果, 继续执行别的代码. 然后发生线程切换, 在另外一个线程中执行被调方代码并返回结果. 调用和拿到调用结果, 不是在同一个函数中, 一般也不在同一个线程中.</span></span></li><li><span class="name"><span class="innerContentContainer">异步的常见方式是: 调用的同时注册回调函数, 然后在没有执行结果的情况下直接返回, 接着往下执行. 回调函数则会在被调者执行完之后被调用.</span></span></li><li><span class="name"><span class="innerContentContainer">异步, 实际上是把调用逻辑分为4部分: 调用者前半部, 被调者前半部, 被调者后半部, 调用者后半部(也就是回调函数). </span></span></li><li><span class="name"><span class="innerContentContainer"><b>调用者前半部</b> 调用 <b>被调者前半部</b>, <b>被调者前半部</b> 想办法调用 <b>被调者后半部</b>(这里存在跨线程通讯), 这个过程发生在调用者线程中. 然后发生线程切换, 去执行 <b>被调者后半部</b>, 等它执行完了, 再调用 <b>调用者后半部</b>(再强调一遍, 也就是回调函数), 这个过程发生在被调者线程中. </span></span></li><li><span class="name"><span class="innerContentContainer">我之所以说异步是一种特殊的同步实现方法, 是因为调用者前半部 调用 被调者前半部, 是同步调用, 马上得到结果; 被调者后半部, 调用 调用者后半部, 也是同步调用, 马上得到结果. 至于被调者前半部 调用 被调者后半部的机制, 这往往是框架或平台在处理, 对使用者不可见. </span></span></li><li><span class="name"><span class="innerContentContainer">对初学者而言, 理解异步最困难的是理解回调函数. </span></span></li><li><span class="name"><span class="innerContentContainer">但是对于有经验的人来说, 回调函数仅仅是把处理的后半部分单独出来, 稍微有些绕而已, 并不难理解. 真正复杂的问题是, 被调者前半部, 怎么去调用 被调者后半部.</span></span></li><li><span class="name"><span class="innerContentContainer">首先要理解的是, 被调者前半部 和 被调者后半部 处在不同的线程中(调用者前半部, 和回调函数也在不同的线程中).  也就是说, 这是一个跨线程的调用. 因此请参见: "跨线程的同步机制".</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">阻塞</span></span><ul><li><span class="name"><span class="innerContentContainer">阻塞, 就是调用一个函数半途中发生线程切换, 等拿到调用结果时, 再把线程切换回来继续执行.</span></span></li><li><span class="name"><span class="innerContentContainer">其突出特点是虽然线程切换了, 但是函数没有换, 还是在原来函数中. </span></span></li><li><span class="name"><span class="innerContentContainer">从某种意义上讲, 阻塞是操作系统(或者虚拟机)帮忙, 以同步的形式, 完成异步的实质. 毕竟, 同步调用, 代码的执行顺序和编写顺序是一致的, 好理解多了.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">非阻塞, 就是异步. 不用阻塞, 又在IO操作中, 只能是异步. </span></span></li><li><span class="name"><span class="innerContentContainer">epoll: epoll是同步机制, 它支持阻塞, 也可以支持非阻塞. 区别在于入参. epoll_wait() 的</span></span></li><li><span class="name"><span class="innerContentContainer">跨线程的同步机制</span></span><ul><li><span class="name"><span class="innerContentContainer">异步和阻塞, 都涉及到同一个处理逻辑(从业务视角出发), 分解到不同的线程的问题. 因此, 这几个线程之间必须要有同步机制, 才能把业务逻辑处理好. </span></span></li><li><span class="name"><span class="innerContentContainer">同步机制是消息队列. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">还有一种分类方式, 就是把阻塞作为一种特殊的同步调用方式. 其理由是, 同步调用就是这个函数执行完了, 就拿到执行结果了. 阻塞没出函数拿到结果, 所以算同步机制. </span></span><ul><li><span class="name"><span class="innerContentContainer">这个仅仅是一个定义的问题. 这么算也可以. 但是阻塞出现了当前线程挂起, 失去CPU, 以及多个线程间的同步控制, 这种算同步就掩盖了很多技术细节.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">同步阻塞的IO会使线程挂起，同步非阻塞(即轮询)的IO会消耗CPU资源在轮询上。</span></span></li><li><span class="name"><span class="innerContentContainer">IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）.</span></span></li><li><span class="name"><span class="innerContentContainer">直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。</span></span></li></ul></li></ul>
  </body>
</html>