<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>Java  <span class="contentTag" title="Filter #Work">#<span class="contentTagText">Work</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #最小编程规范">#<span class="contentTagText">最小编程规范</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">命名模板</span></span><ul><li><span class="name"><span class="innerContentContainer">输出        out</span></span></li><li><span class="name"><span class="innerContentContainer">输入	in</span></span></li><li><span class="name"><span class="innerContentContainer">模板	template</span></span></li><li><span class="name"><span class="innerContentContainer">执行/执行中	run/running</span></span></li><li><span class="name"><span class="innerContentContainer">名称	name</span></span></li><li><span class="name"><span class="innerContentContainer">密码	password  (不要用缩写psw，或者cipher等。)</span></span></li><li><span class="name"><span class="innerContentContainer">序列号	id&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">读/写	read/write&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">特性	feature</span></span></li><li><span class="name"><span class="innerContentContainer">版本	version</span></span></li><li><span class="name"><span class="innerContentContainer">分支	branch</span></span></li><li><span class="name"><span class="innerContentContainer">工程	project</span></span></li><li><span class="name"><span class="innerContentContainer">驱动	driver</span></span></li><li><span class="name"><span class="innerContentContainer">报告	report</span></span></li><li><span class="name"><span class="innerContentContainer">模块	module</span></span></li><li><span class="name"><span class="innerContentContainer">进程	process</span></span></li><li><span class="name"><span class="innerContentContainer">线程	thread</span></span></li><li><span class="name"><span class="innerContentContainer">参数	param</span></span></li><li><span class="name"><span class="innerContentContainer">属性	attri</span></span></li><li><span class="name"><span class="innerContentContainer">帮助	help</span></span></li><li><span class="name"><span class="innerContentContainer">打印	print</span></span></li><li><span class="name"><span class="innerContentContainer">测试代码	TEST_CODE</span></span></li><li><span class="name"><span class="innerContentContainer">选择	choice</span></span></li><li><span class="name"><span class="innerContentContainer">命令/脚本	cmd</span></span></li><li><span class="name"><span class="innerContentContainer">日期/时间	date/time</span></span></li><li><span class="name"><span class="innerContentContainer">间隔	inter/interval</span></span></li><li><span class="name"><span class="innerContentContainer">修改	modify</span></span></li><li><span class="name"><span class="innerContentContainer">按下	press  (点击鼠标也用press，不用 hit、beat 等。)</span></span></li><li><span class="name"><span class="innerContentContainer">步骤	step</span></span></li><li><span class="name"><span class="innerContentContainer">产生/新建/创建/制造/制作	make (不用build/create等；统一化)</span></span></li><li><span class="name"><span class="innerContentContainer">拷贝	copy</span></span></li><li><span class="name"><span class="innerContentContainer">升级/更新	update </span></span></li><li><span class="name"><span class="innerContentContainer">编译	compile</span></span></li><li><span class="name"><span class="innerContentContainer">发送/接受	send/receive</span></span></li><li><span class="name"><span class="innerContentContainer">源/对象.目标	res/des (不要用source/destince。res/des 对比强烈，很醒目，出现在一起不会错。)</span></span></li><li><span class="name"><span class="innerContentContainer">根	   root</span></span></li><li><span class="name"><span class="innerContentContainer">关键	key (不要用keyword，显得累赘。)</span></span></li><li><span class="name"><span class="innerContentContainer">邮件	mail (不用email)</span></span></li><li><span class="name"><span class="innerContentContainer">存在性	exist</span></span></li><li><span class="name"><span class="innerContentContainer">调试	debug  (不要缩写为dbg，影响可读性。)</span></span></li><li><span class="name"><span class="innerContentContainer">库/基线	base  (不用 database)</span></span></li><li><span class="name"><span class="innerContentContainer">备份/恢复	backup/resume  (backup可以缩写为back，但会影响可读性)</span></span></li><li><span class="name"><span class="innerContentContainer">错误/警告/信息	Error:/Warn:/Info:</span></span></li><li><span class="name"><span class="innerContentContainer">定制	custom</span></span></li><li><span class="name"><span class="innerContentContainer">运营商/客户	vendor</span></span></li><li><span class="name"><span class="innerContentContainer">待完成	// TODO:</span></span></li><li><span class="name"><span class="innerContentContainer">检查	check  (不要使用review、examine、inspecte等。归一。)</span></span></li><li><span class="name"><span class="innerContentContainer">分配	alloc</span></span></li><li><span class="name"><span class="innerContentContainer">备注	remark</span></span></li><li><span class="name"><span class="innerContentContainer">计数器	count</span></span></li><li><span class="name"><span class="innerContentContainer">配置	config  (不要用options、setting等。归一。)</span></span></li><li><span class="name"><span class="innerContentContainer">用户	user  (指代所有使用工具的人。不用 consumer、handler、operator、runner 等。归一。)</span></span></li><li><span class="name"><span class="innerContentContainer">重启	reboot (不要用restart, reset等。归一。)</span></span></li><li><span class="name"><span class="innerContentContainer">服务器/客户机	server/client</span></span></li><li><span class="name"><span class="innerContentContainer">新/旧	new/old</span></span></li><li><span class="name"><span class="innerContentContainer">开/关	open/close</span></span></li><li><span class="name"><span class="innerContentContainer">取/设	get/set</span></span></li><li><span class="name"><span class="innerContentContainer">控制	control</span></span></li><li><span class="name"><span class="innerContentContainer">索引/序号	index</span></span></li><li><span class="name"><span class="innerContentContainer">值	value</span></span></li><li><span class="name"><span class="innerContentContainer">字体	font</span></span></li><li><span class="name"><span class="innerContentContainer">颜色	color</span></span></li><li><span class="name"><span class="innerContentContainer">文本	text</span></span></li><li><span class="name"><span class="innerContentContainer">线条	line</span></span></li><li><span class="name"><span class="innerContentContainer">长/高/重	length/height/weigh</span></span></li><li><span class="name"><span class="innerContentContainer">开关/切换	switch</span></span></li><li><span class="name"><span class="innerContentContainer">操作/处理/工作/任务/职责  job  (不要用 work、task、role等，归一。)</span></span></li><li><span class="name"><span class="innerContentContainer">操作/处理/作用（动词性） handle  (不要用 work、operate、treate、do、deal、task等，归一。还要斟酌, 是不是用do更好。)</span></span></li><li><span class="name"><span class="innerContentContainer">初始化	init</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹名  path (不用dir, folder等)</span></span></li><li><span class="name"><span class="innerContentContainer">文件名     file  (不用 filename这种累赘表达)</span></span></li><li><span class="name"><span class="innerContentContainer">标示	flag</span></span></li><li><span class="name"><span class="innerContentContainer">自A到B	from_A_to_B</span></span></li><li><span class="name"><span class="innerContentContainer">在某个平台上，基于某个平台	on   (不用over 或者 base。)</span></span></li><li><span class="name"><span class="innerContentContainer">A和B	A_and_B</span></span></li><li><span class="name"><span class="innerContentContainer">A作用于B	A_to_B</span></span></li><li><span class="name"><span class="innerContentContainer">指针        ptr_</span></span></li><li><span class="name"><span class="innerContentContainer">字符串    str_</span></span></li><li><span class="name"><span class="innerContentContainer">局部变量	my_</span></span></li><li><span class="name"><span class="innerContentContainer">全局变量	g_</span></span></li><li><span class="name"><span class="innerContentContainer">指向自身	self_</span></span></li><li><span class="name"><span class="innerContentContainer">接口	i_</span></span></li><li><span class="name"><span class="innerContentContainer">多个	multi_</span></span></li><li><span class="name"><span class="innerContentContainer">当前	cur_</span></span></li><li><span class="name"><span class="innerContentContainer">上一个	last_</span></span></li><li><span class="name"><span class="innerContentContainer">下一个	next_</span></span></li><li><span class="name"><span class="innerContentContainer">开始	start_</span></span></li><li><span class="name"><span class="innerContentContainer">结束	end_</span></span></li><li><span class="name"><span class="innerContentContainer">之后	after_</span></span></li><li><span class="name"><span class="innerContentContainer">之前	before_</span></span></li><li><span class="name"><span class="innerContentContainer">自动化	auto_</span></span></li><li><span class="name"><span class="innerContentContainer">是否	is_</span></span></li><li><span class="name"><span class="innerContentContainer">是否使能	use_</span></span></li><li><span class="name"><span class="innerContentContainer">原始	ori_</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">左括号 { 不独占一行;</span></span></li><li><span class="name"><span class="innerContentContainer">包名: 全小写。请采用 com.公司名.模块名.子系统名.类名 方式.</span></span></li><li><span class="name"><span class="innerContentContainer">类名:各单词首字母大写;</span></span></li><li><span class="name"><span class="innerContentContainer">方法名: 第一个单词小写, 其它单词首字母大写;</span></span></li><li><span class="name"><span class="innerContentContainer">属性名: 前缀m, 各单词首字母大写;</span></span></li><li><span class="name"><span class="innerContentContainer">局部变量:前缀 my, 各单词首字母大写.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #代码组织方式">#<span class="contentTagText">代码组织方式</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">java文件由如下部分组成: </span></span></li><li><span class="name"><span class="innerContentContainer">包申明: 即申明自己是谁, 方便别人导入.  只能放在Java文件的第一行. 如: package com.imagescan.tools;  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Java约定, 包名和文件路径保持一致.包名即 路径.类名/接口名.</span></span></li><li><span class="name"><span class="innerContentContainer">导入包: 即导入别的包, 方便在自己类中调用. 一般紧接着包申明.  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">包是java的一级概念. 将相关的类放到一个文件夹中, 这个文件夹就叫类包, 简称包.</span></span></li><li><span class="name"><span class="innerContentContainer">调用其它包中的类时, 需要先导入包, 然后在代码中直接用类名. </span></span></li><li><span class="name"><span class="innerContentContainer">也可以在调用时使用完整的包名(不推荐).</span></span></li><li><span class="name"><span class="innerContentContainer">编译器在寻址包名时, 会查找当前目录和系统环境变量 classpath 包含的目录.</span></span></li><li><span class="name"><span class="innerContentContainer">import java.util.Data;</span></span></li><li><span class="name"><span class="innerContentContainer">可以使用通配符*, 比如: import java.util.*;</span></span></li><li><span class="name"><span class="innerContentContainer">其中以 java/javax 开头的包为核心包, 以 com.org 开头的包为各组织提供的.</span></span></li><li><span class="name"><span class="innerContentContainer">Java编译器会默认导入jdk的java.lang包中的所有类, 其中定义了system/string/object/math等常用类,这些类不需要显式导入.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接下来是类定义, 即普通代码.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #类和对象">#<span class="contentTagText">类和对象</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">java代码的基本组成单位是类, 所有代码都放在类中.</span></span></li><li><span class="name"><span class="innerContentContainer">java没有头文件.</span></span></li><li><span class="name"><span class="innerContentContainer">一个代码文件只能放一个 public 类, 文件名和该类名相同. </span></span></li><li><span class="name"><span class="innerContentContainer">类的定义</span></span><ul><li><span class="name"><span class="innerContentContainer">public class MyClass extends ParentClass {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected string money;</span></span></li><li><span class="name"><span class="innerContentContainer">private int age;</span></span></li><li><span class="name"><span class="innerContentContainer">int money;  // 默认是 private的</span></span></li><li><span class="name"><span class="innerContentContainer">public void barking(){...}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">关键字 extends 表示继承自其父类. 如果没有显式定义父类, 则默认继承自 Object类. 该类是java所有类的基类.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">程序的入口  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">是 public static void main(string[] args) {}.</span></span></li><li><span class="name"><span class="innerContentContainer">main()必须放在某个public类中, 它直接被java解析器调用. 用户代码不能调用.</span></span></li><li><span class="name"><span class="innerContentContainer">main()必须使用 public static void属性. 即它是静态方法, 使用规则见下.</span></span></li><li><span class="name"><span class="innerContentContainer">每个public类都可以有main(), 运行时用哪个为入口在编译器中指定. 一般用这个特性来做UT.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">构造函数</span></span><ul><li><span class="name"><span class="innerContentContainer">类的构造函数会在new该类时被调用. 构造函数用于初始化一个类.</span></span></li><li><span class="name"><span class="innerContentContainer">构造函数和类名相同, 属性为 public void.</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有显式定义构造函数, 则编译器会自动生成一个无参数的构造函数.</span></span></li><li><span class="name"><span class="innerContentContainer">一个类支持多个构造函数, 只要参数不同.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">析构函数</span></span><ul><li><span class="name"><span class="innerContentContainer">java不需要析构函数, 但java垃圾回收只支持 new创造的对象, 某些类不是通过new生成, 那么就需要定义 finalize(), 它是 protected的.</span></span></li><li><span class="name"><span class="innerContentContainer">系统垃圾回收的时机不确定. java 提供system.gc()方法, 应用调用它可强制启动回收. 但并不是马上.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>静态类&amp;静态区域&amp;静态方法  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">static表示静态的意思.</span></span></li><li><span class="name"><span class="innerContentContainer">static 修饰类, 表示它是<b>静态类</b>, 常用于工具类, 不需要new可直接用. </span></span><ul><li><span class="name"><span class="innerContentContainer">静态类跟静态方法一样, 只能访问类的静态成员.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用 static {} 定义类的静态区域, 位于所有方法之外, 一般放在类的最开始.</span></span><ul><li><span class="name"><span class="innerContentContainer">静态区域在类加载时被调用, 只执行一次.一般用于类的静态成员的初始化.</span></span></li><li><span class="name"><span class="innerContentContainer">它不能被代码主动调用. </span></span></li><li><span class="name"><span class="innerContentContainer">可以多个, 但不建议.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">static修饰方法, 表示静态方法. </span></span><ul><li><span class="name"><span class="innerContentContainer">如: public static void myFunc(){}</span></span></li><li><span class="name"><span class="innerContentContainer">静态方法又叫类方法, 不需要new一个类就可直接调用它. 如 MyClass.myFunc().</span></span></li><li><span class="name"><span class="innerContentContainer">类方法只能访问类的其它类方法和静态属性, 如果要访问类的其它资源, 则需要new这个类.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>final 关键字  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">final 表示最终的, 不可改变的意思. </span></span></li><li><span class="name"><span class="innerContentContainer">修饰类, 表示该类不可被继承. </span></span></li><li><span class="name"><span class="innerContentContainer">修饰方法, 表示该方法不可被子类的方法覆盖, 也不支持重载. 所有 private 方法隐含带 final 属性. 而且 final类中的方法默认为final的.</span></span><ul><li><span class="name"><span class="innerContentContainer">final 不可以修饰构造方法.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>abstract 关键字  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">abstract 和 final 有反义词的意思.</span></span></li><li><span class="name"><span class="innerContentContainer">修饰类, 表示<b>抽象类</b>. 抽象类不可实例化, 只能被继承. 但它可以作为对象类型. </span></span><ul><li><span class="name"><span class="innerContentContainer">继承抽象类必须重写所有抽象方法.</span></span></li><li><span class="name"><span class="innerContentContainer">一个类只要有一个抽象方法, 那它就是抽象类, 不可实例化, 只能实例化它的子类.</span></span></li><li><span class="name"><span class="innerContentContainer">抽象类可以不包含任何抽象方法.</span></span></li><li><span class="name"><span class="innerContentContainer">抽象类不能定义 final方法.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">修饰方法, 表示<b>抽象方法</b>. 子类必须重写所有抽象方法.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>构造代码块</b></span></span><ul><li><span class="name"><span class="innerContentContainer">格式: {...}, 放在函数外. 一般为函数最开始.</span></span></li><li><span class="name"><span class="innerContentContainer">构造块的作用是给类的多个对象的共性部分进行初始化.</span></span></li><li><span class="name"><span class="innerContentContainer">对象一建立就会运行构造块, 而且优先于构造函数. 不能用代码调用构造块.</span></span></li><li><span class="name"><span class="innerContentContainer">构造块和构造函数的区别是: 构造块是给所有对象进行统一初始化, 而构造函数则是对特定对象进行初始化. 构造函数可以多个, 但构造块只有一个.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>this指针</b></span></span><ul><li><span class="name"><span class="innerContentContainer">this指向当前对象自身. 所以只能用于方法体内.  this不可用于静态方法和静态块.</span></span></li><li><span class="name"><span class="innerContentContainer">this常用于如下几个场景:</span></span><ul><li><span class="name"><span class="innerContentContainer">成员变量和参数同名, 成员变量别屏蔽, 用this来引用成员变量.</span></span></li><li><span class="name"><span class="innerContentContainer">构造方法通过this来调用另一个构造方法, 如:</span></span><ul><li><span class="name"><span class="innerContentContainer">Public MyClass() {</span></span><ul><li><span class="name"><span class="innerContentContainer">this(0, “null");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">方法中返回当前实例的引用.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>super 关键字</b></span></span><ul><li><span class="name"><span class="innerContentContainer">super() &nbsp; // 调用基类的构造方法, 只能放在构造方法的第一行.</span></span></li><li><span class="name"><span class="innerContentContainer">super.myFunc() &nbsp;// 调用基类被覆盖的方法.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接口的使用方法 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">// 定义接口</span></span></li><li><span class="name"><span class="innerContentContainer">interface 接口名称 [extends 其他的接口名] {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 声明变量. 必须有初始化的值.</span></span></li><li><span class="name"><span class="innerContentContainer">// 抽象方法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 使用接口</span></span></li><li><span class="name"><span class="innerContentContainer">public class 类名 <b>implements </b>接口名称 { ... }</span></span></li><li><span class="name"><span class="innerContentContainer">类可以继承多个接口。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抽象类和接口的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">抽象类可以有构造方法，接口中不能有构造方法。</span></span></li><li><span class="name"><span class="innerContentContainer">抽象类中可以有普通成员变量，接口中没有普通成员变量。</span></span></li><li><span class="name"><span class="innerContentContainer">抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">抽象类中的方法的权限可以多种，接口中的抽象方法只能是 public 类型的。</span></span></li><li><span class="name"><span class="innerContentContainer">抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的。</span></span></li><li><span class="name"><span class="innerContentContainer">一个类可以继承多个接口，但只能继承一个抽象类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类的实例化过程</span></span><ul><li><span class="name"><span class="innerContentContainer">父类中的static代码块，子类（即当前类）的static。</span></span></li><li><span class="name"><span class="innerContentContainer">顺序执行父类的普通代码块。</span></span></li><li><span class="name"><span class="innerContentContainer">父类的构造函数。</span></span></li><li><span class="name"><span class="innerContentContainer">子类普通代码块。</span></span></li><li><span class="name"><span class="innerContentContainer">子类的构造函数，按顺序执行。</span></span></li><li><span class="name"><span class="innerContentContainer">子类方法的执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重载和重写的区别 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型不做限制。</span></span></li><li><span class="name"><span class="innerContentContainer">每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</span></span></li><li><span class="name"><span class="innerContentContainer">重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</span></span></li><li><span class="name"><span class="innerContentContainer">重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内部类 / 静态内部类 / 匿名内部类 / 局部内部类 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">内部类</span></span><ul><li><span class="name"><span class="innerContentContainer">当一个文件中放多个类时, 其它类叫内部类, 内部类不能是 public 类.</span></span></li><li><span class="name"><span class="innerContentContainer">成员内部类可访问外部类所有的方法和成员变量。</span></span></li><li><span class="name"><span class="innerContentContainer">不能有静态的方法和成员变量。</span></span></li><li><span class="name"><span class="innerContentContainer">持有外部类引用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">局部内部类</span></span><ul><li><span class="name"><span class="innerContentContainer">位于方法内的类。Android上及其常见。</span></span></li><li><span class="name"><span class="innerContentContainer">属于匿名内部类的一种，用Lamada表达式实现。</span></span></li><li><span class="name"><span class="innerContentContainer">方法的局部变量要被局部内部类访问，则该变量必须是final修饰。</span></span></li><li><span class="name"><span class="innerContentContainer">Java8 上，被局部内部类访问的局部变量，不需要再显式final，编译器会自动该修饰。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静态内部类</span></span><ul><li><span class="name"><span class="innerContentContainer">用static修饰。不太常见。</span></span></li><li><span class="name"><span class="innerContentContainer">只能访问外部类的静态成员变量与静态方法。</span></span></li><li><span class="name"><span class="innerContentContainer">静态内部类的非静态成员可访问外部类的静态变量，而不可访问外部类的非静态变量。</span></span></li><li><span class="name"><span class="innerContentContainer">不持有外部类引用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">匿名内部类</span></span><ul><li><span class="name"><span class="innerContentContainer">用Lamada表达式实现。</span></span></li><li><span class="name"><span class="innerContentContainer">没有类名，没有class关键字也没有extends和implements等关键字修饰。</span></span></li><li><span class="name"><span class="innerContentContainer">类的定义和对象的实例化同时进行。</span></span></li><li><span class="name"><span class="innerContentContainer">持有外部类引用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">类加载器（ClassLoader）</span></span><ul><li><span class="name"><span class="innerContentContainer">类加载器负责在运行时查找和装入类文件中的类。是一个重要的Java运行时系统组件。</span></span></li><li><span class="name"><span class="innerContentContainer">类加载器包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">根加载器（BootStrap）</span></span><ul><li><span class="name"><span class="innerContentContainer">一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</span></span></li><li><span class="name"><span class="innerContentContainer">JVM不会向Java程序提供对Bootstrap的引用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">扩展加载器（Extension）</span></span><ul><li><span class="name"><span class="innerContentContainer">从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统加载器（System）</span></span><ul><li><span class="name"><span class="innerContentContainer">又叫应用类加载器，其父类是Extension。</span></span></li><li><span class="name"><span class="innerContentContainer">它是应用最广泛的类加载器。</span></span></li><li><span class="name"><span class="innerContentContainer">它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用户自定义类加载器（java.lang.ClassLoader的子类）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类加载的过程</span></span><ul><li><span class="name"><span class="innerContentContainer">创建一个字节数组读入.class文件；</span></span></li><li><span class="name"><span class="innerContentContainer">产生与所加载类对应的Class对象，作为该类的数据访问入口。此时该对象还不可用。</span></span></li><li><span class="name"><span class="innerContentContainer">当类被加载后就进入连接阶段，这一阶段包括</span></span><ul><li><span class="name"><span class="innerContentContainer">验证：包括4种类型的验证：</span></span><ul><li><span class="name"><span class="innerContentContainer">文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</span></span></li><li><span class="name"><span class="innerContentContainer">元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</span></span></li><li><span class="name"><span class="innerContentContainer">字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</span></span></li><li><span class="name"><span class="innerContentContainer">符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">准备：为类的<b>静态变量</b>分配内存并设置默认值。</span></span></li><li><span class="name"><span class="innerContentContainer">解析：将符号引用替换为直接引用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">最后JVM对类进行初始化：</span></span><ul><li><span class="name"><span class="innerContentContainer">如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；</span></span></li><li><span class="name"><span class="innerContentContainer">如果类中存在初始化语句，就依次执行这些初始化语句。到这个阶段，才开始执行类中的代码。</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #HelloWorld">#<span class="contentTagText">HelloWorld</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">/* HelloWorld.java */</span></span></li><li><span class="name"><span class="innerContentContainer">public Class HelloWorld{</span></span><ul><li><span class="name"><span class="innerContentContainer">public static woid main(string arg[]) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println(“Hello, world!");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">编译:  javac HelloWorld.java</span></span></li><li><span class="name"><span class="innerContentContainer">java HelloWorld.java</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #注释">#<span class="contentTagText">注释</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">// 支持单行</span></span></li><li><span class="name"><span class="innerContentContainer">/* 支持多行 */</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印">#<span class="contentTagText">Log打印</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">最简单的方式是 system.print.out() , err() 这样直接在控制台打印消息了。</span></span></li><li><span class="name"><span class="innerContentContainer">java.util.logging ; 在JDK 1.4 版本之后，提供了日志的API ，可以往文件中写日志了。</span></span></li><li><span class="name"><span class="innerContentContainer">log4j , 最强大的记录日志的方式。 可以通过配置 .properties 或是 .xml 的文件， 配置日志的目的地，格式等等。</span></span></li><li><span class="name"><span class="innerContentContainer">log4j 是 apache 提供的库。下载路径http://logging.apache.org/log4j/1.2/download.html&nbsp; .  例如:</span></span><ul><li><span class="name"><span class="innerContentContainer">import org.apache.log4j.Logger;</span></span></li><li><span class="name"><span class="innerContentContainer">import org.apache.log4j.PropertyConfigurator;</span></span></li><li><span class="name"><span class="innerContentContainer">// 1. create log</span></span></li><li><span class="name"><span class="innerContentContainer">Logger log = Logger.getLogger(TestLog4j.class);</span></span></li><li><span class="name"><span class="innerContentContainer">// 2. get log config file</span></span></li><li><span class="name"><span class="innerContentContainer">PropertyConfigurator.configure("log4j.properties");</span></span></li><li><span class="name"><span class="innerContentContainer">// 3. start log.  还有 log.info, log.warn, log.fatal 等打印级别.</span></span></li><li><span class="name"><span class="innerContentContainer">log.debug("Here is some DEBUG");</span></span></li><li><span class="name"><span class="innerContentContainer">log.error("Here is some ERROR");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">commons-logging, 最综合和常见的日志记录方式， 经常是和log4j 结合起来使用。</span></span></li><li><span class="name"><span class="innerContentContainer">打印堆栈</span></span><ul><li><span class="name"><span class="innerContentContainer">+ (new Exception("")). printStackTrace();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #函数">#<span class="contentTagText">函数</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">函数基本形式</span></span><ul><li><span class="name"><span class="innerContentContainer">@ override</span></span></li><li><span class="name"><span class="innerContentContainer">public void myFunc(Bundle savedData) {...}</span></span></li><li><span class="name"><span class="innerContentContainer">其中: @ override, 表示该方法可以在子类中被覆盖.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">函数权限</span></span><ul><li><span class="name"><span class="innerContentContainer">public: 可以被 其它类 调用;</span></span></li><li><span class="name"><span class="innerContentContainer">friendly: 只能被 自身/子类/本包的其他类 调用.</span></span></li><li><span class="name"><span class="innerContentContainer">protect: 只能被自身/子类调用.</span></span></li><li><span class="name"><span class="innerContentContainer">private: 只能被自身调用.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传值/传引用</span></span><ul><li><span class="name"><span class="innerContentContainer">在Java里, 只有如下两种数据是按值传递:</span></span><ul><li><span class="name"><span class="innerContentContainer">基本类型</span></span></li><li><span class="name"><span class="innerContentContainer">按照下面这种定义方式的String,&nbsp;就是直接使用双引号定义字符串方式：String str = “Java私塾”;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它的都是按引用传递。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #整数">#<span class="contentTagText">整数</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">整数</span></span><ul><li><span class="name"><span class="innerContentContainer">最常见的，int， 32位整数。</span></span><ul><li><span class="name"><span class="innerContentContainer">int ii = 5;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它，byte, 8位</span></span></li><li><span class="name"><span class="innerContentContainer">short, 16位</span></span></li><li><span class="name"><span class="innerContentContainer">long, 64位. 直接数要加L后缀。</span></span><ul><li><span class="name"><span class="innerContentContainer">long x = 88888888L;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">枚举值</span></span><ul><li><span class="name"><span class="innerContentContainer">public static enum MyType{</span></span><ul><li><span class="name"><span class="innerContentContainer">ModeType1, ModeType2</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自带字符串的枚举量</span></span><ul><li><span class="name"><span class="innerContentContainer">private static HashMap&lt;String, State&gt; sStates = Maps.newHashMap();</span></span></li><li><span class="name"><span class="innerContentContainer">public enum State {</span></span><ul><li><span class="name"><span class="innerContentContainer">RUNNING("running"),</span></span></li><li><span class="name"><span class="innerContentContainer">STOPPING("stopping"),</span></span></li><li><span class="name"><span class="innerContentContainer">STOPPED("stopped"),</span></span></li><li><span class="name"><span class="innerContentContainer">RESTARTING("restarting");</span></span></li><li><span class="name"><span class="innerContentContainer"><b>State</b>(String state) {</span></span><ul><li><span class="name"><span class="innerContentContainer">sStates.put(state, this);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #布尔量">#<span class="contentTagText">布尔量</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">boolean 只有两个值, true 和 false.  不能与整数进行转换.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #浮点数">#<span class="contentTagText">浮点数</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">浮点数有两种： float, double.</span></span></li><li><span class="name"><span class="innerContentContainer">float f = 2.3f; &nbsp; // 占用4个字节, 32位, 取值范围从 10^-38 到 10^38, 和 -10^38到-10^-38之间.</span></span><ul><li><span class="name"><span class="innerContentContainer">后缀f 必须要.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">double d = 2.3; &nbsp; // 占用8个字节, 64位, 取值范围从 10^-308 到 10^308, 和 -10^308 到 -10^-308 之间. </span></span></li><li><span class="name"><span class="innerContentContainer">小数默认是double类型的。</span></span></li><li><span class="name"><span class="innerContentContainer">浮点数有精度限制, 不能用 == 比较两个浮点数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #常量">#<span class="contentTagText">常量</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">常量用 final 修饰. 即不可改变的变量.</span></span></li><li><span class="name"><span class="innerContentContainer">需要在声明时给定初值。</span></span></li><li><span class="name"><span class="innerContentContainer">常量一般也是全局变量和静态变量, 如: public final static double PI = 3.14159;</span></span></li><li><span class="name"><span class="innerContentContainer">final也可以修饰局部变量, 用于避免变量被重新赋值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #全局变量">#<span class="contentTagText">全局变量</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">全局变量用 public 修饰. 使用时用这样的: MyClass.myValue;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #静态变量">#<span class="contentTagText">静态变量</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">静态变量用 static 修饰. 局部可见, 全局存在. 和c一样.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #运算符表">#<span class="contentTagText">运算符表</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">优先级按照从高到低的顺序书写，也就是优先级为1的优先级最高，优先级14的优先级最低。</span></span></li><li><span class="name"><span class="innerContentContainer">1	() [] .	从左到右</span></span></li><li><span class="name"><span class="innerContentContainer">2	! +(正) -(负) ~(非运算) ++ --	从右向左</span></span></li><li><span class="name"><span class="innerContentContainer">3	* / %	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">4	+(加) -(减)	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">5	&lt;&lt; &gt;&gt;(算数右移) &gt;&gt;&gt;(逻辑右移)	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">6	&lt; &lt;= &gt; &gt;= instanceof	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">7	== !=	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">8	&amp;(按位与)	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">9	^(异或)	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">10	|	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">11	&amp;&amp;	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">12	||	从左向右</span></span></li><li><span class="name"><span class="innerContentContainer">13	?:	从右向左</span></span></li><li><span class="name"><span class="innerContentContainer">14	= += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=	从右向左</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #基本数据类型装箱">#<span class="contentTagText">基本数据类型装箱</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">为了方便大家的习惯, java中有8种基础数据类型没有包装为类, 包括 byte/short/int/long/char/float/double/boolean. </span></span></li><li><span class="name"><span class="innerContentContainer">基本数据类型可以直接使用, 不需要new. 如: int myInt = 500;</span></span></li><li><span class="name"><span class="innerContentContainer">但是由于它们不是对象, 在序列化等场景下不太方便, 所以java提供了装箱类, 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">byte -&gt; Byte</span></span></li><li><span class="name"><span class="innerContentContainer">boolean -&gt; Boolean</span></span></li><li><span class="name"><span class="innerContentContainer">short -&gt; Short</span></span></li><li><span class="name"><span class="innerContentContainer">char -&gt; Character</span></span></li><li><span class="name"><span class="innerContentContainer">int -&gt; Integer</span></span></li><li><span class="name"><span class="innerContentContainer">long -&gt; Long</span></span></li><li><span class="name"><span class="innerContentContainer">float -&gt; Float</span></span></li><li><span class="name"><span class="innerContentContainer">double -&gt; Double</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">装箱</span></span><ul><li><span class="name"><span class="innerContentContainer">即将基础类型包装为对象. 如:</span></span></li><li><span class="name"><span class="innerContentContainer">int myInt = 500;</span></span></li><li><span class="name"><span class="innerContentContainer">Integer myInt2 = new Integar(myInt);</span></span></li><li><span class="name"><span class="innerContentContainer">一旦装箱, 其值就不可以更改.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拆箱</span></span><ul><li><span class="name"><span class="innerContentContainer">将对象转化为基础类. 如:</span></span></li><li><span class="name"><span class="innerContentContainer">int myInt = myInt2.intValue();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">装箱类支持 toString(). toString()是类方法, 所以不需要new一个对象就可以用. 如:</span></span><ul><li><span class="name"><span class="innerContentContainer">String myStr = Interger.toString(500);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自动拆箱和装箱</span></span><ul><li><span class="name"><span class="innerContentContainer">java在 1.5(5.0) 之后提供了自动拆箱和装箱功能, 语法和使用基本数据类型类似. 如:</span></span></li><li><span class="name"><span class="innerContentContainer">Integer myInt = 500;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #指针和引用">#<span class="contentTagText">指针和引用</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Java没有指针. 但是有引用.</span></span></li><li><span class="name"><span class="innerContentContainer">Java把引用作为默认调用方式, 所以并没有专门的运算符或关键字给引用.</span></span></li><li><span class="name"><span class="innerContentContainer">引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</span></span></li><li><span class="name"><span class="innerContentContainer">Java把引用分为4种 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">强引用</span></span><ul><li><span class="name"><span class="innerContentContainer">只要引用还存在，GC就永远不会回收.</span></span></li><li><span class="name"><span class="innerContentContainer">Object obj = new Object(), obj 就是强引用。通过关键字new创建的对象所关联的引用就是强引用。</span></span></li><li><span class="name"><span class="innerContentContainer">当JVM内存空间不足，JVM宁愿抛出 OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会回收具有强引用的“存活”对象。</span></span></li><li><span class="name"><span class="innerContentContainer">强引用是全局变量时, 需要通过 obj = null; 来释放.</span></span></li><li><span class="name"><span class="innerContentContainer">强应用是局部变量时, 当所在代码块运行完成后, 就会自动释放.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">软引用</span></span><ul><li><span class="name"><span class="innerContentContainer">软引用当内存不足的时候才会回收。</span></span></li><li><span class="name"><span class="innerContentContainer">软引用通过 SoftReference 类实现。</span></span></li><li><span class="name"><span class="innerContentContainer">JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。</span></span></li><li><span class="name"><span class="innerContentContainer">使用软引用对象之前需要判断对象是否还存活。</span></span></li><li><span class="name"><span class="innerContentContainer">常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">弱引用</span></span><ul><li><span class="name"><span class="innerContentContainer">可有可无，GC时首先被回收。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 WeakReference 类实现。</span></span></li><li><span class="name"><span class="innerContentContainer">每次GC时都会直接回收弱引用对象。</span></span></li><li><span class="name"><span class="innerContentContainer">由于GC进程的优先级较低，所以弱引用对象并不是很快就会被回收。</span></span></li><li><span class="name"><span class="innerContentContainer">弱应用同样可用于内存敏感的缓存。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">虚引用</span></span><ul><li><span class="name"><span class="innerContentContainer">最弱的一种引用，回收时机未知。当程序需要知道某个对象是否已经被垃圾回收时，可以使用虚引用。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 PhantomReference 类来实现。</span></span></li><li><span class="name"><span class="innerContentContainer">无法通过虚引用访问对象的任何属性或函数。</span></span></li><li><span class="name"><span class="innerContentContainer">当虚引用已经被放到引用队列，则其指向的对象已经被垃圾回收。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #对象判空">#<span class="contentTagText">对象判空</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">对象判空: if (myObject != null) {…}</span></span></li><li><span class="name"><span class="innerContentContainer">NullObject模式: 整一个NullObject与原有对象实现相同的接口或继承同一个父类. 目的是让调用者不需要判空.  要补充代码.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #对象的元属性">#<span class="contentTagText">对象的元属性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">得到当前方法的名字</span></span><ul><li><span class="name"><span class="innerContentContainer">String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回类名/类类型/接口名</span></span><ul><li><span class="name"><span class="innerContentContainer">forName("类名") &nbsp; // 返回一个Class对象的引用. 用于类没有加载时加载它.</span></span></li><li><span class="name"><span class="innerContentContainer">getName() // 返回包含包名的类名.</span></span></li><li><span class="name"><span class="innerContentContainer">getSimpleName() // 返回不包含包名的类名.</span></span></li><li><span class="name"><span class="innerContentContainer">getCanonicalName()  // 返回全限定类名.</span></span></li><li><span class="name"><span class="innerContentContainer">getInterface() &nbsp;// 返回全限定的接口.</span></span></li><li><span class="name"><span class="innerContentContainer">getSuperClass() // 返回直接父类</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">instanceof 操作符</span></span><ul><li><span class="name"><span class="innerContentContainer">用于判断当前类是否是指定类的之类.</span></span></li><li><span class="name"><span class="innerContentContainer">if (mySubObj instanceof myObj) {…}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取包名和类名</span></span><ul><li><span class="name"><span class="innerContentContainer">android中, 可通过 getPachageName() 获取包名, 通过 getClassName() 获取类名.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类的class type对象</span></span><ul><li><span class="name"><span class="innerContentContainer">Java把类的元属性也对象化了, 即 ClassType. 它是静态对象, 系统加载一个类时就会自动创建它的 ClassType 对象, 不需要手动创建. 其用法是:</span></span></li><li><span class="name"><span class="innerContentContainer">已知类, 获取 Class 对象(推荐用这种):</span></span><ul><li><span class="name"><span class="innerContentContainer">Class myClassType = myClass.Class;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">已知对象, 获取其Class对象</span></span><ul><li><span class="name"><span class="innerContentContainer">Class myClassType = myObject.getClass();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">上面这两种的区别在于第二种只能由对象调用.</span></span></li><li><span class="name"><span class="innerContentContainer">通过类名字符串获取其Class对象</span></span><ul><li><span class="name"><span class="innerContentContainer">Class myClassType = Class.forName("MyClassName");</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">对象判等</span></span><ul><li><span class="name"><span class="innerContentContainer">用 == 比较两个对象, 实际对比的是两个对象的地址是不是相同, 即确认这两个对象是不是同一个, 而一般对象对比的初衷是对比两个不同的对象是否具有同样的属性.</span></span></li><li><span class="name"><span class="innerContentContainer">常用的是用 equals()来对比两个对象的值是否相同.</span></span></li><li><span class="name"><span class="innerContentContainer">java.io.file, java.util.Date, java.lang.string,包装类（Integer,Double等）等, 提供的比较规则为：如果两个对象的类型一致，并且值一致，则返回true,这些类有：</span></span></li><li><span class="name"><span class="innerContentContainer">用户自定义的类, 要自己提供&nbsp;equals()定义.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对象比较</span></span><ul><li><span class="name"><span class="innerContentContainer">Comparable接口</span></span><ul><li><span class="name"><span class="innerContentContainer">类继承Comparable接口后，就必须实现 compareTo() 方法。</span></span></li><li><span class="name"><span class="innerContentContainer">该方法用于约定对象的排序规则。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Comparator接口</span></span><ul><li><span class="name"><span class="innerContentContainer">对于已经实现了Comparable接口的类，如何在不修改其代码的前提下改变它的排序规则呢？</span></span></li><li><span class="name"><span class="innerContentContainer">使用Comparator接口。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">深复制和浅复制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">通过调用 clone() 复制一个现有的对象, 是快速生成一个对象的方式.</span></span><ul><li><span class="name"><span class="innerContentContainer">MyClass myClass1 = new MyClass(23, "zhang");</span></span></li><li><span class="name"><span class="innerContentContainer">MyClass myClass2 = (MyClass) myClass1.clone();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复制的时候有两种方式: 深复制和浅复制.</span></span></li><li><span class="name"><span class="innerContentContainer">对于对象的基础数据类型成员, 无论哪种复制都是直接copy 副本. 但是对于对象成员, 浅复制只复制对象的引用. 深复制则复制对象的副本.</span></span></li><li><span class="name"><span class="innerContentContainer">clone()执行的是浅拷贝. 如果需要深拷贝, 则需要复写clone().</span></span></li><li><span class="name"><span class="innerContentContainer">要复写clone(), 需要类 implements Cloneable.</span></span></li><li><span class="name"><span class="innerContentContainer">深复制要求在引用链上的每一级对象都要复写clone(), 显式的拷贝。所以它是相当麻烦的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RTTI (运行时对象类型识别, runtime type identification)</span></span><ul><li><span class="name"><span class="innerContentContainer">在java中, 所有的类型转化都是在运行时进行正确性检查的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Class.newInstance()</span></span><ul><li><span class="name"><span class="innerContentContainer">根据类的class对象new一个新对象.</span></span></li><li><span class="name"><span class="innerContentContainer">这是实现虚拟构造器的一种途径. 它允许你申明: 我不确切的知道类型, 先创建一个对象再说.</span></span></li><li><span class="name"><span class="innerContentContainer">newInstance() 创建的对象必须有默认的构造器.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">泛化引用</span></span><ul><li><span class="name"><span class="innerContentContainer">Class 对象可指向任何类, 不方便在编译时识别出类型错误. 为弥补这一点, 可使用泛化引用来限定Class对象引用的类型, 方便编译器执行额外的类型检查.</span></span></li><li><span class="name"><span class="innerContentContainer">Class&lt;MyClass&gt; myClass = MyClass.class;   // MyClass 是泛化引用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>反射: 通过字符串进行函数调用  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">通过ClassType 字符串实例化类</span></span><ul><li><span class="name"><span class="innerContentContainer">Class&lt;?&gt; myClass = null;</span></span></li><li><span class="name"><span class="innerContentContainer">myClass = class.forName("myClassType");</span></span></li><li><span class="name"><span class="innerContentContainer">myObject = (myClassType)myClass.newInstance();</span></span></li><li><span class="name"><span class="innerContentContainer">myClassType 中必须有无参数构造函数.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取构造方法(包括私有的)</span></span><ul><li><span class="name"><span class="innerContentContainer">public Constructor getConstructor(Class… parameterTypes); // 获得指定的构造方法，注意只能获得 public 权限的构造方法</span></span></li><li><span class="name"><span class="innerContentContainer">public Constructor getDeclaredConstructor(Class… parameterTypes);  // 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。</span></span></li><li><span class="name"><span class="innerContentContainer">public Constructor[] getConstructors() throws SecurityException;   // 获得所有 public 访问权限的构造方法</span></span></li><li><span class="name"><span class="innerContentContainer">public Constructor[] getDeclaredConstructors() throws SecurityException;  // 获得所有的构造方法，包括（public, private,protected,默认权限的）</span></span></li><li><span class="name"><span class="innerContentContainer">例如: </span></span></li><li><span class="name"><span class="innerContentContainer">public static void printConstructor(String className) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Class&lt;?&gt; aClass = Class.forName(className);</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Constructor</b>&lt;?&gt;[] constructors = aClass.<b>getConstructors</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">print(constructors);</span></span></li><li><span class="name"><span class="innerContentContainer">Constructor&lt;?&gt;[] declaredConstructors = aClass.<b>getDeclaredConstructors</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">print(declaredConstructors);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (ClassNotFoundException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取所有成员变量</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void printFiled(String className) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Class&lt;?&gt; aClass = Class.forName(className);</span></span></li><li><span class="name"><span class="innerContentContainer">Field[] fields = aClass.<b>getFields</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">PrintUtils.print(fields);</span></span></li><li><span class="name"><span class="innerContentContainer">Field[] declaredFields = aClass.<b>getDeclaredFields</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">PrintUtils.print(declaredFields);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (ClassNotFoundException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获得指定成员变量</span></span><ul><li><span class="name"><span class="innerContentContainer">public static Field getFiled(String className, String filedName) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Object o = null;</span></span></li><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Class&lt;?&gt; aClass = Class.forName(className);</span></span></li><li><span class="name"><span class="innerContentContainer">Field declaredField = aClass.<b>getDeclaredField</b>(filedName);</span></span></li><li><span class="name"><span class="innerContentContainer">//&nbsp; &nbsp;if not public,you should call this</span></span></li><li><span class="name"><span class="innerContentContainer">declaredField.<b>setAccessible</b>(true);</span></span></li><li><span class="name"><span class="innerContentContainer">return declaredField;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (ClassNotFoundException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (NoSuchFieldException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">return null;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">调用方: Field field =getFiled("MyClassName", "age");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取所有方法</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void printMethods(String className) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">Class&lt;?&gt; aClass = Class.forName(className);</span></span></li><li><span class="name"><span class="innerContentContainer">Method[] declaredMethods = aClass.<b>getDeclaredMethods</b>();</span></span></li><li><span class="name"><span class="innerContentContainer">PrintUtils.print(declaredMethods);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (ClassNotFoundException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">执行指定方法</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void testMethod(){</span></span><ul><li><span class="name"><span class="innerContentContainer">Person person=new Person();</span></span></li><li><span class="name"><span class="innerContentContainer">Method method = <b>getMethod</b>(CLASS_NAME, "FunctionName", String.class);</span></span></li><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 执行方法，结果保存在 person 中</span></span></li><li><span class="name"><span class="innerContentContainer">Object o = method.<b>invoke</b>(person, CHINA);</span></span></li><li><span class="name"><span class="innerContentContainer">// 拿到我们传递进取的参数 country 的值 China</span></span></li><li><span class="name"><span class="innerContentContainer">String country = person.country;</span></span></li><li><span class="name"><span class="innerContentContainer">PrintUtils.print(country);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (IllegalAccessException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (InvocationTargetException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #for循环">#<span class="contentTagText">for循环</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">for (ii = 0; ii &lt; length; ii++) {...}  // 和C的语言一样</span></span></li><li><span class="name"><span class="innerContentContainer">for (变量 * : 数组) {...}   效率较高, 建议使用. 如: </span></span><ul><li><span class="name"><span class="innerContentContainer">for (String myStr : myStrs) {...}   // myStrs是字符串数组. </span></span></li><li><span class="name"><span class="innerContentContainer">变量类型和数组元素类型匹配.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #where循环">#<span class="contentTagText">where循环</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">while (布尔表达式) {...}</span></span></li><li><span class="name"><span class="innerContentContainer">do {...} while (布尔表达式)</span></span></li><li><span class="name"><span class="innerContentContainer">break;   // 用于跳出里层的循环, 继续执行循环下面的语句. </span></span></li><li><span class="name"><span class="innerContentContainer">continue;  // 用于跳出当次循环, 跳转到布尔表达式.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #if和switch">#<span class="contentTagText">if和switch</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">和c一样.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串">#<span class="contentTagText">字符串</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #转义字符">#<span class="contentTagText">转义字符</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">\": 双引号</span></span></li><li><span class="name"><span class="innerContentContainer">\': 单引号&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">\\: 反斜线&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">\0: 空字符&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">\r: 回车</span></span></li><li><span class="name"><span class="innerContentContainer">\n: 换行</span></span></li><li><span class="name"><span class="innerContentContainer">\t: table跳格</span></span></li><li><span class="name"><span class="innerContentContainer">\u: Unicode码, 比如: $ =&gt; \u0024; { =&gt; \u007B.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串定义">#<span class="contentTagText">字符串定义</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">字符串对象String  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">String myString = new String("my string");</span></span></li><li><span class="name"><span class="innerContentContainer">java语言中, "my string"这种标量, 本身就是String 对象, 由编辑器进行初始化.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>可变字符串：StringBuffer 和 StringBuilder  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">String字符串初始化后, 内容不能再改变. 将一个字符串变量指向新值, 则会new一个新的字符串对象, 原来的字符串会进入垃圾回收. 所以性能会比较差.</span></span></li><li><span class="name"><span class="innerContentContainer">如果字符串频繁变化, 这有必要使用 StringBuffer. 它的性能比 new一个新字符串对象要快很多.</span></span><ul><li><span class="name"><span class="innerContentContainer">StringBuffer myStr = new StringBuffer("String init");</span></span></li><li><span class="name"><span class="innerContentContainer">myStr.append("2st. string");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">StringBuffer是线程安全的。因为 StringBuffer 有缓冲区。</span></span></li><li><span class="name"><span class="innerContentContainer">可变字符串类 StringBuilder, 则是线程不安全的. 但它性能更快.</span></span><ul><li><span class="name"><span class="innerContentContainer">StringBuilder的所有方法和 StringBuffer 都一样。</span></span></li><li><span class="name"><span class="innerContentContainer">但是它们都没有被 synchronized 修饰, 所以性能高.</span></span></li><li><span class="name"><span class="innerContentContainer">StringBuilderJava 5中引入的. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">三者在执行速度上：StringBuilder &gt; StringBuffer &gt; String (由于String是常量，不可改变，拼接时会重新创建新的对象)。</span></span></li><li><span class="name"><span class="innerContentContainer">字符串和整型的相互转换</span></span><ul><li><span class="name"><span class="innerContentContainer">String str = String.valueOf(2);</span></span></li><li><span class="name"><span class="innerContentContainer">int i = Integer.parseInt(str); // 需要捕捉异常: NumberFormatException</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符Char --没必要用字符数组表达字符串</span></span><ul><li><span class="name"><span class="innerContentContainer">Char myChar = 'a';    // 单引号是字符, 双引号是字符串.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">String 转化为 Char</span></span><ul><li><span class="name"><span class="innerContentContainer">Char myChar = myString.charAt(index);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">String 转化为 Char[]</span></span><ul><li><span class="name"><span class="innerContentContainer">Char myChars[] = myString.toCharArray();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Char 转化为String</span></span><ul><li><span class="name"><span class="innerContentContainer">String myString = String.valueOf('C');</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串判空">#<span class="contentTagText">字符串判空</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">if (myString.length() == 0)    // 空串</span></span></li><li><span class="name"><span class="innerContentContainer">if (null == myString)     // 字符串对象没有初始化</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串取长">#<span class="contentTagText">字符串取长</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">myString.length();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串比较">#<span class="contentTagText">字符串比较</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串去空格">#<span class="contentTagText">字符串去空格</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">myString.trim();   // 前后去空格</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b><span class="contentTag" title="Filter #字符串拼接">#<span class="contentTagText">字符串拼接</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">字符串可通过 + 号连接, 这是最直观的.</span></span><ul><li><span class="name"><span class="innerContentContainer">String是常量，不可改变，拼接时会重新创建新的对象.</span></span></li><li><span class="name"><span class="innerContentContainer">因此在大循环体内进行字符串拼接, 则可能出现海量的对象创建和销毁, 导致性能问题.</span></span></li><li><span class="name"><span class="innerContentContainer">解决办法是: 单线程下字符串的串联用StringBuilder，多线程下字符串的串联用StrngBuffer。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基本数据类型与字符串连接时, 会自动转化为字符串. </span></span></li><li><span class="name"><span class="innerContentContainer">对象要自动转为字符串, 需要重载 toString() 方法.</span></span></li><li><span class="name"><span class="innerContentContainer">可变字符串<b>StringBuffer 和 StringBuilder, </b>用 append() 来拼接.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串截取">#<span class="contentTagText">字符串截取</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串查找">#<span class="contentTagText">字符串查找</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串替换">#<span class="contentTagText">字符串替换</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串拆分">#<span class="contentTagText">字符串拆分</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串的格式化输出">#<span class="contentTagText">字符串的格式化输出</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #正则表达式">#<span class="contentTagText">正则表达式</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #时间处理">#<span class="contentTagText">时间处理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #获取系统时间">#<span class="contentTagText">获取系统时间</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">System.currentTimeMillis();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #日期时间">#<span class="contentTagText">日期时间</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">方法1: java.util.Date = java.text.DateFormat.getDateInstance().parse(date String);</span></span></li><li><span class="name"><span class="innerContentContainer">方法2: SimpleDateFormat format = new SimpleDateFormat( "dd.MM.yyyy" );</span></span><ul><li><span class="name"><span class="innerContentContainer">Date date = format.parse( myString );</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">把 Java util.Date 转成 sql.Date</span></span><ul><li><span class="name"><span class="innerContentContainer">java.util.Date utilDate = new java.util.Date();</span></span></li><li><span class="name"><span class="innerContentContainer">java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #时区">#<span class="contentTagText">时区</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组">#<span class="contentTagText">数组</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #定义数组">#<span class="contentTagText">定义数组</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">array 的size是固定的，不能动态改变，且一个array只能存放同一种数据类型。</span></span></li><li><span class="name"><span class="innerContentContainer">array的创建</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>int[]</b> myArray = new int[mySize];</span></span></li><li><span class="name"><span class="innerContentContainer">int[] myArray = {value0, value1, ...};</span></span></li><li><span class="name"><span class="innerContentContainer">或者: int myArray[];   // 可以用, 但不常见.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">java.util.Arrays 类能方便地操作数组. 它的函数都是静态函数, 不需要new.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #遍历数据">#<span class="contentTagText">遍历数据</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">数组元素的访问方式, 最典型的是下标, 即 myArray[1];</span></span></li><li><span class="name"><span class="innerContentContainer">int size = myArray.length;</span></span></li><li><span class="name"><span class="innerContentContainer">for (int ii = 1; ii &lt; size; ii++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">myArray[ii]...;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种: </span></span></li><li><span class="name"><span class="innerContentContainer">for(int value: myArray) {</span></span><ul><li><span class="name"><span class="innerContentContainer">value...;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #取长">#<span class="contentTagText">取长</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">myArray.size()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组元素的新增删除">#<span class="contentTagText">数组元素的新增删除</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Java数组元素的数量是固定, 不能新增删除.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组元素的查询">#<span class="contentTagText">数组元素的查询</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">public static int Arrays.binarySearch(Object[] a, Object key);</span></span></li><li><span class="name"><span class="innerContentContainer">在排好序的array中寻找元素 (用折半排序, 时间成本是logN)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果查找值包含在数组中，则返回搜索键的索引；否则返回 - 1.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组排序">#<span class="contentTagText">数组排序</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">public static void Arrays.sort(Object[] a);</span></span></li><li><span class="name"><span class="innerContentContainer">对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #异常处理">#<span class="contentTagText">异常处理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #异常处理">#<span class="contentTagText">异常处理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 程序代码</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch(ExceptionName e1) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Catch 块：异常处理</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} finally {</span></span><ul><li><span class="name"><span class="innerContentContainer">// finally 块：无论如何都会被执行。即使try块中有return，在return之前，也会调用finally块。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #常见异常类型">#<span class="contentTagText">常见异常类型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Java内置异常类 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #自定义异常">#<span class="contentTagText">自定义异常</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">所有异常都必须是 Throwable 的子类。</span></span></li><li><span class="name"><span class="innerContentContainer">如果希望写一个检查性异常类，则需要继承 Exception 类。</span></span></li><li><span class="name"><span class="innerContentContainer">如果希望写一个运行时异常类，那么需要继承 RuntimeException 类。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存管理">#<span class="contentTagText">内存管理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存模型">#<span class="contentTagText">内存模型</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">堆</span></span><ul><li><span class="name"><span class="innerContentContainer">存放对象实例。new 出来的类实例在这里分配内存。</span></span></li><li><span class="name"><span class="innerContentContainer">堆的大小由-Xms指定，默认是物理内存的1/64；最大值由-Xmx指定，默认是物理内存的1/4。</span></span></li><li><span class="name"><span class="innerContentContainer">默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。</span></span><ul><li><span class="name"><span class="innerContentContainer">比例可由 -XX:MinHeapFreeRatio 指定。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">默认空余内存大于70%时，就会减少内存，直到-Xms设置的大小。</span></span><ul><li><span class="name"><span class="innerContentContainer">比例可由 -XX:MaxHeapFreeRatio 指定。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟机栈</span></span><ul><li><span class="name"><span class="innerContentContainer">每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。</span></span></li><li><span class="name"><span class="innerContentContainer">本地方法栈，则是为虚拟机使用到的Native方法服务。</span></span></li><li><span class="name"><span class="innerContentContainer">如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError异常。</span></span></li><li><span class="name"><span class="innerContentContainer">如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">方法区</span></span><ul><li><span class="name"><span class="innerContentContainer">存储已经加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</span></span></li><li><span class="name"><span class="innerContentContainer">该区内少发生垃圾回收。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">程序计数器</span></span><ul><li><span class="name"><span class="innerContentContainer">当前线程所执行的字节码的行号指示器。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存销毁">#<span class="contentTagText">内存销毁</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">finalize方法</span></span><ul><li><span class="name"><span class="innerContentContainer">gc在销毁对象时，会回调finalize()方法。</span></span></li><li><span class="name"><span class="innerContentContainer">通过重写finalize()，我们可以跟踪对象的销毁过程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GC，Gabage Collection，垃圾收集。一般仅指对堆内存的回收。常见的算法有：</span></span><ul><li><span class="name"><span class="innerContentContainer">Reference Counting</span></span></li><li><span class="name"><span class="innerContentContainer">Mark Sweep</span></span><ul><li><span class="name"><span class="innerContentContainer">.NET CLR 使用。</span></span></li><li><span class="name"><span class="innerContentContainer">Java VM 使用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Copy Collection</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">请求垃圾收集的API</span></span><ul><li><span class="name"><span class="innerContentContainer">System.gc()</span></span></li><li><span class="name"><span class="innerContentContainer">Runtime.getRuntime().gc()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GC分为：</span></span><ul><li><span class="name"><span class="innerContentContainer">Minor GC</span></span><ul><li><span class="name"><span class="innerContentContainer">通常发生在新生代的Eden区，在这个区的对象生存期短。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Full Gc / Major GC&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">发生在老年代</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存判定对象可回收的算法有两种机制：引用计数算法 和 可达性分析法。</span></span><ul><li><span class="name"><span class="innerContentContainer">引用计数算法</span></span><ul><li><span class="name"><span class="innerContentContainer">给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。</span></span></li><li><span class="name"><span class="innerContentContainer">计数器变为0时，内存块就被释放。</span></span></li><li><span class="name"><span class="innerContentContainer">实际上很少使用，因为它难以解决对象之间相互循环引用的问题。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">可达性分析法</span></span><ul><li><span class="name"><span class="innerContentContainer">通过一系列被称为 GCRoots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</span></span></li><li><span class="name"><span class="innerContentContainer">可作为GC Roots的对象主要有：</span></span><ul><li><span class="name"><span class="innerContentContainer">栈帧中的本地变量</span></span></li><li><span class="name"><span class="innerContentContainer">本地方法栈中Native方法引用的对象</span></span></li><li><span class="name"><span class="innerContentContainer">方法区中类静态属性引用的对象</span></span></li><li><span class="name"><span class="innerContentContainer">方法区中常量引用的对象</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GC回收算法： 分代收集算法</span></span><ul><li><span class="name"><span class="innerContentContainer">分代收集算法是当前商用虚拟机广泛采用的一种算法。</span></span></li><li><span class="name"><span class="innerContentContainer">根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。</span></span></li><li><span class="name"><span class="innerContentContainer">新生代：刚分配不久的对象生存期短，每次回收都会有大量对象死去。</span></span><ul><li><span class="name"><span class="innerContentContainer">使用『复制算法』，只需复制少量存活对象即可。</span></span></li><li><span class="name"><span class="innerContentContainer">复制算法要点：</span></span><ul><li><span class="name"><span class="innerContentContainer">把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</span></span></li><li><span class="name"><span class="innerContentContainer">当这一块的内存用尽后，把还存活着的对象『复制』到另外一块上面，再将这一块内存空间一次清理掉。</span></span></li><li><span class="name"><span class="innerContentContainer">实现简单，运行高效。</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：在对象存活率较高时就要进行较多的复制操作，效率将会变低。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">老年代：分配时间较久后还活着的对象, 继续存活的概率较大。</span></span><ul><li><span class="name"><span class="innerContentContainer">使用『标记—清理算法』或者『标记—整理算法』，只需标记较少的回收对象即可。</span></span></li><li><span class="name"><span class="innerContentContainer">标记-清除算法：</span></span><ul><li><span class="name"><span class="innerContentContainer">首先『标记』出所有需要回收的对象，然后统一『清除』所有被标记的对象。</span></span></li><li><span class="name"><span class="innerContentContainer">标记和清除两个过程的效率都不高；</span></span></li><li><span class="name"><span class="innerContentContainer">而且清除之后会产生大量不连续的内存碎片。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">标记-整理算法：</span></span><ul><li><span class="name"><span class="innerContentContainer">首先『标记』出所有需要回收的对象，然后进行『整理』，使得存活的对象都向一端移动，最后直接清理掉端边界以外的内存。</span></span></li><li><span class="name"><span class="innerContentContainer">标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片"。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">新生代如何进化成老年代？</span></span><ul><li><span class="name"><span class="innerContentContainer">对象优先在新生代区中分配，若没有足够空间，触发GC；</span></span></li><li><span class="name"><span class="innerContentContainer">特别大的对象，直接进入老年态；</span></span></li><li><span class="name"><span class="innerContentContainer">如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1；</span></span></li><li><span class="name"><span class="innerContentContainer">若年龄超过一定限制（15），则被晋升到老年态。</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件系统">#<span class="contentTagText">文件系统</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件路径分隔符">#<span class="contentTagText">文件路径分隔符</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">String sep = System.getProperty("file.separator");</span></span></li><li><span class="name"><span class="innerContentContainer">myFile = new File('d:'+sep+"study", "data.txt");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #回车换行符">#<span class="contentTagText">回车换行符</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">System.getProperty("line.separator");</span></span></li><li><span class="name"><span class="innerContentContainer">因为操作系统的不同，换行符操也不同：</span></span><ul><li><span class="name"><span class="innerContentContainer">/r Mac</span></span></li><li><span class="name"><span class="innerContentContainer">/n Unix/Linux</span></span></li><li><span class="name"><span class="innerContentContainer">/r/n Windows</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件夹和文件的存在性">#<span class="contentTagText">文件夹和文件的存在性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #遍历文件夹">#<span class="contentTagText">遍历文件夹</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">File dir = new File("directoryName");</span></span></li><li><span class="name"><span class="innerContentContainer">String[] children = dir.list();</span></span></li><li><span class="name"><span class="innerContentContainer">if (children == null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Either dir does not exist or is not a directory</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">for (int i=0; i &lt; children.length; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Get filename of file or directory</span></span></li><li><span class="name"><span class="innerContentContainer">String filename = children[i];</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// It is also possible to filter the list of returned files.</span></span></li><li><span class="name"><span class="innerContentContainer">// This example does not return any files that start with `.'.</span></span></li><li><span class="name"><span class="innerContentContainer">FilenameFilter filter = new FilenameFilter() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public boolean accept(File dir, String name) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return !name.startsWith(".");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">children = dir.list(filter);</span></span></li><li><span class="name"><span class="innerContentContainer">// The list of files can also be retrieved as File objects</span></span></li><li><span class="name"><span class="innerContentContainer">File[] files = dir.listFiles();</span></span></li><li><span class="name"><span class="innerContentContainer">// This filter only returns directories</span></span></li><li><span class="name"><span class="innerContentContainer">FileFilter fileFilter = new FileFilter() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public boolean accept(File file) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return file.isDirectory();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">files = dir.listFiles(fileFilter);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #新建文件夹">#<span class="contentTagText">新建文件夹</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #删除文件夹">#<span class="contentTagText">删除文件夹</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #返回和修改当前路径">#<span class="contentTagText">返回和修改当前路径</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #创建文件">#<span class="contentTagText">创建文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #读文件">#<span class="contentTagText">读文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #写文件">#<span class="contentTagText">写文件</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">向文件末尾添加内容</span></span><ul><li><span class="name"><span class="innerContentContainer">BufferedWriter out = null;</span></span></li><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">out = new BufferedWriter(new FileWriter(”filename”, true));</span></span></li><li><span class="name"><span class="innerContentContainer">out.write(”aString”);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (IOException e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// error processing code</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} finally {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (out != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">out.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #返回文件长度">#<span class="contentTagText">返回文件长度</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件改名改属性">#<span class="contentTagText">文件改名改属性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #删除文件">#<span class="contentTagText">删除文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件系统原语">#<span class="contentTagText">文件系统原语</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">解析/读取XML 文件</span></span><ul><li><span class="name"><span class="innerContentContainer">package net.viralpatel.java.xmlparser;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.io.File;</span></span></li><li><span class="name"><span class="innerContentContainer">import javax.xml.parsers.DocumentBuilder;</span></span></li><li><span class="name"><span class="innerContentContainer">import javax.xml.parsers.DocumentBuilderFactory;</span></span></li><li><span class="name"><span class="innerContentContainer">import org.w3c.dom.Document;</span></span></li><li><span class="name"><span class="innerContentContainer">import org.w3c.dom.Element;</span></span></li><li><span class="name"><span class="innerContentContainer">import org.w3c.dom.Node;</span></span></li><li><span class="name"><span class="innerContentContainer">import org.w3c.dom.NodeList;</span></span></li><li><span class="name"><span class="innerContentContainer">public class XMLParser {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void getAllUserNames(String fileName) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span></span></li><li><span class="name"><span class="innerContentContainer">DocumentBuilder db = dbf.newDocumentBuilder();</span></span></li><li><span class="name"><span class="innerContentContainer">File file = new File(fileName);</span></span></li><li><span class="name"><span class="innerContentContainer">if (file.exists()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Document doc = db.parse(file);</span></span></li><li><span class="name"><span class="innerContentContainer">Element docEle = doc.getDocumentElement();</span></span></li><li><span class="name"><span class="innerContentContainer">// Print root element of the document</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Root element of the document: " + docEle.getNodeName());</span></span></li><li><span class="name"><span class="innerContentContainer">NodeList studentList = docEle.getElementsByTagName("student");</span></span></li><li><span class="name"><span class="innerContentContainer">// Print total student elements in document</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Total students: " + studentList.getLength());</span></span></li><li><span class="name"><span class="innerContentContainer">if (studentList != null &amp;&amp; studentList.getLength() &gt; 0) {</span></span><ul><li><span class="name"><span class="innerContentContainer">for (int i = 0; i &lt; studentList.getLength(); i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Node node = studentList.item(i);</span></span></li><li><span class="name"><span class="innerContentContainer">if (node.getNodeType() == Node.ELEMENT_NODE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println("=====================");</span></span></li><li><span class="name"><span class="innerContentContainer">Element e = (Element) node;</span></span></li><li><span class="name"><span class="innerContentContainer">NodeList nodeList = e.getElementsByTagName("name");</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Name: " + nodeList.item(0).getChildNodes().item(0).getNodeValue());</span></span></li><li><span class="name"><span class="innerContentContainer">nodeList = e.getElementsByTagName("grade");</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Grade: " + nodeList.item(0).getChildNodes().item(0).getNodeValue());</span></span></li><li><span class="name"><span class="innerContentContainer">nodeList = e.getElementsByTagName("age");</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Age: " + nodeList.item(0).getChildNodes().item(0).getNodeValue());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.exit(1);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (Exception e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println(e);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public static void main(String[] args) {</span></span><ul><li><span class="name"><span class="innerContentContainer">XMLParser parser = new XMLParser();</span></span></li><li><span class="name"><span class="innerContentContainer">parser.getAllUserNames("c:\\test.xml");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建 JSON 格式的数据文件</span></span><ul><li><span class="name"><span class="innerContentContainer">import org.json.JSONObject;</span></span></li><li><span class="name"><span class="innerContentContainer">...</span></span></li><li><span class="name"><span class="innerContentContainer">JSONObject json = new JSONObject();</span></span></li><li><span class="name"><span class="innerContentContainer">json.put("city", "Mumbai");</span></span></li><li><span class="name"><span class="innerContentContainer">json.put("country", "India");</span></span></li><li><span class="name"><span class="innerContentContainer">...</span></span></li><li><span class="name"><span class="innerContentContainer">String output = json.toString();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">创建ZIP和JAR文件</span></span><ul><li><span class="name"><span class="innerContentContainer">import java.util.zip.*;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.io.*;</span></span></li><li><span class="name"><span class="innerContentContainer">public class ZipIt {</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void main(String args[]) throws IOException {</span></span><ul><li><span class="name"><span class="innerContentContainer">if (args.length &lt; 2) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.err.println("usage: java ZipIt Zip.zip file1 file2 file3");</span></span></li><li><span class="name"><span class="innerContentContainer">System.exit(-1);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">File zipFile = new File(args[0]);</span></span></li><li><span class="name"><span class="innerContentContainer">if (zipFile.exists()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.err.println("Zip file already exists, please try another");</span></span></li><li><span class="name"><span class="innerContentContainer">System.exit(-2);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">FileOutputStream fos = new FileOutputStream(zipFile);</span></span></li><li><span class="name"><span class="innerContentContainer">ZipOutputStream zos = new ZipOutputStream(fos);</span></span></li><li><span class="name"><span class="innerContentContainer">int bytesRead;</span></span></li><li><span class="name"><span class="innerContentContainer">byte[] buffer = new byte[1024];</span></span></li><li><span class="name"><span class="innerContentContainer">CRC32 crc = new CRC32();</span></span></li><li><span class="name"><span class="innerContentContainer">for (int i=1, n=args.length; i &lt; n; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">String name = args[i];</span></span></li><li><span class="name"><span class="innerContentContainer">File file = new File(name);</span></span></li><li><span class="name"><span class="innerContentContainer">if (!file.exists()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.err.println("Skipping: " + name);</span></span></li><li><span class="name"><span class="innerContentContainer">continue;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">BufferedInputStream bis = new BufferedInputStream(</span></span><ul><li><span class="name"><span class="innerContentContainer">new FileInputStream(file));</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">crc.reset();</span></span></li><li><span class="name"><span class="innerContentContainer">while ((bytesRead = bis.read(buffer)) != -1) {</span></span><ul><li><span class="name"><span class="innerContentContainer">crc.update(buffer, 0, bytesRead);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">bis.close();</span></span></li><li><span class="name"><span class="innerContentContainer">// Reset to beginning of input stream</span></span></li><li><span class="name"><span class="innerContentContainer">bis = new BufferedInputStream(new FileInputStream(file));</span></span></li><li><span class="name"><span class="innerContentContainer">ZipEntry entry = new ZipEntry(name);</span></span></li><li><span class="name"><span class="innerContentContainer">entry.setMethod(ZipEntry.STORED);</span></span></li><li><span class="name"><span class="innerContentContainer">entry.setCompressedSize(file.length());</span></span></li><li><span class="name"><span class="innerContentContainer">entry.setSize(file.length());</span></span></li><li><span class="name"><span class="innerContentContainer">entry.setCrc(crc.getValue());</span></span></li><li><span class="name"><span class="innerContentContainer">zos.putNextEntry(entry);</span></span></li><li><span class="name"><span class="innerContentContainer">while ((bytesRead = bis.read(buffer)) != -1) {</span></span><ul><li><span class="name"><span class="innerContentContainer">zos.write(buffer, 0, bytesRead);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">bis.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">zos.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用NIO进行快速的文件拷贝</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void fileCopy( File in, File out) throws IOException {</span></span><ul><li><span class="name"><span class="innerContentContainer">FileChannel inChannel = new FileInputStream( in ).getChannel();</span></span></li><li><span class="name"><span class="innerContentContainer">FileChannel outChannel = new FileOutputStream( out ).getChannel();</span></span></li><li><span class="name"><span class="innerContentContainer">try {</span></span></li><li><span class="name"><span class="innerContentContainer">//&nbsp;inChannel.transferTo(0, inChannel.size(), outChannel);&nbsp; &nbsp;// original -- apparently has trouble copying large files on Windows</span></span></li><li><span class="name"><span class="innerContentContainer">// magic number for Windows, 64Mb - 32Kb)</span></span><ul><li><span class="name"><span class="innerContentContainer">int maxCount = (64 * 1024 * 1024) - (32 * 1024);</span></span></li><li><span class="name"><span class="innerContentContainer">long size = inChannel.size();</span></span></li><li><span class="name"><span class="innerContentContainer">long position = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">while ( position &lt; size) {</span></span><ul><li><span class="name"><span class="innerContentContainer">position += inChannel.transferTo( position, maxCount, outChannel );</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} finally {</span></span><ul><li><span class="name"><span class="innerContentContainer">if ( inChannel != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">inChannel.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">if ( outChannel != null) {</span></span><ul><li><span class="name"><span class="innerContentContainer">outChannel.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用iText JAR生成PDF</span></span><ul><li><span class="name"><span class="innerContentContainer">import java.io.File;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.io.FileOutputStream;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.io.OutputStream;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.util.Date;</span></span></li><li><span class="name"><span class="innerContentContainer">import com.lowagie.text.Document;</span></span></li><li><span class="name"><span class="innerContentContainer">import com.lowagie.text.Paragraph;</span></span></li><li><span class="name"><span class="innerContentContainer">import com.lowagie.text.pdf.PdfWriter;</span></span></li><li><span class="name"><span class="innerContentContainer">public class GeneratePDF {</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void main(String[] args) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">OutputStream file = new FileOutputStream(new File("C:\\Test.pdf"));</span></span></li><li><span class="name"><span class="innerContentContainer">Document document = new Document();</span></span></li><li><span class="name"><span class="innerContentContainer">PdfWriter.getInstance(document, file);</span></span></li><li><span class="name"><span class="innerContentContainer">document.open();</span></span></li><li><span class="name"><span class="innerContentContainer">document.add(new Paragraph("Hello Kiran"));</span></span></li><li><span class="name"><span class="innerContentContainer">document.add(new Paragraph(new Date().toString()));</span></span></li><li><span class="name"><span class="innerContentContainer">document.close();</span></span></li><li><span class="name"><span class="innerContentContainer">file.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (Exception e) {</span></span><ul><li><span class="name"><span class="innerContentContainer">e.printStackTrace();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典">#<span class="contentTagText">字典</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典定义">#<span class="contentTagText">字典定义</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Map集合中的键对象不允许重复，也就说，任意两个键对象通过equals()方法比较的结果都是false.，但是可以将任意多个键独享映射到同一个值对象上。</span></span></li><li><span class="name"><span class="innerContentContainer">标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap。</span></span></li><li><span class="name"><span class="innerContentContainer">HashMap：Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。</span></span></li><li><span class="name"><span class="innerContentContainer">LinkedHashMap： 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。</span></span></li><li><span class="name"><span class="innerContentContainer">TreeMap ： 基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在 于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。</span></span></li><li><span class="name"><span class="innerContentContainer">WeakHashMao ：弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。</span></span></li><li><span class="name"><span class="innerContentContainer">IdentifyHashMap： : 使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典size">#<span class="contentTagText">字典size</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">int size() ：返回集合中元素的数目</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #判断元素存在性">#<span class="contentTagText">判断元素存在性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">用 containsKey()和 containsValue() 测试 Map中是否包含某个“键”或“值”。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典遍历">#<span class="contentTagText">字典遍历</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// Map.entry&lt;Integer,String&gt; 映射项（键-值对）  有几个方法：用上面的名字entry </span></span></li><li><span class="name"><span class="innerContentContainer">entry.getKey() ;entry.getValue(); entry.setValue();</span></span></li><li><span class="name"><span class="innerContentContainer">//map.entrySet()  返回此映射中包含的映射关系的 Set视图。</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("key= " + entry.getKey() + " and value= "+ entry.getValue());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #成员的新增删除">#<span class="contentTagText">成员的新增删除</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Object <b>put</b>(Object key, Object value)： 向集合中加入元素</span></span></li><li><span class="name"><span class="innerContentContainer">Object remove(Object key)： 删除与KEY相关的元素</span></span></li><li><span class="name"><span class="innerContentContainer">void putAll(Map t)：  将来自特定映像的所有元素添加给该映像</span></span></li><li><span class="name"><span class="innerContentContainer">void clear()：从映像中删除所有映射</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查找key">#<span class="contentTagText">查找key</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">使用keySet()抽取key序列，将map中的所有keys生成一个Set。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查找value">#<span class="contentTagText">查找value</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Object get(Object key)：获得与关键字key相关的 value 。</span></span></li><li><span class="name"><span class="innerContentContainer">使用values()抽取value序列，将map中的所有values生成一个Collection。</span></span></li><li><span class="name"><span class="innerContentContainer">为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #排序">#<span class="contentTagText">排序</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">Android定制的字典类: SparseArray</span></span><ul><li><span class="name"><span class="innerContentContainer">通过避免 基本数据类型的装箱操作 来节省内存开销.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典定义">#<span class="contentTagText">字典定义</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">SparseArray sparseArray = new SparseArray&lt;&gt;();    // 默认容量是10</span></span></li><li><span class="name"><span class="innerContentContainer">SparseArray sparseArray = new SparseArray&lt;&gt;(capacity);  // 指定容量.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #成员的新增删除">#<span class="contentTagText">成员的新增删除</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">sparseArray.put(int key,Student value);  // key永远是int型数据.</span></span></li><li><span class="name"><span class="innerContentContainer">sparseArray.remove(int key);</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #UT">#<span class="contentTagText">UT</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #平台兼容性">#<span class="contentTagText">平台兼容性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #泛型">#<span class="contentTagText">泛型</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #宏定义">#<span class="contentTagText">宏定义</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">集合</span></span><ul><li><span class="name"><span class="innerContentContainer">Java的集合可以存放不同类型的对象. 但不能放基本数据类型.</span></span></li><li><span class="name"><span class="innerContentContainer">可以使用集合提供的ReadOnly方法，以只读方式来使用集合。该方法将返回一个集合的只读版本。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Collection接口 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">collection 定义集合的最基本的接口，List和Set都继承自<b>Collection接口.</b></span></span></li><li><span class="name"><span class="innerContentContainer">boolean add(Object o) ：向集合中加入一个对象的引用</span></span></li><li><span class="name"><span class="innerContentContainer">void clear()：删除集合中所有的对象，即不再持有这些对象的引用</span></span></li><li><span class="name"><span class="innerContentContainer">boolean isEmpty() ：判断集合是否为空</span></span></li><li><span class="name"><span class="innerContentContainer">boolean contains(Object o) ： 判断集合中是否持有特定对象的引用</span></span></li><li><span class="name"><span class="innerContentContainer">boolean remove(Object o) ：从集合中删除一个对象的引用</span></span></li><li><span class="name"><span class="innerContentContainer">int size() ：返回集合中元素的数目</span></span></li><li><span class="name"><span class="innerContentContainer">Object[] toArray() ： 返回一个数组，该数组中包括集合中的所有元素</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Iterartor</b> <b>iterator</b>() ：返回一个Iterator对象，可以用来遍历集合中的元素. iterator<b> 接口定义了如下方法:</b></span></span><ul><li><span class="name"><span class="innerContentContainer">hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true</span></span></li><li><span class="name"><span class="innerContentContainer">next() ：返回下一个元素</span></span></li><li><span class="name"><span class="innerContentContainer">remove()：从集合中删除上一个有next()方法返回的元素。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>List</b>: 可以自动扩展的列表. 可存放重复对象。 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">List接口主要实现类包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">ArrayList() : 代表长度可以改变的数组。可对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢。</span></span><ul><li><span class="name"><span class="innerContentContainer">ListIterator只应该用来由后向前遍历 ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LinkedList(): 在实现中采用链表数据结构。插入和删除速度快，随机访问速度慢。</span></span><ul><li><span class="name"><span class="innerContentContainer">具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法使得LinkedList可以当作堆栈、队列和双向队列使用。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">List 的 get(int index) 方法放回集合中由参数index指定的索引位置的对象，下标从“0” 开始。</span></span></li><li><span class="name"><span class="innerContentContainer">使用 迭代器（Iterator）遍历:</span></span><ul><li><span class="name"><span class="innerContentContainer">Iterator it=list.iterator();</span></span></li><li><span class="name"><span class="innerContentContainer">while(it.hashNext()){</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println(it.next());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Set</b>: 没有重复的集合 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">set是最简单的一种集合，集合中的对象不存在重复，不按特定的方式排序。</span></span></li><li><span class="name"><span class="innerContentContainer">set接口主要实现了两个实现类：</span></span></li><li><span class="name"><span class="innerContentContainer">HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快. </span></span><ul><li><span class="name"><span class="innerContentContainer">存入HashSet的对象必须定义hashCode()。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</span></span><ul><li><span class="name"><span class="innerContentContainer">保存次序的set, 底层为树结构。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。</span></span><ul><li><span class="name"><span class="innerContentContainer">在使用迭代器遍历Set时，结果会按元素插入的次序显示。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">set具有与Collection完全一样的接口，没有任何额外的功能，实际上Set就是Collection,只是行为不同: set不保存重复的元素.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TreeSet, TreeList, Tree** : 自动排序的组数</span></span></li><li><span class="name"><span class="innerContentContainer">把 Array 转换成 Map</span></span><ul><li><span class="name"><span class="innerContentContainer">import java.util.Map;</span></span></li><li><span class="name"><span class="innerContentContainer">import org.apache.commons.lang.ArrayUtils;</span></span></li><li><span class="name"><span class="innerContentContainer">public class Main {</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void main(String[] args) {</span></span><ul><li><span class="name"><span class="innerContentContainer">String[][] countries = { { "United States", "New York" }, { "United Kingdom", "London" },</span></span><ul><li><span class="name"><span class="innerContentContainer">{ "Netherland", "Amsterdam" }, { "Japan", "Tokyo" }, { "France", "Paris" } }</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Map countryCapitals = ArrayUtils.toMap(countries);</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Capital of Japan is " + countryCapitals.get("Japan"));</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println("Capital of France is " + countryCapitals.get("France"));</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改变数组的大小</span></span><ul><li><span class="name"><span class="innerContentContainer">private static Object resizeArray (Object oldArray, int newSize) {</span></span><ul><li><span class="name"><span class="innerContentContainer">int oldSize = java.lang.reflect.Array.getLength(oldArray);</span></span></li><li><span class="name"><span class="innerContentContainer">Class elementType = oldArray.getClass().getComponentType();</span></span></li><li><span class="name"><span class="innerContentContainer">Object newArray = java.lang.reflect.Array.newInstance(</span></span><ul><li><span class="name"><span class="innerContentContainer">elementType,newSize);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">int preserveLength = Math.min(oldSize,newSize);</span></span></li><li><span class="name"><span class="innerContentContainer">if (preserveLength &gt; 0)</span></span><ul><li><span class="name"><span class="innerContentContainer">System.arraycopy (oldArray,0,newArray,0,preserveLength);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">return newArray;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">媒体</span></span><ul><li><span class="name"><span class="innerContentContainer">创建图片的缩略图</span></span><ul><li><span class="name"><span class="innerContentContainer">private void createThumbnail(String filename, int thumbWidth, int thumbHeight, int quality, String outFilename)</span></span><ul><li><span class="name"><span class="innerContentContainer">throws InterruptedException, FileNotFoundException, IOException {</span></span></li><li><span class="name"><span class="innerContentContainer">// load image from filename</span></span></li><li><span class="name"><span class="innerContentContainer">Image image = Toolkit.getDefaultToolkit().getImage(filename);</span></span></li><li><span class="name"><span class="innerContentContainer">MediaTracker mediaTracker = new MediaTracker(new Container());</span></span></li><li><span class="name"><span class="innerContentContainer">mediaTracker.addImage(image, 0);</span></span></li><li><span class="name"><span class="innerContentContainer">mediaTracker.waitForID(0);</span></span></li><li><span class="name"><span class="innerContentContainer">// use this to test for errors at this point: System.out.println(mediaTracker.isErrorAny());</span></span></li><li><span class="name"><span class="innerContentContainer">// determine thumbnail size from WIDTH and HEIGHT</span></span></li><li><span class="name"><span class="innerContentContainer">double thumbRatio = (double)thumbWidth / (double)thumbHeight;</span></span></li><li><span class="name"><span class="innerContentContainer">int imageWidth = image.getWidth(null);</span></span></li><li><span class="name"><span class="innerContentContainer">int imageHeight = image.getHeight(null);</span></span></li><li><span class="name"><span class="innerContentContainer">double imageRatio = (double)imageWidth / (double)imageHeight;</span></span></li><li><span class="name"><span class="innerContentContainer">if (thumbRatio &lt; imageRatio) {</span></span><ul><li><span class="name"><span class="innerContentContainer">thumbHeight = (int)(thumbWidth / imageRatio);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else {</span></span><ul><li><span class="name"><span class="innerContentContainer">thumbWidth = (int)(thumbHeight * imageRatio);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// draw original image to thumbnail image object and</span></span></li><li><span class="name"><span class="innerContentContainer">// scale it to the new size on-the-fly</span></span></li><li><span class="name"><span class="innerContentContainer">BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB);</span></span></li><li><span class="name"><span class="innerContentContainer">Graphics2D graphics2D = thumbImage.createGraphics();</span></span></li><li><span class="name"><span class="innerContentContainer">graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span></span></li><li><span class="name"><span class="innerContentContainer">graphics2D.drawImage(image, 0, 0, thumbWidth, thumbHeight, null);</span></span></li><li><span class="name"><span class="innerContentContainer">// save thumbnail image to outFilename</span></span></li><li><span class="name"><span class="innerContentContainer">BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename));</span></span></li><li><span class="name"><span class="innerContentContainer">JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);</span></span></li><li><span class="name"><span class="innerContentContainer">JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage);</span></span></li><li><span class="name"><span class="innerContentContainer">quality = Math.max(0, Math.min(quality, 100));</span></span></li><li><span class="name"><span class="innerContentContainer">param.setQuality((float)quality / 100.0f, false);</span></span></li><li><span class="name"><span class="innerContentContainer">encoder.setJPEGEncodeParam(param);</span></span></li><li><span class="name"><span class="innerContentContainer">encoder.encode(thumbImage);</span></span></li><li><span class="name"><span class="innerContentContainer">out.close();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抓屏程序</span></span><ul><li><span class="name"><span class="innerContentContainer">import java.awt.Dimension;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.awt.Rectangle;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.awt.Robot;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.awt.Toolkit;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.awt.image.BufferedImage;</span></span></li><li><span class="name"><span class="innerContentContainer">import javax.imageio.ImageIO;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.io.File;</span></span></li><li><span class="name"><span class="innerContentContainer">public void captureScreen(String fileName) throws Exception {</span></span><ul><li><span class="name"><span class="innerContentContainer">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();</span></span></li><li><span class="name"><span class="innerContentContainer">Rectangle screenRectangle = new Rectangle(screenSize);</span></span></li><li><span class="name"><span class="innerContentContainer">Robot robot = new Robot();</span></span></li><li><span class="name"><span class="innerContentContainer">BufferedImage image = robot.createScreenCapture(screenRectangle);</span></span></li><li><span class="name"><span class="innerContentContainer">ImageIO.write(image, "png", new File(fileName));</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">网络</span></span><ul><li><span class="name"><span class="innerContentContainer">HTTP 代理设置</span></span><ul><li><span class="name"><span class="innerContentContainer">System.getProperties().put("http.proxyHost", "someProxyURL");</span></span></li><li><span class="name"><span class="innerContentContainer">System.getProperties().put("http.proxyPort", "someProxyPort");</span></span></li><li><span class="name"><span class="innerContentContainer">System.getProperties().put("http.proxyUser", "someUserName");</span></span></li><li><span class="name"><span class="innerContentContainer">System.getProperties().put("http.proxyPassword", "somePassword");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送邮件</span></span><ul><li><span class="name"><span class="innerContentContainer">import javax.mail.*;</span></span></li><li><span class="name"><span class="innerContentContainer">import javax.mail.internet.*;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.util.*;</span></span></li><li><span class="name"><span class="innerContentContainer">public void postMail(String recipients[ ], String subject, String message , String from) throws MessagingException {</span></span><ul><li><span class="name"><span class="innerContentContainer">boolean debug = false;</span></span><ul><li><span class="name"><span class="innerContentContainer">//Set the host smtp address</span></span></li><li><span class="name"><span class="innerContentContainer">Properties props = new Properties();</span></span></li><li><span class="name"><span class="innerContentContainer">props.put("mail.smtp.host", "smtp.example.com");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// create some properties and get the default Session</span></span></li><li><span class="name"><span class="innerContentContainer">Session session = Session.getDefaultInstance(props, null);</span></span></li><li><span class="name"><span class="innerContentContainer">session.setDebug(debug);</span></span></li><li><span class="name"><span class="innerContentContainer">// create a message</span></span></li><li><span class="name"><span class="innerContentContainer">Message msg = new MimeMessage(session);</span></span></li><li><span class="name"><span class="innerContentContainer">// set the from and to address</span></span></li><li><span class="name"><span class="innerContentContainer">InternetAddress addressFrom = new InternetAddress(from);</span></span></li><li><span class="name"><span class="innerContentContainer">msg.setFrom(addressFrom);</span></span></li><li><span class="name"><span class="innerContentContainer">InternetAddress[] addressTo = new InternetAddress[recipients.length];</span></span></li><li><span class="name"><span class="innerContentContainer">for (int i = 0; i &lt; recipients.length; i++) {</span></span><ul><li><span class="name"><span class="innerContentContainer">addressTo[i] = new InternetAddress(recipients[i]);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">msg.setRecipients(Message.RecipientType.TO, addressTo);</span></span></li><li><span class="name"><span class="innerContentContainer">// Optional : You can also set your custom headers in the Email if you Want</span></span></li><li><span class="name"><span class="innerContentContainer">msg.addHeader("MyHeaderName", "myHeaderValue");</span></span></li><li><span class="name"><span class="innerContentContainer">// Setting the Subject and Content Type</span></span></li><li><span class="name"><span class="innerContentContainer">msg.setSubject(subject);</span></span></li><li><span class="name"><span class="innerContentContainer">msg.setContent(message, "text/plain");</span></span></li><li><span class="name"><span class="innerContentContainer">Transport.send(msg);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送代数据的HTTP 请求</span></span><ul><li><span class="name"><span class="innerContentContainer">import java.io.BufferedReader;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.io.InputStreamReader;</span></span></li><li><span class="name"><span class="innerContentContainer">import java.net.URL;</span></span></li><li><span class="name"><span class="innerContentContainer">public class Main {</span></span><ul><li><span class="name"><span class="innerContentContainer">public static void main(String[] args) {</span></span><ul><li><span class="name"><span class="innerContentContainer">try {</span></span><ul><li><span class="name"><span class="innerContentContainer">URL my_url = new URL("http://coolshell.cn/");</span></span></li><li><span class="name"><span class="innerContentContainer">BufferedReader br = new BufferedReader(new InputStreamReader(my_url.openStream()));</span></span></li><li><span class="name"><span class="innerContentContainer">String strTemp = "";</span></span></li><li><span class="name"><span class="innerContentContainer">while(null != (strTemp = br.readLine())){</span></span></li><li><span class="name"><span class="innerContentContainer">System.out.println(strTemp);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} catch (Exception ex) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ex.printStackTrace();</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">设计模式</span></span><ul><li><span class="name"><span class="innerContentContainer">单例 Singleton示例1  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">public class SimpleSingleton {</span></span><ul><li><span class="name"><span class="innerContentContainer">private static SimpleSingleton singleInstance = new SimpleSingleton();</span></span></li><li><span class="name"><span class="innerContentContainer">//Marking default constructor private</span></span></li><li><span class="name"><span class="innerContentContainer">//to avoid direct instantiation.</span></span></li><li><span class="name"><span class="innerContentContainer">private SimpleSingleton() {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Get instance for class SimpleSingleton</span></span></li><li><span class="name"><span class="innerContentContainer">public static SimpleSingleton getInstance() {</span></span><ul><li><span class="name"><span class="innerContentContainer">return singleInstance;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">单例 Singleton示例2  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">public enum SimpleSingleton {</span></span><ul><li><span class="name"><span class="innerContentContainer">INSTANCE;</span></span></li><li><span class="name"><span class="innerContentContainer">public void doSomething() {</span></span></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//Call the method from Singleton:</span></span></li><li><span class="name"><span class="innerContentContainer">SimpleSingleton.INSTANCE.doSomething();</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Lamada表达式 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">λ表达式本质上是一个匿名方法。比如：</span></span><ul><li><span class="name"><span class="innerContentContainer">public int add(int x, int y) {</span></span><ul><li><span class="name"><span class="innerContentContainer">return x + y;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">转成λ表达式后是这个样子: (int x, int y) -&gt; x + y;</span></span></li><li><span class="name"><span class="innerContentContainer">参数类型也可以省略：(x, y) -&gt; x + y; //返回两数之和</span></span></li><li><span class="name"><span class="innerContentContainer">或者 (x, y) -&gt; { return x + y; }</span></span></li><li><span class="name"><span class="innerContentContainer">可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有参数, 就省事了:  () -&gt; { System.out.println("Hello Lambda!"); }</span></span></li><li><span class="name"><span class="innerContentContainer">如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</span></span><ul><li><span class="name"><span class="innerContentContainer">c -&gt; { return c.size(); }</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。</span></span><ul><li><span class="name"><span class="innerContentContainer">Thread gaoDuanDaQiShangDangCi = new Thread( () -&gt; {</span></span><ul><li><span class="name"><span class="innerContentContainer">System.out.println("This is from an anonymous method (lambda exp).");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} );</span></span></li><li><span class="name"><span class="innerContentContainer">并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">更多高级的内容参见: https://www.jb51.net/article/104903.htm</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Kotlin</span></span><ul><li><span class="name"><span class="innerContentContainer">一个用于多平台应用的静态编程语言。非常年轻。</span></span></li><li><span class="name"><span class="innerContentContainer">Kotlin完全兼容Java的语言，可以编译成Java字节码，支持在JVM上运行。</span></span></li><li><span class="name"><span class="innerContentContainer">也可以编译成JavaScript，方便在没有JVM的设备上运行。</span></span></li><li><span class="name"><span class="innerContentContainer">在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</span></span></li></ul></li></ul>
  </body>
</html>