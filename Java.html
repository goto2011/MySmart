<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><b>Java</b></span><ul><li><span class="name">代码组织方式</span><ul><li><span class="name">最小编程规范</span><ul><li><span class="name">{不独占一行;</span></li><li><span class="name">包名:全小写; 一般采用 com.公司名.模块名.子系统名.类名 方式.</span></li><li><span class="name">类名:各单词首字母大写;</span></li><li><span class="name">方法名:第一个单词小写, 其它单词首字母大写;</span></li><li><span class="name">属性名:前缀m, 各单词首字母大写;</span></li><li><span class="name">局部变量:前缀my, 各单词首字母大写.</span></li></ul></li><li><span class="name">java文件由如下部分组成</span><ul><li><span class="name">包申明: 即申明自己是谁, 方便别人导入.  只能放在Java文件的第一行. 如: package com.imagescan.tools;</span></li><li><span class="name">导入包: 即导入别的包, 方便在自己类中调用. 一般紧接着包申明.</span><ul><li><span class="name">import java.util.Data;</span></li><li><span class="name">可以使用通配符*, 比如: import java.util.*;</span></li><li><span class="name">其中以 java/javax 开头的包为核心包, 以 <a class="contentLink" target="_blank" rel="noreferrer" href="http://com.org">com.org</a> 开头的包为各组织提供的.</span></li><li><span class="name">Java编译器会默认导入jdk的java.lang包中的所有类, 其中定义了system/string/object/math等常用类,这些类不需要显式导入.</span></li></ul></li><li><span class="name">接下来是类定义, 即普通代码.</span></li></ul></li><li><span class="name">包</span><ul><li><span class="name">包是java的核心概念. 将相关的类放到一个文件夹中, 这个文件夹就叫类包, 简称包.</span></li><li><span class="name">Java约定, 包名和文件路径保持一致.包名即 路径.类名/接口名.</span></li><li><span class="name">路径支持递归, 即可以有多级子目录. 各级子目录用 . 分割.</span></li><li><span class="name">调用其它包中的类时, 需要先导入包, 然后在代码中直接用类名. 也可以在调用时使用完整的包名(不推荐).</span></li><li><span class="name">编译器在寻址包名时, 会查找当前目录和系统环境变量 classpath 包含的目录.</span></li></ul></li></ul></li><li><span class="name">make文件</span><ul><li><span class="name">android.mk文件中新增jar包</span></li><li><span class="name">Local_static_java_libraries:=</span><ul><li><span class="name">android_support_v4\</span></li><li><span class="name">Netpad_system</span></li></ul></li><li><span class="name">Local_prebuilt_static_java_libraries:=</span><ul><li><span class="name">libs/function_SDK.jar</span></li></ul></li></ul></li><li><span class="name">类和对象</span><ul><li><span class="name">java代码的基本组成单位是类, 所有代码都放在类中.</span></li><li><span class="name">java没有头文件, 且申明和定义合一. 一个文件只能放一个 public 类, 文件名和该类名相同. 当一个文件中放多个类时, 其它类叫内部类, 内部类不能是 public 类.</span></li><li><span class="name">类的定义</span><ul><li><span class="name">public class MyClass extends ParentClass {</span><ul><li><span class="name">string money;</span></li><li><span class="name">int age;</span></li><li><span class="name">void barking(){...}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">关键字 extends 表示继承自其父类. 如果没有显式定义父类, 则默认继承自 Object类. 该类是java所有类的基类.</span></li></ul></li><li><span class="name">程序运行的总入口</span><ul><li><span class="name">是 public static void main(string[] args) {}.</span></li><li><span class="name">main()必须放在某个public类中, 它直接被java解析器调用. 用户代码不能调用.</span></li><li><span class="name">main()必须使用 public static void属性. 即它是静态方法, 使用规则见下.</span></li><li><span class="name">每个public类都可以有main(), 运行时用哪个为入口在编译器中指定. 一般用这个特性来做UT.</span></li></ul></li><li><span class="name">类方法(静态方法)</span><ul><li><span class="name">类方法即静态方法, 用static定义. 如: public static void myFunc(){}</span></li><li><span class="name">类方法被调用时, 不需要new该类, 而可以直接调用. 比如 MyClass.myFunc().</span></li><li><span class="name">类方法只能访问类的其它类方法和静态变量, 如果要访问类的其它资源, 则需要new.</span></li></ul></li><li><span class="name">构造函数</span><ul><li><span class="name">类的构造函数会在new该类时被调用. 构造函数用于初始化一个类.</span></li><li><span class="name">构造函数和类名相同, 属性为 public void.</span></li><li><span class="name">如果没有显式定义构造函数, 则编译器会自动生成一个无参数的构造函数.</span></li><li><span class="name">一个类支持多个构造函数, 只要参数不同.</span></li></ul></li><li><span class="name">析构函数</span><ul><li><span class="name">java不需要析构函数, 但java垃圾回收只支持 new创造的对象, 某些类不是通过new生成, 那么就需要定义 finalize(), 它是 protected的.</span></li><li><span class="name">系统垃圾回收的时机不确定. java 提供system.gc()方法, 应用调用它可强制启动回收. 但并不是马上.</span></li></ul></li><li><span class="name">static关键字: 静态类/静态区域/静态成员</span><ul><li><span class="name">static 修饰class, 表示它是<b>静态内部类</b>, 较少见. 静态内部类跟静态方法一样, 只能访问类的静态成员.</span></li><li><span class="name">用 static {} 定义类的静态区域, 位于所有方法之外, 一般放在类的最开始.</span><ul><li><span class="name">静态区域在类加载时被调用, 只执行一次.一般用于类的静态成员的初始化.</span></li><li><span class="name">它不能被代码主动调用. </span></li><li><span class="name">可以多个, 但不建议.</span></li></ul></li><li><span class="name">static修饰方法, 表示静态方法. </span></li><li><span class="name">static修饰变量, 表示静态变量.</span></li></ul></li><li><span class="name">final关键字: 表示不可改变/最终版本的意思</span><ul><li><span class="name">修饰类, 表示该类不可被集成. final类中的方法默认为final的.</span></li><li><span class="name">修饰方法, 表示该方法不可被子类的方法覆盖, 也不支持重载. 所有 private 方法隐含带 final 属性.</span></li><li><span class="name">不可以修饰构造方法.</span></li><li><span class="name">修饰变量, 即定义常量. 它的值不可被改写.</span></li></ul></li><li><span class="name">abstract关键字: 抽象 (abstract和final有反义词的意思)</span><ul><li><span class="name">修饰类, 表示抽象类. 抽象类不可实例化, 只能被继承. 但它可以作为对象类型. 继承抽象类必须重写所有抽象方法.</span></li><li><span class="name">修饰方法, 表示抽象方法. 子类必须实现所有抽象方法.</span></li><li><span class="name">一个类只要有一个抽象方法, 那它就是抽象类, 不可实例化.</span></li><li><span class="name">抽象类可以不包含任何抽象方法.</span></li></ul></li><li><span class="name">构造代码块</span><ul><li><span class="name">格式: {...}, 放在函数外. 一般为函数最开始.</span></li><li><span class="name">构造块的作用是给类的多个对象的共性部分进行初始化.</span></li><li><span class="name">对象一建立就会运行构造块, 而且优先于构造函数. 不能用代码调用构造块.</span></li><li><span class="name">构造块和构造函数的区别是: 构造块是给所有对象进行统一初始化, 而构造函数则是对特定对象进行初始化. 构造函数可以多个, 但构造块只有一个.</span></li></ul></li><li><span class="name">this指针</span><ul><li><span class="name">this指向当前对象自身. 所以只能用于方法体内.  this不可用于静态方法和静态块.</span></li><li><span class="name">this常用于如下几个场景:</span><ul><li><span class="name">成员变量和参数同名, 成员变量别屏蔽, 用this来引用成员变量.</span></li><li><span class="name">构造方法通过this来调用另一个构造方法, 如:</span><ul><li><span class="name">Public MyClass() {</span><ul><li><span class="name">this(0, “null");</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">方法中返回当前实例的引用.</span></li></ul></li></ul></li><li><span class="name">super关键字: 指向基类</span><ul><li><span class="name">super() &nbsp; // 调用基类的构造方法, 只能放在构造方法的第一行.</span></li><li><span class="name">super.myFunc() &nbsp;// 调用基类被覆盖的方法.</span></li></ul></li></ul></li><li><span class="name">Hello world!</span><ul><li><span class="name">/* HelloWorld.java */</span></li><li><span class="name">public Class HelloWorld{</span><ul><li><span class="name">public static woid main(string arg[]) {</span><ul><li><span class="name">System.out.println(“Hello, world!");</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">编译:  javac HelloWorld.java</span></li><li><span class="name">java HelloWorld.java</span></li></ul></li><li><span class="name">注释</span><ul><li><span class="name">// 支持单行</span></li><li><span class="name">/* 支持多行 */</span></li></ul></li><li><span class="name">打印log</span><ul><li><span class="name">最简单的方式是 system.print.out() , err() 这样直接在控制台打印消息了。</span></li><li><span class="name">java.util.logging ; 在JDK 1.4 版本之后，提供了日志的API ，可以往文件中写日志了。</span></li><li><span class="name">log4j , 最强大的记录日志的方式。 可以通过配置 .properties 或是 .xml 的文件， 配置日志的目的地，格式等等。</span></li><li><span class="name">log4j 是 apache 提供的库。下载路径<a class="contentLink" target="_blank" rel="noreferrer" href="http://logging.apache.org/log4j/1.2/download.html">http://logging.apache.org/log4j/1.2/download.html</a>&nbsp; .  例如:</span><ul><li><span class="name">import org.apache.log4j.Logger;</span></li><li><span class="name">import org.apache.log4j.PropertyConfigurator;</span></li><li><span class="name">// 1. create log</span></li><li><span class="name">Logger log = Logger.getLogger(TestLog4j.class);</span></li><li><span class="name">// 2. get log config file</span></li><li><span class="name">PropertyConfigurator.configure("log4j.properties");</span></li><li><span class="name">// 3. start log.  还有 <a class="contentLink" target="_blank" rel="noreferrer" href="http://log.info">log.info</a>, log.warn, log.fatal 等打印级别.</span></li><li><span class="name">log.debug("Here is some DEBUG");</span></li><li><span class="name">log.error("Here is some ERROR");</span></li></ul></li><li><span class="name">commons-logging, 最综合和常见的日志记录方式， 经常是和log4j 结合起来使用。</span></li></ul></li><li><span class="name">函数(传值/传址/传引用)</span><ul><li><span class="name">函数基本形式</span><ul><li><span class="name"><span class="contentTag" title="Filter @override">@<span class="contentTagText">override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void myFunc(Bundle savedData) {...}</span></li><li><span class="name">其中: <span class="contentTag" title="Filter @override">@<span class="contentTagText">override</span><span class="contentTagNub"></span></span>, 表示该方法可以在子类中被覆盖.</span></li></ul></li><li><span class="name">函数权限</span><ul><li><span class="name">public: 可以被 其它类 调用;</span></li><li><span class="name">friendly: 只能被 自身/子类/本包的其他类 调用.</span></li><li><span class="name">protect: 只能被自身/子类调用.</span></li><li><span class="name">private: 只能被自身调用.</span></li></ul></li><li><span class="name">传值/传引用</span><ul><li><span class="name">在Java里, 只有如下两种数据是按值传递:</span><ul><li><span class="name">基本类型</span></li><li><span class="name">按照下面这种定义方式的String,&nbsp;就是直接使用双引号定义字符串方式：String str = “Java私塾”;</span></li></ul></li><li><span class="name">其它的都是按引用传递。</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">整数/枚举量</span><ul><li><span class="name">整数</span><ul><li><span class="name">int ii = 5; &nbsp;// 32位整数</span></li><li><span class="name">其它类型有: byte(8位), short(16位), long(64位)</span></li></ul></li><li><span class="name">枚举值</span><ul><li><span class="name">public static enum MyType{</span><ul><li><span class="name">ModeType1, ModeType2</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">布尔量</span><ul><li><span class="name">boolean 只有两个值, true 和 false.  不能与整数进行转换.</span></li></ul></li><li><span class="name">浮点数</span><ul><li><span class="name">float f = 2.3f; &nbsp; // 占用4个字节, 32位, 取值范围从 10^-38 到 10^38, 和 -10^38到-10^-38之间. 后缀f必须要.</span></li><li><span class="name">double d = 2.3; &nbsp; // 占用8个字节, 64位, 取值范围从 10^-308 到 10^308, 和 -10^308 到 -10^-308 之间. 小数默认是float类型.</span></li><li><span class="name">浮点数有精度限制, 不能用 == 比较两个浮点数.</span></li></ul></li><li><span class="name">常量.全局变量.静态变量</span><ul><li><span class="name">常量用 final 修饰, 静态变量用 static 修饰. 全局变量用 public 修饰.</span></li><li><span class="name">综合: public final static double PI = 3.14159;</span></li></ul></li><li><span class="name">运算符表</span><ul><li><span class="name">优先级按照从高到低的顺序书写，也就是优先级为1的优先级最高，优先级14的优先级最低。</span></li><li><span class="name">1	() [] .	从左到右</span></li><li><span class="name">2	! +(正) -(负) ~(非运算) ++ --	从右向左</span></li><li><span class="name">3	* / %	从左向右</span></li><li><span class="name">4	+(加) -(减)	从左向右</span></li><li><span class="name">5	&lt;&lt; &gt;&gt;(算数右移) &gt;&gt;&gt;(逻辑右移)	从左向右</span></li><li><span class="name">6	&lt; &lt;= &gt; &gt;= instanceof	从左向右</span></li><li><span class="name">7	== !=	从左向右</span></li><li><span class="name">8	&amp;(按位与)	从左向右</span></li><li><span class="name">9	^(异或)	从左向右</span></li><li><span class="name">10	|	从左向右</span></li><li><span class="name">11	&amp;&amp;	从左向右</span></li><li><span class="name">12	||	从左向右</span></li><li><span class="name">13	?:	从右向左</span></li><li><span class="name">14	= += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=	从右向左</span></li></ul></li><li><span class="name">数据的拆箱和装箱</span><ul><li><span class="name">为了方便大家的习惯, java中有8种基础数据类型没有包装为类, 包括 byte/short/int/long/char/float/double/boolean.</span></li><li><span class="name">这种数据不是对象, 在序列化等场景下不太方便, 所以java提供了包装类.  包装类包括:</span><ul><li><span class="name">byte -&gt; Byte</span></li><li><span class="name">boolean -&gt; Boolean</span></li><li><span class="name">short -&gt; Short</span></li><li><span class="name">char -&gt; Character</span></li><li><span class="name">int -&gt; Integer</span></li><li><span class="name">long -&gt; Long</span></li><li><span class="name">float -&gt; Float</span></li><li><span class="name">double -&gt; Double</span></li></ul></li><li><span class="name">装箱</span><ul><li><span class="name">即将基础类型包装为对象. 如:</span></li><li><span class="name">int myInt = 500;</span></li><li><span class="name">Integer myInt2 = new Integar(myInt);</span></li><li><span class="name">一旦装箱, 其值就不可以更改.</span></li></ul></li><li><span class="name">拆箱</span><ul><li><span class="name">将对象转化为基础类. 如:</span></li><li><span class="name">int myInt = myInt2.intValue();</span></li></ul></li><li><span class="name">包装类一般是为了 toString(). toString()是类方法, 所以不需要new一个对象就可以用. 如:</span><ul><li><span class="name">String myStr = Interger.toString(500);</span></li></ul></li><li><span class="name">自动拆箱和装箱</span><ul><li><span class="name">java在 1.5(5.0) 之后提供了自动拆箱和装箱功能. 如:</span></li><li><span class="name">Integer myInt = 500;</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">指针和引用</span><ul><li><span class="name">java没有指针. 但是有引用.</span></li><li><span class="name">java把引用作为默认调用方式, 所以并没有提供专门的运算符或关键字给引用.</span></li></ul></li><li><span class="name">对象判空</span><ul><li><span class="name">对象判空: if (myObject != null) {…}</span></li><li><span class="name">NullObject模式: 整一个NullObject与原有对象实现相同的接口或继承同一个父类. 目的是让调用者不需要判空.  要补充代码.</span></li></ul></li><li><span class="name">对象的元属性</span><ul><li><span class="name">得到当前方法的名字</span><ul><li><span class="name">String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();</span></li></ul></li><li><span class="name">返回类名/类类型/接口名</span><ul><li><span class="name">forName("类名") &nbsp; // 返回一个Class对象的引用. 用于类没有加载时加载它.</span></li><li><span class="name">getName() // 返回包含包名的类名.</span></li><li><span class="name">getSimpleName() // 返回不包含包名的类名.</span></li><li><span class="name">getCanonicalName()  // 返回全限定类名.</span></li><li><span class="name">getInterface() &nbsp;// 返回全限定的接口.</span></li><li><span class="name">getSuperClass() // 返回直接父类</span></li></ul></li><li><span class="name">instanceof 操作符</span><ul><li><span class="name">用于判断当前类是否是指定类的之类.</span></li><li><span class="name">if (mySubObj instanceof myObj) {…}</span></li></ul></li><li><span class="name">获取包名和类名</span><ul><li><span class="name">android中, 可通过 getPachageName() 获取包名, 通过 getClassName() 获取类名.</span></li></ul></li><li><span class="name">类的class type对象</span><ul><li><span class="name">Java把类的元属性也对象化了, 即 ClassType. 它是静态对象, 系统加载一个类时就会自动创建它的 ClassType 对象, 不需要手动创建. 其用法是:</span></li><li><span class="name">已知类, 获取 Class 对象(推荐用这种):</span><ul><li><span class="name">Class myClassType = myClass.Class;</span></li></ul></li><li><span class="name">已知对象, 获取其Class对象</span><ul><li><span class="name">Class myClassType = myObject.getClass();</span></li></ul></li><li><span class="name">上面这两种的区别在于第二种只能由对象调用.</span></li><li><span class="name">通过类名字符串获取其Class对象</span><ul><li><span class="name">Class myClassType = Class.forName("MyClassName");</span></li></ul></li></ul></li><li><span class="name">对象比较</span><ul><li><span class="name">用 == 比较两个对象, 实际对比的是两个对象的地址是不是相同, 即确认这两个对象是不是同一个, 而一般对象对比的初衷是对比两个不同的对象是否具有同样的属性.</span></li><li><span class="name">常用的是用 equals()来对比两个对象的值是否相同.</span></li><li><span class="name">java.io.file, java.util.Date, java.lang.string,包装类（Integer,Double等）等, 提供的比较规则为：如果两个对象的类型一致，并且值一致，则返回true,这些类有：</span></li><li><span class="name">用户自定义的类, 要自己提供&nbsp;equals()定义.</span></li></ul></li><li><span class="name">深复制和浅复制</span><ul><li><span class="name">通过调用 clone() 复制一个现有的对象, 是快速生成一个对象的方式.</span><ul><li><span class="name">MyClass myClass1 = new MyClass(23, "zhang");</span></li><li><span class="name">MyClass myClass2 = (MyClass) myClass1.clone();</span></li></ul></li><li><span class="name">复制的时候有两种方式: 深复制和浅复制.</span></li><li><span class="name">对于对象的基础数据类型成员, 无论哪种复制都是直接copy 副本. 但是对于对象成员, 浅复制只复制对象的引用. 深复制则复制对象的副本.</span></li><li><span class="name">clone()执行的是浅拷贝. 如果需要深拷贝, 则需要复写clone().</span></li><li><span class="name">要复写clone(), 需要类 implements Cloneable.</span></li><li><span class="name">深复制要求在引用链上的每一级对象都要复写clone(), 显式的拷贝。所以它是相当麻烦的.</span></li></ul></li><li><span class="name">RTTI (运行时对象类型识别, runtime type identification)</span><ul><li><span class="name">在java中, 所有的类型转化都是在运行时进行正确性检查的.</span></li></ul></li><li><span class="name">Class.newInstance()</span><ul><li><span class="name">根据类的class对象new一个新对象.</span></li><li><span class="name">这是实现虚拟构造器的一种途径. 它允许你申明: 我不确切的知道类型, 先创建一个对象再说.</span></li><li><span class="name">newInstance() 创建的对象必须有默认的构造器.</span></li></ul></li><li><span class="name">泛化引用</span><ul><li><span class="name">Class 对象可指向任何类, 不方便在编译时识别出类型错误. 为弥补这一点, 可使用泛化引用来限定Class对象引用的类型, 方便编译器执行额外的类型检查.</span></li><li><span class="name">Class&lt;MyClass&gt; myClass = MyClass.class;   // MyClass 是泛化引用</span></li></ul></li><li><span class="name"><b>反射: 通过字符串进行函数调用</b></span><ul><li><span class="name">1. 通过ClassType 字符串实例化类</span><ul><li><span class="name">Class&lt;?&gt; myClass = null;</span></li><li><span class="name">myClass = class.forName("myClassType");</span></li><li><span class="name">myObject = (myClassType)myClass.newInstance();</span></li><li><span class="name">myClassType 中必须有无参数构造函数.</span></li></ul></li><li><span class="name">2. 获取构造方法(包括私有的)</span><ul><li><span class="name">public Constructor getConstructor(Class… parameterTypes); // 获得指定的构造方法，注意只能获得 public 权限的构造方法</span></li><li><span class="name">public Constructor getDeclaredConstructor(Class… parameterTypes);  // 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。</span></li><li><span class="name">public Constructor[] getConstructors() throws SecurityException;   // 获得所有 public 访问权限的构造方法</span></li><li><span class="name">public Constructor[] getDeclaredConstructors() throws SecurityException;  // 获得所有的构造方法，包括（public, private,protected,默认权限的）</span></li><li><span class="name">例如: </span></li><li><span class="name">public static void printConstructor(String className) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">Class&lt;?&gt; aClass = Class.forName(className);</span></li><li><span class="name"><b>Constructor</b>&lt;?&gt;[] constructors = aClass.<b>getConstructors</b>();</span></li><li><span class="name">print(constructors);</span></li><li><span class="name">Constructor&lt;?&gt;[] declaredConstructors = aClass.<b>getDeclaredConstructors</b>();</span></li><li><span class="name">print(declaredConstructors);</span></li></ul></li><li><span class="name">} catch (ClassNotFoundException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">3. 获取所有成员变量</span><ul><li><span class="name">public static void printFiled(String className) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">Class&lt;?&gt; aClass = Class.forName(className);</span></li><li><span class="name">Field[] fields = aClass.<b>getFields</b>();</span></li><li><span class="name">PrintUtils.print(fields);</span></li><li><span class="name">Field[] declaredFields = aClass.<b>getDeclaredFields</b>();</span></li><li><span class="name">PrintUtils.print(declaredFields);</span></li></ul></li><li><span class="name">} catch (ClassNotFoundException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">4. 获得指定成员变量</span><ul><li><span class="name">public static Field getFiled(String className, String filedName) {</span><ul><li><span class="name">Object o = null;</span></li><li><span class="name">try {</span><ul><li><span class="name">Class&lt;?&gt; aClass = Class.forName(className);</span></li><li><span class="name">Field declaredField = aClass.<b>getDeclaredField</b>(filedName);</span></li><li><span class="name">//&nbsp; &nbsp;if not public,you should call this</span></li><li><span class="name">declaredField.<b>setAccessible</b>(true);</span></li><li><span class="name">return declaredField;</span></li></ul></li><li><span class="name">} catch (ClassNotFoundException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">} catch (NoSuchFieldException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">return null;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">调用方: Field field =getFiled("MyClassName", "age");</span></li></ul></li><li><span class="name">5. 获取所有方法</span><ul><li><span class="name">public static void printMethods(String className) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">Class&lt;?&gt; aClass = Class.forName(className);</span></li><li><span class="name">Method[] declaredMethods = aClass.<b>getDeclaredMethods</b>();</span></li><li><span class="name">PrintUtils.print(declaredMethods);</span></li></ul></li><li><span class="name">} catch (ClassNotFoundException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">6. 执行指定方法</span><ul><li><span class="name">public static void testMethod(){</span><ul><li><span class="name">Person person=new Person();</span></li><li><span class="name">Method method = <b>getMethod</b>(CLASS_NAME, "FunctionName", String.class);</span></li><li><span class="name">try {</span><ul><li><span class="name">// 执行方法，结果保存在 person 中</span></li><li><span class="name">Object o = method.<b>invoke</b>(person, CHINA);</span></li><li><span class="name">// 拿到我们传递进取的参数 country 的值 China</span></li><li><span class="name">String country = person.country;</span></li><li><span class="name">PrintUtils.print(country);</span></li></ul></li><li><span class="name">} catch (IllegalAccessException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">} catch (InvocationTargetException e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li></ul></li><li><span class="name">for</span><ul><li><span class="name">for (ii = 0; ii &lt; length; ii++) {...}  // 和C的语言一样</span></li><li><span class="name">for (变量 * : 数组) {...}   效率较高, 建议使用. 如: </span><ul><li><span class="name">for (String myStr : myStrs) {...}   // myStrs是字符串数组. </span></li><li><span class="name">变量类型和数组元素类型匹配.</span></li></ul></li></ul></li><li><span class="name">while</span><ul><li><span class="name">while (布尔表达式) {...}</span></li><li><span class="name">do {...} while (布尔表达式)</span></li><li><span class="name">break;   // 用于跳出里层的循环, 继续执行循环下面的语句. </span></li><li><span class="name">continue;  // 用于跳出当次循环, 跳转到布尔表达式.</span></li></ul></li><li><span class="name">if &amp; switch</span><ul><li><span class="name">和c一样.</span></li></ul></li><li><span class="name">字符串</span><ul><li><span class="name">常用转义符</span><ul><li><span class="name">\": 双引号</span></li><li><span class="name">\': 单引号&nbsp;</span></li><li><span class="name">\\: 反斜线&nbsp;</span></li><li><span class="name">\0: 空字符&nbsp;</span></li><li><span class="name">\r: 回车</span></li><li><span class="name">\n: 换行</span></li><li><span class="name">\t: table跳格</span></li><li><span class="name">\u: Unicode码, 比如: $ =&gt; \u0024; { =&gt; \u007B.</span></li></ul></li><li><span class="name">字符串定义</span><ul><li><span class="name">字符Char--尽量不要用字符数组</span><ul><li><span class="name">Char myChar = 'a';    // 单引号是字符, 双引号是字符串.</span></li></ul></li><li><span class="name">字符串对象String</span><ul><li><span class="name">String myString = new String("my string");</span></li><li><span class="name">java语言中, "my string"这种标量, 本身就是String 对象, 由编辑器进行初始化.</span></li></ul></li><li><span class="name">String 转化为 Char</span><ul><li><span class="name">Char myChar = myString.charAt(index);</span></li></ul></li><li><span class="name">String 转化为 Char[]</span><ul><li><span class="name">Char myChars[] = myString.toCharArray();</span></li></ul></li><li><span class="name">Char 转化为String</span><ul><li><span class="name">String myString = String.valueOf('C');</span></li></ul></li></ul></li><li><span class="name">字符串和整型的相互转换</span><ul><li><span class="name">String str = String.valueOf(2);</span></li><li><span class="name">int i = Integer.parseInt(str); // 需要捕捉异常: NumberFormatException</span></li></ul></li><li><span class="name">可变字符串</span><ul><li><span class="name">字符串初始化后, 内容不能再改变. 将一个字符串变量指向新值, 则会new一个新的字符串对象, 原来的字符串会进入垃圾回收.</span></li><li><span class="name">如果字符串频繁变化, 这有必要使用 StringBuffer. 它的性能比new一个新字符串对象要快很多, 推荐使用.</span><ul><li><span class="name">StringBuffer myStr = new StringBuffer("String init");</span></li><li><span class="name">myStr.append("2st. string");</span></li></ul></li><li><span class="name">StringBuffer是线程安全的, 还有一个可变字符串类, StringBuilder, 是线程不安全的, 性能更快.</span></li></ul></li><li><span class="name">判空</span><ul><li><span class="name">myString.length() == 0    // 空串</span></li><li><span class="name">null == myString     // 字符串对象没有初始化</span></li></ul></li><li><span class="name">取长度</span><ul><li><span class="name">myString.length();</span></li></ul></li><li><span class="name">去空格</span><ul><li><span class="name">myString.trim();   // 前后去空格</span></li></ul></li><li><span class="name">拼接</span><ul><li><span class="name">字符串可通过 + 号连接, 这是最直观的.</span></li><li><span class="name">基本数据类型与字符串连接时, 会自动转化为字符串. 对象要自动转为字符串, 需要重载 toString() 方法.</span></li><li><span class="name">可变字符串可以用 append() 来拼接.</span></li></ul></li></ul></li><li><span class="name">数组, Map</span><ul><li><span class="name">把 Array 转换成 Map</span><ul><li><span class="name">import java.util.Map;</span></li><li><span class="name">import org.apache.commons.lang.ArrayUtils;</span></li><li><span class="name">public class Main {</span><ul><li><span class="name">public static void main(String[] args) {</span><ul><li><span class="name">String[][] countries = { { "United States", "New York" }, { "United Kingdom", "London" },</span><ul><li><span class="name">{ "Netherland", "Amsterdam" }, { "Japan", "Tokyo" }, { "France", "Paris" } }</span></li></ul></li><li><span class="name">Map countryCapitals = ArrayUtils.toMap(countries);</span></li><li><span class="name">System.out.println("Capital of Japan is " + countryCapitals.get("Japan"));</span></li><li><span class="name">System.out.println("Capital of France is " + countryCapitals.get("France"));</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">改变数组的大小</span><ul><li><span class="name">private static Object resizeArray (Object oldArray, int newSize) {</span><ul><li><span class="name">int oldSize = java.lang.reflect.Array.getLength(oldArray);</span></li><li><span class="name">Class elementType = oldArray.getClass().getComponentType();</span></li><li><span class="name">Object newArray = java.lang.reflect.Array.newInstance(</span><ul><li><span class="name">elementType,newSize);</span></li></ul></li><li><span class="name">int preserveLength = Math.min(oldSize,newSize);</span></li><li><span class="name">if (preserveLength &gt; 0)</span><ul><li><span class="name">System.arraycopy (oldArray,0,newArray,0,preserveLength);</span></li></ul></li><li><span class="name">return newArray;</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">文件</span><ul><li><span class="name">向文件末尾添加内容</span><ul><li><span class="name">BufferedWriter out = null;</span></li><li><span class="name">try {</span><ul><li><span class="name">out = new BufferedWriter(new FileWriter(”filename”, true));</span></li><li><span class="name">out.write(”aString”);</span></li></ul></li><li><span class="name">} catch (IOException e) {</span><ul><li><span class="name">// error processing code</span></li></ul></li><li><span class="name">} finally {</span><ul><li><span class="name">if (out != null) {</span><ul><li><span class="name">out.close();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">创建 JSON 格式的数据文件</span><ul><li><span class="name">import org.json.JSONObject;</span></li><li><span class="name">...</span></li><li><span class="name">JSONObject json = new JSONObject();</span></li><li><span class="name">json.put("city", "Mumbai");</span></li><li><span class="name">json.put("country", "India");</span></li><li><span class="name">...</span></li><li><span class="name">String output = json.toString();</span></li></ul></li><li><span class="name">列出文件和目录</span><ul><li><span class="name">File dir = new File("directoryName");</span><ul><li><span class="name">String[] children = dir.list();</span></li><li><span class="name">if (children == null) {</span><ul><li><span class="name">// Either dir does not exist or is not a directory</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">for (int i=0; i &lt; children.length; i++) {</span><ul><li><span class="name">// Get filename of file or directory</span></li><li><span class="name">String filename = children[i];</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// It is also possible to filter the list of returned files.</span></li><li><span class="name">// This example does not return any files that start with `.'.</span></li><li><span class="name">FilenameFilter filter = new FilenameFilter() {</span><ul><li><span class="name">public boolean accept(File dir, String name) {</span><ul><li><span class="name">return !name.startsWith(".");</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">children = dir.list(filter);</span></li><li><span class="name">// The list of files can also be retrieved as File objects</span></li><li><span class="name">File[] files = dir.listFiles();</span></li><li><span class="name">// This filter only returns directories</span></li><li><span class="name">FileFilter fileFilter = new FileFilter() {</span><ul><li><span class="name">public boolean accept(File file) {</span><ul><li><span class="name">return file.isDirectory();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">files = dir.listFiles(fileFilter);</span></li></ul></li></ul></li><li><span class="name">创建ZIP和JAR文件</span><ul><li><span class="name">import java.util.zip.*;</span></li><li><span class="name">import <a class="contentLink" target="_blank" rel="noreferrer" href="http://java.io">java.io</a>.*;</span></li><li><span class="name">public class ZipIt {</span><ul><li><span class="name">public static void main(String args[]) throws IOException {</span><ul><li><span class="name">if (args.length &lt; 2) {</span><ul><li><span class="name">System.err.println("usage: java ZipIt Zip.zip file1 file2 file3");</span></li><li><span class="name">System.exit(-1);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">File zipFile = new File(args[0]);</span></li><li><span class="name">if (zipFile.exists()) {</span><ul><li><span class="name">System.err.println("Zip file already exists, please try another");</span></li><li><span class="name">System.exit(-2);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">FileOutputStream fos = new FileOutputStream(zipFile);</span></li><li><span class="name">ZipOutputStream zos = new ZipOutputStream(fos);</span></li><li><span class="name">int bytesRead;</span></li><li><span class="name">byte[] buffer = new byte[1024];</span></li><li><span class="name">CRC32 crc = new CRC32();</span></li><li><span class="name">for (int i=1, n=args.length; i &lt; n; i++) {</span><ul><li><span class="name">String name = args[i];</span></li><li><span class="name">File file = new File(name);</span></li><li><span class="name">if (!file.exists()) {</span><ul><li><span class="name">System.err.println("Skipping: " + name);</span></li><li><span class="name">continue;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">BufferedInputStream bis = new BufferedInputStream(</span><ul><li><span class="name">new FileInputStream(file));</span></li></ul></li><li><span class="name">crc.reset();</span></li><li><span class="name">while ((bytesRead = bis.read(buffer)) != -1) {</span><ul><li><span class="name">crc.update(buffer, 0, bytesRead);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">bis.close();</span></li><li><span class="name">// Reset to beginning of input stream</span></li><li><span class="name">bis = new BufferedInputStream(new FileInputStream(file));</span></li><li><span class="name">ZipEntry entry = new ZipEntry(name);</span></li><li><span class="name">entry.setMethod(ZipEntry.STORED);</span></li><li><span class="name">entry.setCompressedSize(file.length());</span></li><li><span class="name">entry.setSize(file.length());</span></li><li><span class="name">entry.setCrc(crc.getValue());</span></li><li><span class="name">zos.putNextEntry(entry);</span></li><li><span class="name">while ((bytesRead = bis.read(buffer)) != -1) {</span><ul><li><span class="name">zos.write(buffer, 0, bytesRead);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">bis.close();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">zos.close();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">解析/读取XML 文件</span><ul><li><span class="name">package net.viralpatel.java.xmlparser;</span></li><li><span class="name">import java.io.File;</span></li><li><span class="name">import javax.xml.parsers.DocumentBuilder;</span></li><li><span class="name">import javax.xml.parsers.DocumentBuilderFactory;</span></li><li><span class="name">import org.w3c.dom.Document;</span></li><li><span class="name">import org.w3c.dom.Element;</span></li><li><span class="name">import org.w3c.dom.Node;</span></li><li><span class="name">import org.w3c.dom.NodeList;</span></li><li><span class="name">public class XMLParser {</span><ul><li><span class="name">public void getAllUserNames(String fileName) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span></li><li><span class="name">DocumentBuilder db = dbf.newDocumentBuilder();</span></li><li><span class="name">File file = new File(fileName);</span></li><li><span class="name">if (file.exists()) {</span><ul><li><span class="name">Document doc = db.parse(file);</span></li><li><span class="name">Element docEle = doc.getDocumentElement();</span></li><li><span class="name">// Print root element of the document</span></li><li><span class="name">System.out.println("Root element of the document: " + docEle.getNodeName());</span></li><li><span class="name">NodeList studentList = docEle.getElementsByTagName("student");</span></li><li><span class="name">// Print total student elements in document</span></li><li><span class="name">System.out.println("Total students: " + studentList.getLength());</span></li><li><span class="name">if (studentList != null &amp;&amp; studentList.getLength() &gt; 0) {</span><ul><li><span class="name">for (int i = 0; i &lt; studentList.getLength(); i++) {</span><ul><li><span class="name">Node node = studentList.item(i);</span></li><li><span class="name">if (node.getNodeType() == Node.ELEMENT_NODE) {</span><ul><li><span class="name">System.out.println("=====================");</span></li><li><span class="name">Element e = (Element) node;</span></li><li><span class="name">NodeList nodeList = e.getElementsByTagName("name");</span></li><li><span class="name">System.out.println("Name: " + nodeList.item(0).getChildNodes().item(0).getNodeValue());</span></li><li><span class="name">nodeList = e.getElementsByTagName("grade");</span></li><li><span class="name">System.out.println("Grade: " + nodeList.item(0).getChildNodes().item(0).getNodeValue());</span></li><li><span class="name">nodeList = e.getElementsByTagName("age");</span></li><li><span class="name">System.out.println("Age: " + nodeList.item(0).getChildNodes().item(0).getNodeValue());</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">System.exit(1);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">} catch (Exception e) {</span><ul><li><span class="name">System.out.println(e);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">public static void main(String[] args) {</span><ul><li><span class="name">XMLParser parser = new XMLParser();</span></li><li><span class="name">parser.getAllUserNames("c:\\test.xml");</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">使用NIO进行快速的文件拷贝</span><ul><li><span class="name">public static void fileCopy( File in, File out) throws IOException {</span><ul><li><span class="name">FileChannel inChannel = new FileInputStream( in ).getChannel();</span></li><li><span class="name">FileChannel outChannel = new FileOutputStream( out ).getChannel();</span></li><li><span class="name">try {</span></li><li><span class="name">//&nbsp;inChannel.transferTo(0, inChannel.size(), outChannel);&nbsp; &nbsp;// original -- apparently has trouble copying large files on Windows</span></li><li><span class="name">// magic number for Windows, 64Mb - 32Kb)</span><ul><li><span class="name">int maxCount = (64 * 1024 * 1024) - (32 * 1024);</span></li><li><span class="name">long size = inChannel.size();</span></li><li><span class="name">long position = 0;</span></li><li><span class="name">while ( position &lt; size) {</span><ul><li><span class="name">position += inChannel.transferTo( position, maxCount, outChannel );</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">} finally {</span><ul><li><span class="name">if ( inChannel != null) {</span><ul><li><span class="name">inChannel.close();</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">if ( outChannel != null) {</span><ul><li><span class="name">outChannel.close();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">使用iText JAR生成PDF</span><ul><li><span class="name">import java.io.File;</span></li><li><span class="name">import java.io.FileOutputStream;</span></li><li><span class="name">import java.io.OutputStream;</span></li><li><span class="name">import java.util.Date;</span></li><li><span class="name">import com.lowagie.text.Document;</span></li><li><span class="name">import com.lowagie.text.Paragraph;</span></li><li><span class="name">import com.lowagie.text.pdf.PdfWriter;</span></li><li><span class="name">public class GeneratePDF {</span><ul><li><span class="name">public static void main(String[] args) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">OutputStream file = new FileOutputStream(new File("C:\\Test.pdf"));</span></li><li><span class="name">Document document = new Document();</span></li><li><span class="name">PdfWriter.getInstance(document, file);</span></li><li><span class="name">document.open();</span></li><li><span class="name">document.add(new Paragraph("Hello Kiran"));</span></li><li><span class="name">document.add(new Paragraph(new Date().toString()));</span></li><li><span class="name">document.close();</span></li><li><span class="name">file.close();</span></li></ul></li><li><span class="name">} catch (Exception e) {</span><ul><li><span class="name">e.printStackTrace();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">媒体</span><ul><li><span class="name">创建图片的缩略图</span><ul><li><span class="name">private void createThumbnail(String filename, int thumbWidth, int thumbHeight, int quality, String outFilename)</span><ul><li><span class="name">throws InterruptedException, FileNotFoundException, IOException {</span></li><li><span class="name">// load image from filename</span></li><li><span class="name">Image image = Toolkit.getDefaultToolkit().getImage(filename);</span></li><li><span class="name">MediaTracker mediaTracker = new MediaTracker(new Container());</span></li><li><span class="name">mediaTracker.addImage(image, 0);</span></li><li><span class="name">mediaTracker.waitForID(0);</span></li><li><span class="name">// use this to test for errors at this point: System.out.println(mediaTracker.isErrorAny());</span></li><li><span class="name">// determine thumbnail size from WIDTH and HEIGHT</span></li><li><span class="name">double thumbRatio = (double)thumbWidth / (double)thumbHeight;</span></li><li><span class="name">int imageWidth = image.getWidth(null);</span></li><li><span class="name">int imageHeight = image.getHeight(null);</span></li><li><span class="name">double imageRatio = (double)imageWidth / (double)imageHeight;</span></li><li><span class="name">if (thumbRatio &lt; imageRatio) {</span><ul><li><span class="name">thumbHeight = (int)(thumbWidth / imageRatio);</span></li></ul></li><li><span class="name">} else {</span><ul><li><span class="name">thumbWidth = (int)(thumbHeight * imageRatio);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// draw original image to thumbnail image object and</span></li><li><span class="name">// scale it to the new size on-the-fly</span></li><li><span class="name">BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB);</span></li><li><span class="name">Graphics2D graphics2D = thumbImage.createGraphics();</span></li><li><span class="name">graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span></li><li><span class="name">graphics2D.drawImage(image, 0, 0, thumbWidth, thumbHeight, null);</span></li><li><span class="name">// save thumbnail image to outFilename</span></li><li><span class="name">BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename));</span></li><li><span class="name">JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);</span></li><li><span class="name">JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage);</span></li><li><span class="name">quality = Math.max(0, Math.min(quality, 100));</span></li><li><span class="name">param.setQuality((float)quality / 100.0f, false);</span></li><li><span class="name">encoder.setJPEGEncodeParam(param);</span></li><li><span class="name">encoder.encode(thumbImage);</span></li><li><span class="name">out.close();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">抓屏程序</span><ul><li><span class="name">import java.awt.Dimension;</span></li><li><span class="name">import java.awt.Rectangle;</span></li><li><span class="name">import java.awt.Robot;</span></li><li><span class="name">import java.awt.Toolkit;</span></li><li><span class="name">import java.awt.image.BufferedImage;</span></li><li><span class="name">import javax.imageio.ImageIO;</span></li><li><span class="name">import java.io.File;</span></li><li><span class="name">public void captureScreen(String fileName) throws Exception {</span><ul><li><span class="name">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();</span></li><li><span class="name">Rectangle screenRectangle = new Rectangle(screenSize);</span></li><li><span class="name">Robot robot = new Robot();</span></li><li><span class="name">BufferedImage image = robot.createScreenCapture(screenRectangle);</span></li><li><span class="name">ImageIO.write(image, "png", new File(fileName));</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">网络</span><ul><li><span class="name">HTTP 代理设置</span><ul><li><span class="name">System.getProperties().put("http.proxyHost", "someProxyURL");</span></li><li><span class="name">System.getProperties().put("http.proxyPort", "someProxyPort");</span></li><li><span class="name">System.getProperties().put("http.proxyUser", "someUserName");</span></li><li><span class="name">System.getProperties().put("http.proxyPassword", "somePassword");</span></li></ul></li><li><span class="name">发送邮件</span><ul><li><span class="name">import javax.mail.*;</span></li><li><span class="name">import javax.mail.internet.*;</span></li><li><span class="name">import java.util.*;</span></li><li><span class="name">public void postMail(String recipients[ ], String subject, String message , String from) throws MessagingException {</span><ul><li><span class="name">boolean debug = false;</span><ul><li><span class="name">//Set the host smtp address</span></li><li><span class="name">Properties props = new Properties();</span></li><li><span class="name">props.put("mail.smtp.host", "<a class="contentLink" target="_blank" rel="noreferrer" href="http://smtp.example.com">smtp.example.com</a>");</span></li></ul></li><li><span class="name">// create some properties and get the default Session</span></li><li><span class="name">Session session = Session.getDefaultInstance(props, null);</span></li><li><span class="name">session.setDebug(debug);</span></li><li><span class="name">// create a message</span></li><li><span class="name">Message msg = new MimeMessage(session);</span></li><li><span class="name">// set the from and to address</span></li><li><span class="name">InternetAddress addressFrom = new InternetAddress(from);</span></li><li><span class="name">msg.setFrom(addressFrom);</span></li><li><span class="name">InternetAddress[] addressTo = new InternetAddress[recipients.length];</span></li><li><span class="name">for (int i = 0; i &lt; recipients.length; i++) {</span><ul><li><span class="name">addressTo[i] = new InternetAddress(recipients[i]);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">msg.setRecipients(<a class="contentLink" target="_blank" rel="noreferrer" href="http://Message.RecipientType.TO">Message.RecipientType.TO</a>, addressTo);</span></li><li><span class="name">// Optional : You can also set your custom headers in the Email if you Want</span></li><li><span class="name">msg.addHeader("MyHeaderName", "myHeaderValue");</span></li><li><span class="name">// Setting the Subject and Content Type</span></li><li><span class="name">msg.setSubject(subject);</span></li><li><span class="name">msg.setContent(message, "text/plain");</span></li><li><span class="name">Transport.send(msg);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">发送代数据的HTTP 请求</span><ul><li><span class="name">import java.io.BufferedReader;</span></li><li><span class="name">import java.io.InputStreamReader;</span></li><li><span class="name">import java.net.URL;</span></li><li><span class="name">public class Main {</span><ul><li><span class="name">public static void main(String[] args) {</span><ul><li><span class="name">try {</span><ul><li><span class="name">URL my_url = new URL("<a class="contentLink" target="_blank" rel="noreferrer" href="http://coolshell.cn/">http://coolshell.cn/</a>");</span></li><li><span class="name">BufferedReader br = new BufferedReader(new InputStreamReader(my_url.openStream()));</span></li><li><span class="name">String strTemp = "";</span></li><li><span class="name">while(null != (strTemp = br.readLine())){</span></li><li><span class="name">System.out.println(strTemp);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">} catch (Exception ex) {</span><ul><li><span class="name">ex.printStackTrace();</span></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">多线程</span><ul><li><span class="name">单例 Singleton示例1</span><ul><li><span class="name">public class SimpleSingleton {</span><ul><li><span class="name">private static SimpleSingleton singleInstance = new SimpleSingleton();</span></li><li><span class="name">//Marking default constructor private</span></li><li><span class="name">//to avoid direct instantiation.</span></li><li><span class="name">private SimpleSingleton() {</span></li><li><span class="name">}</span></li><li><span class="name">//Get instance for class SimpleSingleton</span></li><li><span class="name">public static SimpleSingleton getInstance() {</span><ul><li><span class="name">return singleInstance;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">单例 Singleton示例2</span><ul><li><span class="name">public enum SimpleSingleton {</span><ul><li><span class="name">INSTANCE;</span></li><li><span class="name">public void doSomething() {</span></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//Call the method from Singleton:</span></li><li><span class="name">SimpleSingleton.INSTANCE.doSomething();</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">其它</span><ul><li><span class="name">转字符串到日期</span><ul><li><span class="name">java.util.Date = java.text.DateFormat.getDateInstance().parse(date String);</span></li><li><span class="name">或者是:</span></li><li><span class="name">SimpleDateFormat format = new SimpleDateFormat( "dd.MM.yyyy" );</span></li><li><span class="name">Date date = format.parse( myString );</span></li></ul></li><li><span class="name">把 Java util.Date 转成 sql.Date</span><ul><li><span class="name">java.util.Date utilDate = new java.util.Date();</span></li><li><span class="name">java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());</span></li></ul></li><li><span class="name"></span></li></ul></li></ul>
  </body>
</html>