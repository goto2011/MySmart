<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>IT技术 <span class="contentTag" title="Filter #Work">#<span class="contentTagText">Work</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">编程语言是推动软件技术发展最有力的技术之一。</span></span></li><li><span class="name"><span class="innerContentContainer">人们最想从科技当中得到的, 是控制生活的能力.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">函数库，引擎，框架，平台，其实是一个意思。只是羞于用旧词，所以不断发明新词。  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">硬件</span></span><ul><li><span class="name"><span class="innerContentContainer">芯片</span></span></li><li><span class="name"><span class="innerContentContainer">存储</span></span></li><li><span class="name"><span class="innerContentContainer">显示</span></span></li><li><span class="name"><span class="innerContentContainer">传感器</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件制造</span></span><ul><li><span class="name"><span class="innerContentContainer">手机生产流程</span></span><ul><li><span class="name"><span class="innerContentContainer">贴片</span></span><ul><li><span class="name"><span class="innerContentContainer">即把CPU等芯片贴到pcb板上，使用贴片机。然后有焊接工序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JDBC加载</span></span><ul><li><span class="name"><span class="innerContentContainer">jtag加载小boot包.</span></span></li><li><span class="name"><span class="innerContentContainer">内容包括qcsbl、oemsbl、partition、oeminfo的初始包（包括otp、logo等）等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DT</span></span><ul><li><span class="name"><span class="innerContentContainer">写单板条码到手机，检查烧片版本的版本信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">升级烧片</span></span><ul><li><span class="name"><span class="innerContentContainer">升级烧片版本。包括多个步骤，比如可能需要格式化U盘等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CT</span></span><ul><li><span class="name"><span class="innerContentContainer">校准射频参数；手机要进FTM模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BT</span></span><ul><li><span class="name"><span class="innerContentContainer">综测。最耗时间的一个步骤。</span></span></li><li><span class="name"><span class="innerContentContainer">手机进FTM模式。</span></span></li><li><span class="name"><span class="innerContentContainer">无卡注册方案和快速注册方案也是用于这个阶段。</span></span><ul><li><span class="name"><span class="innerContentContainer">CDMA无卡注册方案方案</span></span><ul><li><span class="name"><span class="innerContentContainer">将频段、频点信息写入nv 60009，相关代码修改参见特性宏：DTS7X27_CDMA_LOCK_EREQ。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">WCDMA无卡注册方案</span></span><ul><li><span class="name"><span class="innerContentContainer">UMTS无卡注册方案是虚拟出一张sim卡，相关代码修改参见：HUAWEI_FEATHER_BT_NOSIM。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MMI测试</span></span><ul><li><span class="name"><span class="innerContentContainer">MMI测试，确认各器件是否好用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MT</span></span><ul><li><span class="name"><span class="innerContentContainer">整机测试，测试天线，包括rf、gps、wifi。</span></span></li><li><span class="name"><span class="innerContentContainer">手机要进WT模式。</span></span></li><li><span class="name"><span class="innerContentContainer">PT</span></span></li><li><span class="name"><span class="innerContentContainer">整机电流测试，主要测试进待机、电池电压、温度和基底电流。</span></span></li><li><span class="name"><span class="innerContentContainer">相关方案是快速待机。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">正常升级</span></span><ul><li><span class="name"><span class="innerContentContainer">一般用SD卡升级方式（也有USB的），从工程菜单进入升级，以便升级前备份nv。</span></span></li><li><span class="name"><span class="innerContentContainer">现在升级大包中也放了cust包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MMI2</span></span><ul><li><span class="name"><span class="innerContentContainer">版本升级后进行mmi测试，再次确认各器件是否好用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CW(LT)</span></span><ul><li><span class="name"><span class="innerContentContainer">贴背贴，以前叫LT，现在叫CW。</span></span></li><li><span class="name"><span class="innerContentContainer">因为现在是离线打背贴，因为可以在生产前把背贴打印出来，加快生产效率。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CW(LT)</span></span><ul><li><span class="name"><span class="innerContentContainer">关键的一步。</span></span></li><li><span class="name"><span class="innerContentContainer">写入sn、wifi/bt地址、IMEI(for gsm)/MEID/ESN(for cdma)、simlock数据等。</span></span></li><li><span class="name"><span class="innerContentContainer">做cust升级，即写入cust分区、写入vendor/country信息，然后重启。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MC</span></span><ul><li><span class="name"><span class="innerContentContainer">功能是检查手机emei号和背贴上是否一致。</span></span></li><li><span class="name"><span class="innerContentContainer">要恢复出厂设置。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">彩包</span></span><ul><li><span class="name"><span class="innerContentContainer">彩包、装箱。</span></span></li><li><span class="name"><span class="innerContentContainer">产线流程结束。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">生产附属流程1：改制</span></span><ul><li><span class="name"><span class="innerContentContainer">即切换运营商。要修改IMEI，并进行cust升级。</span></span></li><li><span class="name"><span class="innerContentContainer">一般发生在产线和一线库房。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">生产附属流程2：开卡</span></span><ul><li><span class="name"><span class="innerContentContainer">仅针对机卡合一手机。</span></span></li><li><span class="name"><span class="innerContentContainer">在运营商营业点进行开卡操作，然后交付消费者使用。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">基础设施 (系统软件)</span></span><ul><li><span class="name"><span class="innerContentContainer">驱动</span></span></li><li><span class="name"><span class="innerContentContainer">操作系统</span></span><ul><li><span class="name"><span class="innerContentContainer">四位计算机的原理及其实现 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">操作系统的分类</span></span><ul><li><span class="name"><span class="innerContentContainer">单内核</span></span><ul><li><span class="name"><span class="innerContentContainer">整个系统为一个单独的进程来实现, 所有内核服务都在同一个地址空间内运行. 可直接调用函数.</span></span></li><li><span class="name"><span class="innerContentContainer">Linux属于单内核.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">微内核</span></span><ul><li><span class="name"><span class="innerContentContainer">内核功能划分为多个独立进程, 分别有自己的地址空间. </span></span></li><li><span class="name"><span class="innerContentContainer">所以不能直接调用函数, 而是通过IPC消息来完成内核通讯. </span></span></li><li><span class="name"><span class="innerContentContainer">优势在于安全, 一个进程的死掉一般不影响另一个. </span></span></li><li><span class="name"><span class="innerContentContainer">缺点是IPC开销较之函数调用大很多, 所以性能不佳. </span></span></li><li><span class="name"><span class="innerContentContainer">WinNT 和 mac osx 都属于微内核.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux的取舍</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux 提供了抢占式内核, 支持内核线程, 以及动态装载内核模块的功能, 汲取了微内核的精华.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Linux 方案设计的务实态度</span></span><ul><li><span class="name"><span class="innerContentContainer">任何改变都要针对现实中确实存在的问题, 经过完善的设计并有正确简洁的实现.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内存管理</span></span><ul><li><span class="name"><span class="innerContentContainer">多级缓存</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">任务管理</span></span><ul><li><span class="name"><span class="innerContentContainer">进程</span></span></li><li><span class="name"><span class="innerContentContainer">线程</span></span></li><li><span class="name"><span class="innerContentContainer">协程</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设备管理</span></span></li><li><span class="name"><span class="innerContentContainer">文件系统</span></span></li><li><span class="name"><span class="innerContentContainer">桌面子系统</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux桌面子系统</span></span><ul><li><span class="name"><span class="innerContentContainer">KDE</span></span><ul><li><span class="name"><span class="innerContentContainer">1998年发布第一个版本.</span></span></li><li><span class="name"><span class="innerContentContainer">基于QT.</span></span></li><li><span class="name"><span class="innerContentContainer">Ubuntu, OpenSUSE, Fedora 都支持.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GNOME</span></span><ul><li><span class="name"><span class="innerContentContainer">1999年发布第一版.</span></span></li><li><span class="name"><span class="innerContentContainer">2011年发布GNOME3, 激怒了很多人, 导致Mate和 cinnamon的出现.</span></span></li><li><span class="name"><span class="innerContentContainer">GNOME 是Fedora的默认桌面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Unity</span></span><ul><li><span class="name"><span class="innerContentContainer">Unity是Ubuntu为cinnamon开发的一个外壳, 在GNOME上运行.</span></span></li><li><span class="name"><span class="innerContentContainer">显示风格类似于Mac.</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">浏览器</span></span><ul><li><span class="name"><span class="innerContentContainer">JS引擎</span></span><ul><li><span class="name"><span class="innerContentContainer">Node 的是 V8.</span></span></li><li><span class="name"><span class="innerContentContainer">Chrome 的是 V8.</span></span></li><li><span class="name"><span class="innerContentContainer">Safari 的是 JavaScript Core.</span></span></li><li><span class="name"><span class="innerContentContainer">Firefox 的是 SpiderMonkey.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库</span></span><ul><li><span class="name"><span class="innerContentContainer">基础理论</span></span><ul><li><span class="name"><span class="innerContentContainer">关系数据库设计的三大范式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MySQL</span></span><ul><li><span class="name"><span class="innerContentContainer">原理</span></span></li><li><span class="name"><span class="innerContentContainer">InnoDB</span></span></li><li><span class="name"><span class="innerContentContainer">优化</span></span></li><li><span class="name"><span class="innerContentContainer">索引</span></span><ul><li><span class="name"><span class="innerContentContainer">聚集索引, 非聚集索引</span></span></li><li><span class="name"><span class="innerContentContainer">复合索引</span></span></li><li><span class="name"><span class="innerContentContainer">自适应哈希索引(AHI)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">explain</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">NoSQL</span></span><ul><li><span class="name"><span class="innerContentContainer">MongoDB</span></span></li><li><span class="name"><span class="innerContentContainer">Hbase</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">中间件</span></span><ul><li><span class="name"><span class="innerContentContainer">Web Server</span></span><ul><li><span class="name"><span class="innerContentContainer">Nginx</span></span></li><li><span class="name"><span class="innerContentContainer">OpenResty</span></span></li><li><span class="name"><span class="innerContentContainer">Tengine</span></span></li><li><span class="name"><span class="innerContentContainer">Apache Httpd</span></span></li><li><span class="name"><span class="innerContentContainer">Tomcat</span></span><ul><li><span class="name"><span class="innerContentContainer">架构原理</span></span></li><li><span class="name"><span class="innerContentContainer">调优方案</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Jetty</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缓存</span></span><ul><li><span class="name"><span class="innerContentContainer">本地缓存</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">客户端缓存</span></span></li><li><span class="name"><span class="innerContentContainer">服务端缓存</span></span><ul><li><span class="name"><span class="innerContentContainer">Web缓存</span></span></li><li><span class="name"><span class="innerContentContainer">Memcached</span></span></li><li><span class="name"><span class="innerContentContainer">Redis</span></span><ul><li><span class="name"><span class="innerContentContainer">架构</span></span></li><li><span class="name"><span class="innerContentContainer">回收策略</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Tair</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">消息队列</span></span><ul><li><span class="name"><span class="innerContentContainer">消息总线</span></span></li><li><span class="name"><span class="innerContentContainer">消息的顺序</span></span></li><li><span class="name"><span class="innerContentContainer">RabbitMQ</span></span></li><li><span class="name"><span class="innerContentContainer">RocketMQ</span></span></li><li><span class="name"><span class="innerContentContainer">ActiveMQ</span></span></li><li><span class="name"><span class="innerContentContainer">Kafka</span></span></li><li><span class="name"><span class="innerContentContainer">Redis 消息推送</span></span></li><li><span class="name"><span class="innerContentContainer">ZeroMQ</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定时调度</span></span><ul><li><span class="name"><span class="innerContentContainer">单机定时调度</span></span></li><li><span class="name"><span class="innerContentContainer">分布式定时调度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RPC</span></span><ul><li><span class="name"><span class="innerContentContainer">Dubbo</span></span></li><li><span class="name"><span class="innerContentContainer">Thrift</span></span></li><li><span class="name"><span class="innerContentContainer">gRPC</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库中间件</span></span><ul><li><span class="name"><span class="innerContentContainer">Sharding Jdbc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">日志系统</span></span><ul><li><span class="name"><span class="innerContentContainer">日志搜集</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">配置中心</span></span></li><li><span class="name"><span class="innerContentContainer">API 网关</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络</span></span><ul><li><span class="name"><span class="innerContentContainer">协议</span></span><ul><li><span class="name"><span class="innerContentContainer">OSI 七层协议</span></span></li><li><span class="name"><span class="innerContentContainer">TCP/IP</span></span></li><li><span class="name"><span class="innerContentContainer">HTTP</span></span></li><li><span class="name"><span class="innerContentContainer">HTTP2.0</span></span></li><li><span class="name"><span class="innerContentContainer">HTTPS</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络模型</span></span><ul><li><span class="name"><span class="innerContentContainer">Epoll</span></span></li><li><span class="name"><span class="innerContentContainer">Java NIO</span></span></li><li><span class="name"><span class="innerContentContainer">kqueue</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">连接和短连接</span></span></li><li><span class="name"><span class="innerContentContainer">框架</span></span></li><li><span class="name"><span class="innerContentContainer">零拷贝（Zero-copy）</span></span></li><li><span class="name"><span class="innerContentContainer">序列化(二进制协议)</span></span><ul><li><span class="name"><span class="innerContentContainer">Hessian</span></span></li><li><span class="name"><span class="innerContentContainer">Protobuf</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">虚拟化</span></span><ul><li><span class="name"><span class="innerContentContainer">KVM</span></span></li><li><span class="name"><span class="innerContentContainer">Xen</span></span></li><li><span class="name"><span class="innerContentContainer">OpenVZ</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">容器技术</span></span><ul><li><span class="name"><span class="innerContentContainer">Docker</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">云（硬件, 非本地化）</span></span><ul><li><span class="name"><span class="innerContentContainer">云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务）。</span></span></li><li><span class="name"><span class="innerContentContainer">云的本质是为了采样方便. 过程即结局. <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">之所以有云计算?</span></span><ul><li><span class="name"><span class="innerContentContainer">廉价pc硬件, 使得堆机器成为可能.</span></span></li><li><span class="name"><span class="innerContentContainer">单机的成本/容量是非线性的，所以分布式的核心是线性的水平扩展整个集群的功能. 包括:</span></span></li><li><span class="name"><span class="innerContentContainer">集群协调管理机制</span></span></li><li><span class="name"><span class="innerContentContainer">容量与弹性伸缩</span></span></li><li><span class="name"><span class="innerContentContainer">数据和状态一致性</span></span></li><li><span class="name"><span class="innerContentContainer">容错和故障恢复</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Google的老五篇</span></span><ul><li><span class="name"><span class="innerContentContainer">Google File System</span></span></li><li><span class="name"><span class="innerContentContainer">MapReduce</span></span></li><li><span class="name"><span class="innerContentContainer">Bigtable</span></span></li><li><span class="name"><span class="innerContentContainer">Cluster</span></span></li><li><span class="name"><span class="innerContentContainer">Chubby</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">云存储 (比较简单)</span></span></li><li><span class="name"><span class="innerContentContainer">IaaS，基础设施即服务，云主机，云PC</span></span><ul><li><span class="name"><span class="innerContentContainer">供应商提供操作系统，存储和网络。</span></span></li><li><span class="name"><span class="innerContentContainer">核心技术是操作系统虚拟化。关键因素有：</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟操作系统</span></span><ul><li><span class="name"><span class="innerContentContainer">linux</span></span></li><li><span class="name"><span class="innerContentContainer">windows</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">宿主系统</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟驱动</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主要供应商：vmware</span></span></li><li><span class="name"><span class="innerContentContainer">OpenStack</span></span></li><li><span class="name"><span class="innerContentContainer">Docker</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PaaS，平台即服务，云服务</span></span><ul><li><span class="name"><span class="innerContentContainer">供应商还提供中间件，运行时，引擎。客户自己完成数据和应用。</span></span></li><li><span class="name"><span class="innerContentContainer">本质是把每个函数和数据分配一个ip地址，放在公网上访问。</span></span></li><li><span class="name"><span class="innerContentContainer">并行编程模型，MapReduce。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分布存储，包括google的GFS和hadoop。</span></span></li><li><span class="name"><span class="innerContentContainer">数据管理技术，例如bigtable。</span></span></li><li><span class="name"><span class="innerContentContainer">主要供应商：微软 Azure，亚马逊 AWS，Google App Engine。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">半PaaS：基础设施和平台都一样，但是硬件放在内网。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>SaaS</b>：软件即服务。一般表现为一个网站。（SaaS和大数据实际上是同一个概念）</span></span><ul><li><span class="name"><span class="innerContentContainer">Google 的秘密- PageRank 彻底解说 中文版 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">浅析PageRank算法 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">搜索的始祖和原理 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">供应商还提供数据和应用。</span></span></li><li><span class="name"><span class="innerContentContainer">Google搜索引擎就是最典型的SaaS。还有比如github。</span></span></li><li><span class="name"><span class="innerContentContainer">软件给人带来的最大的困扰是什么呢?  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">是软件复用.  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">软件看起来是非常容易复用的. ctrl c + ctrl v搞定一切, 本应该比任何其它人类产品都更容易复用才对.</span></span></li><li><span class="name"><span class="innerContentContainer">但是, 有一些非外行人所能理解的原因, 导致软件复用相当困难.</span></span></li><li><span class="name"><span class="innerContentContainer">聪明人思考这个问题有70多年了. </span></span></li><li><span class="name"><span class="innerContentContainer">最新的答案是云计算.</span></span></li><li><span class="name"><span class="innerContentContainer">云计算的本质是给每个代码块分配一个IP地址, 放在公网上. 你访问这个IP, 就等于访问了这个代码块.</span></span></li><li><span class="name"><span class="innerContentContainer">这么做一下子解决了3个问题:</span></span><ul><li><span class="name"><span class="innerContentContainer">可访问性问题.</span></span><ul><li><span class="name"><span class="innerContentContainer">可访问。</span></span></li><li><span class="name"><span class="innerContentContainer">可计费</span></span></li><li><span class="name"><span class="innerContentContainer">可停止访问</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">唯一性问题. </span></span><ul><li><span class="name"><span class="innerContentContainer">网址和公网IP天生是全球唯一的。</span></span></li><li><span class="name"><span class="innerContentContainer">解决了唯一性，就不用重复发明轮子了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">客户端和服务器端各自演进的问题</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码块这个概念的演进历史</span></span><ul><li><span class="name"><span class="innerContentContainer">库，包，API。其实都一个意思，就是一堆函数。</span></span></li><li><span class="name"><span class="innerContentContainer">引擎</span></span></li><li><span class="name"><span class="innerContentContainer">平台</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">半SaaS：运行在内网，供应商只提供应用，不接触数据。</span></span><ul><li><span class="name"><span class="innerContentContainer">但是用这些数据训练出的AI模型可带走。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">大数据（后端）</span></span><ul><li><span class="name"><span class="innerContentContainer">大数据的本质是为了将来的全数据时代提供访问数据的能力.  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">以后的数据的量级是这样的:    <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">每个人, 每秒种产生100个数据, 每天产生1000万数据, 每年产生 200亿个数据.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">全球70亿人, 每年产生 1400亿亿个数据.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">面对这样的采样率, 一切抽象化, 比如单位, 企业, 阶级, 民族, 国家, 种族, 校友, 老乡, 宗族, 都失去价值了.    <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">为什么这样讲呢?</span></span></li><li><span class="name"><span class="innerContentContainer">首先, 这些东西本身存在的价值在于它们是钥匙, 钥匙的本质就是用小东西控制大东西. </span></span></li><li><span class="name"><span class="innerContentContainer">为什么要用小东西控制大东西? 因为大东西我们拿不动, 至少不能低成本的拿.</span></span></li><li><span class="name"><span class="innerContentContainer">一旦我们拿得动大东西, 谁还去拿小东西?</span></span></li><li><span class="name"><span class="innerContentContainer">比如说你有一个空间戒指, 任何东西都可以放进去, 而且放进去就没有重量了, 那么, 你还需要房子干什么呢? 你什么都带在身上就好了.</span></span></li><li><span class="name"><span class="innerContentContainer">云的目的, 就在于低成本的完成这种密度的采样.   <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">大数据的目的, 就是每时每刻都能读写 1400亿亿个数据.    <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">AI的目的, 就在于瞬间分析完这些数据, 然后给你提供最优的判断和选择.  <span class="contentTag" title="Filter @me">@<span class="contentTagText">me</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">有这样的数据的支撑, </span></span></li><li><span class="name"><span class="innerContentContainer">我还需要组建企业干什么呢? </span></span></li><li><span class="name"><span class="innerContentContainer">我还需要去民政局登记结婚干什么呢?</span></span></li><li><span class="name"><span class="innerContentContainer">我还需要统计GDP干什么呢?</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">比数据库更大。</span></span></li><li><span class="name"><span class="innerContentContainer">大数据的特点是：</span></span><ul><li><span class="name"><span class="innerContentContainer">记录多（时间长）</span></span></li><li><span class="name"><span class="innerContentContainer">字段多（客观事物自身的属性维度本身就多）</span></span></li><li><span class="name"><span class="innerContentContainer">多数字段是空（收集全数据成本太高）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">搜索引擎原理</span></span></li><li><span class="name"><span class="innerContentContainer">全文检索库</span></span><ul><li><span class="name"><span class="innerContentContainer">Lucene</span></span></li><li><span class="name"><span class="innerContentContainer">Elasticsearch</span></span></li><li><span class="name"><span class="innerContentContainer">Solr</span></span></li><li><span class="name"><span class="innerContentContainer">sphinx</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">大数据的前身</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库时代的界面系统叫IMS。</span></span></li><li><span class="name"><span class="innerContentContainer">大数据库时代的界面系统叫BI（商业智慧），支撑决策。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">访问方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">文件</span></span></li><li><span class="name"><span class="innerContentContainer">SQL</span></span></li><li><span class="name"><span class="innerContentContainer">多维分析（OLAP）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">流式计算</span></span><ul><li><span class="name"><span class="innerContentContainer">Storm</span></span></li><li><span class="name"><span class="innerContentContainer">Flink</span></span></li><li><span class="name"><span class="innerContentContainer">Kafka Stream</span></span></li><li><span class="name"><span class="innerContentContainer">应用场景</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Hadoop：分布式计算框架</span></span><ul><li><span class="name"><span class="innerContentContainer">分布式文件系统（Hadoop Distributed File System，HDFS），负责存储。</span></span></li><li><span class="name"><span class="innerContentContainer">YARN，负责集群管理和调度，相当于进程调度。</span></span></li><li><span class="name"><span class="innerContentContainer">MapReduce，定义了集群上处理数据的基本操作，即分布式编程模型，相当于SDK。其设计原则是把所有计算都拆成Map和Reduce两个过程。</span></span><ul><li><span class="name"><span class="innerContentContainer">Map(映射)：</span></span></li><li><span class="name"><span class="innerContentContainer">Reduce(化简)：就是将业务逻辑复杂的处理调度给处理能力比较高的计算机，将处理能力小的处理给小型的计算机。</span></span></li><li><span class="name"><span class="innerContentContainer">数据处理可以分解为由多个Job（包含一个Mapper和一个Reducer）组成的有向无环图（DAG）,然后每个Mapper和Reducer放到Hadoop集群上执行，就可以得出结果。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Hive ：构建在MapReduce框架之上的类SQL查询引擎。</span></span></li><li><span class="name"><span class="innerContentContainer">Hbase：基于HDFS的键值对存储系统为Hadoop提供了联机事务处理(OLTP)能力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Spark：分布式计算框架（成熟中）</span></span><ul><li><span class="name"><span class="innerContentContainer">大数据引擎。</span></span></li><li><span class="name"><span class="innerContentContainer">万物都是RDD，在RDD之上你可以方便地进行更高层的操作。</span></span></li><li><span class="name"><span class="innerContentContainer">和hadoop相比，优势是：</span></span><ul><li><span class="name"><span class="innerContentContainer">内存数据库性能比hadoop快100倍。</span></span></li><li><span class="name"><span class="innerContentContainer">开发易用性较高。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">人工智能  参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/90d071d16aad">https://workflowy.com/#/90d071d16aad</a></span></span></li><li><span class="name"><span class="innerContentContainer">前端</span></span><ul><li><span class="name"><span class="innerContentContainer">Web前端</span></span><ul><li><span class="name"><span class="innerContentContainer">jsp</span></span></li><li><span class="name"><span class="innerContentContainer">html/css</span></span></li><li><span class="name"><span class="innerContentContainer">php</span></span><ul><li><span class="name"><span class="innerContentContainer">smarty(MVC模式)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">java</span></span><ul><li><span class="name"><span class="innerContentContainer">SSH框架</span></span><ul><li><span class="name"><span class="innerContentContainer">Struts(MVC)</span></span></li><li><span class="name"><span class="innerContentContainer">Spring</span></span></li><li><span class="name"><span class="innerContentContainer">Hibernate</span></span><ul><li><span class="name"><span class="innerContentContainer">数据表对象化</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SSM框架（更流行）</span></span><ul><li><span class="name"><span class="innerContentContainer">Spring</span></span><ul><li><span class="name"><span class="innerContentContainer">2003年推出。</span></span></li><li><span class="name"><span class="innerContentContainer">核心思想是IoC（控制反转），即不再需要程序员去显式地`new`一个对象，而是让Spring框架帮你来完成这一切。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SpringMVC</span></span><ul><li><span class="name"><span class="innerContentContainer">负责拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MyBatis</span></span><ul><li><span class="name"><span class="innerContentContainer">MyBatis对jdbc的封装。mybatis通过配置文件关联到各实体类的Mapper文件，其中配置了每个类对数据库所需进行的sql语句映射。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Python</span></span><ul><li><span class="name"><span class="innerContentContainer">django(MTV模式)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">PC前端</span></span><ul><li><span class="name"><span class="innerContentContainer">C# </span></span></li><li><span class="name"><span class="innerContentContainer">C++</span></span><ul><li><span class="name"><span class="innerContentContainer">QT</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">手机前端</span></span><ul><li><span class="name"><span class="innerContentContainer">Android：java（Kotlin）</span></span></li><li><span class="name"><span class="innerContentContainer">IOS：object C（Swift）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>编程语言</b></span></span><ul><li><span class="name"><span class="innerContentContainer">软件的本质是依赖. 它是人脑对物质世界的理解或投影。</span></span></li><li><span class="name"><span class="innerContentContainer">语言语法</span></span><ul><li><span class="name"><span class="innerContentContainer">2014/7/14, 初始化</span></span></li><li><span class="name"><span class="innerContentContainer">2018-01-05, 按C语言语法做了扩充</span></span></li><li><span class="name"><span class="innerContentContainer">2020-06-22, 按java语法做了扩充</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #最小编程规范">#<span class="contentTagText">最小编程规范</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #代码组织方式">#<span class="contentTagText">代码组织方式</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #类和对象">#<span class="contentTagText">类和对象</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #HelloWorld">#<span class="contentTagText">HelloWorld</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #注释">#<span class="contentTagText">注释</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印">#<span class="contentTagText">Log打印</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #函数">#<span class="contentTagText">函数</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #整数">#<span class="contentTagText">整数</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #布尔量">#<span class="contentTagText">布尔量</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #浮点数">#<span class="contentTagText">浮点数</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #常量">#<span class="contentTagText">常量</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #全局变量">#<span class="contentTagText">全局变量</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #静态变量">#<span class="contentTagText">静态变量</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #枚举量">#<span class="contentTagText">枚举量</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #运算符表">#<span class="contentTagText">运算符表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #基本数据类型装箱">#<span class="contentTagText">基本数据类型装箱</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #指针和引用">#<span class="contentTagText">指针和引用</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #对象判空">#<span class="contentTagText">对象判空</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #对象的元属性">#<span class="contentTagText">对象的元属性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #for循环">#<span class="contentTagText">for循环</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #where循环">#<span class="contentTagText">where循环</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #if和switch">#<span class="contentTagText">if和switch</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串">#<span class="contentTagText">字符串</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #转义字符">#<span class="contentTagText">转义字符</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串定义">#<span class="contentTagText">字符串定义</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串判空">#<span class="contentTagText">字符串判空</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串取长">#<span class="contentTagText">字符串取长</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串比较">#<span class="contentTagText">字符串比较</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串去空格">#<span class="contentTagText">字符串去空格</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串拼接">#<span class="contentTagText">字符串拼接</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串截取">#<span class="contentTagText">字符串截取</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串查找">#<span class="contentTagText">字符串查找</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串替换">#<span class="contentTagText">字符串替换</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串拆分">#<span class="contentTagText">字符串拆分</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字符串的格式化输出">#<span class="contentTagText">字符串的格式化输出</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #正则表达式">#<span class="contentTagText">正则表达式</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #中文编码">#<span class="contentTagText">中文编码</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #时间处理">#<span class="contentTagText">时间处理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #获取系统时间">#<span class="contentTagText">获取系统时间</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #日期时间">#<span class="contentTagText">日期时间</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #时区">#<span class="contentTagText">时区</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组">#<span class="contentTagText">数组</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #定义数组">#<span class="contentTagText">定义数组</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #遍历数据">#<span class="contentTagText">遍历数据</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #取长">#<span class="contentTagText">取长</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组元素的新增删除">#<span class="contentTagText">数组元素的新增删除</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组元素的查询">#<span class="contentTagText">数组元素的查询</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #数组排序">#<span class="contentTagText">数组排序</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #异常处理">#<span class="contentTagText">异常处理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #常见异常类型">#<span class="contentTagText">常见异常类型</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #异常处理">#<span class="contentTagText">异常处理</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #自定义异常">#<span class="contentTagText">自定义异常</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存管理">#<span class="contentTagText">内存管理</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存模型">#<span class="contentTagText">内存模型</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存申请">#<span class="contentTagText">内存申请</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存销毁">#<span class="contentTagText">内存销毁</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存拷贝">#<span class="contentTagText">内存拷贝</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存清零">#<span class="contentTagText">内存清零</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #内存比较">#<span class="contentTagText">内存比较</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件系统">#<span class="contentTagText">文件系统</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件路径分隔符">#<span class="contentTagText">文件路径分隔符</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #回车换行符">#<span class="contentTagText">回车换行符</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件夹和文件的存在性">#<span class="contentTagText">文件夹和文件的存在性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #遍历文件夹">#<span class="contentTagText">遍历文件夹</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #新建文件夹">#<span class="contentTagText">新建文件夹</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #删除文件夹">#<span class="contentTagText">删除文件夹</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #返回和修改当前路径">#<span class="contentTagText">返回和修改当前路径</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #创建文件">#<span class="contentTagText">创建文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #读文件">#<span class="contentTagText">读文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #写文件">#<span class="contentTagText">写文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #返回文件长度">#<span class="contentTagText">返回文件长度</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件改名改属性">#<span class="contentTagText">文件改名改属性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #删除文件">#<span class="contentTagText">删除文件</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #文件系统原语">#<span class="contentTagText">文件系统原语</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #hash表">#<span class="contentTagText">hash表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典">#<span class="contentTagText">字典</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典定义">#<span class="contentTagText">字典定义</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典size">#<span class="contentTagText">字典size</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #判断元素存在性">#<span class="contentTagText">判断元素存在性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #字典遍历">#<span class="contentTagText">字典遍历</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #成员的新增删除">#<span class="contentTagText">成员的新增删除</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #key和元素的查找">#<span class="contentTagText">key和元素的查找</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #排序">#<span class="contentTagText">排序</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #链表">#<span class="contentTagText">链表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #UT">#<span class="contentTagText">UT</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #平台兼容性">#<span class="contentTagText">平台兼容性</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #泛型">#<span class="contentTagText">泛型</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #宏定义">#<span class="contentTagText">宏定义</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IDE</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #导入工程">#<span class="contentTagText">导入工程</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #快捷键映射">#<span class="contentTagText">快捷键映射</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #更换主题">#<span class="contentTagText">更换主题</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F1文件名查找">#<span class="contentTagText">F1文件名查找</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F2符号查找">#<span class="contentTagText"><u>F2符号查找</u></span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F3上一处">#<span class="contentTagText">F3上一处</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F4下一处">#<span class="contentTagText">F4下一处</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F5全文检索">#<span class="contentTagText">F5全文检索</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F6关键字高亮">#<span class="contentTagText">F6关键字高亮</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F7已打开文件列表">#<span class="contentTagText">F7已打开文件列表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F8书签列表">#<span class="contentTagText">F8书签列表</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #F9加书签">#<span class="contentTagText">F9加书签</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常规算法</span></span><ul><li><span class="name"><span class="innerContentContainer">算法复杂度速查表   <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">排序、查找算法</span></span><ul><li><span class="name"><span class="innerContentContainer">排序大的分类可以分为两种：内排序和外排序。</span></span><ul><li><span class="name"><span class="innerContentContainer">在排序过程中，全部记录存放在内存，则称为内排序.</span></span></li><li><span class="name"><span class="innerContentContainer">如果排序过程中需要使用外存，则称为外排序。</span></span></li><li><span class="name"><span class="innerContentContainer">下面讲的排序都是属于内排序。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">插入排序</span></span><ul><li><span class="name"><span class="innerContentContainer">每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。分为: </span></span></li><li><span class="name"><span class="innerContentContainer">直接插入排序</span></span><ul><li><span class="name"><span class="innerContentContainer">时间复杂度: O(n2)</span></span></li><li><span class="name"><span class="innerContentContainer">稳定.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">二分法插入排序</span></span><ul><li><span class="name"><span class="innerContentContainer">找合适的插入位置时, 采用二分法查找. 因为已排序子集是有序的.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">希尔排序</span></span><ul><li><span class="name"><span class="innerContentContainer">先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序.</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">选择排序</span></span><ul><li><span class="name"><span class="innerContentContainer">每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。</span></span></li><li><span class="name"><span class="innerContentContainer">直接选择排序</span></span><ul><li><span class="name"><span class="innerContentContainer">在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(n2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">堆排序</span></span><ul><li><span class="name"><span class="innerContentContainer">堆排序是一种树形选择排序，是对直接选择排序的有效改进。</span></span></li><li><span class="name"><span class="innerContentContainer">初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">交换排序</span></span><ul><li><span class="name"><span class="innerContentContainer">冒泡排序</span></span><ul><li><span class="name"><span class="innerContentContainer">在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(n2)</span></span></li><li><span class="name"><span class="innerContentContainer">稳定.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">快速排序</span></span><ul><li><span class="name"><span class="innerContentContainer">选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">归并排序</span></span><ul><li><span class="name"><span class="innerContentContainer">归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(nlog2n)</span></span></li><li><span class="name"><span class="innerContentContainer">稳定</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">桶排序</span></span><ul><li><span class="name"><span class="innerContentContainer">直接桶排序</span></span><ul><li><span class="name"><span class="innerContentContainer">将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</span></span></li><li><span class="name"><span class="innerContentContainer">然后对每个桶内的元素进行排序。可以选择任意一种排序算法。</span></span></li><li><span class="name"><span class="innerContentContainer">最后将将各个桶中的元素合并成一个大的有序序列。</span></span></li><li><span class="name"><span class="innerContentContainer">假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为 O(n)+O(m)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk 。当 k 接近于 n 时，桶排序的时间复杂度就可以认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">计数排序</span></span><ul><li><span class="name"><span class="innerContentContainer">计数排序本质上是一种特殊的桶排序，当桶的个数取最大( maxV-minV+1 )的时候，就变成了计数排序。</span></span></li><li><span class="name"><span class="innerContentContainer">和桶排序过程比较像，差别在于桶的数量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">基数排序</span></span><ul><li><span class="name"><span class="innerContentContainer">将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，按照个位、十位、百位、...依次来排。</span></span></li><li><span class="name"><span class="innerContentContainer">时间复杂度: O(d(n+r))</span></span></li><li><span class="name"><span class="innerContentContainer">稳定.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">二分查找</span></span></li><li><span class="name"><span class="innerContentContainer">Java 中的排序</span></span><ul><li><span class="name"><span class="innerContentContainer">Collections.sort算法调用的是归并排序。</span></span></li><li><span class="name"><span class="innerContentContainer">Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">布隆过滤器</span></span><ul><li><span class="name"><span class="innerContentContainer">常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。</span></span></li><li><span class="name"><span class="innerContentContainer">注意：会有一定的错误率。</span></span></li><li><span class="name"><span class="innerContentContainer">优点：空间和时间效率都很高。 </span></span></li><li><span class="name"><span class="innerContentContainer">缺点：随着存入的元素数量增加，误算率随之增加。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字符串比较</span></span><ul><li><span class="name"><span class="innerContentContainer">KMP 算法</span></span><ul><li><span class="name"><span class="innerContentContainer">KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">深度优先</span></span><ul><li><span class="name"><span class="innerContentContainer">一条路走到黑, 到黑再回头重走.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">广度优先</span></span><ul><li><span class="name"><span class="innerContentContainer">先遍历完所有邻居, 再找邻居的邻居.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态规划</span></span><ul><li><span class="name"><span class="innerContentContainer">动态规划是一个广泛的概念. 它的基本理念是把一个复杂问题分解为多个简单问题, 然后按照一定的顺序解决这些简单问题, 并把它们的解组合成复杂问题的解.</span></span></li><li><span class="name"><span class="innerContentContainer">动态规划算法有如下几种:</span></span></li><li><span class="name"><span class="innerContentContainer">贪心算法</span></span><ul><li><span class="name"><span class="innerContentContainer">贪心算法每次取当前最佳的，期望通过所有的局部最优解的总和来产生一个全局最优解。</span></span></li><li><span class="name"><span class="innerContentContainer">设计贪心算法的步骤:</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 将优化问题转换成多个子问题, 先基于当前之问题做出最优选择，然后再解决下一个子问题。</span></span></li><li><span class="name"><span class="innerContentContainer">2. 证明原问题总是有一个最优解是贪心选择的得到的，从而说明贪心选择的安全。</span></span></li><li><span class="name"><span class="innerContentContainer">3. 说明在做出贪心选择后，剩下的子问题具有这样一个性质, 即如果将子问题的最优解和我们所做的贪心选择联合起来，可以得到一个更加负责的动态规划解。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">背包问题</span></span><ul><li><span class="name"><span class="innerContentContainer">问题: 给定N个物品和一个容量为C的背包,物品i的重量为Wi，其价值为Vi，背包问题是如何选择装入背包的物品，使得装入背包中物品的总价值最大。</span></span></li><li><span class="name"><span class="innerContentContainer">三种贪心思想：</span></span><ul><li><span class="name"><span class="innerContentContainer">选择价值最大的物品</span></span></li><li><span class="name"><span class="innerContentContainer">选择重量最轻的物品</span></span></li><li><span class="name"><span class="innerContentContainer">选择单位重量价值最大的物品</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">毫无疑问，我们当然选择第三种。先把性价比最高的全部装入，最后不足全部装入的部分装入。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">贪心算法的优势是简单高效, 一步到位, 没有"回溯"过程. 但是缺点就是往往找不到全局最优解, 而且差距甚大.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">回溯算法</span></span><ul><li><span class="name"><span class="innerContentContainer">许多复杂的，规模较大的问题都可以使用回溯法，所以它有“通用解题方法”的美称。</span></span></li><li><span class="name"><span class="innerContentContainer">回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。走不通就退回再走.</span></span></li><li><span class="name"><span class="innerContentContainer">满足回溯条件的某个状态的点称为“回溯点”。</span></span></li><li><span class="name"><span class="innerContentContainer">在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">剪枝算法</span></span><ul><li><span class="name"><span class="innerContentContainer">一种基于剪枝（ α-βcut-off）的深度优先搜索（depth-first search）。</span></span></li><li><span class="name"><span class="innerContentContainer">将走棋方定为MAX方，因为它选择着法时总是对其子节点的评估值取极大值，即选择对自己最为有利的着法；</span></span></li><li><span class="name"><span class="innerContentContainer">将应对方定为MIN方，因为它走棋时需要对其子节点的评估值取极小值，即选择对走棋方最为不利的、最有钳制作用的着法。</span></span></li><li><span class="name"><span class="innerContentContainer">α-β剪枝是根据极大-极小搜索规则的进行的，虽然它没有遍历某些子树的大量节点，但它仍不失为穷尽搜索的本性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">经典动态规划</span></span><ul><li><span class="name"><span class="innerContentContainer">可以采用动态规划算法进行解决的一个重要性质即是该问题必须具备最优子结构性质.</span></span></li><li><span class="name"><span class="innerContentContainer">最优子结构性质, 指原问题的最优解必然包含了原问题的子问题的一个最优解。</span></span></li><li><span class="name"><span class="innerContentContainer">最短路径规划问题</span></span><ul><li><span class="name"><span class="innerContentContainer">解决步骤是: </span></span></li><li><span class="name"><span class="innerContentContainer">从终点开始, 从终点的邻居开始, 计算每个点到终点的最短距离. </span></span></li><li><span class="name"><span class="innerContentContainer">一直延伸到始点, 此时的最短距离即为答案.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态规划算法每一次都会保留所有可能的选择策略中的最优者，因为总体的最优必然包含某个局部最优解.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">朴素贝叶斯</span></span><ul><li><span class="name"><span class="innerContentContainer">贝叶斯定理: P(B|A)=P(A|B)P(B) / P(A)</span></span><ul><li><span class="name"><span class="innerContentContainer">换个形式就是: P(类别|特征)=P(特征|类别)P(类别) / P(特征)</span></span></li><li><span class="name"><span class="innerContentContainer">P(A)称为"先验概率"（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。</span></span></li><li><span class="name"><span class="innerContentContainer">P(A|B)称为"后验概率"（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。</span></span></li><li><span class="name"><span class="innerContentContainer">P(B|A)/P(B)称为"可能性函数"（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。</span></span></li><li><span class="name"><span class="innerContentContainer">后验概率　＝　先验概率 ｘ 调整因子</span></span></li><li><span class="name"><span class="innerContentContainer">这就是贝叶斯推断的含义。我们先预估一个"先验概率"，然后加入实验结果，看这个实验到底是增强还是削弱了"先验概率"，由此得到更接近事实的"后验概率"。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故称.</span></span></li><li><span class="name"><span class="innerContentContainer">朴素贝叶斯分类是其中最简单的, 也是较常见的.</span></span></li><li><span class="name"><span class="innerContentContainer">举例, 假定姑娘们判断嫁不嫁, 会考虑4个特征: 帅不帅, 性格好不好, 高不高, 上进不上进</span></span><ul><li><span class="name"><span class="innerContentContainer">现在有个男生, 4个特征分别是不帅，性格不好，身高矮，不上进, 那么女生是嫁还是不嫁？</span></span></li><li><span class="name"><span class="innerContentContainer">即比较 p(嫁|(不帅、性格不好、身高矮、不上进))与 p(不嫁|(不帅、性格不好、身高矮、不上进)), 哪个概率大? </span></span></li><li><span class="name"><span class="innerContentContainer">直接求p(嫁|(不帅、性格不好、身高矮、不上进)) 不容易, 但是可以应用贝叶斯定理, 将其转化为好求的3个量:</span></span><ul><li><span class="name"><span class="innerContentContainer">p (不帅、性格不好、身高矮、不上进|嫁)</span></span><ul><li><span class="name"><span class="innerContentContainer">它等于 p(不帅|嫁)*p(性格不好|嫁)*p(身高矮|嫁)*p(不上进|嫁). 分别统计这几个概率, 就可以得出结果.</span></span></li><li><span class="name"><span class="innerContentContainer">不过这个等式要成立, 要求各特征之间相互独立.</span></span></li><li><span class="name"><span class="innerContentContainer">这就是朴素的来历, 朴素贝叶斯算法是假设各个特征之间相互独立.</span></span></li><li><span class="name"><span class="innerContentContainer">这一假设使得朴素贝叶斯法变得简单，但有时会牺牲分类准确率。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">p (不帅、性格不好、身高矮、不上进)</span></span></li><li><span class="name"><span class="innerContentContainer">p(嫁)</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">推荐算法通常被分为如下4类:</span></span></li><li><span class="name"><span class="innerContentContainer">协同过滤推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐</span></span></li><li><span class="name"><span class="innerContentContainer">输入：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）</span></span></li><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">基于邻域的协同过滤（基于用户和基于项）</span></span></li><li><span class="name"><span class="innerContentContainer">基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">需要最小域</span></span></li><li><span class="name"><span class="innerContentContainer">不需要用户和项</span></span></li><li><span class="name"><span class="innerContentContainer">大部分场景中能够产生足够好的结果</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">冷启动问题</span></span></li><li><span class="name"><span class="innerContentContainer">需要标准化产品</span></span></li><li><span class="name"><span class="innerContentContainer">需要很高的用户和项的比例（1：10）</span></span></li><li><span class="name"><span class="innerContentContainer">流行度偏见（有长尾的时候表现不够好）</span></span></li><li><span class="name"><span class="innerContentContainer">难于提供解释</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">基于内容的推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：向用户推荐和其过去喜欢项的内容（例如元数据、描述、话题等等）相似的项</span></span></li><li><span class="name"><span class="innerContentContainer">输入：仅仅依赖于项和用户的内容 / 描述（除了惯用数据）</span></span></li><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">信息检索（例如 tf-idf 和 Okapi BM25）</span></span></li><li><span class="name"><span class="innerContentContainer">机器学习（例如朴素贝叶斯、支持向量机、决策树等等）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">没有冷启动问题</span></span></li><li><span class="name"><span class="innerContentContainer">不需要惯用数据</span></span></li><li><span class="name"><span class="innerContentContainer">没有流行度偏见，可以推荐有罕见特性的项</span></span></li><li><span class="name"><span class="innerContentContainer">可以使用用户内容特性来提供解释</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">项内容必须是机器可读的和有意义的</span></span></li><li><span class="name"><span class="innerContentContainer">容易归档用户</span></span></li><li><span class="name"><span class="innerContentContainer">很难有意外，缺少多样性</span></span></li><li><span class="name"><span class="innerContentContainer">很难联合多个项的特性</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">混合推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：综合利用协同过滤推荐算法和基于内容的推荐算法各自的优点同时抵消各自的缺点</span></span></li><li><span class="name"><span class="innerContentContainer">输入：同时使用用户和项的内容特性与惯用数据，同时从两种输入类型中获益</span></span></li><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">加权</span></span></li><li><span class="name"><span class="innerContentContainer">交换</span></span></li><li><span class="name"><span class="innerContentContainer">混合</span></span></li><li><span class="name"><span class="innerContentContainer">特性组合</span></span></li><li><span class="name"><span class="innerContentContainer">案列</span></span></li><li><span class="name"><span class="innerContentContainer">特征增强</span></span></li><li><span class="name"><span class="innerContentContainer">元层次</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">由于单独使用协同过滤推荐算法和基于内容的推荐算法</span></span></li><li><span class="name"><span class="innerContentContainer">没有冷启动问题</span></span></li><li><span class="name"><span class="innerContentContainer">没有流行度偏见，可推荐有罕见特性的项</span></span></li><li><span class="name"><span class="innerContentContainer">可产生意外，实现多样性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">需要通过大量的工作才能得到正确的平衡</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">流行度推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">简介：这是一种推荐流行项的方法 (例如最多下载、最多看过、最大影响的项)</span></span></li><li><span class="name"><span class="innerContentContainer">输入：使用惯用数据和项的内容（例如类目）</span></span></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">相对容易实现</span></span></li><li><span class="name"><span class="innerContentContainer">良好的基准算法</span></span></li><li><span class="name"><span class="innerContentContainer">有助于解决新用户冷启动问题</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">需要标准化产品</span></span></li><li><span class="name"><span class="innerContentContainer">经常需要一些项的类型进行分类</span></span></li><li><span class="name"><span class="innerContentContainer">不会推荐新项（很少有机会被观测到）</span></span></li><li><span class="name"><span class="innerContentContainer">推荐列表不会改变太大</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">高级非传统推荐算法</span></span><ul><li><span class="name"><span class="innerContentContainer">类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">深度学习</span></span></li><li><span class="name"><span class="innerContentContainer">学习等级</span></span></li><li><span class="name"><span class="innerContentContainer">Multi-armed bandits（探索 / 开发）</span></span></li><li><span class="name"><span class="innerContentContainer">上下文感知推荐</span></span></li><li><span class="name"><span class="innerContentContainer">张量分解</span></span></li><li><span class="name"><span class="innerContentContainer">分解机</span></span></li><li><span class="name"><span class="innerContentContainer">社会推荐</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">优点：</span></span><ul><li><span class="name"><span class="innerContentContainer">利于勉强维持最终性能百分点</span></span></li><li><span class="name"><span class="innerContentContainer">你可以说你正在使用渐进的方式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">缺点：</span></span><ul><li><span class="name"><span class="innerContentContainer">难于理解</span></span></li><li><span class="name"><span class="innerContentContainer">缺乏推荐工具支持</span></span></li><li><span class="name"><span class="innerContentContainer">没有为你的首个推荐系统提供推荐的方式</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">最小生成树算法</span></span><ul><li><span class="name"><span class="innerContentContainer">Kruskal算法</span></span><ul><li><span class="name"><span class="innerContentContainer">此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</span></span></li><li><span class="name"><span class="innerContentContainer">1. 把图中的所有边按代价从小到大排序；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 把图中的n个顶点看成独立的n棵树组成的森林；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</span></span></li><li><span class="name"><span class="innerContentContainer">4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Prim算法</span></span><ul><li><span class="name"><span class="innerContentContainer">此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</span></span></li><li><span class="name"><span class="innerContentContainer">图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</span></span></li><li><span class="name"><span class="innerContentContainer">在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</span></span></li><li><span class="name"><span class="innerContentContainer">重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</span></span></li><li><span class="name"><span class="innerContentContainer">由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">最短路径算法</span></span><ul><li><span class="name"><span class="innerContentContainer">从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径. 解决问题的算法：</span></span></li><li><span class="name"><span class="innerContentContainer">迪杰斯特拉算法（Dijkstra算法）</span></span><ul><li><span class="name"><span class="innerContentContainer">迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</span></span></li><li><span class="name"><span class="innerContentContainer">Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，</span></span></li><li><span class="name"><span class="innerContentContainer">然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。</span></span></li><li><span class="name"><span class="innerContentContainer">然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">弗洛伊德算法（Floyd算法）</span></span></li><li><span class="name"><span class="innerContentContainer">SPFA算法</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">算法</span></span><ul><li><span class="name"><span class="innerContentContainer">显示</span></span></li><li><span class="name"><span class="innerContentContainer">照片效果</span></span></li><li><span class="name"><span class="innerContentContainer">定位</span></span></li><li><span class="name"><span class="innerContentContainer">空间寻路</span></span></li><li><span class="name"><span class="innerContentContainer">物体识别</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据结构</span></span><ul><li><span class="name"><span class="innerContentContainer">链表、数组</span></span><ul><li><span class="name"><span class="innerContentContainer">数组的特点是访问很快，但是元素的插入和删除很慢。</span></span></li><li><span class="name"><span class="innerContentContainer">List主要分为3类，ArrayList， LinkedList和Vector。</span></span></li><li><span class="name"><span class="innerContentContainer">Vector是ArrayList的线程安全版，它的方法前都加了synchronized锁，其他实现逻辑都相同。</span></span></li><li><span class="name"><span class="innerContentContainer">List是一个有序的集合, 允许有空值, 也允许等值.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">集合</span></span></li><li><span class="name"><span class="innerContentContainer">队列</span></span><ul><li><span class="name"><span class="innerContentContainer">队列是一个先入先出（FIFO）的数据结构.</span></span></li><li><span class="name"><span class="innerContentContainer">Java中用Queue类. Queue接口与List、Set同一级别，都是继承了Collection接口。</span></span></li><li><span class="name"><span class="innerContentContainer">非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</span></span></li><li><span class="name"><span class="innerContentContainer">阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">字典、关联数组</span></span></li><li><span class="name"><span class="innerContentContainer">栈</span></span><ul><li><span class="name"><span class="innerContentContainer">java中 Stack 是线程安全的。</span></span></li><li><span class="name"><span class="innerContentContainer">内部使用数组保存数据，不够时翻倍。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">树</span></span><ul><li><span class="name"><span class="innerContentContainer">二叉树</span></span><ul><li><span class="name"><span class="innerContentContainer">每个节点最多有两个叶子节点。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">完全二叉树</span></span><ul><li><span class="name"><span class="innerContentContainer">叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">平衡二叉树</span></span><ul><li><span class="name"><span class="innerContentContainer">左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">二叉查找树（BST）</span></span><ul><li><span class="name"><span class="innerContentContainer">二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">红黑树</span></span><ul><li><span class="name"><span class="innerContentContainer">红黑树是一个平衡的二叉树，但不完美。虽然我们希望一个所有查找都能在~lgN次比较内结束，但是这样在动态插入中保持树的完美平衡代价太高，所以我们稍微放松逛一下限制，希望找到一个能在对数时间内完成查找的数据结构。</span></span></li><li><span class="name"><span class="innerContentContainer">红黑树需要满足的五条性质：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 节点是红色或者是黑色；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 根节点是黑色；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 每个叶节点（NIL或空节点）是黑色；</span></span></li><li><span class="name"><span class="innerContentContainer">4. 每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）</span></span></li><li><span class="name"><span class="innerContentContainer">5. 从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可以通过数学来证明，满足这五条性质的二叉树可以将查找删除维持在对数时间内。</span></span></li><li><span class="name"><span class="innerContentContainer">添加阶段后，左旋或者右旋从而再次达到平衡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">B，B+，B*树</span></span><ul><li><span class="name"><span class="innerContentContainer">B-树是一种平衡的多路搜索树（并不一定是二叉的）.</span></span></li><li><span class="name"><span class="innerContentContainer">B+树是应文件系统所需而出的一种B-树的变型树。B+树在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</span></span></li><li><span class="name"><span class="innerContentContainer">B*书: 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3.</span></span></li><li><span class="name"><span class="innerContentContainer">B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。</span></span></li><li><span class="name"><span class="innerContentContainer">MySQL是基于B+树聚集索引组织表.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LSM 树</span></span><ul><li><span class="name"><span class="innerContentContainer">LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</span></span></li><li><span class="name"><span class="innerContentContainer">B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</span></span></li><li><span class="name"><span class="innerContentContainer">LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</span></span></li><li><span class="name"><span class="innerContentContainer">极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</span></span></li><li><span class="name"><span class="innerContentContainer">Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">BitSet</span></span><ul><li><span class="name"><span class="innerContentContainer">经常用于大规模数据的排重检查。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">图</span></span><ul><li><span class="name"><span class="innerContentContainer">连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</span></span></li><li><span class="name"><span class="innerContentContainer">强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</span></span></li><li><span class="name"><span class="innerContentContainer">连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</span></span></li><li><span class="name"><span class="innerContentContainer">生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</span></span></li><li><span class="name"><span class="innerContentContainer">最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">设计模式</span></span><ul><li><span class="name"><span class="innerContentContainer">是否设计过通用的组件？  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">请设计一个通用的 Dialog（弹出层）组件</span></span></li><li><span class="name"><span class="innerContentContainer">会提供什么接口？</span></span></li><li><span class="name"><span class="innerContentContainer">可能会遇到什么细节问题？</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DDD(Domain-driven Design - 领域驱动设计)</span></span><ul><li><span class="name"><span class="innerContentContainer">命令查询职责分离(CQRS)</span></span></li><li><span class="name"><span class="innerContentContainer">贫血，充血模型</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Actor 模式</span></span></li><li><span class="name"><span class="innerContentContainer">响应式编程</span></span><ul><li><span class="name"><span class="innerContentContainer">Reactor</span></span></li><li><span class="name"><span class="innerContentContainer">RxJava</span></span></li><li><span class="name"><span class="innerContentContainer">Vert.x</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DODAF2.0</span></span></li><li><span class="name"><span class="innerContentContainer">Serverless</span></span></li><li><span class="name"><span class="innerContentContainer">Service Mesh</span></span></li><li><span class="name"><span class="innerContentContainer">软件框架要解决的首要问题是什么？</span></span><ul><li><span class="name"><span class="innerContentContainer">为了区别变化和不变的部分提供工具支撑。</span></span></li><li><span class="name"><span class="innerContentContainer">COM如何做到这一点？</span></span><ul><li><span class="name"><span class="innerContentContainer">如果只是实现变化，接口不变，则无问题。如A调用B，A和B各自演进，且没有彼此的源代码；只要接口不变就无问题。</span></span></li><li><span class="name"><span class="innerContentContainer">如果接口变化，需要调用方适配新旧两种接口，保证向下兼容。在A和B中，旧A不可以调用新B，其它组合无问题。</span></span></li><li><span class="name"><span class="innerContentContainer">作为A，可以在运行时探测系统中存在哪个版本的B，并决定该用哪种接口，这是COM的强大之处，也是COM设计时要搞定的首要问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">hal体现了google对产业的理解力</span></span><ul><li><span class="name"><span class="innerContentContainer">linux基金会与硬件厂商的矛盾不可调和。</span></span></li><li><span class="name"><span class="innerContentContainer">hal将linux架空，解决了这个问题，也就释放了产业界的威力。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>设计模式的若干原则  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">单一职责原则: 就一个类而言，应该仅有一个引起它变化的原因。</span></span></li><li><span class="name"><span class="innerContentContainer">开闭原则：一个软件实体应当对扩展开放，对修改关闭。</span></span></li><li><span class="name"><span class="innerContentContainer">里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象。</span></span></li><li><span class="name"><span class="innerContentContainer">依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。</span></span></li><li><span class="name"><span class="innerContentContainer">接口隔离原则：客户端不应该依赖那些它不需要的接口。</span></span></li><li><span class="name"><span class="innerContentContainer">迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。</span></span></li><li><span class="name"><span class="innerContentContainer">重用发布等价原则: 重用的粒度就是发布的粒度.</span></span></li><li><span class="name"><span class="innerContentContainer">共用封闭原则: </span></span><ul><li><span class="name"><span class="innerContentContainer">包中的所有类对于同一类性质的变化应该是共同封闭的。</span></span></li><li><span class="name"><span class="innerContentContainer">一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">共同重用原则: 一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中所有类。</span></span></li><li><span class="name"><span class="innerContentContainer">稳定依赖原则: 朝着稳定的方向进行依赖。</span></span></li><li><span class="name"><span class="innerContentContainer">稳定抽象原则: 包的抽象程度应该和其稳定程度一致。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>23种常见设计模式</b></span></span><ul><li><span class="name"><span class="innerContentContainer">1995 年，GoF（Gang of Four，四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。</span></span></li><li><span class="name"><span class="innerContentContainer">根据目的对这23种模式进行分类, 如下:</span></span></li><li><span class="name"><span class="innerContentContainer">创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。</span></span><ul><li><span class="name"><span class="innerContentContainer">单例</span></span><ul><li><span class="name"><span class="innerContentContainer">Singleton</span></span></li><li><span class="name"><span class="innerContentContainer">某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">原型</span></span><ul><li><span class="name"><span class="innerContentContainer">Prototype</span></span></li><li><span class="name"><span class="innerContentContainer">将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工厂方法：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Factory Method</span></span></li><li><span class="name"><span class="innerContentContainer">定义一个用于创建产品的接口，由子类决定生产什么产品。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抽象工厂</span></span><ul><li><span class="name"><span class="innerContentContainer">Abstract Factory</span></span></li><li><span class="name"><span class="innerContentContainer">提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">建造者</span></span><ul><li><span class="name"><span class="innerContentContainer">Builder</span></span></li><li><span class="name"><span class="innerContentContainer">将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">构型模式：用于描述如何将类或对象按某种布局组成更大的结构.</span></span><ul><li><span class="name"><span class="innerContentContainer">代理</span></span><ul><li><span class="name"><span class="innerContentContainer">Proxy</span></span></li><li><span class="name"><span class="innerContentContainer">为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">适配器：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Adapter</span></span></li><li><span class="name"><span class="innerContentContainer">将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">桥接</span></span><ul><li><span class="name"><span class="innerContentContainer">Bridge</span></span></li><li><span class="name"><span class="innerContentContainer">将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">装饰</span></span><ul><li><span class="name"><span class="innerContentContainer">Decorator</span></span></li><li><span class="name"><span class="innerContentContainer">动态的给对象增加一些职责，即增加其额外的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">外观</span></span><ul><li><span class="name"><span class="innerContentContainer">Facade</span></span></li><li><span class="name"><span class="innerContentContainer">为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">享元</span></span><ul><li><span class="name"><span class="innerContentContainer">Flyweight</span></span></li><li><span class="name"><span class="innerContentContainer">运用共享技术来有效地支持大量细粒度对象的复用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">组合</span></span><ul><li><span class="name"><span class="innerContentContainer">Composite</span></span></li><li><span class="name"><span class="innerContentContainer">将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</span></span><ul><li><span class="name"><span class="innerContentContainer">模板方法：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Template Method</span></span></li><li><span class="name"><span class="innerContentContainer">定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">策略</span></span><ul><li><span class="name"><span class="innerContentContainer">Strategy</span></span></li><li><span class="name"><span class="innerContentContainer">定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">命令</span></span><ul><li><span class="name"><span class="innerContentContainer">Command</span></span></li><li><span class="name"><span class="innerContentContainer">将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">职责链</span></span><ul><li><span class="name"><span class="innerContentContainer">Chain of Responsibility</span></span></li><li><span class="name"><span class="innerContentContainer">把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">状态</span></span><ul><li><span class="name"><span class="innerContentContainer">State</span></span></li><li><span class="name"><span class="innerContentContainer">允许一个对象在其内部状态发生改变时改变其行为能力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">观察者</span></span><ul><li><span class="name"><span class="innerContentContainer">Observer</span></span></li><li><span class="name"><span class="innerContentContainer">多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中介者</span></span><ul><li><span class="name"><span class="innerContentContainer">Mediator</span></span></li><li><span class="name"><span class="innerContentContainer">定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">迭代器</span></span><ul><li><span class="name"><span class="innerContentContainer">Iterator</span></span></li><li><span class="name"><span class="innerContentContainer">提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">访问者</span></span><ul><li><span class="name"><span class="innerContentContainer">Visitor</span></span></li><li><span class="name"><span class="innerContentContainer">在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">备忘录</span></span><ul><li><span class="name"><span class="innerContentContainer">Memento</span></span></li><li><span class="name"><span class="innerContentContainer">在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">解释器：类模式。</span></span><ul><li><span class="name"><span class="innerContentContainer">Interpreter</span></span></li><li><span class="name"><span class="innerContentContainer">提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用场景</span></span></li><li><span class="name"><span class="innerContentContainer">单例模式</span></span></li><li><span class="name"><span class="innerContentContainer">责任链模式</span></span></li><li><span class="name"><span class="innerContentContainer">MVC模式-史前的模式</span></span><ul><li><span class="name"><span class="innerContentContainer">Model : Hold Your Application’s Data</span></span><ul><li><span class="name"><span class="innerContentContainer">通常可以理解为数据模型及其算法, 负责执行程序的核心运算与判断逻辑.</span></span></li><li><span class="name"><span class="innerContentContainer">通过 view获得用户 输入的数据,</span></span></li><li><span class="name"><span class="innerContentContainer">然后根据从数据库查询相关的信息,</span></span></li><li><span class="name"><span class="innerContentContainer">最后进行运算和判断, 将得到的结果交给 view来显示.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Controller: Binds the model and view together and is the application logic;&nbsp;Decides How to Handle the Users Inputs。</span></span><ul><li><span class="name"><span class="innerContentContainer">控制器,作为 model与 view之间的枢纽, 负责控制程序的执行流程以及对象之间的互动.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">View: the user can see&nbsp; and interact with it.</span></span><ul><li><span class="name"><span class="innerContentContainer">用户的操作接口, 就是 GUI,应该使用哪种接口组件,组件间的排列位置与顺序都需要设计.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">IOC</span></span></li><li><span class="name"><span class="innerContentContainer">AOP</span></span></li><li><span class="name"><span class="innerContentContainer">微服务思想</span></span><ul><li><span class="name"><span class="innerContentContainer">康威定律</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">UML</span></span><ul><li><span class="name"><span class="innerContentContainer">统一建模语言（Unified Modeling Language，UML）是用来做软件设计的可视化建模语言.</span></span></li><li><span class="name"><span class="innerContentContainer">1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。</span></span></li><li><span class="name"><span class="innerContentContainer">它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</span></span></li><li><span class="name"><span class="innerContentContainer">类图</span></span><ul><li><span class="name"><span class="innerContentContainer">类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。</span></span></li><li><span class="name"><span class="innerContentContainer">类使用包含类名、属性和操作且带有分隔线的矩形来表示。包括如下元素：</span></span></li><li><span class="name"><span class="innerContentContainer">类名（Name）是一个字符串，例如，Student。</span></span></li><li><span class="name"><span class="innerContentContainer">属性（Attribute）是指类的特性，即类的成员变量。格式如下：[可见性]属性名:类型[=默认值]</span></span><ul><li><span class="name"><span class="innerContentContainer">可见性：表示该属性对类外的元素是否可见</span></span><ul><li><span class="name"><span class="innerContentContainer">+ 公有</span></span></li><li><span class="name"><span class="innerContentContainer">- 私有</span></span></li><li><span class="name"><span class="innerContentContainer"># 受保护</span></span></li><li><span class="name"><span class="innerContentContainer">~ 朋友</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例如：-name:String</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。格式如下：[可见性]名称(参数列表)[:返回类型]</span></span></li><li><span class="name"><span class="innerContentContainer">例如：+display():void。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接口：接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。</span></span><ul><li><span class="name"><span class="innerContentContainer">它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。</span></span></li><li><span class="name"><span class="innerContentContainer">接口使用一个带有名称的小圆圈来进行表示。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">类之间的关系</span></span><ul><li><span class="name"><span class="innerContentContainer">继承关系，is-a，空心三角剪头，实线，指向父类</span></span><ul><li><span class="name"><span class="innerContentContainer">也叫泛化（Generalization）关系。继承是对象之间耦合度最大的一种关系，是 is-a 的关系。</span></span></li><li><span class="name"><span class="innerContentContainer">泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关联关系，has-a，即包含关系，普通剪头，实线，指向被包含方</span></span><ul><li><span class="name"><span class="innerContentContainer">关联关系指一个类的对象作为另一个类的成员变量 这种情况。</span></span></li><li><span class="name"><span class="innerContentContainer">单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。</span></span></li><li><span class="name"><span class="innerContentContainer">双向的关联可以用带两个箭头或者没有箭头的实线来表示。</span></span></li><li><span class="name"><span class="innerContentContainer">也可以在关联线的两端标注角色名，代表两种不同的角色。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">聚合关系，尾部空心菱形剪头，实线，指向被包含的类</span></span><ul><li><span class="name"><span class="innerContentContainer">聚合（Aggregation）关系是强的关联关系，是整体和部分之间的关系。</span></span></li><li><span class="name"><span class="innerContentContainer">聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</span></span></li><li><span class="name"><span class="innerContentContainer">在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">组合关系，尾部实心菱形剪头，实线，指向被包含的类</span></span><ul><li><span class="name"><span class="innerContentContainer">组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种最强的聚合关系，是 contains-a 关系。</span></span></li><li><span class="name"><span class="innerContentContainer">在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，头和嘴的关系，没有了头，嘴也就不存在了。</span></span></li><li><span class="name"><span class="innerContentContainer">在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意，组合关系和聚合关系在一些场景下不分，都按 聚合关系 算。</span></span></li><li><span class="name"><span class="innerContentContainer">依赖关系，use-a，调用关系，普通剪头，虚线，指向被调用方</span></span><ul><li><span class="name"><span class="innerContentContainer">依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。</span></span></li><li><span class="name"><span class="innerContentContainer">在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</span></span></li><li><span class="name"><span class="innerContentContainer">依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">实现关系，接口和实现之间，空心三角剪头，虚线，指向接口</span></span><ul><li><span class="name"><span class="innerContentContainer">实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</span></span></li><li><span class="name"><span class="innerContentContainer">在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">分布式设计</span></span><ul><li><span class="name"><span class="innerContentContainer">扩展性设计</span></span></li><li><span class="name"><span class="innerContentContainer">稳定性 &amp; 高可用</span></span><ul><li><span class="name"><span class="innerContentContainer">硬件负载均衡</span></span></li><li><span class="name"><span class="innerContentContainer">软件负载均衡</span></span></li><li><span class="name"><span class="innerContentContainer">限流</span></span></li><li><span class="name"><span class="innerContentContainer">应用层容灾</span></span></li><li><span class="name"><span class="innerContentContainer">跨机房容灾</span></span></li><li><span class="name"><span class="innerContentContainer">容灾演练流程</span></span></li><li><span class="name"><span class="innerContentContainer">平滑启动</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库扩展</span></span><ul><li><span class="name"><span class="innerContentContainer">读写分离模式</span></span></li><li><span class="name"><span class="innerContentContainer">分片模式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务治理</span></span><ul><li><span class="name"><span class="innerContentContainer">服务注册与发现</span></span></li><li><span class="name"><span class="innerContentContainer">服务路由控制</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分布式一致</span></span><ul><li><span class="name"><span class="innerContentContainer">CAP 与 BASE 理论</span></span></li><li><span class="name"><span class="innerContentContainer">分布式锁</span></span></li><li><span class="name"><span class="innerContentContainer">分布式一致性算法</span></span><ul><li><span class="name"><span class="innerContentContainer">PAXOS</span></span></li><li><span class="name"><span class="innerContentContainer">Zab</span></span></li><li><span class="name"><span class="innerContentContainer">Raft</span></span></li><li><span class="name"><span class="innerContentContainer">Gossip</span></span></li><li><span class="name"><span class="innerContentContainer">两阶段提交、多阶段提交</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">幂等</span></span></li><li><span class="name"><span class="innerContentContainer">分布式一致方案</span></span></li><li><span class="name"><span class="innerContentContainer">分布式 Leader 节点选举</span></span></li><li><span class="name"><span class="innerContentContainer">TCC(Try/Confirm/Cancel) 柔性事务</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分布式文件系统</span></span></li><li><span class="name"><span class="innerContentContainer">唯一ID 生成</span></span><ul><li><span class="name"><span class="innerContentContainer">全局唯一ID</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致性Hash算法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DevOps</span></span><ul><li><span class="name"><span class="innerContentContainer">Code + Operate 合一; </span></span></li><li><span class="name"><span class="innerContentContainer">Test + Deploy 高度自动化, 由一两个人负责, 并加入Code组.</span></span></li><li><span class="name"><span class="innerContentContainer">最彻底的方式是, Test + Deploy 由研发工程师轮流值日.</span></span></li><li><span class="name"><span class="innerContentContainer">Code + Test + Deploy + Operate, 四种角色, 使用统一的平台, 工具和质量体系.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">性能</span></span><ul><li><span class="name"><span class="innerContentContainer">性能优化方法论</span></span></li><li><span class="name"><span class="innerContentContainer">容量评估</span></span></li><li><span class="name"><span class="innerContentContainer">CDN 网络</span></span></li><li><span class="name"><span class="innerContentContainer">连接池</span></span></li><li><span class="name"><span class="innerContentContainer">性能调优</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">并发</span></span><ul><li><span class="name"><span class="innerContentContainer">多线程</span></span><ul><li><span class="name"><span class="innerContentContainer">缺点</span></span><ul><li><span class="name"><span class="innerContentContainer">线程安全：由于统一进程下的多个线程是共享同样的地址空间和数据的，又由于线程执行顺序的不可预知性，一个线程可能会修改其他线程正在使用的变量，这一方面是给数据共享带来了便利；另一方面，如果处理不当，会产生脏读，幻读等问题，好在Java提供了一系列的同步机制来帮助解决这一问题，例如内置锁。</span></span></li><li><span class="name"><span class="innerContentContainer">活跃性问题。可能会发生长时间的等待锁，甚至是死锁。</span></span></li><li><span class="name"><span class="innerContentContainer">性能问题。 线程的频繁调度切换会浪费资源，同步机制会导致内存缓冲区的数据无效，以及增加同步流量。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">线程安全</span></span><ul><li><span class="name"><span class="innerContentContainer">定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，则称这个类时线程安全的。线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</span></span></li><li><span class="name"><span class="innerContentContainer">线程安全产生的原因：正确性取决于多个线程的交替执行时序，产生了竞态条件。</span></span></li><li><span class="name"><span class="innerContentContainer">原子类： 应尽量使用原子类，这样会让你分析线程安全时更加方便，但需要注意的是用线程安全类构建的类并不能保证线程安全。例如，一个AtomicInteger get() 和&nbsp;AtomicInteger set() 是线程安全的，在一个类的一个方法 f()中同时用到了这两个方法，此时的f()就是线程不安全的，因为你不能保证这个复合操作中的get 和 set同时更新。</span></span></li><li><span class="name"><span class="innerContentContainer">达到线程安全的措施</span></span><ul><li><span class="name"><span class="innerContentContainer">加锁</span></span><ul><li><span class="name"><span class="innerContentContainer">锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。</span></span></li><li><span class="name"><span class="innerContentContainer">加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。</span></span></li><li><span class="name"><span class="innerContentContainer">加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不共享状态</span></span><ul><li><span class="name"><span class="innerContentContainer">无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。</span></span></li><li><span class="name"><span class="innerContentContainer">线程关闭： 仅在单线程环境下使用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不可变对象</span></span><ul><li><span class="name"><span class="innerContentContainer">可以使用 final 修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">充分挖掘多核性能资源  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">CPU由单核变成多核，理想情况是代码不改动，软件性能可以线性增长。</span></span></li><li><span class="name"><span class="innerContentContainer">多核性能优化涉及的元素包括：OS、编程语言、平台、软件。</span></span></li><li><span class="name"><span class="innerContentContainer">主流架构是SMP（对称多核），目标是代码不动，通过编译器优化指令流，达到平滑过渡。</span></span></li><li><span class="name"><span class="innerContentContainer">linux具有SMP能力，而c/c++不支持，需要用多线程库来重新实现。</span></span></li><li><span class="name"><span class="innerContentContainer">java等基于虚拟机；python、Ruby等动态语言；erlang函数式语言，在SMP方面较之c/c++都有天然的优势。</span></span></li><li><span class="name"><span class="innerContentContainer">另一个架构是AMP（非对称多核），即每个核跑一个OS，OS上再跑多个应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致性、事务</span></span><ul><li><span class="name"><span class="innerContentContainer">事务是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）</span></span></li><li><span class="name"><span class="innerContentContainer">事务的 ACID 特性</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库管理系统中事务(transaction)的四个特性：</span></span><ul><li><span class="name"><span class="innerContentContainer">原子性（Atomicity）</span></span><ul><li><span class="name"><span class="innerContentContainer">原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。可采用“A向B转账”这个例子来说明.</span></span></li><li><span class="name"><span class="innerContentContainer">在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致性（Consistency）</span></span><ul><li><span class="name"><span class="innerContentContainer">一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</span></span></li><li><span class="name"><span class="innerContentContainer">如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</span></span></li><li><span class="name"><span class="innerContentContainer">保障机制：</span></span><ul><li><span class="name"><span class="innerContentContainer">业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</span></span></li><li><span class="name"><span class="innerContentContainer">数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；</span></span></li><li><span class="name"><span class="innerContentContainer">数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">隔离性（Isolation）</span></span><ul><li><span class="name"><span class="innerContentContainer">多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</span></span></li><li><span class="name"><span class="innerContentContainer">在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">持久性（Durability）</span></span><ul><li><span class="name"><span class="innerContentContainer">持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）</span></span></li><li><span class="name"><span class="innerContentContainer">write ahead logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事务的隔离级别</span></span><ul><li><span class="name"><span class="innerContentContainer">未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</span></span></li><li><span class="name"><span class="innerContentContainer">读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</span></span></li><li><span class="name"><span class="innerContentContainer">可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</span></span></li><li><span class="name"><span class="innerContentContainer">序列化：所有事物串行处理（牺牲了效率）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MVCC</span></span><ul><li><span class="name"><span class="innerContentContainer">MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能.</span></span></li><li><span class="name"><span class="innerContentContainer">读锁：也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</span></span></li><li><span class="name"><span class="innerContentContainer">写锁：又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</span></span></li><li><span class="name"><span class="innerContentContainer">表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</span></span></li><li><span class="name"><span class="innerContentContainer">行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</span></span></li><li><span class="name"><span class="innerContentContainer">MVCC 会产生幻读问题（更新时异常）.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">锁</span></span><ul><li><span class="name"><span class="innerContentContainer">Java中的锁和同步类</span></span></li><li><span class="name"><span class="innerContentContainer">公平锁 &amp; 非公平锁</span></span></li><li><span class="name"><span class="innerContentContainer">悲观锁</span></span></li><li><span class="name"><span class="innerContentContainer">乐观锁 &amp; CAS</span></span></li><li><span class="name"><span class="innerContentContainer">ABA 问题</span></span></li><li><span class="name"><span class="innerContentContainer">CopyOnWrite容器</span></span></li><li><span class="name"><span class="innerContentContainer">RingBuffer</span></span></li><li><span class="name"><span class="innerContentContainer">可重入锁 &amp; 不可重入锁</span></span></li><li><span class="name"><span class="innerContentContainer">互斥锁 &amp; 共享锁</span></span></li><li><span class="name"><span class="innerContentContainer">死锁</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">软件工程</span></span><ul><li><span class="name"><span class="innerContentContainer">代码规范</span></span><ul><li><span class="name"><span class="innerContentContainer">代码文件头注释</span></span><ul><li><span class="name"><span class="innerContentContainer">/*******************************************************************</span></span><ul><li><span class="name"><span class="innerContentContainer">*Copyright(C),&nbsp;Your&nbsp;Company</span></span></li><li><span class="name"><span class="innerContentContainer">*FileName:&nbsp;文件名</span></span></li><li><span class="name"><span class="innerContentContainer">*Author: 作者</span></span></li><li><span class="name"><span class="innerContentContainer">*Version: 版本</span></span></li><li><span class="name"><span class="innerContentContainer">*Date: 完成日期</span></span></li><li><span class="name"><span class="innerContentContainer">*Description:&nbsp; 用于主要说明此程序文件完成的主要功能</span></span><ul><li><span class="name"><span class="innerContentContainer">与其他模块或函数的接口、输出值、取值范围、</span></span><ul><li><span class="name"><span class="innerContentContainer">含义及参数间的控制、顺序、独立及依赖关系</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">*Others:</span></span></li><li><span class="name"><span class="innerContentContainer">*History:&nbsp; 修改历史记录列表，每条修改记录应包含修改日期、修改者及修改内容简介</span></span><ul><li><span class="name"><span class="innerContentContainer">1.&nbsp;2020-1-4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duangan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Init.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">******************************************************************/</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">瀑布模型</span></span></li><li><span class="name"><span class="innerContentContainer">IPD流程</span></span><ul><li><span class="name"><span class="innerContentContainer">tr1: 需求基线。tr1后需求就要处在变更控制下。</span></span></li><li><span class="name"><span class="innerContentContainer">charter: 任务书。</span></span></li><li><span class="name"><span class="innerContentContainer">CDCP: 概念决策评审点。概念阶段完成。</span></span></li><li><span class="name"><span class="innerContentContainer">tr2: 功能基线。确定产品规格需求。</span></span></li><li><span class="name"><span class="innerContentContainer">tr3</span></span><ul><li><span class="name"><span class="innerContentContainer">分配基线。</span></span></li><li><span class="name"><span class="innerContentContainer">入口条件完成SRS。</span></span></li><li><span class="name"><span class="innerContentContainer">此时软件开始投入，t0单板到位，底层开始调试点亮t0单板。</span></span></li><li><span class="name"><span class="innerContentContainer">第一阶段最大的风险点是T1烧片。T1（V3）大约tr3之后的一个月.</span></span></li><li><span class="name"><span class="innerContentContainer">t1烧片</span></span><ul><li><span class="name"><span class="innerContentContainer">等t0单板调通，最重要是装备和射频启动投入，开始为t1烧片和产线试制准备。</span></span></li><li><span class="name"><span class="innerContentContainer">t1烧片要求最主要的频段要可以CBT、升级、nv备份恢复等关键功能能通，经过裁剪的MMI、经过裁剪的产线流程要ok。</span></span></li><li><span class="name"><span class="innerContentContainer">t1烧片版本只转测试给硬测。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">PICP: 计划决策评审点，计划阶段完成。</span></span></li><li><span class="name"><span class="innerContentContainer">tr4</span></span><ul><li><span class="name"><span class="innerContentContainer">交付基线。软件模块工作完成，联调完成。</span></span></li><li><span class="name"><span class="innerContentContainer">注意: HLD/LLC/Coding/UT/ST/BBIT都发生在tr3到tr4之间。</span></span></li><li><span class="name"><span class="innerContentContainer">tr4前会出第一个正式转测试版本，软测团队开始介入；</span></span></li><li><span class="name"><span class="innerContentContainer">定价和配置器启动。</span></span></li><li><span class="name"><span class="innerContentContainer">软件经理要关注国家入网测试、认证测试、运营商准入测试送测时间点。</span></span></li><li><span class="name"><span class="innerContentContainer">试制 T2（V4）和tr4同时. </span></span></li><li><span class="name"><span class="innerContentContainer">tr4的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">无致命问题。</span></span></li><li><span class="name"><span class="innerContentContainer">软件遗漏缺陷密度：目标是35，下限27，上限43；单位是“个/千行”。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tr4a</span></span><ul><li><span class="name"><span class="innerContentContainer">系统设计验证/SDV。</span></span></li><li><span class="name"><span class="innerContentContainer">系统测试完成，性能测试ok。</span></span></li><li><span class="name"><span class="innerContentContainer">tr4a后，软件稳定度达到一定水平，开始检查软件APR。</span></span></li><li><span class="name"><span class="innerContentContainer">BOM发布，并开始首次爬坡（大致时间）；</span></span></li><li><span class="name"><span class="innerContentContainer">批量物料采购，部分达到；</span></span></li><li><span class="name"><span class="innerContentContainer">资料开发完成；</span></span></li><li><span class="name"><span class="innerContentContainer">销售模型完成。</span></span></li><li><span class="name"><span class="innerContentContainer">试制PP1（VN1, 小批量，硬件设计固化））在tr4a之后.</span></span></li><li><span class="name"><span class="innerContentContainer">tr4a的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">内部问题单解决率85%;</span></span></li><li><span class="name"><span class="innerContentContainer">严重问题少于15个。</span></span></li><li><span class="name"><span class="innerContentContainer">底层软件的质量如果不能在tr4a之前稳定下来，产品的风险就比较大了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tr5</span></span><ul><li><span class="name"><span class="innerContentContainer">产品基线。</span></span></li><li><span class="name"><span class="innerContentContainer">此时有个活动，即beta test。</span></span></li><li><span class="name"><span class="innerContentContainer">内部测试完成；</span></span></li><li><span class="name"><span class="innerContentContainer">可少量早期发货。</span></span></li><li><span class="name"><span class="innerContentContainer">tr5的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">软件DI&lt;40</span></span><ul><li><span class="name"><span class="innerContentContainer">DI值的计算方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">致命问题10</span></span></li><li><span class="name"><span class="innerContentContainer">严重问题3</span></span></li><li><span class="name"><span class="innerContentContainer">一般问题1</span></span></li><li><span class="name"><span class="innerContentContainer">提示问题0.1</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">严重问题DI&lt;12。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tr6</span></span><ul><li><span class="name"><span class="innerContentContainer">发布基线。</span></span></li><li><span class="name"><span class="innerContentContainer">过了tr6，产品就转维护。</span></span></li><li><span class="name"><span class="innerContentContainer">试制PP2（VN2, 第二次小批量）应在tr6之前完成。</span></span></li><li><span class="name"><span class="innerContentContainer">试制LV=Line Verification, EMS量产确认。和tr6同时进行. LV之后一般还有两次试制:</span></span><ul><li><span class="name"><span class="innerContentContainer">RU=Ramp UP，爬坡</span></span></li><li><span class="name"><span class="innerContentContainer"> MP=Mass Production, 量产</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tr6的出口条件</span></span><ul><li><span class="name"><span class="innerContentContainer">总DI&lt;30;</span></span></li><li><span class="name"><span class="innerContentContainer">严重问题DI=0</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">各tr点间的周期</span></span><ul><li><span class="name"><span class="innerContentContainer">总时间:</span></span><ul><li><span class="name"><span class="innerContentContainer">A类项目charter后190天发货；</span></span></li><li><span class="name"><span class="innerContentContainer">B类项目时150天发货。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tr3-tr4，一般2个月；</span></span></li><li><span class="name"><span class="innerContentContainer">tr4-tr4a，一般1.5-2个月；</span></span></li><li><span class="name"><span class="innerContentContainer">tr4a-tr5，两周；</span></span></li><li><span class="name"><span class="innerContentContainer">tr5-tr6，两-三周。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">试制的大致周期</span></span><ul><li><span class="name"><span class="innerContentContainer">每次试制间隔时间大约在1个月，不能少于20天，因为投板周期一般在两周左右。</span></span></li><li><span class="name"><span class="innerContentContainer">新产品投板次数不超过4次，非新产品一般2-3次。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">敏捷开发</span></span><ul><li><span class="name"><span class="innerContentContainer">敏捷宣言</span></span><ul><li><span class="name"><span class="innerContentContainer">2001年敏捷宣言发布。</span></span></li><li><span class="name"><span class="innerContentContainer">签字的人中有顶级程序员：Kent Beck, Robert C.Mortin, Marin Fowler。</span></span></li><li><span class="name"><span class="innerContentContainer">内容包括：</span></span></li><li><span class="name"><span class="innerContentContainer">个体和交互 胜过 过程和工具</span></span></li><li><span class="name"><span class="innerContentContainer">可以工作的软件 胜过 面面俱到的文档</span></span></li><li><span class="name"><span class="innerContentContainer">客户合作 胜过 合同谈判</span></span></li><li><span class="name"><span class="innerContentContainer">响应变化 胜过 遵循计划</span></span></li><li><span class="name"><span class="innerContentContainer">虽然右项也具有价值，但我们认为左项具有更大的价值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">敏捷可解决什么问题？变化。</span></span></li><li><span class="name"><span class="innerContentContainer">变化从哪里来？数据（DOD）显示，初期提出的45%的需求没有用。</span></span></li><li><span class="name"><span class="innerContentContainer">敏捷是帮助发现问题的，不是解决问题。敏捷的本质是尽早暴露问题，以便修正。</span></span></li><li><span class="name"><span class="innerContentContainer">软件系统的内在规律</span></span><ul><li><span class="name"><span class="innerContentContainer">复杂性几乎无法归约。系统不可能一蹴而就，人类在复杂系统前只能渐进迭代思考；</span></span></li><li><span class="name"><span class="innerContentContainer">软件缺陷有极大的相关性，如果不及时清理，就会指数级上升。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">敏捷经济学</span></span><ul><li><span class="name"><span class="innerContentContainer">争取每时每刻都在做最有价值的事情，低价值的事情要往后放、往下砍。</span></span></li><li><span class="name"><span class="innerContentContainer">小步快跑，每一步都做价值判断，减少风险成本。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>敏捷运动的两个具体实现是 SCRUM 和 XP</b></span></span></li><li><span class="name"><span class="innerContentContainer">SCRUM</span></span></li><li><span class="name"><span class="innerContentContainer">极限编程（XP）</span></span><ul><li><span class="name"><span class="innerContentContainer">完整团队</span></span><ul><li><span class="name"><span class="innerContentContainer">项目的所有参与者（开发人员、业务分析师、测试人员等等）一起工作在一个开放的场所中，他们是同一个团队的成员。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">计划游戏</span></span><ul><li><span class="name"><span class="innerContentContainer">计划是持续的，循序渐进的。</span></span></li><li><span class="name"><span class="innerContentContainer">每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。</span></span></li><li><span class="name"><span class="innerContentContainer">2-3周为一个周期；</span></span></li><li><span class="name"><span class="innerContentContainer">第一天确定了需求就可以编码；</span></span></li><li><span class="name"><span class="innerContentContainer">各个阶段并行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">客户测试</span></span><ul><li><span class="name"><span class="innerContentContainer">作为选择每个所期望的特性的一部分，客户定义出自动验收测试来表明该特性可以工作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">简单设计, user story</span></span><ul><li><span class="name"><span class="innerContentContainer">团队保持设计恰好和当前的系统功能相匹配，它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">建模的方法：workshop，笔、卡片、面对面。</span></span></li><li><span class="name"><span class="innerContentContainer">设计和实现不可分割。</span></span></li><li><span class="name"><span class="innerContentContainer">user story</span></span><ul><li><span class="name"><span class="innerContentContainer">只描述系统的外在特征。一般的形式是：</span></span><ul><li><span class="name"><span class="innerContentContainer">名称：***</span></span></li><li><span class="name"><span class="innerContentContainer">事件：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 用户做了什么；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 系统做了什么（仅限界面看到的部分）；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 用户又做了什么；</span></span></li><li><span class="name"><span class="innerContentContainer">4. 系统又做了什么</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件需要持续的细化,&nbsp;一直到把内涵说明完毕为止。</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">名称：买饮料</span></span></li><li><span class="name"><span class="innerContentContainer">事件：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 用户投进一些钱；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 售货机显示用户已经投入了多少钱；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 如果钱够，则饮料对应的按钮会亮；</span></span></li><li><span class="name"><span class="innerContentContainer">4. 用户按下某个亮的按钮；</span></span></li><li><span class="name"><span class="innerContentContainer">5. 售货机“吐”出对应的饮料；</span></span></li><li><span class="name"><span class="innerContentContainer">6. 售货机找零给他。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ser story有啥用?</span></span><ul><li><span class="name"><span class="innerContentContainer">主要用来评估工作量，并进一步评估进度和发布时间。</span></span></li><li><span class="name"><span class="innerContentContainer">收集完所有的user story，我们评估最简单的那个，将其设为1点，其它 story 也各有点数。点数是相对的，所以可以很粗糙。</span></span></li><li><span class="name"><span class="innerContentContainer">为了准确的评估点数对应的工作量，一般敏捷团队会用2周时间摸索自己的能力基线。</span></span></li><li><span class="name"><span class="innerContentContainer">两周就是一个相当常见的迭代周期。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发布周期不满足要求怎么办？</span></span><ul><li><span class="name"><span class="innerContentContainer">把一些story弄到下一个发布周期去；</span></span></li><li><span class="name"><span class="innerContentContainer">把一些story分解为多个，用户认为缺不可少的放进来，不是很紧急的放出去。</span></span></li><li><span class="name"><span class="innerContentContainer">后一种较受认可。</span></span></li><li><span class="name"><span class="innerContentContainer">加人更多的人力.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">user story的载体: CRC卡片</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">结对编程</span></span><ul><li><span class="name"><span class="innerContentContainer">所有的产品软件都是由两个程序员，并排坐在一起在同一台电脑上构建的。</span></span></li><li><span class="name"><span class="innerContentContainer">一般经验较少的人负责编码，经验较多的人负责评审。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">测试驱动开发</span></span><ul><li><span class="name"><span class="innerContentContainer">程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。</span></span></li><li><span class="name"><span class="innerContentContainer">不实施TDD，持续集成就没有效果，进而破坏迭代，导致敏捷化为乌有。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改进设计</span></span><ul><li><span class="name"><span class="innerContentContainer">随时改进糟糕的代码。保持代码尽可能的干净，具有表达力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">持续集成</span></span><ul><li><span class="name"><span class="innerContentContainer">团队总是使系统完整地被集成。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">集体代码所有权</span></span><ul><li><span class="name"><span class="innerContentContainer">任何结对的程序员都可以在任何时候改进任何代码。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">编码标准</span></span><ul><li><span class="name"><span class="innerContentContainer">系统中所有的代码看起来就好像是被单独一个--非常值得胜任的--人编写的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">隐喻</span></span><ul><li><span class="name"><span class="innerContentContainer">团队提出一个程序工作原理的公共景像。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可持续的速度</span></span><ul><li><span class="name"><span class="innerContentContainer">团队只有持久才有获胜的希望，他们以能够长期维持的速度努力工作，他们保存精力，他们把项目看作是马拉松长袍，而不是全速短跑。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;&lt;敏捷软件开发&gt;&gt;读书笔记</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 测试是如何驱动设计，驱动编码，驱动重构的？</span></span><ul><li><span class="name"><span class="innerContentContainer">看第6章，一个好例子。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 软件可以分为哪几个层面？三个层面：</span></span><ul><li><span class="name"><span class="innerContentContainer">“外衣”，即人机接口；所有用户可以看见的部分（性能也能“看”见，但是不算外衣吧）。</span></span><ul><li><span class="name"><span class="innerContentContainer">这部分本来应该比逻辑层更“软”，但是很不幸，现代操作系统和软件平台（指java或类似的东西）的发展，导致这部分完全不受程序员控制，也就是说，一旦选定操作系统和软件平台，如何使用界面元素就定死了，必须按它的游戏规则玩。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">逻辑层，不属于第一层和第三层的其它的一切，包括业务逻辑，安全性，性能，并发，日志等。</span></span></li><li><span class="name"><span class="innerContentContainer">基础设施，包括硬件、操作系统、文件系统、数据库、编译器和库，也就是说，所有在你的流程中不可能更改的那些部分。除了按它们的游戏规则玩别无他法。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，我这里不是指硬件、操作系统、数据库本身，这些东西也不需要你去做测试。我指的是，你的软件对这些东西的封装那一层逻辑，即软件和这些基础设施的接口层。</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有这个接口层，逻辑层直接访问基础设施，那么整个代码就无法ut了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. “外衣”层如何 ut？</span></span><ul><li><span class="name"><span class="innerContentContainer">目前可以说，不能，只有系统测试，或者说是验收测试。为什么，因为这部分不受程序员左右，纯粹是os和平台厂商的舞台，而他们一般都是最慢的一群人。</span></span></li><li><span class="name"><span class="innerContentContainer">好的测试框架，比如google的 monkey。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 逻辑层，此为ut的绝大部分领域。</span></span><ul><li><span class="name"><span class="innerContentContainer">泛观众敏捷、TDD、重构书，这个是没有说出口的秘密。</span></span></li><li><span class="name"><span class="innerContentContainer">明白这一点，就知道把大师的宏论落地，真是我纭纭众生的苦差事啊。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 基础设施层。其实也是要ut 的，但方法还处在不靠谱阶段。</span></span><ul><li><span class="name"><span class="innerContentContainer">目前这部分ut 的办法是Mock Object模式。即打桩。创建合适的桩类，传给需要ut 的对象，然后测之。</span></span></li><li><span class="name"><span class="innerContentContainer">桩函数要特别简单，绝大部分直接返回ok、fail即可（否则成本就太高了）。但是往往从桩类的设计中，可以得出构架层面的设计，比如要不要分层，分为几层，是否有特定硬件的依赖，要不要使用xml，要不要支持多线程等等。</span></span></li><li><span class="name"><span class="innerContentContainer">是的，我们找到银弹了。我们是特别幸运的一代人。---没有任何讽刺之意。原因详见第八条。我恨不得马上解释一下，但是后面还有一个强有力的观点要表达，所以不得不推迟一点）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7.  这里所说的测试，包括非自动化测试吗？</span></span><ul><li><span class="name"><span class="innerContentContainer">不包括。所有的非自动化测试，都不是测试。因为它们收不到驱动设计、驱动编码、驱动重构的益处。</span></span></li><li><span class="name"><span class="innerContentContainer">非自动化测试，可以称之为绝望的呐喊。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 测试为什么可以驱动设计，驱动编码，驱动重构的？---关于这个问题的心理学解释</span></span><ul><li><span class="name"><span class="innerContentContainer">软件，涉及3个角色，用户，程序员，电脑。程序员负责把用户的需求“翻译”给电脑“听”。</span></span></li><li><span class="name"><span class="innerContentContainer">之前的软件过程（我是指ut之前），认为最大的问题是程序员没听懂用户的话，导致“翻译”失败。他们认为之所以有那么多的软件失败，是因为程序员都太geek了。</span></span></li><li><span class="name"><span class="innerContentContainer">但这不是真的。用户和程序员都是人，人与人沟通其实没那么难，尤其是在用户给程序员发工资的情况下。</span></span></li><li><span class="name"><span class="innerContentContainer">问题其实出在程序员到电脑这个阶段的沟通失败。</span></span></li><li><span class="name"><span class="innerContentContainer">从人脑角度看需求的物件特别多了，比如需求文档，设计文档，验收测试，原型，uml，结构图，数据流图等等，甚至会议也算。（因为大家都觉得这块是问题嘛，所以拼命发明新东西，从不同角度来考验它。）</span></span></li><li><span class="name"><span class="innerContentContainer">但是，从电脑角度看需求的物件只有一个，就是代码。</span></span></li><li><span class="name"><span class="innerContentContainer">凡是只有一个的地方，最容易出问题，最容易掩盖问题。独木难支啊。</span></span></li><li><span class="name"><span class="innerContentContainer">ut，是另一个从电脑角度看需求的物件。</span></span></li><li><span class="name"><span class="innerContentContainer">将来，可能还会发明很多从电脑角度看需求的物件来，但是目前，ut是唯一的第二个。</span></span></li><li><span class="name"><span class="innerContentContainer">因此，用好了，它能改变一切。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 编码即重构</span></span><ul><li><span class="name"><span class="innerContentContainer">重构并不是有了一堆代码后重新整理它的过程。</span></span></li><li><span class="name"><span class="innerContentContainer">你写下第一行代码的过程也叫重构。那时你重构的是空白代码。c程序员应该能理解我在说什么。世间万物，从0开始，是我们的哲学。</span></span></li><li><span class="name"><span class="innerContentContainer">并不存在一个重构之外的编码阶段。重构和编码过程完全重合，两者等义。</span></span></li><li><span class="name"><span class="innerContentContainer">有人会问，那我现在到底是在重构，还是在编码？</span></span></li><li><span class="name"><span class="innerContentContainer">你会问你的父亲，“到底是该叫你父亲，还是该叫你爸爸？”吗？</span></span></li><li><span class="name"><span class="innerContentContainer">如果你已经在重构了，那这番话就直接pass掉吧。我想告知的是那些无限期的拖延重构、一直到项目结束的人们。你们并不是如同想象的那样在拖延一件可有可无的叫重构的事，其实你已经在重构了，已经在糟糕的重构了，而且越来越糟。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统工程与项目管理的区别</span></span><ul><li><span class="name"><span class="innerContentContainer">前者：设计质量决定系统质量；后者：软件生命周期</span></span></li><li><span class="name"><span class="innerContentContainer">前者：信息隐藏；后者：清晰的需求管理</span></span></li><li><span class="name"><span class="innerContentContainer">前者：持续集成；后者：测试策略；</span></span></li><li><span class="name"><span class="innerContentContainer">前者：重视复杂度；后者：重视组织成熟度</span></span></li><li><span class="name"><span class="innerContentContainer">前者：成功取决于是否有精于技术的领导；后者：是否有完美的管理流程。</span></span></li><li><span class="name"><span class="innerContentContainer">前者：团队每阶段的自反馈；后者：项目时间点控制</span></span></li><li><span class="name"><span class="innerContentContainer">前者：设计与实现不分离；后者：成本、设计和视野决定成功。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">杜军--编程能力</span></span><ul><li><span class="name"><span class="innerContentContainer">编程能力一定是为某个业务服务的，因此，程序员要想清楚自己希望朝哪个业务领域发展；</span></span></li><li><span class="name"><span class="innerContentContainer">凡是依赖倒置的，都是面向对象的；反之则是面向过程的。</span></span></li><li><span class="name"><span class="innerContentContainer">从编程角度，面向过程即面向编辑器；面向对象，即面向现实世界。</span></span></li><li><span class="name"><span class="innerContentContainer">敏捷唯一指的是软件团队的应变能力。</span></span></li><li><span class="name"><span class="innerContentContainer">简单的代码不等于篇幅简短的代码，也不等于拒绝运用技巧。</span></span></li><li><span class="name"><span class="innerContentContainer">各种度量工具给出的都是工程指标，好的代码至少有一半是无法度量的，只能在需求快速变化中得到检验。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">代码 Review</span></span></li><li><span class="name"><span class="innerContentContainer">RUP</span></span></li><li><span class="name"><span class="innerContentContainer">看板管理</span></span></li><li><span class="name"><span class="innerContentContainer">代码质量度量</span></span><ul><li><span class="name"><span class="innerContentContainer">CC：圈复杂度</span></span><ul><li><span class="name"><span class="innerContentContainer">计算公式为：V(G)=n+1。其中，n表示判定节点的数量，指if...else 和 switch...case分支的数量。</span></span></li><li><span class="name"><span class="innerContentContainer">cyclomatic complexity。是一种代码复杂度的衡量标准。</span></span></li><li><span class="name"><span class="innerContentContainer">业界标准&lt;10，华为无线软件平均是19.82，最大为1274。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Depth：嵌套深度</span></span><ul><li><span class="name"><span class="innerContentContainer">主要指条件及循环嵌套的层次。</span></span></li><li><span class="name"><span class="innerContentContainer">业界标准无此项数据；华为无线软件平均3.66，最大为17。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Fan-out：扇出数</span></span><ul><li><span class="name"><span class="innerContentContainer">指一个函数直接调用其它函数的数目。这个值越小维护性、代码可读性越好。</span></span></li><li><span class="name"><span class="innerContentContainer">业界数据&lt;7，华为无线软件为27.8，最大为2006。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Avg CC/Depth/Fan-out</span></span><ul><li><span class="name"><span class="innerContentContainer">例如：avg CC=sum(CC*state)/sum(state)，state表示代码行数。</span></span></li><li><span class="name"><span class="innerContentContainer">对这三个指标进行加权，权重为每个函数的语句占比.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MI</span></span><ul><li><span class="name"><span class="innerContentContainer">MI指可维护性系数，MI=avg CC + avg depths + avg Fan-out。它是相对值。</span></span></li><li><span class="name"><span class="innerContentContainer">为什么需要MI这个值？</span></span></li><li><span class="name"><span class="innerContentContainer">因为CC、depths、Fan-out这三个指标不能互相替代，各有其代表性。从实践上看，随着版本演进，depths和Fan-out有明显的恶化趋势。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何统计重复代码？</span></span><ul><li><span class="name"><span class="innerContentContainer">simian可以统计。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">重构</span></span></li><li><span class="name"><span class="innerContentContainer">PDCA 循环质量管理</span></span></li><li><span class="name"><span class="innerContentContainer">FMEA管理模式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">web 安全</span></span><ul><li><span class="name"><span class="innerContentContainer">XSS</span></span></li><li><span class="name"><span class="innerContentContainer">CSRF</span></span></li><li><span class="name"><span class="innerContentContainer">SQL 注入</span></span></li><li><span class="name"><span class="innerContentContainer">Hash Dos</span></span></li><li><span class="name"><span class="innerContentContainer">脚本注入</span></span></li><li><span class="name"><span class="innerContentContainer">漏洞扫描工具</span></span></li><li><span class="name"><span class="innerContentContainer">验证码</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DDoS 防范</span></span></li><li><span class="name"><span class="innerContentContainer">用户隐私信息保护</span></span></li><li><span class="name"><span class="innerContentContainer">序列化漏洞</span></span></li><li><span class="name"><span class="innerContentContainer">加密解密</span></span><ul><li><span class="name"><span class="innerContentContainer">对称加密</span></span></li><li><span class="name"><span class="innerContentContainer">哈希算法</span></span></li><li><span class="name"><span class="innerContentContainer">非对称加密</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务器安全</span></span></li><li><span class="name"><span class="innerContentContainer">数据安全</span></span><ul><li><span class="name"><span class="innerContentContainer">数据备份</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络隔离</span></span><ul><li><span class="name"><span class="innerContentContainer">内外网分离</span></span></li><li><span class="name"><span class="innerContentContainer">登录跳板机</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">授权、认证</span></span><ul><li><span class="name"><span class="innerContentContainer">RBAC</span></span></li><li><span class="name"><span class="innerContentContainer">OAuth2.0</span></span></li><li><span class="name"><span class="innerContentContainer">双因素认证（2FA）</span></span></li><li><span class="name"><span class="innerContentContainer">单点登录(SSO)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">测试&amp;运维</span></span><ul><li><span class="name"><span class="innerContentContainer">软件测试</span></span><ul><li><span class="name"><span class="innerContentContainer">FS 模块的UT 代码  <span class="contentTag" title="Filter #TODO">#<span class="contentTagText">TODO</span><span class="contentTagNub"></span></span>  比较经典的UT例子</span></span></li><li><span class="name"><span class="innerContentContainer">用例设计方法  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">白盒测试</span></span><ul><li><span class="name"><span class="innerContentContainer">语句覆盖</span></span></li><li><span class="name"><span class="innerContentContainer">分支覆盖</span></span></li><li><span class="name"><span class="innerContentContainer">条件覆盖</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">黑盒测试</span></span><ul><li><span class="name"><span class="innerContentContainer">等价类方法: 把用例空间划分为若干个集合, 集合内的元素具有统计一致性, 因此只需要测试一个用例即可代表其它所有.</span></span></li><li><span class="name"><span class="innerContentContainer">边界值</span></span></li><li><span class="name"><span class="innerContentContainer">因果图: 用图表示输入的组合关系.</span></span></li><li><span class="name"><span class="innerContentContainer">判定表: 用图标表示输出的组合关系.</span></span></li><li><span class="name"><span class="innerContentContainer">正交实验法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灰盒测试</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用例设计例子 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">测试场景: 登录页面 ，上面有两个输入框：用户名，密码，下面是一个登录按钮。 </span></span></li><li><span class="name"><span class="innerContentContainer">1. 参考依据: 严格按照产品设计规格测试用例</span></span></li><li><span class="name"><span class="innerContentContainer">2. 必答项</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 不同分辨率，样式符合ui设计.</span></span></li><li><span class="name"><span class="innerContentContainer">2. 用户名输入框内容的校验： 空串的提示, 特殊字符，长度 ，超长或换行后ui的显示，校验的时机（失焦或点击登录）.</span></span></li><li><span class="name"><span class="innerContentContainer">3. 密码框的校验：空串的提示, 特殊字符的校验，长度的检验，是否阻止拷贝粘贴, 密码的显示，校验的时机（失焦或点击登录）.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 登录按钮ui展示正常，可以正常点击，点击后的行为符合规格，正常发起登录请求.</span></span></li><li><span class="name"><span class="innerContentContainer">5. 对请求返回的数据正常响应，正常跳转或相关提示符合ui设计(包括正确输入和错误输入).</span></span></li><li><span class="name"><span class="innerContentContainer">6. 输入框回车键后的行为需要统一定义.</span></span></li><li><span class="name"><span class="innerContentContainer">7. 是否保存历史记录.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 加分项</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 使用脚本或其它手段多次点击登录按钮，页面行为无异常</span></span></li><li><span class="name"><span class="innerContentContainer">2. 使用抓包工具查看密码是否加密</span></span></li><li><span class="name"><span class="innerContentContainer">3. 尝试sql注入是否可以绕过校验</span></span></li><li><span class="name"><span class="innerContentContainer">4. 使用moc工具伪造数据回包，是否对页面产生影响</span></span></li><li><span class="name"><span class="innerContentContainer">5. 日志中查看开发是否输出了敏感信息</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TDD 理论</span></span></li><li><span class="name"><span class="innerContentContainer">单元测试, UT</span></span><ul><li><span class="name"><span class="innerContentContainer">UT用例的设计方法</span></span><ul><li><span class="name"><span class="innerContentContainer">规格导出法</span></span><ul><li><span class="name"><span class="innerContentContainer">顾名思义，就是将规格切分为一个个的用例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">等价类法</span></span><ul><li><span class="name"><span class="innerContentContainer">等价类法需要较强的业务能力。</span></span></li><li><span class="name"><span class="innerContentContainer">基于对输入、输出集合中的等价子集; 每个子集只找一个作为用例。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">边界值法</span></span><ul><li><span class="name"><span class="innerContentContainer">这个方法是对等价类法的补充。因为边界最容易出问题。</span></span></li><li><span class="name"><span class="innerContentContainer">边界包括上边界和下边界.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">UT属于白盒测试, 属于研发自验证范畴.</span></span></li><li><span class="name"><span class="innerContentContainer">UT工具</span></span><ul><li><span class="name"><span class="innerContentContainer">单元测试现在已经成为标准的编程实践. 但是UT和编程语言以及业务模型强相关.</span></span></li><li><span class="name"><span class="innerContentContainer">C++缺少Java和.Net平台语言的反射机制，所以无法枚举测试方法，必须手工添加，或者使用一些特别的宏，弄得代码非常难看。</span></span></li><li><span class="name"><span class="innerContentContainer">Java语言单元测试是JUnit的天下.</span></span></li><li><span class="name"><span class="innerContentContainer">C#基本上都用NUnit.</span></span></li><li><span class="name"><span class="innerContentContainer">C++则群花怒放，单元测试框架非常多.</span></span><ul><li><span class="name"><span class="innerContentContainer">推荐 CxxTest和TUT。</span></span></li><li><span class="name"><span class="innerContentContainer">JUnit移植过来的 CppUnit，Boost::test，CppTest，CxxTest， TUT等等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CxxTest</span></span><ul><li><span class="name"><span class="innerContentContainer">无须写额外的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">采用的方法比较特殊，用Perl分析C++的源文件，从中抽取测试方法，创建 TestSuite。</span></span></li><li><span class="name"><span class="innerContentContainer">语法与JUnit非常相似，没有使用高级的C++特性，也没有定义特别的宏.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TUT</span></span><ul><li><span class="name"><span class="innerContentContainer">结构框架简单。添加新的测试工作量小；无须注册测试；可移植性好（因其只需两个头文件，就可以完成测试工作）；便于装卸；提供接口可以扩展其输出方式等。</span></span></li><li><span class="name"><span class="innerContentContainer">最大的优点：轻量级，便于装卸和可扩展其输出方式；</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：断言似乎不是很好，只用了一个ensure()函数，不知道对复杂的测试是否支持；输出的测试结果较为简单。</span></span></li><li><span class="name"><span class="innerContentContainer">TUT利用了高级C++&nbsp;Template功能，必须比较新的编译器才支持，<a class="contentLink" target="_blank" rel="noreferrer" href="http://比如VC6和VS.NET">比如VC6和VS.NET</a>&nbsp;2002就不支持，<a class="contentLink" target="_blank" rel="noreferrer" href="http://必须VS.NET">必须VS.NET</a>&nbsp;2003以上或者Intel C++ Complier 8.1以上。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Boost::test</span></span><ul><li><span class="name"><span class="innerContentContainer">结构框架较为复杂。添加新的测试工作量也不大；提供多种测试方法，可注册测试用例，也可不注册；可移植性一般；装卸不易；在控制异常、崩溃方面的能力胜过其它所有对手；拥有良好的断言功能；大概能支持多种输出方式，但更改输出方式不易；支持测试套件。</span></span></li><li><span class="name"><span class="innerContentContainer">最大的优点：控制异常崩溃的能力、良好的断言、输出结果较为详细、编写测试的方法灵活；</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：结构框架较为复杂，更改输出方式不易，装卸不易。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CXXTest</span></span><ul><li><span class="name"><span class="innerContentContainer">结构框架的复杂性处于TUT与boost::test之间。添加新的测试工作量非常小；无须注册测试用例；可移植性很好；便于装卸；控制异常、崩溃方面的能力也不错；拥有良好的断言功能；支持多种输出方式；支持测试套件。</span></span></li><li><span class="name"><span class="innerContentContainer">最大的优点：编译即测试方式，并且可以双击结果行立即定位到相应的源代码，相当吸引人；支持多种输出，输出结果较为详细；编写测试简单；</span></span></li><li><span class="name"><span class="innerContentContainer">缺点：需要用到perl对测试代码进行文法扫描，生成可执行代码，需要用到makefile文件（不是必须）；准备工作比较麻烦。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMocker</span></span><ul><li><span class="name"><span class="innerContentContainer">cmockery 是google发布的用于C单元测试的一个轻量级的框架。</span></span></li><li><span class="name"><span class="innerContentContainer">主要特点：</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 免费且开源，google提供技术支持；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 轻量级的框架，使测试更加快速简单；</span></span></li><li><span class="name"><span class="innerContentContainer">3. 避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</span></span></li><li><span class="name"><span class="innerContentContainer">4. 并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取源码：</span></span></li><li><span class="name"><span class="innerContentContainer">直接下载：http://code.<a class="contentLink" target="_blank" rel="noreferrer" href="http://google.com/p/cmockery/downloads/list">google.com/p/cmockery/downloads/list</a></span></span></li><li><span class="name"><span class="innerContentContainer">svn地址：svn checkout <a class="contentLink" target="_blank" rel="noreferrer" href="http://cmockery.googlecode.com/svn/trunk/">http://cmockery.googlecode.com/svn/trunk/</a> cmockery-read-only</span></span></li><li><span class="name"><span class="innerContentContainer">编译方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">windows</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 打开使用VS2003/2005/2008 提供的 命令提示窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">2. cd 到CMockery的目录的window目录</span></span></li><li><span class="name"><span class="innerContentContainer">3. 运行 nmake 命令</span></span><ul><li><span class="name"><span class="innerContentContainer">E:</span></span></li><li><span class="name"><span class="innerContentContainer">cd E:\OpenSource\c\cMockery</span></span></li><li><span class="name"><span class="innerContentContainer">cd windows</span></span></li><li><span class="name"><span class="innerContentContainer">nmake</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">cmockery.lib文件以及一些测试代码都在 Windows目录下；</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">linux</span></span><ul><li><span class="name"><span class="innerContentContainer">cd 到 cMockery 源码目录</span></span></li><li><span class="name"><span class="innerContentContainer">sudo ./configure</span></span></li><li><span class="name"><span class="innerContentContainer">sudo make</span></span></li><li><span class="name"><span class="innerContentContainer">sudo make install</span></span></li><li><span class="name"><span class="innerContentContainer">库文件安装到：/usr/local/lib</span></span></li><li><span class="name"><span class="innerContentContainer">头文件安装到：/usr/local/include/google</span></span></li><li><span class="name"><span class="innerContentContainer">注意此时还应该加载一下CMockery库：</span></span></li><li><span class="name"><span class="innerContentContainer">cd /usr/local/lib</span></span></li><li><span class="name"><span class="innerContentContainer">sudo ldconfig</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">压力测试</span></span></li><li><span class="name"><span class="innerContentContainer">全链路压测</span></span></li><li><span class="name"><span class="innerContentContainer">A/B 、灰度、蓝绿测试</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">硬件测评测试</span></span><ul><li><span class="name"><span class="innerContentContainer">稳定性测试</span></span><ul><li><span class="name"><span class="innerContentContainer">统计指标是Monkey测试1000小时（或10部手机各100小时），死机、冻屏、重启多少次。</span></span></li><li><span class="name"><span class="innerContentContainer">指标:</span></span><ul><li><span class="name"><span class="innerContentContainer">tr4a：大T 2%，其它 4%。</span></span></li><li><span class="name"><span class="innerContentContainer">tr5：统一为1%。</span></span></li><li><span class="name"><span class="innerContentContainer">tr6：大T 0.2%，其它 0.4%。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">FFR的概念</span></span><ul><li><span class="name"><span class="innerContentContainer">现场失效率，指产品故障数占市场在保量的比例。</span></span></li><li><span class="name"><span class="innerContentContainer">故障率涵盖所有用户送来维修的问题手机，包括未复现。</span></span></li><li><span class="name"><span class="innerContentContainer">从诺基亚引入。</span></span></li><li><span class="name"><span class="innerContentContainer">FFR的公式: FFR=12 * 月度故障量 / 产品在保量。</span></span><ul><li><span class="name"><span class="innerContentContainer">这是个年化值;</span></span></li><li><span class="name"><span class="innerContentContainer">度故障率是采用三个月的平滑数据，所以上市头两个月没有数据。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">NFF</span></span><ul><li><span class="name"><span class="innerContentContainer">无故障返修率。即问题没有复现。</span></span></li><li><span class="name"><span class="innerContentContainer">在欧美甚多，因为欧美多采用直接换机策略，维修放在后台集中做，服务代表看不到客户，加大了复现问题的难度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常规手机测试</span></span><ul><li><span class="name"><span class="innerContentContainer">软件压力测试: 用自动测试软件连续给手机拨打1000个电话,检查手机是否会发生故障.</span></span></li><li><span class="name"><span class="innerContentContainer">抗摔性测试</span></span><ul><li><span class="name"><span class="innerContentContainer">抗摔性测试由专门的PRT可靠性实验来进行. </span></span></li><li><span class="name"><span class="innerContentContainer">半米的微跌落测试要做300/面(手机有6个面). </span></span></li><li><span class="name"><span class="innerContentContainer">2米的跌落测试每个面需各做一次.</span></span></li><li><span class="name"><span class="innerContentContainer">以及模拟人把手机扔到桌面的测试，要测试100次。</span></span></li><li><span class="name"><span class="innerContentContainer">电池要在4m高度，连续抛下100次后不能有断裂。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">高温低温测试</span></span><ul><li><span class="name"><span class="innerContentContainer">让手机处于高低不同的温度来检测手机的适应性。</span></span></li><li><span class="name"><span class="innerContentContainer">一般低温为-20度，高温80度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">高湿度测试</span></span><ul><li><span class="name"><span class="innerContentContainer">用一个专门的箱子来操作滴水测试, 模拟人出汗的情况(水里面掺有一定比例的盐)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">百格测试</span></span><ul><li><span class="name"><span class="innerContentContainer">用专用刀片在手机的外壳画100个格子10*10；</span></span></li><li><span class="name"><span class="innerContentContainer">用专用胶带粘其表面，以及用常见化妆品反复涂抹外壳，看会不会掉漆。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">翻盖测试</span></span><ul><li><span class="name"><span class="innerContentContainer">对翻盖手机进行翻盖10万次,检查壳体的损耗情况.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">扭矩测试</span></span><ul><li><span class="name"><span class="innerContentContainer">用夹具夹住两头,一头左拧,一头右拧.</span></span></li><li><span class="name"><span class="innerContentContainer">测试壳体和手机里面大型器件的强度.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">静电测试</span></span><ul><li><span class="name"><span class="innerContentContainer">冬季手摸金属的东西容易产生静电, 可能击穿手机电路.</span></span></li><li><span class="name"><span class="innerContentContainer">有专门的静电枪（10-15kV高压，低电流）和铜板来测试，持续时间之300ms到2s。</span></span></li><li><span class="name"><span class="innerContentContainer">充电器也要做。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">按键测试: 借助机器以给定的力量击打键盘10万次.</span></span></li><li><span class="name"><span class="innerContentContainer">沙尘测试</span></span><ul><li><span class="name"><span class="innerContentContainer">手机放入特定的箱子,细小的沙子被鼓吹起来.</span></span></li><li><span class="name"><span class="innerContentContainer">数小时后,察看手机里面是否有沙子进入.</span></span></li><li><span class="name"><span class="innerContentContainer">如果是,那么手机密闭性不好,结构设计有待重新调整.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">兼容性测试</span></span><ul><li><span class="name"><span class="innerContentContainer">sd卡兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">usb兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">蓝牙兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">wifi兼容性</span></span></li><li><span class="name"><span class="innerContentContainer">sim卡兼容性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它测试项</span></span><ul><li><span class="name"><span class="innerContentContainer">电池反接看是否有异常；</span></span></li><li><span class="name"><span class="innerContentContainer">靠近铁板、日光灯、心脏起搏器等打电话看是否有异常；</span></span></li><li><span class="name"><span class="innerContentContainer">长时间打电话，看发热情况。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">温升测试: 一次温升测试至少要4天，由硬测完成。</span></span></li><li><span class="name"><span class="innerContentContainer">射频测试: 一次简单射频指标的测试为1-2天；复杂指标要一周以上。</span></span></li><li><span class="name"><span class="innerContentContainer">dfx: 生产流程相关设计</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">认证测试</span></span><ul><li><span class="name"><span class="innerContentContainer">GCF测试</span></span><ul><li><span class="name"><span class="innerContentContainer">GCF：全球认证论坛。</span></span></li><li><span class="name"><span class="innerContentContainer">高通可以帮助我们做；MTK也可以。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FCC测试</span></span><ul><li><span class="name"><span class="innerContentContainer">主要用于测试射频。</span></span></li><li><span class="name"><span class="innerContentContainer">北美、南美需要这个测试。</span></span></li><li><span class="name"><span class="innerContentContainer">周期长，需要1.5到2个月才能拿到报告。</span></span></li><li><span class="name"><span class="innerContentContainer">关键点是改芯片或天线后，必须重新送测，即硬件不能改动过大。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3C认证</span></span><ul><li><span class="name"><span class="innerContentContainer">即国家入网证，中国需要。</span></span></li><li><span class="name"><span class="innerContentContainer">拿报告比较简单。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">google TA认证</span></span><ul><li><span class="name"><span class="innerContentContainer">即CTS测试。</span></span></li><li><span class="name"><span class="innerContentContainer">广义的CTS 包括CTS/GTS/VTS 等6种测试套件.</span></span></li><li><span class="name"><span class="innerContentContainer">测试周期较长。CTS 现在有100多万条case (2019-12-15), 测试一次要3天.</span></span></li><li><span class="name"><span class="innerContentContainer">测试目的是保证android平台的兼容性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMC测试: 静电相关的测试</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常规监控</span></span></li><li><span class="name"><span class="innerContentContainer">APM</span></span></li><li><span class="name"><span class="innerContentContainer">统计分析</span></span></li><li><span class="name"><span class="innerContentContainer">持续集成(CI/CD)</span></span><ul><li><span class="name"><span class="innerContentContainer">Jenkins</span></span></li><li><span class="name"><span class="innerContentContainer">环境分离</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自动化运维</span></span><ul><li><span class="name"><span class="innerContentContainer">Ansible</span></span></li><li><span class="name"><span class="innerContentContainer">puppet</span></span></li><li><span class="name"><span class="innerContentContainer">chef</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DevOps</span></span></li><li><span class="name"><span class="innerContentContainer">文档管理</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开源</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>开源协议</b></span></span><ul><li><span class="name"><span class="innerContentContainer">一共有多少license: 1800种以上，最常见的有9种，覆盖了90%以上的开源项目。</span></span></li><li><span class="name"><span class="innerContentContainer">80%的开源代码是企业贡献的。</span></span></li><li><span class="name"><span class="innerContentContainer">License的种类 </span></span><ul><li><span class="name"><span class="innerContentContainer">BSD：商业友好. 可随意使用，包括闭源. </span></span><ul><li><span class="name"><span class="innerContentContainer">BSD比较有特点的是，要求将涉及到源码库的开发者（个人、公司）的版权声明写到修改后代码文件中，或附带在产品的文本中（例如：说明书等）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MPL，只需公开修改的部分</span></span><ul><li><span class="name"><span class="innerContentContainer">其它和GPL一样, 就是允许修改者修改MPL的开源代码，形成一个二进制接口，然后再外部通过这个接口来扩展原MPL的开源代码库功能。</span></span></li><li><span class="name"><span class="innerContentContainer">此时，只需要开放二进制接口设计的这部分代码，而不需要开放扩展的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPL：全部公开（具有传染性）</span></span><ul><li><span class="name"><span class="innerContentContainer">要求在GPL许可下的开源代码进行修改后，必须再次以GPL许可公开修改后的代码。</span></span></li><li><span class="name"><span class="innerContentContainer">使用静态方式链接GPL许可证的开源代码库，则这个产品将必须以GPL许可方式开放源码。</span></span></li><li><span class="name"><span class="innerContentContainer">如果使用动态方式链接，则产品只需要开发和GPL许可代码库相关的那部分就可以。</span></span></li><li><span class="name"><span class="innerContentContainer">如果系统只能支持静态链接，且又使用了一个GPL许可的代码（哪怕只有一个文件），则这个系统就必须开放源码。这就是所谓“传染性”。</span></span></li><li><span class="name"><span class="innerContentContainer">LGPL，Less GPL，是在GPL上允许静态链接LGPL的开源代码库。所以成为“弱”GPL。</span></span></li><li><span class="name"><span class="innerContentContainer">Linxu 用的就是 LGPL.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">开源协议的分布比例: </span></span><ul><li><span class="name"><span class="innerContentContainer">截至到2012年底，约50%的开源项目使用GPL V2，</span></span></li><li><span class="name"><span class="innerContentContainer">约25%的使用GPL V3，</span></span></li><li><span class="name"><span class="innerContentContainer">剩下25%的使用其它协议（主要是Apache、BSP）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GPL V2规定的两种例外情况</span></span><ul><li><span class="name"><span class="innerContentContainer">独立进程间通讯的调用，动态链接集成.</span></span></li><li><span class="name"><span class="innerContentContainer">系统调用，即syscall。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">开源义务的履行方式</span></span><ul><li><span class="name"><span class="innerContentContainer">written offer模式, 就是提出请求, 就寄光盘. 最常见。优势是受众可控。</span></span></li><li><span class="name"><span class="innerContentContainer">直接把代码放在网上. 使用不广。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Apache开源协议的特点</span></span><ul><li><span class="name"><span class="innerContentContainer">简称ASL, 属于商业友好的开源协议.</span></span></li><li><span class="name"><span class="innerContentContainer">以ASL发布的代码，可以被合并入闭源的专有软件，并且在各种各样的限制性条件下发布。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">公共域: Public Domain&nbsp;— 可供任何人以任何目的使用和修改的软件，甚至可以将其并入商业软件的分发。公共域软件不保留版权，作者也不保留任何权利。</span></span></li><li><span class="name"><span class="innerContentContainer">开源官司的诉讼情况:  开源公司已经由好几百起了，商业公司从未胜诉。FSF（自由软件基金会）是业界最大的开源软件维权组织，全部胜诉。</span></span></li><li><span class="name"><span class="innerContentContainer">专利方面: </span></span><ul><li><span class="name"><span class="innerContentContainer">GPL、LGPL对代码中的专利有非常严格限制。即，不允许有专利相关的代码在开源库中。</span></span></li><li><span class="name"><span class="innerContentContainer">MPL对专利就有一点不同。虽然不允许有专利相关代码在开源代码中，但是如果开发者是专利权人，并公开书面声明免费授予使用这个开源代码的专利权。则可以把专利相关的代码放入代码库中。另外，如果先声明代码为MPL许可后，又去申请其中的专利，这是不允许的。</span></span></li><li><span class="name"><span class="innerContentContainer">Apache、BSD、MIT则对专利没有任何申明。因此自由也是有“风险”的。我们在使用这些开源代码时，还需要评估其中的专利问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">免责声明: 所有的开源代码许可证都有“免责声明”。通俗点说，如果你用了开源代码，而最后发现这些代码的问题导致各种意外（严重事故、出人命、设备罢工、等等），源码的开发者不负任何责任。</span></span></li><li><span class="name"><span class="innerContentContainer">著名开源软件列表: http://zh.wikipedia.org/wiki/开放源代码软件列表&nbsp;&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">如何避开GPL感染？&nbsp;&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">区隔。即用接口层将GPL代码和非GPL之间隔离。</span></span></li><li><span class="name"><span class="innerContentContainer">最著名的是android。</span></span></li><li><span class="name"><span class="innerContentContainer">目前似乎只有嵌入式用得通。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用内核头文件，进行系统调用的程序，算不算衍生？&nbsp;&nbsp;</span></span><ul><li><span class="name"><span class="innerContentContainer">不算。运行于用户态且只使用系统调用的程序不受GPL约束。</span></span></li><li><span class="name"><span class="innerContentContainer">这一点是Linus反复申明且写入linux readme文件中的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">链接使用GPL授权的代码，算不算衍生？</span></span><ul><li><span class="name"><span class="innerContentContainer">算。这就是引起无数争议的GPL“传染性”。</span></span></li><li><span class="name"><span class="innerContentContainer">链接了开源的库，自身就需要开源。</span></span></li><li><span class="name"><span class="innerContentContainer">链接的情况需要细分：</span></span><ul><li><span class="name"><span class="innerContentContainer">静态链接，主程序必须开源；</span></span></li><li><span class="name"><span class="innerContentContainer">动态连接，还有一条细缝，即当可以证明主程序和库之间具有独立性，就可以不开源。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">内核动态载入的模块，算不算衍生？</span></span><ul><li><span class="name"><span class="innerContentContainer">未定。这是硬件厂商和社区间持续争议的中心.</span></span></li><li><span class="name"><span class="innerContentContainer">最著名的莫过于图形开发商ATI/NVidia，他们把自己设备的驱动做成ko文件。</span></span></li><li><span class="name"><span class="innerContentContainer">社区经常愤怒的批评，但是一般并不会上升到法律层面，所以胜负未知。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GNU GPL 只要求使用代码的客户可以获得修改后的代码。它不要求将所有修改后的代码都发布给公众。</span></span></li><li><span class="name"><span class="innerContentContainer">在云计算时代, GPL （2.x ~ 3.x） 协议出现了一个非常大的“漏洞”，就是软件“发布” 才必须开源。如果我的软件不发布，即使使用 GPL (2.x ~ 3.x) 也可以不用开源。托管软件或云端上的软件，很多就是利用这个漏洞.  于是AGPL 协议产生了。</span></span></li><li><span class="name"><span class="innerContentContainer">GPL V3的四大特点</span></span><ul><li><span class="name"><span class="innerContentContainer">不能回头，凡以GPL V3授权的成果将永远以GPL V3发行；</span></span></li><li><span class="name"><span class="innerContentContainer">最惠“国”条款。凡就GPL授权的成果达成的任何协议，如果优于GPL，则自动适用于任何第三方。</span></span></li><li><span class="name"><span class="innerContentContainer">硬件要保证用户修改软件的权利，以防止Tivo化（Tivo化即当用某种方式发现软件被修改，硬件就不正常运行）；</span></span></li><li><span class="name"><span class="innerContentContainer">用户可开关DRM。GPL不禁止DRM进入自由软件，而且要给予用户关闭它的自由。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何看待GPL3？</span></span><ul><li><span class="name"><span class="innerContentContainer">GPL V3不能和GPL V2兼容；但可以和apache兼容。</span></span></li><li><span class="name"><span class="innerContentContainer">商业公司似乎正在主导GPL内涵的解释, 在GPL V3的修订委员会中，商业公司占据了半数以上的席位。</span></span></li><li><span class="name"><span class="innerContentContainer">&nbsp;v3 比较大的隐忧是可能导致开源界的分裂，起码现在分裂的风险比任何时候都大了。最引人注目的就是rms和 Linus 关于v3的分歧了。</span></span></li><li><span class="name"><span class="innerContentContainer">v3 的初衷，就rms重申过的而言，是希望推动硬件开源。</span></span></li><li><span class="name"><span class="innerContentContainer">这个理想本身有无必要性另说，目前一个眼面前的风险就是可能导致linux 生态环境受到较大的破坏。尤其是正方兴未艾的android。</span></span></li><li><span class="name"><span class="innerContentContainer">GPL v2就有传染性，但这个传染性是受限的。象android推行4年没有诉讼，基本上确立了v2 传染性的两个边界：</span></span></li><li><span class="name"><span class="innerContentContainer">1. 核心态的开源代码，不会传染到用户态；</span></span></li><li><span class="name"><span class="innerContentContainer">2. 使用gcc库，不管什么方式，都不会传染。（当然，这点从开源一开始就是这样的，和android关系不大）。</span></span></li><li><span class="name"><span class="innerContentContainer">而在v3上，是否还是这样，就非常不确定了。现在连gcc都切换到v3，不免让人怀疑rms的目的。</span></span></li><li><span class="name"><span class="innerContentContainer">对商业公司而言，最怕的就是不确定的风险。尤其是和rms 这种又臭又硬、又有办法、还占着理的人打官司的风险。</span></span></li><li><span class="name"><span class="innerContentContainer">现在Linus顶着不用v3，危机还不会很快爆发。以后就不一定了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">日志框架</span></span><ul><li><span class="name"><span class="innerContentContainer">Log4j、Log4j2</span></span></li><li><span class="name"><span class="innerContentContainer">Logback</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ORM</span></span></li><li><span class="name"><span class="innerContentContainer">网络框架</span></span></li><li><span class="name"><span class="innerContentContainer">Web 框架</span></span><ul><li><span class="name"><span class="innerContentContainer">Spring 家族</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">工具框架</span></span><ul><li><span class="name"><span class="innerContentContainer">JetBrain公司和它的产品 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">支付宝使用的30多个开源软件 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer">史上最全的开发和设计资源大全 <span class="contentTag" title="Filter @iFile">@<span class="contentTagText">iFile</span><span class="contentTagNub"></span></span></span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">专利与创新</span></span><ul><li><span class="name"><span class="innerContentContainer">专利的3个特点</span></span><ul><li><span class="name"><span class="innerContentContainer">新颖性：以前没有；</span></span></li><li><span class="name"><span class="innerContentContainer">创造性：强调这是智慧的成果；</span></span></li><li><span class="name"><span class="innerContentContainer">有用性：有用。</span></span></li><li><span class="name"><span class="innerContentContainer">第二点是本质。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">专利交底书的结构</span></span><ul><li><span class="name"><span class="innerContentContainer">现有技术</span></span><ul><li><span class="name"><span class="innerContentContainer">现有技术写得恰当，对专利的通过益处极大，这一点经常被忽略。</span></span></li><li><span class="name"><span class="innerContentContainer">要寻找和本案最接近但又不同的技术，不同点要一目了然，且有害。</span></span></li><li><span class="name"><span class="innerContentContainer">比如，本案有5个步骤，现有技术只有头3个。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">技术方案</span></span><ul><li><span class="name"><span class="innerContentContainer">技术方案是保护重点。</span></span></li><li><span class="name"><span class="innerContentContainer">将每个功能步骤都虚拟成一个功能单元（不论是软件还是硬件）。</span></span></li><li><span class="name"><span class="innerContentContainer">先介绍各自的功能，再串起来介绍如何通过这些功能完成本发明方案。</span></span></li><li><span class="name"><span class="innerContentContainer">技术方案的撰写特点</span></span><ul><li><span class="name"><span class="innerContentContainer">要在抽象和新颖性之间求得最佳的折衷。</span></span></li><li><span class="name"><span class="innerContentContainer">越抽象，别人就越不可绕过，保护范围越广。</span></span></li><li><span class="name"><span class="innerContentContainer">但方案越抽象，新颖性就很难保证。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">实施例</span></span><ul><li><span class="name"><span class="innerContentContainer">由于比较细节，保护访问比较小，但也要被保护。</span></span></li><li><span class="name"><span class="innerContentContainer">实施例即技术方案的具体实现方式。</span></span></li><li><span class="name"><span class="innerContentContainer">可以写多个，并要多层保护，这个不行有那个。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TRIZ理论--创新方法</span></span><ul><li><span class="name"><span class="innerContentContainer">分割原则</span></span><ul><li><span class="name"><span class="innerContentContainer">将物体分成独立的部分。</span></span></li><li><span class="name"><span class="innerContentContainer">使物体成为可拆卸的。</span></span></li><li><span class="name"><span class="innerContentContainer">增加物体的分割程度。</span></span></li><li><span class="name"><span class="innerContentContainer">例：货船分成同型的几个部分，必要时，可将船加长些或变短些．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拆出原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从物体中拆出"干扰'部分("干扰"特性)或者相反，分出唯一需要的部分或需要的特性。与上述把物体分成几个相同部分的技法相反，这里是要把物体分成几个不同的部分．</span></span></li><li><span class="name"><span class="innerContentContainer">例，一般小游艇的照明和其他用电是艇上发动机带动发电机供给的．为了停泊时能继续供电，要安装一个由内燃机传动的辅助发电机．发动机必然造成噪音和振动。建议将发动机和发电机分置于距游艇不远的两个容器里，用电缆连接．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">局部性质原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从物体或外部介质(外部作用)的一致结构过渡到不一致结构。</span></span></li><li><span class="name"><span class="innerContentContainer">物体的不同部分应当具有不同的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">物体的每一部分均应具备最适于它工作的条件。 例：为了防治矿山坑道里的粉尘，向工具(钻机和料车的工作机构)呈锥体状喷洒小水珠。水珠愈小，除尘效果愈好．但小水珠容易形成雾，这使工作困难．解决办法：环绕小水珠锥体外层再造成一层大水珠。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">不对称原则</span></span><ul><li><span class="name"><span class="innerContentContainer">物体的对称形式转为不对称形式。</span></span></li><li><span class="name"><span class="innerContentContainer">如果物体不是对称的，则加强它的不对称程度。</span></span></li><li><span class="name"><span class="innerContentContainer">例：防撞汽车轮胎具有一个高强度的侧缘，以抵抗人行道路缘石的碰撞。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">组合原则</span></span><ul><li><span class="name"><span class="innerContentContainer">把相同的物体或完成类似操作的物体组合合起来。</span></span></li><li><span class="name"><span class="innerContentContainer">把时间上相同或类似的操作联合起来。</span></span></li><li><span class="name"><span class="innerContentContainer">例：双联显微镜组；由一个人操作，另一个人观察和记录。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多功能原则</span></span><ul><li><span class="name"><span class="innerContentContainer">一个物体执行多种不同功能，因而不需要其他物体。</span></span></li><li><span class="name"><span class="innerContentContainer">例：提包的提手可同时作为拉力器。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">‘玛特廖什卡'原则</span></span><ul><li><span class="name"><span class="innerContentContainer">一个物体位于另一物体之内，而后者又位于第三个物体之内，等等。</span></span></li><li><span class="name"><span class="innerContentContainer">一个物体通过另一个物体的空腔。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">重量补偿原则</span></span><ul><li><span class="name"><span class="innerContentContainer">将物体与具有上升力的另一物体结合以抵消其重量。例：氢气球吊起广告牌。</span></span></li><li><span class="name"><span class="innerContentContainer">将物体与介质(最好是气动力和液动力)相互作用以抵消其重量。</span></span></li><li><span class="name"><span class="innerContentContainer">总的设想是，如果需要改变转动物体的质量，而其质量又不能按照一定的要求改变，那么应使该物体成为翼状的，改变翼片运动方向的倾斜角度，便可获得需要方向的附加力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">预先反作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">如果按课题条件必须完成某种作用，则应提前完成反作用。一般是为了对冲原功能的消极作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">预先作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">预先完成要求的作用(整个的或部分的)。</span></span></li><li><span class="name"><span class="innerContentContainer">预先将物体安放妥当，使它们能在现场和最方便地点立即完成所需要的作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">"予先放枕头"原则</span></span><ul><li><span class="name"><span class="innerContentContainer">以事先准备好的应急手段补偿物体的底可靠性。</span></span></li><li><span class="name"><span class="innerContentContainer">例：树枝在锯掉之前套上一个紧箍环，树木感该处有" 病"，于是向那里输送营养物质和治疗物质。这样，在树枝被锯之前这些物质便积聚起来，锯后锯口会迅速愈合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">等势原则</span></span><ul><li><span class="name"><span class="innerContentContainer">改变工作条件，使物体上升或下降．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">"相反"原则</span></span><ul><li><span class="name"><span class="innerContentContainer">不实现课题条件规定的作用而实现相反的作用．</span></span></li><li><span class="name"><span class="innerContentContainer">使物体或外部介质的活动部分成为不动的，而使不动的成为可动的．</span></span></li><li><span class="name"><span class="innerContentContainer">将物体颠倒．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">球形原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从直线部分过渡到曲线部分，从平面过渡到球面，从正六面体或平行六面体过渡到球形结构。</span></span></li><li><span class="name"><span class="innerContentContainer">利用棍子、球体、螺旋。</span></span></li><li><span class="name"><span class="innerContentContainer">从直线运动过浑到旋转运动，利用离心力。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">动态原则</span></span><ul><li><span class="name"><span class="innerContentContainer">物体(或外部介质）的特性的变化应当在每一工作阶段都是最佳的。</span></span></li><li><span class="name"><span class="innerContentContainer">将物体分成彼此相对移动的几个部分。</span></span></li><li><span class="name"><span class="innerContentContainer">使不动的物体成为动的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">局部作用或过量作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">如果难于取得百分之百所要求的功效，则应当取得略小或略大的功效。此时可能把课题大大简化。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">向另一维度过渡的原则</span></span><ul><li><span class="name"><span class="innerContentContainer">如果物体作线性运动（或分布）有困难，则使物体在二维度(即平面)上移动。相应地，在一个平面上的运动(或分布)可以过渡到三维空间。</span></span></li><li><span class="name"><span class="innerContentContainer">利用多层结构替代单层结构。</span></span></li><li><span class="name"><span class="innerContentContainer">将物体倾斜或侧置．</span></span></li><li><span class="name"><span class="innerContentContainer">利用指定面的反面．</span></span></li><li><span class="name"><span class="innerContentContainer">利用投向相邻面或反面的光流。代表技术系统总发展趋势的链：从点到线，然后到面，到体，最后到许多个物体的共存．</span></span></li><li><span class="name"><span class="innerContentContainer">例： "越冬圆木在圆形停泊场水中存放，其特征是，为了增大停泊场的单位容积，和减小受冻木材的体积，将圆木扎成捆，其横截面的宽和高超过圆木的长度，然后立着放"。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">机械振动原则</span></span><ul><li><span class="name"><span class="innerContentContainer">使物体振动。</span></span></li><li><span class="name"><span class="innerContentContainer">如果巳在振动，则提高它的振动频率(达到超声波频率)。</span></span></li><li><span class="name"><span class="innerContentContainer">利用共振频率。</span></span></li><li><span class="name"><span class="innerContentContainer">用压电振动器替代机械振动器。</span></span></li><li><span class="name"><span class="innerContentContainer">利用超声波振动同电磁场配合。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">周期作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">从连续作用过渡到周期作用(脉冲)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果作用已经是周期的，则改变周期性。</span></span></li><li><span class="name"><span class="innerContentContainer">利用脉冲的间歇完成其他作用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">连续有益作用原则</span></span><ul><li><span class="name"><span class="innerContentContainer">连续工作(物体的所有部分均应一直满负荷工作)。</span></span></li><li><span class="name"><span class="innerContentContainer">消除空转和间歇运转。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">跃过原则</span></span><ul><li><span class="name"><span class="innerContentContainer">高速跃过某过程或其个别阶段(如有害的或危险的)。</span></span></li><li><span class="name"><span class="innerContentContainer">例：产胶合板时用烘烤法加工木材，其特征是，为保持木材的本性，在生产胶合板的过程中直接用300～600·C 的燃气火焰短时作用于烘烤木材。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">变害为利原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用有害因素(特别是介质的有害作用)获得有益的效果。</span></span></li><li><span class="name"><span class="innerContentContainer">通过有害因素与另外几个有害因素的组合来消除有害因素。</span></span></li><li><span class="name"><span class="innerContentContainer">将有害因素加强到不再是有害的程度。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">反向联系原则</span></span><ul><li><span class="name"><span class="innerContentContainer">进行反向联系。</span></span></li><li><span class="name"><span class="innerContentContainer">如果已有反向联系，则改变它。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">"中介"原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用可以迁移或有传送作用的中间物体。</span></span></li><li><span class="name"><span class="innerContentContainer">把另一个(易分开的)物体暂时附加给某一物体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">自我服务原则</span></span><ul><li><span class="name"><span class="innerContentContainer">物体应当为自我服务，完成辅助和修理工作。</span></span></li><li><span class="name"><span class="innerContentContainer">利用废料(能的和物质的)。</span></span></li><li><span class="name"><span class="innerContentContainer">例，一般都是利用专门装置供给电焊枪中的电焊条．建议利用电焊电流工作的螺旋管供给电焊条。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复制原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用简单而便宜的复制品代替难以得到的、复杂的、昂贵的、不方便的或易损坏的物体。</span></span></li><li><span class="name"><span class="innerContentContainer">用光学拷贝(图像）代替物体或物体系统。此时要改变比例(放大或缩小复制品)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果利用可见光的复制品，则转为红外线的或紫外线的复制。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用廉价的不持久性代替昂贵的持久性原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用一组廉价物体代替一个昂贵物体，放弃某些品质(如持久性)。</span></span></li><li><span class="name"><span class="innerContentContainer">比如：一次性针管。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代替力学原理原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用光学，声学、 ‘味学"等设计原理代替力学设计原理。</span></span></li><li><span class="name"><span class="innerContentContainer">用电场．磁场和电磁场同物体相互作用。</span></span></li><li><span class="name"><span class="innerContentContainer">由恒定场转向不定场，由时间固定的场转向时间变化的场，由无结构的场转向有一定结构的场。</span></span></li><li><span class="name"><span class="innerContentContainer">利用铁磁颗粒组成的场．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用气动和液压结构的原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用气体结构和液体结构代替物体的固体的部分，如充气和充液的结构，气枕，静液的和液体反冲的结构．</span></span></li><li><span class="name"><span class="innerContentContainer">如果需要短时间使一种 物体与另一种物体紧紧靠住，则应用"气袋"法．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用软壳和薄膜原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用软壳和薄膜代替一般的结构。</span></span></li><li><span class="name"><span class="innerContentContainer">用软壳和薄膜使物体同外部介质隔离。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用多孔材料原则</span></span><ul><li><span class="name"><span class="innerContentContainer">把物体作成多孔的或利用附加多孔元件(镶嵌，覆盖，等等)。</span></span></li><li><span class="name"><span class="innerContentContainer">如果物体是多孔的，事先用某种物质填充空孔。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改变颜色原则</span></span><ul><li><span class="name"><span class="innerContentContainer">改变物体或外部介质的颜色。</span></span></li><li><span class="name"><span class="innerContentContainer">改变物体或外部介质的透明度。</span></span></li><li><span class="name"><span class="innerContentContainer">为了观察难以看到的物体或过程，利用染色添加剂。</span></span></li><li><span class="name"><span class="innerContentContainer">如果已采用了这种添加剂，则采用荧光粉。</span></span></li><li><span class="name"><span class="innerContentContainer">例：透明绷带不必取掉便可观察伤情。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一致原则</span></span><ul><li><span class="name"><span class="innerContentContainer">同指定物体相互作用的物体应当用同一(或性质相近的)材料制成．</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">部分剔除和再生原则</span></span><ul><li><span class="name"><span class="innerContentContainer">已完成自己的使命或已无用的物体部分应当剔除(溶解．蒸发等)或在工作过程中直接变化。</span></span></li><li><span class="name"><span class="innerContentContainer">消除的部分应当在工作过程中直接再生。</span></span></li><li><span class="name"><span class="innerContentContainer">例："检查焊接过程的高压区的方法是向高温区加入光导探头。其特征是，为改善在电弧焊和电火花焊接过程中检查高温区的可能性，利用可熔化的探头．它以不低于自己熔化速度的速度被不断地送人检查的高温区"。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">改变物体聚合态原则</span></span><ul><li><span class="name"><span class="innerContentContainer">这里包括的不仅是简单的过渡，例如从固态过渡到液态，还有向"假态"(假液态)和中间状态的过渡，例如采用弹性固体。</span></span></li><li><span class="name"><span class="innerContentContainer">例：降落跑道的减速地段建成"浴盆"形式，里面充满粘性液体，上面再铺上厚厚一层弹性物质。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">相变原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用相变时发生的现象，例如体积改变，放热或吸热，</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用热膨胀原则</span></span><ul><li><span class="name"><span class="innerContentContainer">利用材料的热膨胀(或热收缩)。</span></span></li><li><span class="name"><span class="innerContentContainer">利用一些热膨胀系数不同的材料。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用强氧化剂原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用富氧空气代替普通空气。</span></span></li><li><span class="name"><span class="innerContentContainer">用氧气替换富氧空气。</span></span></li><li><span class="name"><span class="innerContentContainer">用电离辐射作用于空气或氧气。</span></span></li><li><span class="name"><span class="innerContentContainer">用臭氧化了的氧气．</span></span></li><li><span class="name"><span class="innerContentContainer">用臭氧替换臭氧化的(或电离的)氧气。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">采用惰性介质原则</span></span><ul><li><span class="name"><span class="innerContentContainer">用惰性介质代替普通介质。</span></span></li><li><span class="name"><span class="innerContentContainer">在真空中进行某过程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">利用混合材料原则</span></span><ul><li><span class="name"><span class="innerContentContainer">由同种材料转为混合材料。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">商业模式</span></span><ul><li><span class="name"><span class="innerContentContainer">监控</span></span></li><li><span class="name"><span class="innerContentContainer">游戏娱乐</span></span></li><li><span class="name"><span class="innerContentContainer">广告</span></span></li><li><span class="name"><span class="innerContentContainer">电子商务</span></span></li><li><span class="name"><span class="innerContentContainer">在线教育</span></span></li><li><span class="name"><span class="innerContentContainer">金融</span></span></li></ul></li></ul>
  </body>
</html>