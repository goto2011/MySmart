<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">11-事件处理</span><ul><li><span class="name">Android的事件处理分为 基于监听的机制, 以及 基于回调的机制.</span></li><li><span class="name">事件监听器机制分为4个步骤:</span><ul><li><span class="name">Step 1:为某个事件源(组件)设置一个监听器,用于监听用户操作</span></li><li><span class="name">Step 2:用户的操作, 触发了事件源的监听器</span></li><li><span class="name">Step 3:生成了对应的事件对象, 将该对象作为参数传给事件监听器</span></li><li><span class="name">step 4:事件监听器对事件对象进行判断, 执行对应的事件处理器(对应事件的处理方法)</span></li></ul></li><li><span class="name">事件监听器实现方式有几种:</span></li><li><span class="name">1. 直接用匿名内部类</span><ul><li><span class="name">最常用的一种:直接setXxxListener后,重写里面的方法即可.</span></li><li><span class="name">使用场景: 临时使用一次,复用性不高.</span></li><li><span class="name">public class MainActivity extends Activity {</span><ul><li><span class="name">private Button btnshow;</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">btnshow = (Button) findViewById(R.id.btnshow);</span></li><li><span class="name">btnshow.<b>setOnClickListener</b>(new OnClickListener() {</span><ul><li><span class="name">//重写点击事件的处理方法onClick()</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name">//显示Toast信息</span></li><li><span class="name">Toast.makeText(getApplicationContext(), "你点击了按钮", Toast.LENGTH_SHORT).show();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">2. 使用内部类</span><ul><li><span class="name">对监听类进行命名. </span></li><li><span class="name">目的是复用. 如果本activity中的多个控件使用同一个监听器类, 则会节省很多代码.</span></li><li><span class="name">public class MainActivity extends Activity {</span><ul><li><span class="name">private Button btnshow;</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">btnshow = (Button) findViewById(R.id.btnshow);</span></li><li><span class="name">//直接new一个内部类对象作为参数</span></li><li><span class="name">btnshow.<b>setOnClickListener</b>(new BtnClickListener());</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法</span></li><li><span class="name">class <b>BtnClickListener </b>implements View.OnClickListener {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name">Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">3. 使用外部类</span><ul><li><span class="name">这种形式用的比较少！因为外部类不能直接访问用户界面类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁.</span></li><li><span class="name">使用场景是多个activity共用同一个监听器类, 则可以这么用. 但是这样耦合性太高, 不建议.</span></li><li><span class="name">将内部类外部化即可, 不累述.</span></li></ul></li><li><span class="name">4. 直接使用Activity作为事件监听器</span><ul><li><span class="name">需要让Activity类实现XxxListener事件监听接口, 在Activity中定义重写对应的事件处理器方法.</span></li><li><span class="name">// 让Activity方法实现OnClickListener接口</span></li><li><span class="name">public class MainActivity extends Activity implements <b>OnClickListener </b>{</span><ul><li><span class="name">private Button btnshow;</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">btnshow = (Button) findViewById(R.id.btnshow);</span></li><li><span class="name">// 直接写个this</span></li><li><span class="name">btnshow.<b>setOnClickListener</b>(<b>this</b>);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 重写接口中的抽象方法</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name">Toast.makeText(getApplicationContext(), "点击了按钮", Toast.LENGTH_SHORT).show();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">5. 直接绑定到布局文件</span><ul><li><span class="name">就是直接在xml布局文件中对应得Activity中定义一个事件处理方法</span></li><li><span class="name">// 布局文件</span></li><li><span class="name">&lt;LinearLayout xmlns:android="<a class="contentLink" target="_blank" rel="noreferrer" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</span><ul><li><span class="name">xmlns:tools="<a class="contentLink" target="_blank" rel="noreferrer" href="http://schemas.android.com/tools">http://schemas.android.com/tools</a>"</span><ul><li><span class="name">android:id="@+id/LinearLayout1"</span></li><li><span class="name">android:layout_width="match_parent"</span></li><li><span class="name">android:layout_height="match_parent"</span></li><li><span class="name">android:orientation="vertical" &gt;</span></li><li><span class="name">&lt;Button</span><ul><li><span class="name">android:layout_width="wrap_content"</span></li><li><span class="name">android:layout_height="wrap_content"</span></li><li><span class="name">android:text="按钮"</span></li><li><span class="name">// 直接使用函数名</span></li><li><span class="name">android:onClick="<b>myclick</b>"/&gt;</span></li></ul></li></ul></li><li><span class="name">&lt;/LinearLayout&gt;</span></li></ul></li><li><span class="name">// 代码</span></li><li><span class="name">public class MainActivity extends Activity {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 自定义一个方法,传入一个view组件作为参数</span></li><li><span class="name">public void <b>myclick</b>(View source) {</span><ul><li><span class="name">Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">基于回调的事件处理机制使用场景主要是自定义view</span><ul><li><span class="name">当用户在GUI组件上激发某个事件时,组件有自己特定的方法会负责处理该事件 通常用法:继承基本的GUI组件,重写该组件的事件处理方法,即自定义view.</span></li><li><span class="name">注意:在xml布局中使用自定义的view时,需要使用"全限定类名".</span></li></ul></li><li><span class="name">常见View组件的回调方法有:</span><ul><li><span class="name">在该组件上触发屏幕事件: boolean&nbsp;onTouchEvent(MotionEvent event);</span></li><li><span class="name">在该组件上按下某个按钮时: boolean&nbsp;onKeyDown(int keyCode,KeyEvent event);</span></li><li><span class="name">松开组件上的某个按钮时: boolean&nbsp;onKeyUp(int keyCode,KeyEvent event);</span></li><li><span class="name">长按组件某个按钮时: boolean&nbsp;onKeyLongPress(int keyCode,KeyEvent event);</span></li><li><span class="name">键盘快捷键事件发生: boolean&nbsp;onKeyShortcut(int keyCode,KeyEvent event);</span></li><li><span class="name">在组件上触发轨迹球屏事件: boolean&nbsp;onTrackballEvent(MotionEvent event);</span></li><li><span class="name">当组件的焦点发生改变,和前面的6个不同,这个方法只能够在View中重写哦！ protected void&nbsp;onFocusChanged(boolean gainFocus, int direction, Rect previously FocusedRect)</span></li></ul></li><li><span class="name">自定义view使用事件回调</span><ul><li><span class="name">// 布局</span></li><li><span class="name">&lt;RelativeLayout xmlns:android="<a class="contentLink" target="_blank" rel="noreferrer" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</span><ul><li><span class="name">xmlns:tools="<a class="contentLink" target="_blank" rel="noreferrer" href="http://schemas.android.com/tools">http://schemas.android.com/tools</a>"</span></li><li><span class="name">android:layout_width="match_parent"</span></li><li><span class="name">android:layout_height="match_parent"</span></li><li><span class="name">tools:context=".MyActivity"&gt;</span></li><li><span class="name">&lt;example.jay.com.mybutton.MyButton</span><ul><li><span class="name">android:layout_width="wrap_content"</span></li><li><span class="name">android:layout_height="wrap_content"</span></li><li><span class="name">android:text="按钮"/&gt;</span></li></ul></li></ul></li><li><span class="name">// MyButton.java</span></li><li><span class="name">public class MyButton extends Button{</span><ul><li><span class="name">private static String TAG = "呵呵";</span></li><li><span class="name">public MyButton(Context context, AttributeSet attrs) {</span><ul><li><span class="name">super(context, attrs);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//重写键盘按下触发的事件</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public boolean onKeyDown(int keyCode, KeyEvent event) {</span><ul><li><span class="name">super.onKeyDown(keyCode,event);</span></li><li><span class="name">Log.i(TAG, "onKeyDown方法被调用");</span></li><li><span class="name"><b>return true;</b></span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//重写弹起键盘触发的事件</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public boolean onKeyUp(int keyCode, KeyEvent event) {</span><ul><li><span class="name">super.onKeyUp(keyCode,event);</span></li><li><span class="name">Log.i(TAG,"onKeyUp方法被调用");</span></li><li><span class="name">return true;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//组件被触摸了</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public boolean onTouchEvent(MotionEvent event) {</span><ul><li><span class="name">super.onTouchEvent(event);</span></li><li><span class="name">Log.i(TAG,"onTouchEvent方法被调用");</span></li><li><span class="name">return true;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name"><b>冒泡事件传播</b></span><ul><li><span class="name">这个概念非常关键, 但是理解有难度. 注意好好掌握. </span></li><li><span class="name">事件传播的顺序:</span><ul><li><span class="name">触发组件绑定的事件监听器</span></li><li><span class="name">触发组件提供的回调;</span></li><li><span class="name">传播到父view, 也是先事件监听器, 后回调;</span></li><li><span class="name">传播到组件所在的activity.</span></li></ul></li><li><span class="name">这个链条的每个方法的返回值都是 Boolean, 用于表示该事件是否处理完了. 如果返回 True, 则表示处理完了. 如果返回 False, 则会继续传递.</span></li></ul></li><li><span class="name">复杂事件处理: OnTouchListener, 包括:</span><ul><li><span class="name">onTouch(View v, MotionEvent event):这里面的参数依次是触发触摸事件的组件,触碰事件event 封装了触发事件的详细信息，同样包括事件的类型、触发时间等信息。比如event.getX(),event.getY()</span></li><li><span class="name">我们也可以对触摸的动作类型进行判断,使用event.getAction( )再进行判断;如:</span></li><li><span class="name">event.getAction == MotionEvent.ACTION_DOWN：按下事件</span></li><li><span class="name">event.getAction == MotionEvent.ACTION_MOVE:移动事件</span></li><li><span class="name">event.getAction == MotionEvent.ACTION_UP:弹起事件</span></li><li><span class="name">例子:</span></li><li><span class="name">public class MyView extends View{</span><ul><li><span class="name">public float X = 50;</span></li><li><span class="name">public float Y = 50;</span></li><li><span class="name">//创建画笔</span></li><li><span class="name">Paint paint = new Paint();</span></li><li><span class="name">public MyView(Context context,AttributeSet set)</span></li><li><span class="name">{</span><ul><li><span class="name">super(context,set);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onDraw(Canvas canvas) {</span><ul><li><span class="name">super.onDraw(canvas);</span></li><li><span class="name">paint.setColor(Color.BLUE);</span></li><li><span class="name">canvas.drawCircle(X,Y,30,paint);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public boolean onTouchEvent(MotionEvent event) {</span><ul><li><span class="name">this.X = event.getX();</span></li><li><span class="name">this.Y = event.getY();</span></li><li><span class="name">//通知组件进行重绘</span></li><li><span class="name">this.invalidate();</span></li><li><span class="name">return true;</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">多点触碰处理</span><ul><li><span class="name">多点触碰就是多个手指在屏幕上进行操作，用的最多的估计是放大缩功能吧，比如很多的图片浏览器都支持缩放！理论上Android系统本身可以处理多达256个手指的触摸，当然这取决于手机硬件的支持.</span></li><li><span class="name">前面两点都有用到 MotionEvent，可根据event.getAction() &amp; MotionEvent.ACTION_MASK 来判断是哪种操作, 包括按下, 抬起, 移动.</span></li><li><span class="name">除了上面介绍的三种单点操作外，还有两个多点专用的操作：</span><ul><li><span class="name">MotionEvent.ACTION_POINTER_DOWN:当屏幕上已经有一个点被按住，此时再按下其他点时触发。</span></li><li><span class="name">MotionEvent.ACTION_POINTER_UP:当屏幕上有多个点被按住，松开其中一个点时触发（即非最后一个点被放开时）。</span></li></ul></li><li><span class="name">事件流程:</span><ul><li><span class="name">当我们一个手指触摸屏幕 ——&gt; 触发ACTION_DOWN事件</span></li><li><span class="name">接着有另一个手指也触摸屏幕 ——&gt; 触发ACTION_POINTER_DOWN事件,如果还有其他手指触摸，继续触发</span></li><li><span class="name">有一个手指离开屏幕 ——&gt; 触发ACTION_POINTER_UP事件，继续有手指离开，继续触发</span></li><li><span class="name">当最后一个手指离开屏幕 ——&gt; 触发ACTION_UP事件</span></li><li><span class="name">而且在整个过程中，ACTION_MOVE事件会一直不停地被触发.</span></li></ul></li><li><span class="name">可以通过 event.getX(int)或者 event.getY(int)来获得不同触摸点的位置： 比如 event.getX(0)可以获得第一个接触点的X坐标，event.getX(1)获得第二个接触点的X坐标这样.</span></li><li><span class="name">可以通过 MotionEvent.getPointerCount()方法判断当前有多少个手指在触摸.</span></li><li><span class="name">例子</span></li><li><span class="name">public class MainActivity extends Activity implements OnTouchListener {</span><ul><li><span class="name">private ImageView img_test;</span></li><li><span class="name">// 縮放控制</span></li><li><span class="name">private Matrix matrix = new Matrix();</span></li><li><span class="name">private Matrix savedMatrix = new Matrix();</span></li><li><span class="name">// 不同状态的表示：</span></li><li><span class="name">private static final int NONE = 0;</span></li><li><span class="name">private static final int DRAG = 1;</span></li><li><span class="name">private static final int ZOOM = 2;</span></li><li><span class="name">private int mode = NONE;</span></li><li><span class="name">// 定义第一个按下的点，两只接触点的重点，以及出事的两指按下的距离：</span></li><li><span class="name">private PointF startPoint = new PointF();</span></li><li><span class="name">private PointF midPoint = new PointF();</span></li><li><span class="name">private float oriDis = 1f;</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span><ul><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">img_test = (ImageView) this.findViewById(R.id.img_test);</span></li><li><span class="name">img_test.setOnTouchListener(this);</span></li></ul></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public boolean onTouch(View v, MotionEvent event) {</span><ul><li><span class="name">ImageView view = (ImageView) v;</span><ul><li><span class="name">switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {</span></li><li><span class="name">// 单指</span></li><li><span class="name">case MotionEvent.ACTION_DOWN:</span><ul><li><span class="name">matrix.set(view.getImageMatrix());</span></li><li><span class="name">savedMatrix.set(matrix);</span></li><li><span class="name">startPoint.set(event.getX(), event.getY());</span></li><li><span class="name">mode = DRAG;</span></li><li><span class="name">break;</span></li></ul></li><li><span class="name">// 双指</span></li><li><span class="name">case MotionEvent.ACTION_POINTER_DOWN:</span><ul><li><span class="name">oriDis = distance(event);</span></li><li><span class="name">if (oriDis &gt; 10f) {</span><ul><li><span class="name">savedMatrix.set(matrix);</span></li><li><span class="name">midPoint = middle(event);</span></li><li><span class="name">mode = ZOOM;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">break;</span></li></ul></li><li><span class="name">// 手指放开</span></li><li><span class="name">case MotionEvent.ACTION_UP:</span></li><li><span class="name">case MotionEvent.ACTION_POINTER_UP:</span><ul><li><span class="name">mode = NONE;</span></li><li><span class="name">break;</span></li></ul></li><li><span class="name">// 单指滑动事件</span></li><li><span class="name">case MotionEvent.ACTION_MOVE:</span><ul><li><span class="name">if (mode == DRAG) {</span><ul><li><span class="name">// 是一个手指拖动</span></li><li><span class="name">matrix.set(savedMatrix);</span></li><li><span class="name">matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y);</span></li></ul></li><li><span class="name">} else if (mode == ZOOM) {</span><ul><li><span class="name">// 两个手指滑动</span></li><li><span class="name">float newDist = distance(event);</span></li><li><span class="name">if (newDist &gt; 10f) {</span><ul><li><span class="name">matrix.set(savedMatrix);</span></li><li><span class="name">float scale = newDist / oriDis;</span></li><li><span class="name">matrix.postScale(scale, scale, midPoint.x, midPoint.y);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">break;</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 设置ImageView的Matrix</span></li><li><span class="name">view.setImageMatrix(matrix);</span></li><li><span class="name">return true;</span></li></ul></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 计算两个触摸点之间的距离</span></li><li><span class="name">private float distance(MotionEvent event) {</span><ul><li><span class="name">float x = event.getX(0) - event.getX(1);</span><ul><li><span class="name">float y = event.getY(0) - event.getY(1);</span></li><li><span class="name">return FloatMath.sqrt(x * x + y * y);</span></li></ul></li></ul></li><li><span class="name">}</span></li><li><span class="name">// 计算两个触摸点的中点</span></li><li><span class="name">private PointF middle(MotionEvent event) {</span><ul><li><span class="name">float x = event.getX(0) + event.getX(1);</span><ul><li><span class="name">float y = event.getY(0) + event.getY(1);</span></li><li><span class="name">return new PointF(x / 2, y / 2);</span></li></ul></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">响应系统设置的事件(Configuration类)</span><ul><li><span class="name">Configuration类是用来描述手机设备的配置信息的，比如屏幕方向，触摸屏的触摸方式等，代码在 frameworks/base/core/java/android/content/res/Configuration.java.</span></li><li><span class="name">方法列表</span><ul><li><span class="name">densityDpi：屏幕密度</span></li><li><span class="name">fontScale：当前用户设置的字体的缩放因子</span></li><li><span class="name">hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：</span><ul><li><span class="name">HARDKEYBOARDHIDDEN_NO,  十六进制的0</span></li><li><span class="name">HARDKEYBOARDHIDDEN_YES，十六进制的1</span></li></ul></li><li><span class="name">keyboard：获取当前关联额键盘类型：该属性的返回值：KEYBOARD_12KEY（只有12个键的小键盘）、KEYBOARD_NOKEYS、KEYBOARD_QWERTY（普通键盘）</span></li><li><span class="name">keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。</span></li><li><span class="name">locale：获取用户当前的语言环境</span></li><li><span class="name">mcc：获取移动信号的国家码</span></li><li><span class="name">mnc：获取移动信号的网络码</span></li><li><span class="name">ps:国家代码和网络代码共同确定当前手机网络运营商</span></li><li><span class="name">navigation：判断系统上方向导航设备的类型。该属性的返回值：NAVIGATION_NONAV（无导航）、 NAVIGATION_DPAD(DPAD导航）NAVIGATION_TRACKBALL（轨迹球导航）、NAVIGATION_WHEEL（滚轮导航）</span></li><li><span class="name">orientation：获取系统屏幕的方向。该属性的返回值：ORIENTATION_LANDSCAPE（横向屏幕）、ORIENTATION_PORTRAIT（竖向屏幕）</span></li><li><span class="name">screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示</span></li><li><span class="name">touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：</span><ul><li><span class="name">TOUCHSCREEN_NOTOUCH（无触摸屏）</span></li><li><span class="name">TOUCHSCREEN_STYLUS（触摸笔式触摸屏）</span></li><li><span class="name">TOUCHSCREEN_FINGER（接收手指的触摸屏）</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">例子:</span></li><li><span class="name">// 在AndroidManifest.xml添加下述内容</span></li><li><span class="name">权限:&nbsp;&lt; uses-permission android:name="android.permission.CHANGE_CONFIGURATION" /&gt;</span></li><li><span class="name">在&lt; activity标签中添加:android:configChanges="orientation"&nbsp;将targetSdkVersion改为12以上的,12也可以.</span></li><li><span class="name">public class MainActivity extends Activity {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">protected void onCreate(Bundle savedInstanceState) {</span><ul><li><span class="name">super.onCreate(savedInstanceState);</span></li><li><span class="name">setContentView(R.layout.activity_main);</span></li><li><span class="name">Button btn = (Button) findViewById(R.id.btncahange);</span></li><li><span class="name">btn.setOnClickListener(new OnClickListener() {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onClick(View v) {</span><ul><li><span class="name">Configuration config = getResources().getConfiguration();</span></li><li><span class="name">//如果是横屏的话切换成竖屏</span></li><li><span class="name">if(config.orientation == Configuration.ORIENTATION_LANDSCAPE) {</span><ul><li><span class="name">MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span></li></ul></li><li><span class="name">}</span></li><li><span class="name">//如果竖屏的话切换成横屏</span></li><li><span class="name">if(config.orientation == Configuration.ORIENTATION_PORTRAIT) {</span><ul><li><span class="name">MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li><li><span class="name">}</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onConfigurationChanged(Configuration newConfig) {</span><ul><li><span class="name">super.onConfigurationChanged(newConfig);</span></li><li><span class="name">String screen = newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE?"横屏":"竖屏";</span></li><li><span class="name">Toast.makeText(MainActivity.this, "系统屏幕方向发生改变 \n 修改后的方向为" + screen, Toast.LENGTH_SHORT).show();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">Gestures(手势)</span><ul><li><span class="name">在应用中通过手势来操作会大大提升用户体验.</span></li><li><span class="name">手势交互的执行顺序</span><ul><li><span class="name">1.手指触碰屏幕时，触发MotionEvent事件.</span></li><li><span class="name">2.该事件被OnTouchListener监听，可在它的onTouch()方法中获得该MotionEvent对象.</span></li><li><span class="name">3.通过GestureDetector转发MotionEvent对象给OnGestureListener.</span></li><li><span class="name">4.我们可以通过OnGestureListener获得该对象，然后获取相关信息，以及做相关处理.</span></li></ul></li><li><span class="name">GestureListener 提供了下述回调方法：</span><ul><li><span class="name">按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。</span></li><li><span class="name">抛掷（onFling）： 手指在触摸屏上迅速移动，并松开的动作。</span></li><li><span class="name">长按（onLongPress）： 手指按在持续一段时间，并且没有松开。</span></li><li><span class="name">滚动（onScroll）： 手指在触摸屏上滑动。</span></li><li><span class="name">按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。</span></li><li><span class="name">抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。</span></li></ul></li><li><span class="name">知道了GestureListener的相关方法后，实现手势检测也很简单，步骤如下：</span><ul><li><span class="name">创建GestureDetector对象，创建时需实现GestureListener传入</span></li><li><span class="name">将Activity或者特定组件上的TouchEvent的事件交给GestureDetector处理.</span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name">系统事件</span><ul><li><span class="name">点击home键后, 系统会发出一个 Intent_Action_Close_System_Dialogs 的广播.</span></li></ul></li></ul>
  </body>
</html>