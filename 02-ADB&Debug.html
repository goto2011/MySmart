<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>02-ADB&amp;Debug</b></span></span><ul><li><span class="name"><span class="innerContentContainer">调试工具包</span></span><ul><li><span class="name"><span class="innerContentContainer">AVD：&nbsp;(android virtual machine):安卓虚拟设备,就是安卓的模拟器 --性能差，基本不可用</span></span></li><li><span class="name"><span class="innerContentContainer">ADT：&nbsp;(android development tools)安卓开发工具</span></span></li><li><span class="name"><span class="innerContentContainer">DDMS：(dalvik debug monitor service)安卓调试工具</span></span></li><li><span class="name"><span class="innerContentContainer">adb：安卓调试桥, 在sdk的platform-tools目录下.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>结构化分析问题</b></span></span><ul><li><span class="name"><span class="innerContentContainer">1. 读出指定应用的PID, 过滤Log --用于复现问题抓log，快速定位</span></span><ul><li><span class="name"><span class="innerContentContainer">寻找指定应用PID的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep 'Start proc' "   // 用于启动应用的场景</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell "ps | grep 'com.android.settings' "   // 用于应用已经启动起来的场景.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抓指定PID的log</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat -c"   // 清旧Log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep &lt;PID&gt; " &gt; 1.log</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 确定应用线程和包名</span></span><ul><li><span class="name"><span class="innerContentContainer">Start proc</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager: Start proc \d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 有时上面这个方法不行，原因是进程启动在log窗口之前，那么就直接跟踪activity切换流。</span></span></li><li><span class="name"><span class="innerContentContainer">4. 跟踪activity切换流。这个对跟踪用户操作流，进而理解问题本质价值很大</span></span><ul><li><span class="name"><span class="innerContentContainer">START u0|Relayout Window| wm_on_resume_called| Changing focus from Window</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager: START u0&nbsp;{\w+ com.android.settings</span></span></li><li><span class="name"><span class="innerContentContainer">WindowManager: Relayout Window{\w+ &nbsp;u0 com.android.settings</span></span></li><li><span class="name"><span class="innerContentContainer">wm_on_resume_called: \[\d+,com.android.settings]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4.1 读出前台应用</span></span><ul><li><span class="name"><span class="innerContentContainer">前台窗口: adb shell " dumpsys window displays | grep mCurrentFocus"</span></span></li><li><span class="name"><span class="innerContentContainer">前台应用: adb shell " dumpsys window displays | grep mFocusedApp"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4.2 读出屏幕分辨率、应用窗口大小等: adb shell " dumpsys window displays | grep init"</span></span></li><li><span class="name"><span class="innerContentContainer">5. 针对稳定性问题，跟踪AMS杀进程的流程   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Killing|am_kill</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager:&nbsp;Killing&nbsp;\d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 时刻关注丢帧, GC, Log溢出的情况, 因为系统资源衰竭的时候, 各种奇怪的事都会发生</span></span><ul><li><span class="name"><span class="innerContentContainer">垃圾回收： Starting a blocking GC Alloc|GC freed|am_low_memory|force_gc</span></span></li><li><span class="name"><span class="innerContentContainer">丢帧： Choreographer: Skipped</span></span><ul><li><span class="name"><span class="innerContentContainer">当掉帧数超过SKIPPED_FRAME_WARNING_LIMIT（默认30帧）时会打印.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log溢出： identical</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 警惕binder异常  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,<a class="contentLink" target="_blank" rel="noreferrer" href="http://com.starbucks.cn">com.starbucks.cn</a>,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span></li><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer"><b>940: delay的时长(单位: 毫秒)   --关键</b></span></span></li><li><span class="name"><span class="innerContentContainer">com.starbucks.cn: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比.</span></span></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">waitForResponse: binder卡住, 在堆栈中可见.</span></span></li><li><span class="name"><span class="innerContentContainer">audioserver_binder_timeout: binder超时 </span></span><ul><li><span class="name"><span class="innerContentContainer">(command|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">参见: Binder问题分析方法</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">官方Log注释</span></span><ul><li><span class="name"><span class="innerContentContainer">原生代码中其实有大量的关键log的文档. 这类文档叫 event.logtags.</span></span></li><li><span class="name"><span class="innerContentContainer">其数据格式是: event|1|5</span></span></li><li><span class="name"><span class="innerContentContainer">event表示含义;</span></span></li><li><span class="name"><span class="innerContentContainer">第一个数字表示数据类型, 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">1: int</span></span></li><li><span class="name"><span class="innerContentContainer">2: long</span></span></li><li><span class="name"><span class="innerContentContainer">3: string</span></span></li><li><span class="name"><span class="innerContentContainer">4: list</span></span></li><li><span class="name"><span class="innerContentContainer">5: float</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二个数字表示数据属性, 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">1: Number of objects</span></span></li><li><span class="name"><span class="innerContentContainer">2: Number of bytes</span></span></li><li><span class="name"><span class="innerContentContainer">3: Number of milliseconds</span></span></li><li><span class="name"><span class="innerContentContainer">4: Number of allocations</span></span></li><li><span class="name"><span class="innerContentContainer">5: Id</span></span></li><li><span class="name"><span class="innerContentContainer">6: Percent</span></span></li><li><span class="name"><span class="innerContentContainer">s: Number of seconds (monotonic time)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Input Log关键字</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Input</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://blog.csdn.net/DroidPhone/article/details/8432055">https://blog.csdn.net/DroidPhone/article/details/8432055</a></span></span></li><li><span class="name"><span class="innerContentContainer">常规： Inputreader|inputdispatcher|inputmanager_dispatch|InputTransport|PhoneWindowManager|processMotionEvent|dispatchPointerEvent</span></span></li><li><span class="name"><span class="innerContentContainer">View 处理触摸事件： processMotionEvent </span></span><ul><li><span class="name"><span class="innerContentContainer">Input log开关不打开时，这个打印也有，所以方便。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置input模式：setInputDispatchMode</span></span><ul><li><span class="name"><span class="innerContentContainer">包括正常，禁用，冻结三种模式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>input rawdata： Input event</b></span></span><ul><li><span class="name"><span class="innerContentContainer">其中，device 即设备ID</span></span></li><li><span class="name"><span class="innerContentContainer">Type, 事件类型.</span></span><ul><li><span class="name"><span class="innerContentContainer">0, EV_SYN，同步事件。因为一个事件要保上报多次，所以需要同步事件来确认整个事件上报完毕。</span></span></li><li><span class="name"><span class="innerContentContainer">1, EV_KEY，描述键盘，按键或者类似键盘设备的状态变化。</span></span></li><li><span class="name"><span class="innerContentContainer">2, EV_REL，用来描述相对坐标轴上数值的变化，例如：鼠标向左方移动了5个单位。</span></span></li><li><span class="name"><span class="innerContentContainer">3, EV_ABS, 用来描述坐标轴上数值的变化，例如：描述触摸屏上坐标的值。</span></span></li><li><span class="name"><span class="innerContentContainer">4, EV_MSC, 当不能匹配现有的类型时，使用该类型。</span></span></li><li><span class="name"><span class="innerContentContainer">5, EV_SW, 描述具备两种状态的输入开关。</span></span></li><li><span class="name"><span class="innerContentContainer">17, EV_LED, 控制设备上的LED灯的开和关。</span></span></li><li><span class="name"><span class="innerContentContainer">18, EV_SND, 用来给设备输出提示声音。</span></span></li><li><span class="name"><span class="innerContentContainer">20, EV_REP, 用于可以自动重复的设备（autorepeating）。</span></span></li><li><span class="name"><span class="innerContentContainer">21, EV_FF, 用来给输入设备发送强制回馈命令。</span></span></li><li><span class="name"><span class="innerContentContainer">22, EV_PWR, 用于电源开关的输入。</span></span></li><li><span class="name"><span class="innerContentContainer">23, EV_FF_STATUS, 用于接收设备的强制反馈状态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">code，指键值，即键的ID. 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">code值依赖 type字段, 相当于type的进一步说明.</span></span></li><li><span class="name"><span class="innerContentContainer">EV_KEY</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式，比如，KEY_A代表键盘上的A键.</span></span></li><li><span class="name"><span class="innerContentContainer">当一个按键被按下时，一个带有按键编码和value为1的事件被发出。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个按键被释放时，一个value为0的事件被发出。</span></span></li><li><span class="name"><span class="innerContentContainer">有些硬件当按键重复时会发出事件，这些事件的value值为2。</span></span></li><li><span class="name"><span class="innerContentContainer">通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。</span></span></li><li><span class="name"><span class="innerContentContainer">几个特殊的codes:</span></span></li><li><span class="name"><span class="innerContentContainer">116, 0x74, power键</span></span></li><li><span class="name"><span class="innerContentContainer">115, 0x73, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">114, 0x72, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_&lt;name&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">BTN_TOOL_PEN, 0x140</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_RUBBER, 0x141</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_BRUSH, 0x142</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_PENCIL, 0x143</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_AIRBRUSH, 0x144</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_FINGER, 0x145</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_MOUSE, 0x146</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_LENS, 0x147</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_QUINTTAP, 0x148</span></span></li><li><span class="name"><span class="innerContentContainer">这些codes用于配合触控板，平板和触摸屏这些设备的输入，这些设备可以使用手指，笔或者其它工具。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个事件发生并且检测到某种工具在使用时，相应的BTN_TOOL_&lt;name&gt; code事件应该把value设为1，</span></span></li><li><span class="name"><span class="innerContentContainer">当该工具不再和输入设备进行交互时，value应该复位为0。</span></span></li><li><span class="name"><span class="innerContentContainer">所有的触控板，当事件发生时，平板和触摸屏映泰至少使用一种BTN_TOOL_&lt;name&gt; code。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">0x14a, BTN_TOUCH, 触摸屏</span></span><ul><li><span class="name"><span class="innerContentContainer">用于触摸事件。当一个输入工具被判定为有意义的物理接触时，这一特性的value值应该设为1。</span></span></li><li><span class="name"><span class="innerContentContainer">所谓有意义的物理接触可以是任何的接触，又或者是满足某种定义条件的接触。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，触摸板可以当触摸的压力达到某一个值以上时才把value设为1，一个用笔的平板当笔划过但没有接触到平板的表面时，把BTN_TOOL_PEN的value设为1，而把BTN_TOUCH的value设为0.</span></span></li><li><span class="name"><span class="innerContentContainer">出于历史的原因，用户空间会把带有BTN_TOOL_FINGER和 BTN_TOUCH的触摸设备解释为触摸板，而类似的不带BTN_TOOL_FINGER的触摸设备则被解释为触摸屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">0x14b，BTN_STYLUS, 手写笔</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP,BTN_TOOL_TRIPLETAP, BTN_TOOL_QUADTAP</span></span><ul><li><span class="name"><span class="innerContentContainer">这些codes表明一个，两个，三个和四个手指参与触摸板和触摸屏的操作。</span></span></li><li><span class="name"><span class="innerContentContainer">如果用户使用两只手指在触摸板上试图滚动屏幕上的内容，在运动期间，应该发送value为1的BTN_TOOL_DOUBLETAP。</span></span></li><li><span class="name"><span class="innerContentContainer">在多手指触摸驱动中，应该使用input_mt_report_finger_count()函数来发出以上这些codes，详情请参看内核文档：multi-touch-protocol.txt。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EV_REL</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_REL事件描述了某种特性的相对变化量。例如，鼠标向左方移动了几个单位距离，但是他的绝对位置是未知的。</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们可以知道绝对位置，那我们应该使用EV_ABS而不是EV_REL。</span></span></li><li><span class="name"><span class="innerContentContainer">下面这些属于EV_REL的codes有特别的意义：</span></span></li><li><span class="name"><span class="innerContentContainer">REL_WHEEL, REL_HWHEEL:</span></span><ul><li><span class="name"><span class="innerContentContainer">用于对应的垂直方向和水平方向的滚轮。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EV_ABS</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_ABS事件描述了某一特性的绝对变化值，例如，触摸板会用它发出当前位置的绝对坐标值。</span></span></li><li><span class="name"><span class="innerContentContainer">以下这些属于EV_ABS的 codes有特殊的意义：</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_DISTANCE:</span></span></li><li><span class="name"><span class="innerContentContainer">用来描述触摸工具离触摸表面的距离。这一事件应该只有当触摸工具在表面悬空滑过时发出，也就是说，在靠经触摸表面，但是BTN_TOUCH的value是0的时候。如果输入设备可以工作在3维坐标时，应该考虑使用ABS_Z会更好。</span></span><ul><li><span class="name"><span class="innerContentContainer">ABS_MT_&lt;name&gt;:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用于描述多手指触摸输入设备。详情请参考内核文档：multi-touch-protocol.txt。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">value，指具体值</span></span><ul><li><span class="name"><span class="innerContentContainer">1 表示按下</span></span></li><li><span class="name"><span class="innerContentContainer">0 表示抬起</span></span></li><li><span class="name"><span class="innerContentContainer">触摸事件时，value表示坐标。x, y轴是分开上报的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件上报： notifyMotion|notifyKey|dispatchMotion|dispatchKey</b></span></span><ul><li><span class="name"><span class="innerContentContainer">分为两组，前者在入队列前打印，后两者在分发前打印。两组内容基本一样，仅policyFlags可能会发生变化。</span></span></li><li><span class="name"><span class="innerContentContainer">各枚举字段的含义在 input.h 中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">eventTime, 事件上报时间</span></span></li><li><span class="name"><span class="innerContentContainer">downTime, down事件时间。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，所有非down的事件，它的downTime不等于自己的eventTime，而是等于上一次的eventTime。</span></span></li><li><span class="name"><span class="innerContentContainer">凡是不满足这个条件的，都是非法事件，会被过滤掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">deviceId： 设备id。即hal层input设备id。</span></span><ul><li><span class="name"><span class="innerContentContainer">R版本上，注入的事件都写入 -1。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">source，设备类型</span></span><ul><li><span class="name"><span class="innerContentContainer">触屏： 0x1002</span></span></li><li><span class="name"><span class="innerContentContainer">键盘： 0x101</span></span></li><li><span class="name"><span class="innerContentContainer">鼠标： 0x2002</span></span></li><li><span class="name"><span class="innerContentContainer">手写笔： 0x4002</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">policyFlags： 即wms窗口策略。 重要</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 保持系统唤醒</span></span></li><li><span class="name"><span class="innerContentContainer">2, 是虚拟导航按键</span></span></li><li><span class="name"><span class="innerContentContainer">4, 是特殊功能修饰健（Ctrl、shift 之类）</span></span></li><li><span class="name"><span class="innerContentContainer">8, </span></span></li><li><span class="name"><span class="innerContentContainer">0x100 0000，注入的事件</span></span></li><li><span class="name"><span class="innerContentContainer">0x200 0000，可信的</span></span></li><li><span class="name"><span class="innerContentContainer">0x400 0000， 过滤的</span></span></li><li><span class="name"><span class="innerContentContainer">0x800 0000， 禁用自动重复事件。</span></span></li><li><span class="name"><span class="innerContentContainer">0x2000 0000，交互的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">0x4000 0000，事件要传递到应用层，即 PASS_TO_USER.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">action: 事件类型。重要。</span></span><ul><li><span class="name"><span class="innerContentContainer">0： down</span></span></li><li><span class="name"><span class="innerContentContainer">1： up</span></span></li><li><span class="name"><span class="innerContentContainer">2： move</span></span></li><li><span class="name"><span class="innerContentContainer">3： cancel</span></span></li><li><span class="name"><span class="innerContentContainer">4： outside</span></span></li><li><span class="name"><span class="innerContentContainer">7： hover move</span></span></li><li><span class="name"><span class="innerContentContainer">9： hover enter</span></span></li><li><span class="name"><span class="innerContentContainer">10： hover exit</span></span></li><li><span class="name"><span class="innerContentContainer">11： button press</span></span></li><li><span class="name"><span class="innerContentContainer">12： button release</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">actionButton： 按键类型，比如左键、中键、右键之类。</span></span></li><li><span class="name"><span class="innerContentContainer">flags： 标记</span></span><ul><li><span class="name"><span class="innerContentContainer">对于触摸事件，用于标记点位发生在屏幕边界，分上下左右。--不常用。</span></span></li><li><span class="name"><span class="innerContentContainer">对于按键事件，这个字段重要多了。</span></span><ul><li><span class="name"><span class="innerContentContainer">2，软键盘产生的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">8, 事件来自系统，不可被应用屏蔽。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Precision: 分x、y轴, 屏幕密度，一般是1。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>keyCode: 按键键值(逻辑)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">在 Keycodes.h 和 KeyEvent.java 中定义，两者保持一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">在 InputEventLabels.h 中引用。如果要写入，这三处要保持一致。</span></span></li><li><span class="name"><span class="innerContentContainer">fwk和应用使用keyCode。</span></span></li><li><span class="name"><span class="innerContentContainer">常见键值包括：</span></span></li><li><span class="name"><span class="innerContentContainer">26, 0x1a, KEYCODE_POWER，power键</span></span></li><li><span class="name"><span class="innerContentContainer">24, 0x18, KEYCODE_VOLUME_UP, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">25, 0x19, KEYCODE_VOLUME_DOWN, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">4, KEYCODE_BACK</span></span></li><li><span class="name"><span class="innerContentContainer">3, KEYCODE_HOME</span></span></li><li><span class="name"><span class="innerContentContainer">187, 0xBB, KEYCODE_APP_SWITCH.</span></span></li><li><span class="name"><span class="innerContentContainer">82，0x52，KEYCODE_MENU.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>scanCode: 按键键值(硬件)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">输入设备上报的值。在 framework/base/data/keyboards 目录下的各 *.kl 文件中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">116, 0x74, power键</span></span></li><li><span class="name"><span class="innerContentContainer">115, 0x73, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">114, 0x72, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">102, 0x66, home键</span></span></li><li><span class="name"><span class="innerContentContainer">158, 0x9e, back键</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">metaState: 键盘，标识 Ctrl、ALT等按键的状态。 参见 ameta_none</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>触摸屏报点： Pointer</b></span></span><ul><li><span class="name"><span class="innerContentContainer">id：点的序号，从0开始，一些input事件有多个点。</span></span></li><li><span class="name"><span class="innerContentContainer">toolType： 触摸工具类型。</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 手指</span></span></li><li><span class="name"><span class="innerContentContainer">2, 手写笔</span></span></li><li><span class="name"><span class="innerContentContainer">3, 鼠标</span></span></li><li><span class="name"><span class="innerContentContainer">4, 橡皮擦 ？</span></span></li><li><span class="name"><span class="innerContentContainer">5, 手掌 ？</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">x, y： 点坐标</span></span></li><li><span class="name"><span class="innerContentContainer">pressure: 按下压力值。用于按压屏或者手写笔。</span></span></li><li><span class="name"><span class="innerContentContainer">size： 触摸区域的大小（近似值）。0到1之间。</span></span></li><li><span class="name"><span class="innerContentContainer">touchMajor, tohchMinor, 触摸区域的长轴和短轴（单位为像素）</span></span></li><li><span class="name"><span class="innerContentContainer">toolMajor, toolMinor, 触摸根工具的长轴和短轴 （单位为像素）</span></span></li><li><span class="name"><span class="innerContentContainer">这4个值一般一样。</span></span></li><li><span class="name"><span class="innerContentContainer">orientation: 屏幕方向，0表示竖屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">channel 发送事件的流程</span></span><ul><li><span class="name"><span class="innerContentContainer">enqueueDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">prepareDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">startDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">publishMotionEvent</span></span></li><li><span class="name"><span class="innerContentContainer">finishDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">sendFinishedSignal</span></span></li><li><span class="name"><span class="innerContentContainer">receiveFinishedSignal </span></span><ul><li><span class="name"><span class="innerContentContainer">注意，errno=11 并不是什么错误。意思是当前处理过程被其它进程打断，后续调度回来会继续处理，不会影响业务。这种错误id很常见。</span></span></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">取得焦点窗口： Focus entered window</span></span></li><li><span class="name"><span class="innerContentContainer"><b>事件注入： injectInputEvent|should inject</b></span></span><ul><li><span class="name"><span class="innerContentContainer">injectorPid: 注入线程id</span></span></li><li><span class="name"><span class="innerContentContainer">injectorUid: 注入线程uid</span></span></li><li><span class="name"><span class="innerContentContainer">Finished with result to 0: 注入成功。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件拦截： interceptKeyBeforeQueueing|interceptKeyBeforeDispatching</span></span></li><li><span class="name"><span class="innerContentContainer">事件cancel： InputDispatcher: cancel</span></span><ul><li><span class="name"><span class="innerContentContainer">各字段含义和 notify Motion相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件cancel的原因：cancellation events</span></span><ul><li><span class="name"><span class="innerContentContainer">其中，channel, cancel</span></span></li><li><span class="name"><span class="innerContentContainer">synthesized，被cancel的事件的数量</span></span></li><li><span class="name"><span class="innerContentContainer">mode，cancel模式</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 点事件</span></span></li><li><span class="name"><span class="innerContentContainer">2, 非点事件</span></span></li><li><span class="name"><span class="innerContentContainer">3, callback事件</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件被跳过： skipping inconsistent motion event</span></span></li><li><span class="name"><span class="innerContentContainer">事件删除： Dropping</span></span><ul><li><span class="name"><span class="innerContentContainer">第二个关键字是删除原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件过滤： filter|shouldInterceptEventLocked </span></span></li><li><span class="name"><span class="innerContentContainer">事件冲突： Conflicting pointer actions</span></span></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">设备识别： Device added|New device|Input event</span></span><ul><li><span class="name"><span class="innerContentContainer">其中，id 后面用得比较多。</span></span></li><li><span class="name"><span class="innerContentContainer">classes 为设备类型，为掩码量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">光标显示： unfade|fade|cursor</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏切换： Device reconfigured</span></span><ul><li><span class="name"><span class="innerContentContainer">其中，size： 屏幕坐标</span></span></li><li><span class="name"><span class="innerContentContainer">orientation： 0表示竖屏, 1表示横屏。</span></span></li><li><span class="name"><span class="innerContentContainer">mode： 设备模式，参见 DeviceMode.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Sensor</span></span><ul><li><span class="name"><span class="innerContentContainer">hal层上报数据：sensors-hal|ap_sensors</span></span></li><li><span class="name"><span class="innerContentContainer">服务： SensorManager|SensorService</span></span></li><li><span class="name"><span class="innerContentContainer">接近光： proximity</span></span></li><li><span class="name"><span class="innerContentContainer">加速度： accelerometer</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Window / View / 动画</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>焦点窗口切换</b>： Set focused app to|Changing focus from</span></span></li><li><span class="name"><span class="innerContentContainer">创建task stack： wm_stack_created</span></span><ul><li><span class="name"><span class="innerContentContainer">StackId: 指activity task ID</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将window移动到top 或 bottom： wm_task_moved</span></span><ul><li><span class="name"><span class="innerContentContainer">(TaskId|1|5), (ToTop|1), (Index|1)</span></span></li><li><span class="name"><span class="innerContentContainer">Totop: 1表示top，0表示bottom</span></span></li><li><span class="name"><span class="innerContentContainer">index： target position的值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">移除task： wm_task_removed</span></span><ul><li><span class="name"><span class="innerContentContainer">(TaskId|1|5),  (Reason|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Reason: 移除原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">窗口大小： Rect</span></span></li><li><span class="name"><span class="innerContentContainer">surfaces内存溢出: wm_no_surface_memory <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">(Window|3),(PID|1|5),(Operation|3) </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">bootanim finished: wm_boot_animation_done  (time|2|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>屏幕状态</b></span></span><ul><li><span class="name"><span class="innerContentContainer">分辨率/屏幕大小： 搜 width，height，crop</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕宽度一般是1080，直接搜1080</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">刷新率: fps</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏切换： orientation， 0, 竖屏； 1, 横屏</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏高度： StatusBar</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systemui / 导航栏 / 状态栏 / 通知栏</span></span><ul><li><span class="name"><span class="innerContentContainer">SystemUi</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟导航栏： NavigationBar</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏： StatusBar</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏</span></span><ul><li><span class="name"><span class="innerContentContainer">通知被取消： notification_cancel</span></span></li><li><span class="name"><span class="innerContentContainer">通知被点击： notification_action_clicked</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏被点击： notification_clicked</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏扩展或收缩： notification_expansion</span></span></li><li><span class="name"><span class="innerContentContainer">新通知显示状态改变： notification_visibility_changed</span></span><ul><li><span class="name"><span class="innerContentContainer">新的显示状态，旧的显示状态</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">显示通知栏： notification_panel_revealed</span></span></li><li><span class="name"><span class="innerContentContainer">隐藏通知栏： notification_panel_hidden</span></span></li><li><span class="name"><span class="innerContentContainer">模块全部通知取消： notification_cancel_all</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： cancel原因，监听者</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通知取消： notification_cancel</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： cancel原因，监听者</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通知： notification_enqueue</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： uid, pid, 包名，id, tag, userid, notificatin, status(0=post, 1=update, 2=ignored)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">sysui_view_visibility (category|1|5),(visible|1|6)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_action (category|1|5),(pkg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_multi_action (content|4)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_count (name|3),(increment|1)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_histogram (name|3),(bucket|1)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏 / 唤醒睡眠 / 屏幕亮度</span></span><ul><li><span class="name"><span class="innerContentContainer">亮灭屏原因： power_screen_state</span></span><ul><li><span class="name"><span class="innerContentContainer">1. offOrOn: 0, 灭；1，亮</span></span></li><li><span class="name"><span class="innerContentContainer">2. because: 亮灭屏原因</span></span><ul><li><span class="name"><span class="innerContentContainer">参见 PowerManager.java， 300行。</span></span></li><li><span class="name"><span class="innerContentContainer">亮屏</span></span><ul><li><span class="name"><span class="innerContentContainer">0, 其它原因</span></span></li><li><span class="name"><span class="innerContentContainer">1, 按键</span></span></li><li><span class="name"><span class="innerContentContainer">2, 应用</span></span></li><li><span class="name"><span class="innerContentContainer">3, 设备插入</span></span></li><li><span class="name"><span class="innerContentContainer">4, 手势</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灭屏</span></span><ul><li><span class="name"><span class="innerContentContainer">0, 应用请求</span></span></li><li><span class="name"><span class="innerContentContainer">2, 屏幕超时</span></span></li><li><span class="name"><span class="innerContentContainer">4, power键</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏： onScreenChanged|PowerManagetService</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕亮灭: <b>screen_toggled</b> (screen_state|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">0 : screen off</span></span></li><li><span class="name"><span class="innerContentContainer">1 : screen on</span></span></li><li><span class="name"><span class="innerContentContainer">2 : 已锁屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏广播： power_screen_broadcast_send|power_screen_broadcast_done</span></span><ul><li><span class="name"><span class="innerContentContainer">wakelockCount: 发送广播的数量</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕亮度变化： Brightness</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕亮度变化： auto_brightness_adj</span></span><ul><li><span class="name"><span class="innerContentContainer">其中, old_lux: 旧的环境光度</span></span></li><li><span class="name"><span class="innerContentContainer">old_brightness： 旧的屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer">new_lux：新的环境光度</span></span></li><li><span class="name"><span class="innerContentContainer">new_brightness： 新的屏幕亮度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ams点亮屏幕（开机过程）： boot_progress_enable_screen  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService calls enableScreenAfterBoot().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灭屏时被清空的应用持有唤醒数量： power_sleep_requested</span></span></li><li><span class="name"><span class="innerContentContainer">锁屏类型: lock_screen_type (type|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity / 应用进程</span></span><ul><li><span class="name"><span class="innerContentContainer">新建activity： Relayout Window|DecorView setVisibility</span></span></li><li><span class="name"><span class="innerContentContainer">activity启动： start U0|am_create_task|am_create_activity|am_restart_activity|am_on_create_called|am_on_start_called|am_on_restart_called|am_relaunch_resume_activity|am_relaunch_activity</span></span></li><li><span class="name"><span class="innerContentContainer">Activity 显示到界面上：am_task_to_front|am_resume_activity|am_on_resume_called|Displayed</span></span></li><li><span class="name"><span class="innerContentContainer"><b>启动activity耗时: am _activity_launch_time  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">am_activity_launch_time:[0,225986022, com.android.camera/.Camera, 19823]</span></span></li><li><span class="name"><span class="innerContentContainer">其中 19823 是绘制的毫秒数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity绘制时间： am_activity_fully_drawn_time <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">已经存在的activity接受新的intent: am_new_intent</span></span><ul><li><span class="name"><span class="innerContentContainer">数据结构: (User|1|5),(Token|1|5),(Task ID|1|5),(Component Name|3),(Action|3),(MIME Type|3),(URI|3),(Flags|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity结束： am_finish_activity|am_destroy_activity|am_stop_activity|am_on_stop_called|am_on_destroy_called</span></span><ul><li><span class="name"><span class="innerContentContainer">am_destroy_activity 有reasen字段.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程优先级调整: adj \ d+</span></span></li><li><span class="name"><span class="innerContentContainer">activity从栈中被移除： am_remove_task</span></span><ul><li><span class="name"><span class="innerContentContainer">数据是两个整数，前者是task id，后者是stack id。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">recent(运行历史)显示： startRecentsActivity</span></span></li><li><span class="name"><span class="innerContentContainer">Application 线程绑定到工作队列: am_proc_bound</span></span></li><li><span class="name"><span class="innerContentContainer">Stack focus: am_focused_stack</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (Display Id|1|5), (Focused Stack Id|1|5), (Last Focused Stack Id|1|5), (Reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">The activity's onTopResumedActivityChanged(true) has been called: am_on_top_resumed_gained_called</span></span></li><li><span class="name"><span class="innerContentContainer">The activity's onTopResumedActivityChanged(false) has been called:  am_on_top_resumed_lost_called</span></span></li><li><span class="name"><span class="innerContentContainer">An activity been add into stopping list: am_add_to_stopping</span></span></li><li><span class="name"><span class="innerContentContainer">回调onActivityResult: am_on_activity_result_called</span></span></li><li><span class="name"><span class="innerContentContainer">暂停activity: am_pause_activity|am_on_paused_called|am_set_resumed_activity</span></span></li><li><span class="name"><span class="innerContentContainer">activity启动异常: am_proc_bad|am_process_start_timeout|am_failed_to_pause</span></span></li><li><span class="name"><span class="innerContentContainer">activity恢复正常: am_proc_good</span></span></li><li><span class="name"><span class="innerContentContainer">应用启动： Start proc|New app record|am_proc_start|am_pre_boot</span></span></li><li><span class="name"><span class="innerContentContainer">进程处理事件： handleMessage, what   --有的有, 有的没有.</span></span></li><li><span class="name"><span class="innerContentContainer">Usb对话框： showMtpDialog : mode</span></span></li><li><span class="name"><span class="innerContentContainer">应用清理（会造成应用退出）： Clearing app   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">attach进程失败(找不到pid)： am_drop_process  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Task 被压缩: am_compact</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (Pid|1|5),(Process Name|3),(Action|3),(BeforeRssTotal|2|2),(BeforeRssFile|2|2),(BeforeRssAnon|2|2),(BeforeRssSwap|2|2),(DeltaRssTotal|2|2),(DeltaRssFile|2|2),(DeltaRssAnon|2|2),(DeltaRssSwap|2|2),(Time|2|3),(LastAction|1|2),(LastActionTimestamp|2|3),(setAdj|1|2),(procState|1|2),(BeforeZRAMFree|2|2),(DeltaZRAMFree|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">any processes of a uid have started running:  am_uid_running</span></span></li><li><span class="name"><span class="innerContentContainer">all processes of a uid have stopped:  am_uid_stopped</span></span></li><li><span class="name"><span class="innerContentContainer">the state of a uid has become active:  am_uid_active</span></span></li><li><span class="name"><span class="innerContentContainer">the state of a uid has become idle (background check enforced):  am_uid_idle</span></span></li><li><span class="name"><span class="innerContentContainer">a service is being forcibly stopped because its app went idle:  am_stop_idle_service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">全局手势</span></span></li><li><span class="name"><span class="innerContentContainer">launcher / 桌面</span></span><ul><li><span class="name"><span class="innerContentContainer">桌面应用点击： launcher.itemclickhandler</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">稳定性 Log关键字 <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">crash开始： beginning of crash</span></span></li><li><span class="name"><span class="innerContentContainer"><b>AMS杀进程: Killing|am_kill</b></span></span><ul><li><span class="name"><span class="innerContentContainer">am_kill 是event log，数据是：</span></span><ul><li><span class="name"><span class="innerContentContainer"> (User|1|5), (PID|1|5), (Process Name|3), (OomAdj|1|5), (<b>Reason</b>|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Killing 是logcat。</span></span></li><li><span class="name"><span class="innerContentContainer">这两个log是一一对应的。</span></span></li><li><span class="name"><span class="innerContentContainer">最有价值的字段是reason。常见的有几种：</span></span><ul><li><span class="name"><span class="innerContentContainer">user request after error： 进程遇到错误自杀.</span></span></li><li><span class="name"><span class="innerContentContainer">empty: 空进程</span></span></li><li><span class="name"><span class="innerContentContainer">remove task: </span></span></li><li><span class="name"><span class="innerContentContainer">stop: 被强制杀死。比如通过 adb shell kill 这种。</span></span></li><li><span class="name"><span class="innerContentContainer">anr： 应用失去响应</span></span></li><li><span class="name"><span class="innerContentContainer">scheduleCrash for: 进程之前已经死掉</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中间的数字是adj。999就是空进程。</span></span></li><li><span class="name"><span class="innerContentContainer">如果杀进程的log太多，可只看指定进程的：</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager:&nbsp;Killing&nbsp;\d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用crash: am_crash</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Exception|3), (Message|3), (File|3), (Line|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ANR： ANR in|Input event dispatching timed out</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟机重启（进程会退出）： shutting down vm</span></span></li><li><span class="name"><span class="innerContentContainer">一级crash： crash|fatal|backtrace|died|goodbye|Androidruntime|am_crash|service crashed|java.lang.runtimeexception|exit zygote|Death received|am_proc_died|Sending signal|binderDied|lowmemorykiller</span></span></li><li><span class="name"><span class="innerContentContainer">二级crash：Err|fail|unexpected|system.err|java.lang|Systrace</span></span></li><li><span class="name"><span class="innerContentContainer">卡死冻屏: held by|blocked|caused by|locked|waiting on|locked</span></span></li><li><span class="name"><span class="innerContentContainer">activity ANR: am_anr</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (pid|1|5), (Package Name|3), (Flags|1|5), (reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_wtf: </span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Tag|3), (Message|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程短时间crash多次： am_process_crashed_too_much</span></span></li><li><span class="name"><span class="innerContentContainer">Watchdog</span></span><ul><li><span class="name"><span class="innerContentContainer">进程踢狗: tickle (authority|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog (Service|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_proc_pss (Process|3),(Pid|1|5),(Pss|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_soft_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2),(Skip|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_hard_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_pss_stats (EmptyPss|1|2),(EmptyCount|1|1),(BackgroundPss|1|2),(BackgroundCount|1|1),(ServicePss|1|2),(ServiceCount|1|1),(VisiblePss|1|2),(VisibleCount|1|1),(ForegroundPss|1|2),(ForegroundCount|1|1),(NoPssCount|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_proc_stats (DeathsInOne|1|1),(DeathsInTwo|1|1),(DeathsInThree|1|1),(DeathsInFour|1|1),(DeathsInFive|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_scheduled_reboot (Now|2|1),(Interval|1|3),(StartTime|1|3),(Window|1|3),(Skip|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_meminfo (MemFree|1|2),(Buffers|1|2),(Cached|1|2),(Active|1|2),(Inactive|1|2),(AnonPages|1|2),(Mapped|1|2),(Slab|1|2),(SReclaimable|1|2),(SUnreclaim|1|2),(PageTables|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_vmstat (runtime|2|3),(pgfree|1|1),(pgactivate|1|1),(pgdeactivate|1|1),(pgfault|1|1),(pgmajfault|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_requested_reboot (NoWait|1|1),(ScheduleInterval|1|3),(RecheckInterval|1|3),(StartTime|1|3),(Window|1|3),(MinScreenOff|1|3),(MinNextAlarm|1|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低内存杀进程: lowmemorykiller</span></span><ul><li><span class="name"><span class="innerContentContainer">lowmemorykiller: Killing ':accountservice' (15215) (tgid 15215), adj 965,</span></span><ul><li><span class="name"><span class="innerContentContainer">: to free 121500kB on behalf of 'kswapd0' (90) because</span></span></li><li><span class="name"><span class="innerContentContainer">: cache 1925820kB is below limit 347440kB for oom score 606</span></span></li><li><span class="name"><span class="innerContentContainer">: Free memory is -28000kB above reserved.</span></span></li><li><span class="name"><span class="innerContentContainer">: Free CMA is 17836kB</span></span></li><li><span class="name"><span class="innerContentContainer">: Total reserve is 133660kB</span></span></li><li><span class="name"><span class="innerContentContainer">: Total free pages is 150736kB</span></span></li><li><span class="name"><span class="innerContentContainer">: Total file cache is 2844160kB</span></span></li><li><span class="name"><span class="innerContentContainer">: GFP mask is 0x14000c0</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Total free pages is 150736kB，剩余内存仅有约150M。cache 1925820kB is below limit 347440kB，1925820kB &lt; 347440kB，显然矛盾。for oom score 606与adj 965也不一致。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低内存杀进程: killinfo</span></span><ul><li><span class="name"><span class="innerContentContainer">(Pid|1|5), (Uid|1|5), (OomAdj|1), (MinOomAdj|1), (TaskSize|1), (enum kill_reasons|1|5), (MemFree|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(Cached|1), (SwapCached|1), (Buffers|1), (Shmem|1), (Unevictable|1), (SwapTotal|1), (SwapFree|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(ActiveAnon|1), (InactiveAnon|1), (ActiveFile|1), (InactiveFile|1), (SReclaimable|1), (SUnreclaim|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(KernelStack|1), (PageTables|1), (IonHeap|1), (IonHeapPool|1), (CmaFree|1), (MsSinceEvent|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(MsSincePrevWakeup|1), (WakeupsSinceEvent|1), (SkippedWakeups|1)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">性能 Log关键字  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">丢帧： Choreographer: Skipped</span></span><ul><li><span class="name"><span class="innerContentContainer">当掉帧数超过SKIPPED_FRAME_WARNING_LIMIT（默认30帧）时会打印.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log溢出： identical</span></span></li><li><span class="name"><span class="innerContentContainer">CPU占用率: cpu</span></span><ul><li><span class="name"><span class="innerContentContainer">(total|1|6),(user|1|6),(system|1|6),(iowait|1|6),(irq|1|6),(softirq|1|6)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU占用率： CPU usage</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存 Log关键字  <span class="contentTag" title="Filter #问题内存">#<span class="contentTagText">问题内存</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">内存信息： am_meminfo</span></span><ul><li><span class="name"><span class="innerContentContainer">数据：(Cached|2|2), (Free|2|2), (Zram|2|2), (Kernel|2|2), (Native|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">pss信息： am_pss</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： (Pid|1|5), (UID|1|5), (Process Name|3), (Pss|2|2), (Uss|2|2), (SwapPss|2|2), (Rss|2|2), (StatType|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(ProcState|1|5), </span></span><ul><li><span class="name"><span class="innerContentContainer">进程状态，参见 ActivityManager.h. 其中2表示前台进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">(TimeToCollect|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">垃圾回收： Starting a blocking GC Alloc|GC freed|am_low_memory|force_gc</span></span></li><li><span class="name"><span class="innerContentContainer">强制垃圾回收: force_gc (reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其他模块 Log关键字</span></span><ul><li><span class="name"><span class="innerContentContainer">应用</span></span><ul><li><span class="name"><span class="innerContentContainer">GMS拒绝注册: gms_unknown</span></span></li><li><span class="name"><span class="innerContentContainer">联系人数量和查询时间: contacts_aggregation (aggregation time|2|3), (count|1|1)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">查询阶段 count为负，合并阶段 count为正.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单项被选中: menu_item_selected</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (Menu type where 0 is options and 1 is context|1|5), (Menu item title|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单打开: menu_opened</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (Menu type where 0 is options and 1 is context|1|5)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统</span></span><ul><li><span class="name"><span class="innerContentContainer">输入法： inputmethod</span></span></li><li><span class="name"><span class="innerContentContainer">音量调节： volume_changed| VOLUME_CHANGED_ACTION</span></span></li><li><span class="name"><span class="innerContentContainer">开机动画播放完成： wm_boot_animation_done  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">允许安装未知来源的应用： unknown_sources_enabled</span></span><ul><li><span class="name"><span class="innerContentContainer">1为允许</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">恢复出厂设置</span></span><ul><li><span class="name"><span class="innerContentContainer">重置统计： rescue_note</span></span></li><li><span class="name"><span class="innerContentContainer">重置等级： rescue_level</span></span></li><li><span class="name"><span class="innerContentContainer">重置成功： rescue_success</span></span></li><li><span class="name"><span class="innerContentContainer">重置失败： rescue_failure</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">存储分区统计： storage_state</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： uuid, old state, new state, 可用空间，总空间</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统重启： beginning of main|beginning of system </span></span></li><li><span class="name"><span class="innerContentContainer">底层模块启动: boot_progress_start (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">ZygoteInit 启动各模块: boot_progress_preload_start (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">ZygoteInit 启动结束: boot_progress_preload_end (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">启动Dalvik: dvm_lock_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式:  (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动ART: art_hidden_api_access</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (access_method|1),(flags|1),(class|3),(member|3),(type_signature|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ams就绪： boot_progress_ams_ready (数字是毫秒数)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService.systemReady() starts</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SystemServer 启动: boot_progress_system_run</span></span></li><li><span class="name"><span class="innerContentContainer">SystemServer 启动: system_server_start</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (start_count|1), (uptime|2|3), (elapse_time|2|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统进入桌面： system now ready  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">写系统文件: commit_sys_config_file (name|3),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">配置改变: configuration_changed</span></span></li><li><span class="name"><span class="innerContentContainer">切换用户（多用户, 子用户）</span></span><ul><li><span class="name"><span class="innerContentContainer">starting user|android.intent.action.USER_SWITCHED</span></span></li><li><span class="name"><span class="innerContentContainer">dispatchUserSwitch</span></span></li><li><span class="name"><span class="innerContentContainer">am_switch_user|am_user_state_changed，这些打印都没有用了。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">账户: sync</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (id|3), (event|1|5), (source|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(account|1|5), account是账号名的hash值.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">功耗 / 充电 / 电池</span></span><ul><li><span class="name"><span class="innerContentContainer">功耗service： PowerManagetService</span></span></li><li><span class="name"><span class="innerContentContainer">过滤power: intercept_power (action|3),(mPowerKeyHandled|1),(mPowerKeyPressCounter|1)</span></span></li><li><span class="name"><span class="innerContentContainer">电池电量： battery_level</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式： 电量，电压，温度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电状态： battery_status</span></span><ul><li><span class="name"><span class="innerContentContainer">第一个参数： 2，充电；3，放电；4，未充电；5，充满电。</span></span></li><li><span class="name"><span class="innerContentContainer">第二个参数：2，电池正常；3，过热；4，电池损坏；5，电压过高；6，未知故障；7，电池过冷。</span></span></li><li><span class="name"><span class="innerContentContainer">第三个参数：1，放电；0，充电</span></span></li><li><span class="name"><span class="innerContentContainer">第四个参数：1，AC直充；2，USB充电；4，无线充电</span></span></li><li><span class="name"><span class="innerContentContainer">第五个参数：电池类型，li-ion，锂电池。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">放电状态： battery_discharge</span></span><ul><li><span class="name"><span class="innerContentContainer">放电时长，最低电流，最高电量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">广播</span></span><ul><li><span class="name"><span class="innerContentContainer">接收广播： received broadcast|onReceive， 太多，请直接搜广播名</span></span></li><li><span class="name"><span class="innerContentContainer">忽略特定广播： am_broadcast_discard_filter|am_broadcast_discard_app</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： (User|1|5),(Broadcast|1|5),(Action|3),(Receiver Number|1|1),(BroadcastFilter|1|5) / (App|3)</span></span></li><li><span class="name"><span class="innerContentContainer">原因可能是: timeout/ANR/crash.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">音频</span></span><ul><li><span class="name"><span class="innerContentContainer">AudioFlinger| AudioTrack|AudioPolicy</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Camera</span></span><ul><li><span class="name"><span class="innerContentContainer">前后置切换: connect call</span></span><ul><li><span class="name"><span class="innerContentContainer">camera id 0: 后置</span></span></li><li><span class="name"><span class="innerContentContainer">camera id 1: 强制</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">闪光灯状态: </span></span></li><li><span class="name"><span class="innerContentContainer">生成缩略图: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Provider / SQL</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库写入： onSharedPreferenceChanged</span></span></li><li><span class="name"><span class="innerContentContainer">provider没有准备好： am_provider_lost_process</span></span></li><li><span class="name"><span class="innerContentContainer">数据库操作: db_sample  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (db|3),(sql|3),(time|1|3),(blocking_package|3),(sample_percent|1|6)</span></span></li><li><span class="name"><span class="innerContentContainer">db：数据库的文件名</span></span></li><li><span class="name"><span class="innerContentContainer">sql：已执行的查询（无查询参数）</span></span></li><li><span class="name"><span class="innerContentContainer">time：cpu时间戳，单位毫秒，包括锁定获取  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">blocking_package：如果在主线程上，则为程序包名称，否则为“”</span></span></li><li><span class="name"><span class="innerContentContainer">sample_percent：记录此查询的可能性百分比</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库写入： ***_upgrade_receiver (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_current (current|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_max (max|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_alloc_attempt (attempts|1|4)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_released (Memory released|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_db_corrupt (Database file corrupt|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">Selinux 权限检验失败  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">denied {execute/read/write} for </span></span></li><li><span class="name"><span class="innerContentContainer">其中校验目标即 comm字段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">security_adb_shell_interactive</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_shell_command&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(command|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_sync_recv&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_sync_send&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_app_process_start&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(process|3),(start_time|2|3),(uid|1),(pid|1),(seinfo|3),(sha256|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_dismissed</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_dismiss_auth_attempt&nbsp; &nbsp;(success|1),(method_strength|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_secured</span></span></li><li><span class="name"><span class="innerContentContainer">security_os_startup&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (boot_state|3),(verity_mode|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_os_shutdown</span></span></li><li><span class="name"><span class="innerContentContainer">security_logging_started</span></span></li><li><span class="name"><span class="innerContentContainer">security_logging_stopped</span></span></li><li><span class="name"><span class="innerContentContainer">security_media_mounted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3),(label|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_media_unmounted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3),(label|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_log_buffer_size_critical</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_expiration_set&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(timeout|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_complexity_set&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(length|1),(quality|1),(num_letters|1),(num_non_letters|1),(num_numeric|1),(num_uppercase|1),(num_lowercase|1),(num_symbols|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_history_length_set&nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(length|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_max_screen_lock_timeout_set&nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(timeout|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_max_password_attempts_set&nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(num_failures|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_disabled_features_set&nbsp; (package|3),(admin_user|1),(target_user|1),(features|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_remote_lock&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_wipe_failed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_generated&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_imported&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_destroyed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_user_restriction_added&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (package|3),(admin_user|1),(restriction|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_user_restriction_removed&nbsp; &nbsp; &nbsp; &nbsp; (package|3),(admin_user|1),(restriction|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_authority_installed&nbsp; &nbsp; &nbsp; &nbsp; (success|1),(subject|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_authority_removed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (success|1),(subject|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_crypto_self_test_completed&nbsp; &nbsp; &nbsp; (success|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_integrity_violation&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_validation_failure&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Service</span></span><ul><li><span class="name"><span class="innerContentContainer">创建： am_create_service</span></span></li><li><span class="name"><span class="innerContentContainer">销毁： am_destroy_service</span></span></li><li><span class="name"><span class="innerContentContainer">启动： startService</span></span></li><li><span class="name"><span class="innerContentContainer">Service多次crash： am_service_crashed_too_much</span></span><ul><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">绑定, 解绑：  bindService|unbindService</span></span></li><li><span class="name"><span class="innerContentContainer">统计绑定了多少个客户端： total connections for service</span></span></li><li><span class="name"><span class="innerContentContainer">重启： am_schedule_service_restart</span></span></li><li><span class="name"><span class="innerContentContainer">访问统计: service_manager_stats (call_count|1), (total_time|1|3), (duration|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">响应迟缓: service_manager_slow (time|1|3), (service|3)</span></span></li><li><span class="name"><span class="innerContentContainer">服务空闲而关闭： am_stop_idle_service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PackageManagerService</span></span><ul><li><span class="name"><span class="innerContentContainer">Package Manager starts: boot_progress_pms_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan starts: boot_progress_pms_system_scan_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan starts: boot_progress_pms_data_scan_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan ends: boot_progress_pms_scan_end (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager ready: boot_progress_pms_ready (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">check activity_launch_time for Home app: Value of "unknown sources" setting at app install time:  unknown_sources_enabled (value|1)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager critical info: pm_critical_info (msg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Disk usage stats for verifying quota correctness: pm_package_stats </span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (manual_time|2|3),(quota_time|2|3),(manual_data|2|2),(quota_data|2|2),(manual_cache|2|2),(quota_cache|2|2)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">WiFi / 网络</span></span><ul><li><span class="name"><span class="innerContentContainer">网络流量统计： netstats_mobile_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">字段太多，网上补充</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Wifi 流量统计： netstats_wifi_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">字段太多，网上补充</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">wifi状态改变: wifi_state_changed (wifi_state|3)</span></span></li><li><span class="name"><span class="innerContentContainer">事件分发: wifi_event_handled (wifi_event|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">[15 - 0] HSM event (as defined in WifiStateTracker.java)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Supplicant状态改变: wifi_supplicant_state_changed (supplicant_state|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">[8 - 0] Supplicant state (as defined in SupplicantState.java)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Location</span></span><ul><li><span class="name"><span class="innerContentContainer">定位成功, 上报位置数据: location_controller</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Web / HTTP / WebView</span></span><ul><li><span class="name"><span class="innerContentContainer">NTP成功: ntp_success (server|3),(rtt|2),(offset|2)</span></span></li><li><span class="name"><span class="innerContentContainer">NTP失败: ntp_failure (server|3),(msg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">http_stats (useragent|3),(response|2|3),(processing|2|3),(tx|1|2),(rx|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">viewroot_layout (Layout time|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">view_build_drawing_cache (View created drawing cache|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">view_use_drawing_cache (View drawn using bitmap cache|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_zoom_level_change (start level|1|5),(end level|1|5),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">viewroot_draw (Draw time|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_double_tap_duration (duration|1|3),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_snap_center</span></span></li><li><span class="name"><span class="innerContentContainer">exp_det_attempt_to_call_object_getclass (app_signature|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LibC异常</span></span><ul><li><span class="name"><span class="innerContentContainer">bionic_event_memcpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcat_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_memmov_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncat_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_memset_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcat_integer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncat_integer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_old_response (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_wrong_server (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_wrong_query (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">exp_det_cert_pin_failure (certs|4)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时区</span></span><ul><li><span class="name"><span class="innerContentContainer">时区： timezone</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_trigger_received (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_read_from_data_app (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_uninstall (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_install (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_nothing (token_bytes|3), (success|1)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">ADB命令</span></span><ul><li><span class="name"><span class="innerContentContainer">重启及刷机</span></span><ul><li><span class="name"><span class="innerContentContainer">adb reboot</span></span></li><li><span class="name"><span class="innerContentContainer">高通EDL模式(快速刷机): adb reboot edl</span></span></li><li><span class="name"><span class="innerContentContainer">刷机: fastboot</span></span><ul><li><span class="name"><span class="innerContentContainer">fastboot 刷机即线刷，通过USB刷机。要求在PC上有刷机工具。</span></span></li><li><span class="name"><span class="innerContentContainer">重启到bootloader：adb reboot bootloader</span></span></li><li><span class="name"><span class="innerContentContainer">在fastboot 中也可以进 EDL: fastboot oem edl</span></span></li><li><span class="name"><span class="innerContentContainer">下载一个分区： fastboot flash boot boot.img</span></span></li><li><span class="name"><span class="innerContentContainer">重启到recovery，即恢复模式：adb reboot recovery</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">刷机: recovery</span></span><ul><li><span class="name"><span class="innerContentContainer">recovery 刷机即卡刷，通过sd卡刷机。</span></span></li><li><span class="name"><span class="innerContentContainer">adb reboot recovery</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">安全模式: 开机过程中，显示静态logo时按下音量下，进入安全模式。</span></span></li><li><span class="name"><span class="innerContentContainer">导出应用的apk文件</span></span><ul><li><span class="name"><span class="innerContentContainer">找包名： adb shell pm list package</span></span></li><li><span class="name"><span class="innerContentContainer">找apk安装路径： adb shell pm path + 包名</span></span></li><li><span class="name"><span class="innerContentContainer">adb pull 即可。</span></span></li><li><span class="name"><span class="innerContentContainer">Google play商店的包名是： com.android.vending </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ADB连接</span></span><ul><li><span class="name"><span class="innerContentContainer">读出ADB版本: adb version</span></span></li><li><span class="name"><span class="innerContentContainer">等待设备连接上: adb wait-for-device</span></span></li><li><span class="name"><span class="innerContentContainer">以root方式运行: adb root</span></span></li><li><span class="name"><span class="innerContentContainer">查看连接中的设备：adb devices.  返回 device-ID 列表. 可用于其它命令. 适用于多设备连接的场景.</span></span></li><li><span class="name"><span class="innerContentContainer">指定设备: 所有adb命令都支持 -s &lt;device-ID&gt;开关, 以指定设备.</span></span></li><li><span class="name"><span class="innerContentContainer">读出设备序列号：adb get-serialno</span></span></li><li><span class="name"><span class="innerContentContainer">读出设备状态: adb get-state</span></span><ul><li><span class="name"><span class="innerContentContainer">设备的状态有 3 钟，device&nbsp;,&nbsp;offline&nbsp;,&nbsp;unknown</span></span></li><li><span class="name"><span class="innerContentContainer">device：设备正常连接</span></span></li><li><span class="name"><span class="innerContentContainer">offline：连接出现异常，设备无响应</span></span></li><li><span class="name"><span class="innerContentContainer">unknown：没有连接设备</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">终止adb服务进程：adb kill-server</span></span></li><li><span class="name"><span class="innerContentContainer">重启adb服务进程：adb start-server</span></span></li><li><span class="name"><span class="innerContentContainer">查看ADB帮助：adb help</span></span></li><li><span class="name"><span class="innerContentContainer">问题解决: 5037端口被占用</span></span><ul><li><span class="name"><span class="innerContentContainer">报错： cannot connect to 127.0.0.1:5037</span></span></li><li><span class="name"><span class="innerContentContainer">解决办法：netstat -ano | findstr "3037"  。 找到进程号后，杀掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将PC上的某个端口重定向到设备的某个端口:  db forward tcp:1314 tcp:8888</span></span></li><li><span class="name"><span class="innerContentContainer">关闭 USB 调试模式: adb shell settings put global adb_enabled 0</span></span></li><li><span class="name"><span class="innerContentContainer">无线连接 ADB 方法1</span></span><ul><li><span class="name"><span class="innerContentContainer">手机、PC处于相同的网络下，手机 root ，安装应用 adbWireless ，启动应用后点击界面中间的按钮</span></span></li><li><span class="name"><span class="innerContentContainer">运行 adb connect 192.168.1.102&nbsp;, 即可通过无线的方式连接手机，缺点是速度比较慢</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无线连接 ADB 方法2</span></span><ul><li><span class="name"><span class="innerContentContainer">usb连接接手机, 输入命令: adb tcpip 5555</span></span><ul><li><span class="name"><span class="innerContentContainer">restarting in TCP mode port: 5555</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拔掉手机, 输入命令: adb connect 192.168.0.44:5555  (手机IP地址)</span></span><ul><li><span class="name"><span class="innerContentContainer">connected to 192.168.11.117:5555</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">无线连接 ADB 方法3</span></span><ul><li><span class="name"><span class="innerContentContainer">上面两个方法都需要usb支持, 本方法不需要.</span></span></li><li><span class="name"><span class="innerContentContainer">在 Android 设备上安装一个终端模拟器。下载地址是: <a class="contentLink" target="_blank" rel="noreferrer" href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></span></span></li><li><span class="name"><span class="innerContentContainer">将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</span></span></li><li><span class="name"><span class="innerContentContainer">打开 Android 设备上的终端模拟器执行：su setprop service.adb.tcp.port 5555</span></span><ul><li><span class="name"><span class="innerContentContainer">如果失败, restart adbd</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">找到 Android 设备的 IP 地址。</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell ifconfig | grep Mask ，读出</span></span></li><li><span class="name"><span class="innerContentContainer">也可在 设置 - 关于手机 - 状态信息 - IP地址 中查询.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在电脑上通过 adb 和 IP 地址连接 Android 设备: adb connect &lt;device-ip-address&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">如果能看到&nbsp;connected to &lt;device-ip-address&gt;:5555&nbsp;这样的输出则表示连接成功。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>常见调试命令</b></span></span><ul><li><span class="name"><span class="innerContentContainer">通过文件名搜路径： find -name <a class="contentLink" target="_blank" rel="noreferrer" href="http://hidl.so">hidl.so</a></span></span></li><li><span class="name"><span class="innerContentContainer">打开指针位置： adb shell settings put system pointer_location 1</span></span></li><li><span class="name"><span class="innerContentContainer">打开布局边界： adb shell setprop debug.layout true</span></span></li><li><span class="name"><span class="innerContentContainer">更改屏幕休眠时间: adb shell settings put system screen_off_timeout 300000    // 半小时</span></span></li><li><span class="name"><span class="innerContentContainer">写入屏幕亮度: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">启动 Monkey：adb shell monkey -v -p &lt;apk&gt; 50000</span></span></li><li><span class="name"><span class="innerContentContainer">截图/截屏：adb exec-out screencap -p &gt; sc.png</span></span><ul><li><span class="name"><span class="innerContentContainer">老方法: adb shell screencap /sdcard/DCIM/1.png. 然后 adb push.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">录屏:  adb shell screenrecord /sdcard/record.mp4  --bugreport</span></span><ul><li><span class="name"><span class="innerContentContainer">最长录制时间是 180 秒。</span></span></li><li><span class="name"><span class="innerContentContainer">bugreport参数会在视频中添加时间戳。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送文本内容(不能发中文):  adb shell input text test123456</span></span></li><li><span class="name"><span class="innerContentContainer">压缩文件（压缩log）： tar -cvf</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>模拟按键</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>模拟按键事件:  adb shell input keyevent &lt;KEYCODE&gt;</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>KEYCODE</b>在 KeyEvent.java 中定义，有：</span></span></li><li><span class="name"><span class="innerContentContainer">3	HOME 键</span></span></li><li><span class="name"><span class="innerContentContainer">4	返回键</span></span></li><li><span class="name"><span class="innerContentContainer">5	打开拨号应用</span></span></li><li><span class="name"><span class="innerContentContainer">6	挂断电话</span></span></li><li><span class="name"><span class="innerContentContainer">24	增加音量</span></span></li><li><span class="name"><span class="innerContentContainer">25	降低音量</span></span></li><li><span class="name"><span class="innerContentContainer">26	电源键</span></span></li><li><span class="name"><span class="innerContentContainer">27	拍照（打开拍照应用）</span></span></li><li><span class="name"><span class="innerContentContainer">64	打开浏览器</span></span></li><li><span class="name"><span class="innerContentContainer">82	菜单键</span></span></li><li><span class="name"><span class="innerContentContainer">85	播放/暂停</span></span></li><li><span class="name"><span class="innerContentContainer">86	停止播放</span></span></li><li><span class="name"><span class="innerContentContainer">87	播放下一首</span></span></li><li><span class="name"><span class="innerContentContainer">88	播放上一首</span></span></li><li><span class="name"><span class="innerContentContainer">122	移动光标到行首或列表顶部</span></span></li><li><span class="name"><span class="innerContentContainer">123	移动光标到行末或列表底部</span></span></li><li><span class="name"><span class="innerContentContainer">126	恢复播放</span></span></li><li><span class="name"><span class="innerContentContainer">127	暂停播放</span></span></li><li><span class="name"><span class="innerContentContainer">164	静音</span></span></li><li><span class="name"><span class="innerContentContainer">176	打开系统设置</span></span></li><li><span class="name"><span class="innerContentContainer">187	切换应用</span></span></li><li><span class="name"><span class="innerContentContainer">207	打开联系人</span></span></li><li><span class="name"><span class="innerContentContainer">208	打开日历</span></span></li><li><span class="name"><span class="innerContentContainer">209	打开音乐</span></span></li><li><span class="name"><span class="innerContentContainer">210	打开计算器</span></span></li><li><span class="name"><span class="innerContentContainer">220	降低屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer">221	提高屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer"><b>223	 系统休眠</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>224	 点亮屏幕</b></span></span></li><li><span class="name"><span class="innerContentContainer">231	打开语音助手</span></span></li><li><span class="name"><span class="innerContentContainer">276	如果没有 wakelock 则让系统休眠</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">模拟触摸事件:  adb shell input tap 500 500</span></span></li><li><span class="name"><span class="innerContentContainer">模拟滑动解锁(前提是没有设锁屏密码): adb shell input swipe 300 1000 300 500</span></span></li><li><span class="name"><span class="innerContentContainer">模拟滑动事件:  adb shell input swipe 900 500 100 500</span></span></li><li><span class="name"><span class="innerContentContainer">模拟长按事件: adb shell input swipe 500 500 501 501 2000</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Prop项&amp;Features</span></span><ul><li><span class="name"><span class="innerContentContainer">写入prop项（重启不失效）： pull 到本地，用写字板写入，然后再push回去，改权限644，最后重启。</span></span></li><li><span class="name"><span class="innerContentContainer">读出prop值:  adb shell getprop ro.build.version.sdk</span></span></li><li><span class="name"><span class="innerContentContainer">写入prop项： adb shell setprop ***=0/1/true/false</span></span><ul><li><span class="name"><span class="innerContentContainer">重启后失效</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出feature值: </span></span><ul><li><span class="name"><span class="innerContentContainer">有两个命令。结果不太一样。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell pm list features</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell dumpsys package f</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕分辨率</span></span><ul><li><span class="name"><span class="innerContentContainer">读出: adb shell wm size</span></span><ul><li><span class="name"><span class="innerContentContainer">返回值大概是: Physical size: 1080x1920   // 物理</span></span></li><li><span class="name"><span class="innerContentContainer">Override size: 480x1024   // 软件写入的</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写入: adb shell wm size 800x1600</span></span></li><li><span class="name"><span class="innerContentContainer">复原: adb shell wm size reset</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕刷新率</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell " while( true); do dumpsys SurfaceFlinger | gerp refresh-rate; sleep 1; done"</span></span></li><li><span class="name"><span class="innerContentContainer">r版本后，开发人员选项支持刷新率显示，菜单是 功能标记 - 显示刷新率。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">像素密度, density</span></span><ul><li><span class="name"><span class="innerContentContainer">写入: adb shell wm density n (n=1, 2, 3)</span></span></li><li><span class="name"><span class="innerContentContainer">复原: adb shell wm densit reset</span></span></li><li><span class="name"><span class="innerContentContainer">读出: adb shell wm density</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕密度: adb shell getprop&nbsp;ro.sf.lcd_density</span></span></li><li><span class="name"><span class="innerContentContainer">读出屏幕状态:  adb shell dumpsys display</span></span><ul><li><span class="name"><span class="innerContentContainer">返回值大概是:</span></span></li><li><span class="name"><span class="innerContentContainer">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span></span><ul><li><span class="name"><span class="innerContentContainer">Display: mDisplayId=0</span></span></li><li><span class="name"><span class="innerContentContainer">init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span></span></li><li><span class="name"><span class="innerContentContainer">deferred=false layoutNeeded=false</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中&nbsp;mDisplayId&nbsp;为 显示屏编号，init&nbsp;是初始分辨率和屏幕密度，app&nbsp;的高度比&nbsp;init&nbsp;里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出亮度模式: adb shell settings get system screen_brightness_mode</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前亮度值: adb shell settings get system screen_brightness</span></span></li><li><span class="name"><span class="innerContentContainer">读出屏幕休眠时间: adb shell settings get system screen_off_timeout</span></span></li><li><span class="name"><span class="innerContentContainer">更改亮度值（亮度值在0—255之间）: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">更改休眠时间，10分钟: adb shell settings put system screen_off_timeout 600000</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏和导航栏的显示隐藏: adb shell settings put global policy_control &lt;key-values&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">key-values 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">immersive.full	同时隐藏</span></span></li><li><span class="name"><span class="innerContentContainer">immersive.status	隐藏状态栏</span></span></li><li><span class="name"><span class="innerContentContainer">immersive.navigation	隐藏导航栏</span></span></li><li><span class="name"><span class="innerContentContainer">immersive.preconfirms	?</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这些键对应的值可则如下值用逗号组合：</span></span><ul><li><span class="name"><span class="innerContentContainer">apps	所有应用</span></span></li><li><span class="name"><span class="innerContentContainer">所有界面</span></span></li><li><span class="name"><span class="innerContentContainer">packagename	指定应用</span></span></li><li><span class="name"><span class="innerContentContainer">-packagename	排除指定应用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例如: adb shell settings put global policy_control immersive.full=*</span></span><ul><li><span class="name"><span class="innerContentContainer">表示设置应用在所有界面下都同时隐藏状态栏和导航栏。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Settings，系统设置</b></span></span><ul><li><span class="name"><span class="innerContentContainer">设置数据库位置</span></span><ul><li><span class="name"><span class="innerContentContainer">M版本及之前在： /data/data/com.android.providers.settings/databases</span></span></li><li><span class="name"><span class="innerContentContainer">M版本之后在： /data/system/users/0/，一个表一个XML，类似 settings_secure.xml。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对字段进行读写</span></span><ul><li><span class="name"><span class="innerContentContainer">读出设置项： adb shell settings get &lt;表名&gt; &lt;字段名&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">写入配置项： adb shell settings put &lt;表名&gt; &lt;字段名&gt; &lt;值&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">表名有： global, secure, system, config 等。</span></span></li><li><span class="name"><span class="innerContentContainer">字段名在 android.provider.Settings 中定义。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见读出命令</span></span><ul><li><span class="name"><span class="innerContentContainer">读出屏幕休眠时间: adb shell settings get system screen_off_timeout</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前亮度值: adb shell settings get system screen_brightness</span></span></li><li><span class="name"><span class="innerContentContainer">读出亮度模式: adb shell settings get system screen_brightness_mode</span></span></li><li><span class="name"><span class="innerContentContainer">读出 android_id: adb shell settings get secure android_id.  返回: 51b6be48bac8c569</span></span></li><li><span class="name"><span class="innerContentContainer">读出通过网络获取时间的状态: adb shell settings get global auto_time.   // 1为允许, 0为不允许</span></span></li><li><span class="name"><span class="innerContentContainer">读出默认输入法: adb shell settings get secure default_input_method   // com.sohu.inputmethod.sogouoem/.SogouIME  默认搜狗输入法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见写入命令</span></span><ul><li><span class="name"><span class="innerContentContainer">关闭 USB 调试模式: adb shell settings put global adb_enabled 0</span></span></li><li><span class="name"><span class="innerContentContainer">打开指针位置： adb shell settings put system pointer_location 1</span></span></li><li><span class="name"><span class="innerContentContainer">更改屏幕休眠时间: adb shell settings put system screen_off_timeout 300000    // 半小时</span></span></li><li><span class="name"><span class="innerContentContainer">写入屏幕亮度: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">更改亮度值（亮度值在0—255之间）: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">更改休眠时间，10分钟: adb shell settings put system screen_off_timeout 600000</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏和导航栏的显示隐藏: adb shell settings put global policy_control &lt;key-values&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">写入通过网络获取时间的状态: adb shell settings put global auto_time 1</span></span></li><li><span class="name"><span class="innerContentContainer">put命令更改默认输入法（将io.appium.android.ime/.UnicodeIME改为com.sohu.inputmethod.sogouoem/.SogouIME）</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell settings put secure default_input_method com.sohu.inputmethod.sogouoem/.SogouIME</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">直接打开指定页面</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 adb shell am start  &lt;页面&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">常见页面</span></span><ul><li><span class="name"><span class="innerContentContainer">开发者设置: com.android.settings.DevelopmentSettings</span></span></li><li><span class="name"><span class="innerContentContainer">设置主页面: adb shell am start com.android.settings/com.android.settings.Settings</span></span></li><li><span class="name"><span class="innerContentContainer">安全: adb shell am start com.android.settings/com.android.settings.SecuritySettings</span></span></li><li><span class="name"><span class="innerContentContainer">手机无线信息: adb shell am start com.android.settings/com.android.settings.RadioInfo</span></span></li><li><span class="name"><span class="innerContentContainer">电池信息: com.android.settings.BatteryInfo</span></span></li><li><span class="name"><span class="innerContentContainer">日期和时间设置: com.android.settings.DateTimeSettings</span></span></li><li><span class="name"><span class="innerContentContainer">关于手机: com.android.settings.DeviceInfoSettings</span></span></li><li><span class="name"><span class="innerContentContainer">选择手机语言: com.android.settings.LocalePicker</span></span></li><li><span class="name"><span class="innerContentContainer">正在运行的程序（服务）: com.android.settings.RunningServices</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它页面</span></span><ul><li><span class="name"><span class="innerContentContainer">com.android.settings.AccessibilitySettings: 辅助功能设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ActivityPicker: 选择活动</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ApnSettings: APN设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ApplicationSettings: 应用程序设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.BandMode: 设置GSM/UMTS波段</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DateTimeSettingsSetupWizard: 日期和时间设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DeviceAdminSettings: 设备管理器</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.Display: 显示-设置显示字体大小及预览</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DisplaySettings: 显示设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DockSettings: 底座设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.IccLockSettings: SIM卡锁定设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.InstalledAppDetails: 安装应用信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.LanguageSettings: 语言和键盘设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.LocalePickerInSetupWizard: 选择手机语言</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ManageApplications: 已下载（安装）软件列表</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.MasterClear: 恢复出厂设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.MediaFormat: 格式化手机闪存</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.PhysicalKeyboardSettings: 设置键盘</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.PrivacySettings: 隐私设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ProxySelector: 代理设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.RadioInfo: 手机信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.SecuritySettings: 位置和安全设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.Settings: 系统设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.WirelessSettings: 无线和网络设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.SettingsSafetyLegalActivity: 安全信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.SoundSettings: 声音设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.TestingSettings: 测试-显示手机信息、电池信息、使用情况统计、Wifi information、服务信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.TetherSettings: 绑定与便携式热点</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.TextToSpeechSettings: 文字转语音设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.UsageStats: 使用情况统计</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.UserDictionarySettings: 用户词典</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.VoiceInputOutputSettings: 语音输入与输出设置</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU</span></span><ul><li><span class="name"><span class="innerContentContainer">CPU信息: adb shell cat /proc/cpuinfo</span></span><ul><li><span class="name"><span class="innerContentContainer">输出范例如:</span></span></li><li><span class="name"><span class="innerContentContainer">Processor       : ARMv7 Processor rev 0 (v7l)</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 0</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 1</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 2</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 3</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</span></span></li><li><span class="name"><span class="innerContentContainer">CPU implementer : 0x51</span></span></li><li><span class="name"><span class="innerContentContainer">CPU architecture: 7</span></span></li><li><span class="name"><span class="innerContentContainer">CPU variant     : 0x2</span></span></li><li><span class="name"><span class="innerContentContainer">CPU part        : 0x06f</span></span></li><li><span class="name"><span class="innerContentContainer">CPU revision    : 0</span></span></li><li><span class="name"><span class="innerContentContainer">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</span></span></li><li><span class="name"><span class="innerContentContainer">Revision        : 000b</span></span></li><li><span class="name"><span class="innerContentContainer">Serial          : 0000000000000000</span></span></li><li><span class="name"><span class="innerContentContainer">这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是&nbsp;Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是&nbsp;ARMv7 Processor rev 0 (v71)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU型号: adb shell getprop ro.product.board</span></span></li><li><span class="name"><span class="innerContentContainer">CPU 支持的 abi 列表: adb shell getprop ro.product.cpu.abilist</span></span></li><li><span class="name"><span class="innerContentContainer">CPU 支持的 abi 列表: adb shell cat /system/build.prop | grep ro.product.cpu.abi</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设备</span></span><ul><li><span class="name"><span class="innerContentContainer">读出 android_id: adb shell settings get secure android_id.  返回: 51b6be48bac8c569</span></span></li><li><span class="name"><span class="innerContentContainer">设备型号: adb shell getprop ro.product.model . 返回: Nexus 5</span></span></li><li><span class="name"><span class="innerContentContainer">Android 系统版本: adb shell getprop ro.build.version.release. 返回: 5.0.2</span></span></li><li><span class="name"><span class="innerContentContainer">SDK版本号: adb shell getprop ro.build.version.sdk</span></span></li><li><span class="name"><span class="innerContentContainer">Android 安全补丁程序级别: adb shell getprop ro.build.version.security_patch</span></span></li><li><span class="name"><span class="innerContentContainer">品牌: adb shell getprop ro.product.brand</span></span></li><li><span class="name"><span class="innerContentContainer">设备名: adb shell getprop <a class="contentLink" target="_blank" rel="noreferrer" href="http://ro.product.name">ro.product.name</a></span></span></li><li><span class="name"><span class="innerContentContainer">是否支持 OTG: adb shell getprop persist.sys.isUsbOtgEnabled</span></span></li><li><span class="name"><span class="innerContentContainer">IMEI: adb shell su service call iphonesubinfo 1</span></span><ul><li><span class="name"><span class="innerContentContainer">输出的是二进制流, 要注意转化.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IP地址: adb shell ifconfig | grep Mask</span></span></li><li><span class="name"><span class="innerContentContainer">WiFi局域网IP: adb shell ifconfig wlan0</span></span></li><li><span class="name"><span class="innerContentContainer">国家码： getprop <a class="contentLink" target="_blank" rel="noreferrer" href="http://ro.com.google.clientidbase.ms">ro.com.google.clientidbase.ms</a></span></span><ul><li><span class="name"><span class="innerContentContainer">中国是 android-cn</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">综合网络状态: adb shell netcfg, 部分设备有效.</span></span></li><li><span class="name"><span class="innerContentContainer">MAC地址：adb shell cat /sys/class/net/wlan0/address</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">WIFI</span></span><ul><li><span class="name"><span class="innerContentContainer">打开WiFi: adb shell svc wifi enable</span></span></li><li><span class="name"><span class="innerContentContainer">关闭WiFi: adb shell svc wifi disable</span></span></li><li><span class="name"><span class="innerContentContainer">读出wifi状态: adb shell dumpsys wifi. 可以读出到当前连接的wifi名、搜索到的wifi列表、wifi强度等</span></span></li><li><span class="name"><span class="innerContentContainer">查看wifi密码：adb shell cat /data/misc/wifi/*.conf</span></span></li><li><span class="name"><span class="innerContentContainer">读出设备名称：adb shell cat /system/build.prop</span></span></li><li><span class="name"><span class="innerContentContainer">读出、写入wifi状态（wifi_on）、飞行模式（airlpane_mode_on）等，这里也是appium中 getNetworkConnection读出设备网络状态的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">读出通过网络获取时间的状态: adb shell settings get global auto_time.   // 1为允许, 0为不允许</span></span></li><li><span class="name"><span class="innerContentContainer">写入通过网络获取时间的状态: adb shell settings put global auto_time 1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电</span></span><ul><li><span class="name"><span class="innerContentContainer">读出设备电池状态: adb shell dumpsys battery / batterystats. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">Current Battery Service state:</span></span></li><li><span class="name"><span class="innerContentContainer">AC powered: false</span></span></li><li><span class="name"><span class="innerContentContainer">USB powered: true</span></span></li><li><span class="name"><span class="innerContentContainer">Wireless powered: false</span></span></li><li><span class="name"><span class="innerContentContainer">status: 2   // 电池状态</span></span></li><li><span class="name"><span class="innerContentContainer">health: 2</span></span></li><li><span class="name"><span class="innerContentContainer">present: true</span></span></li><li><span class="name"><span class="innerContentContainer"><b>level: 34   // 当前电量. 最重要.</b></span></span></li><li><span class="name"><span class="innerContentContainer">scale: 100  // 最大电量</span></span></li><li><span class="name"><span class="innerContentContainer">voltage: 3848</span></span></li><li><span class="name"><span class="innerContentContainer">current now: -427943</span></span></li><li><span class="name"><span class="innerContentContainer">temperature: 280   // 电池温度</span></span></li><li><span class="name"><span class="innerContentContainer">technology: Li-ion</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出电源管理状态: adb shell dumpsys power. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">是否处于锁屏状态：mWakefulness=Asleep或者mScreenOn=false</span></span></li><li><span class="name"><span class="innerContentContainer">亮度值：mScreenBrightness=255</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕休眠时间：Screen off timeout: 60000 ms</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕分辨率：mDisplayWidth=1440，mDisplayHeight=2560</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关闭充电功能： adb shell dumpsys battery unplug</span></span></li><li><span class="name"><span class="innerContentContainer">写入电量： adb shell dumpsys battery set level 19</span></span></li><li><span class="name"><span class="innerContentContainer">恢复充电功能： adb shell dumpsys battery reset</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">解锁 （执行remount前要解锁）</span></span><ul><li><span class="name"><span class="innerContentContainer">设置 - 开发人员选项 - OEM解锁，打开</span></span><ul><li><span class="name"><span class="innerContentContainer">OEM解锁在第一屏，如果灰掉，说明已经解锁(读出解锁状态)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb reboot bootloader</span></span></li><li><span class="name"><span class="innerContentContainer">fastboot flashing unlock, 然后按音量+选择unlock。</span></span></li><li><span class="name"><span class="innerContentContainer">fastboot reboot</span></span></li><li><span class="name"><span class="innerContentContainer">对于已经解锁的机器，也需要从这里开始执行。</span></span></li><li><span class="name"><span class="innerContentContainer">adb root</span></span></li><li><span class="name"><span class="innerContentContainer">adb disable-verity  // 禁用 dm_verity</span></span></li><li><span class="name"><span class="innerContentContainer">adb reboot</span></span></li><li><span class="name"><span class="innerContentContainer">adb root</span></span></li><li><span class="name"><span class="innerContentContainer">adb remount</span></span><ul><li><span class="name"><span class="innerContentContainer">成功时返回： remount succeeded</span></span></li><li><span class="name"><span class="innerContentContainer">如果失败，再执行一次，有时解决问题。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">启用 dm_verity: adb enable-verity</span></span></li><li><span class="name"><span class="innerContentContainer">查看SELinux状态： adb shell getenforce</span></span></li><li><span class="name"><span class="innerContentContainer">写入SELinux状态： adb shell setenforce 0/1</span></span><ul><li><span class="name"><span class="innerContentContainer">0 表示关闭</span></span></li><li><span class="name"><span class="innerContentContainer">1 表示打开</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出账号状态: adb shell dumpsys account</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存</span></span><ul><li><span class="name"><span class="innerContentContainer">每个应用程序的内存上限: adb shell getprop dalvik.vm.heapsize</span></span></li><li><span class="name"><span class="innerContentContainer"><b>查看设备cpu和内存占用情况：adb shell top</b></span></span><ul><li><span class="name"><span class="innerContentContainer">输出示例：</span></span></li><li><span class="name"><span class="innerContentContainer">User 0%, System 6%, IOW 0%, IRQ 0%</span></span></li><li><span class="name"><span class="innerContentContainer">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span></span></li><li><span class="name"><span class="innerContentContainer">PID PR CPU% S  # THR     VSS     RSS PCY UID      Name</span></span></li><li><span class="name"><span class="innerContentContainer">8763  0   3% R     1  10640K   1064K  fg shell    top</span></span></li><li><span class="name"><span class="innerContentContainer">131  0   3% S     1      0K      0K  fg root     dhd_dpc</span></span></li><li><span class="name"><span class="innerContentContainer">6144  0   0% S   115 1682004K 115916K  fg system   system_server</span></span></li><li><span class="name"><span class="innerContentContainer">132  0   0% S     1      0K      0K  fg root     dhd_rxf</span></span></li><li><span class="name"><span class="innerContentContainer">1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision</span></span></li><li><span class="name"><span class="innerContentContainer">217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd</span></span></li><li><span class="name"><span class="innerContentContainer">其中: </span></span><ul><li><span class="name"><span class="innerContentContainer">PID: 进程 ID</span></span></li><li><span class="name"><span class="innerContentContainer">PR: 优先级</span></span></li><li><span class="name"><span class="innerContentContainer">CPU%: 当前瞬间占用 CPU 百分比</span></span></li><li><span class="name"><span class="innerContentContainer">S: 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</span></span></li><li><span class="name"><span class="innerContentContainer"># THR: 线程数</span></span></li><li><span class="name"><span class="innerContentContainer">VSS	Virtual Set Size: 虚拟耗用内存（包含共享库占用的内存）</span></span></li><li><span class="name"><span class="innerContentContainer">RSS	Resident Set Size: 实际使用物理内存（包含共享库占用的内存）</span></span></li><li><span class="name"><span class="innerContentContainer">PCY: 调度策略优先级，SP_BACKGROUND/SPFOREGROUND</span></span></li><li><span class="name"><span class="innerContentContainer">UID: 进程所有者的用户 ID</span></span></li><li><span class="name"><span class="innerContentContainer">NAME: 进程名</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看占用内存前6的app：adb shell top -m 6</span></span></li><li><span class="name"><span class="innerContentContainer">刷新一次内存数据，然后返回：adb shell top -n 1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查询各进程内存使用情况：adb shell procrank</span></span></li><li><span class="name"><span class="innerContentContainer"><b>查看当前内存占用：adb shell cat /proc/meminfo</b></span></span><ul><li><span class="name"><span class="innerContentContainer">MemTotal:        1027424 kB    // 设备的总内存</span></span></li><li><span class="name"><span class="innerContentContainer">MemFree:          486564 kB   // 当前空闲内存</span></span></li><li><span class="name"><span class="innerContentContainer">Buffers:           15224 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Cached:            72464 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SwapCached:        24152 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Active:           110572 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Inactive:         259060 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Active(anon):      79176 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Inactive(anon):   207736 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Active(file):      31396 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Inactive(file):    51324 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Unevictable:        3948 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Mlocked:               0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">HighTotal:        409600 kB</span></span></li><li><span class="name"><span class="innerContentContainer">HighFree:         132612 kB</span></span></li><li><span class="name"><span class="innerContentContainer">LowTotal:         617824 kB</span></span></li><li><span class="name"><span class="innerContentContainer">LowFree:          353952 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SwapTotal:        262140 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SwapFree:         207572 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Dirty:                 0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Writeback:             0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">AnonPages:        265324 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Mapped:            47072 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Shmem:              1020 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Slab:              57372 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SReclaimable:       7692 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SUnreclaim:        49680 kB</span></span></li><li><span class="name"><span class="innerContentContainer">KernelStack:        4512 kB</span></span></li><li><span class="name"><span class="innerContentContainer">PageTables:         5912 kB</span></span></li><li><span class="name"><span class="innerContentContainer">NFS_Unstable:          0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Bounce:                0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">WritebackTmp:          0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">CommitLimit:      775852 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Committed_AS:   13520632 kB</span></span></li><li><span class="name"><span class="innerContentContainer">VmallocTotal:     385024 kB</span></span></li><li><span class="name"><span class="innerContentContainer">VmallocUsed:       61004 kB</span></span></li><li><span class="name"><span class="innerContentContainer">VmallocChunk:     209668 kB</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看IO内存分区：adb shell cat /proc/iomem</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分区和文件</span></span><ul><li><span class="name"><span class="innerContentContainer">将system分区重新挂载为可读写分区：adb remount</span></span></li><li><span class="name"><span class="innerContentContainer">从本地复制文件到设备：adb push &lt;local&gt; &lt;remote&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">从设备复制文件到本地：adb pull &lt;remote&gt;&nbsp; &lt;local&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">查看文件内容：adb shell cat &lt;file&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程</span></span><ul><li><span class="name"><span class="innerContentContainer">查看进程列表：adb shell ps</span></span></li><li><span class="name"><span class="innerContentContainer">读出指定进程号： adb shell "ps | grep camera"</span></span></li><li><span class="name"><span class="innerContentContainer">查看指定进程状态：adb shell ps -x [PID]</span></span></li><li><span class="name"><span class="innerContentContainer">杀死一个进程：adb shell kill [pid]</span></span></li><li><span class="name"><span class="innerContentContainer">读出线程数的上限: adb shell cat /proc/sys/kernel/threads_max</span></span><ul><li><span class="name"><span class="innerContentContainer">FindX 是 57798</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出同时打开文件数上限: adb shell cat /proc/sys/fs/file_max</span></span><ul><li><span class="name"><span class="innerContentContainer">FindX 是732094</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关闭 java 虚拟机: adb shell stop</span></span></li><li><span class="name"><span class="innerContentContainer">打开 java 虚拟机: adb shell start</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">APK包管理</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>安装APK：adb install &lt;apkfile&gt; . 参数有: </b></span></span><ul><li><span class="name"><span class="innerContentContainer">-r	允许覆盖安装</span></span></li><li><span class="name"><span class="innerContentContainer">-s	将应用安装到 sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">-d	允许降级覆盖安装</span></span></li><li><span class="name"><span class="innerContentContainer">-g	授予所有运行时权限</span></span></li><li><span class="name"><span class="innerContentContainer">-l	将应用安装到保护目录 /mnt/asec</span></span></li><li><span class="name"><span class="innerContentContainer">-t	允许安装 AndroidManifest.xml 里 application 指定&nbsp;android:testOnly="true"&nbsp;的应用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见安装失败输出代码、含义及可能的解决办法如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_ALREADY_EXISTS	应用已经存在，或卸载了但没卸载干净</span></span><ul><li><span class="name"><span class="innerContentContainer">adb install&nbsp;时使用&nbsp;-r&nbsp;参数，或者先&nbsp;adb uninstall &lt;packagename&gt;&nbsp;再安装</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INVALID_APK	无效的 APK 文件</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INVALID_URI	无效的 APK 文件名</span></span><ul><li><span class="name"><span class="innerContentContainer">确保 APK 文件名里无中文</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INSUFFICIENT_STORAGE	  空间不足</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_DUPLICATE_PACKAGE	已经存在同名程序</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_NO_SHARED_USER	请求的共享用户不存在</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_UPDATE_INCOMPATIBLE	以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</span></span><ul><li><span class="name"><span class="innerContentContainer">先&nbsp;adb uninstall &lt;packagename&gt;&nbsp;再安装</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_SHARED_USER_INCOMPATIBLE	请求的共享用户存在但签名不一致</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_MISSING_SHARED_LIBRARY	安装包使用了设备上不可用的共享库</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_REPLACE_COULDNT_DELETE	替换时无法删除</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_DEXOPT	dex 优化验证失败或空间不足</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_OLDER_SDK	设备系统版本低于应用要求</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_CONFLICTING_PROVIDER	设备里已经存在与应用里同名的 content provider</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_NEWER_SDK	设备系统版本高于应用要求</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_TEST_ONLY	应用是 test-only 的，但安装时没有指定&nbsp;-t&nbsp;参数</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_CPU_ABI_INCOMPATIBLE	包含不兼容设备 CPU 应用程序二进制接口的 native code</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_MISSING_FEATURE	应用使用了设备不可用的功能</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_CONTAINER_ERROR	1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用。</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INVALID_INSTALL_LOCATION	1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用。</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 切换安装位置，添加或删除&nbsp;-s&nbsp;参数;  2. 打包时不与 ROM 使用相同签名。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_MEDIA_UNAVAILABLE	安装位置不可用</span></span><ul><li><span class="name"><span class="innerContentContainer">一般为 sdcard，确认 sdcard 可用或安装到内置存储</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_VERIFICATION_TIMEOUT	验证安装包超时</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_VERIFICATION_FAILURE	验证安装包失败</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_PACKAGE_CHANGED	应用与调用程序期望的不一致</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_UID_CHANGED	以前安装过该应用，与本次分配的 UID 不一致</span></span><ul><li><span class="name"><span class="innerContentContainer">清除以前安装过的残留文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_VERSION_DOWNGRADE	已经安装了该应用更高版本</span></span><ul><li><span class="name"><span class="innerContentContainer">使用&nbsp;-d&nbsp;参数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE	已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_NOT_APK	指定路径不是文件，或不是以&nbsp;.apk&nbsp;结尾</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_BAD_MANIFEST	无法解析的 AndroidManifest.xml 文件</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION	解析器遇到异常</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_NO_CERTIFICATES	安装包没有签名</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES	已安装该应用，且签名与 APK 文件不一致	先卸载设备上的该应用，再安装</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING	解析 APK 文件时遇到&nbsp;CertificateEncodingException</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME	manifest 文件里没有或者使用了无效的包名</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID	manifest 文件里指定了无效的共享用户 ID</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_MANIFEST_MALFORMED	解析 manifest 文件时遇到结构性错误</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_MANIFEST_EMPTY	在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INTERNAL_ERROR	因系统问题安装失败</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_USER_RESTRICTED	用户被限制安装应用</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_DUPLICATE_PERMISSION	应用尝试定义一个已经存在的权限名称</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_NO_MATCHING_ABIS	应用包含设备的应用程序二进制接口不支持的 native code</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_CANCELED_BY_USER	应用安装需要在设备上确认，但未操作设备或点了取消	在设备上同意安装</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_ACWF_INCOMPATIBLE	应用程序与设备不兼容</span></span></li><li><span class="name"><span class="innerContentContainer">does not contain AndroidManifest.xml	无效的 APK 文件</span></span></li><li><span class="name"><span class="innerContentContainer">is not a valid zip file	无效的 APK 文件</span></span></li><li><span class="name"><span class="innerContentContainer">Offline	设备未连接成功	先将设备与 adb 连接成功</span></span></li><li><span class="name"><span class="innerContentContainer">unauthorized	设备未授权允许调试</span></span></li><li><span class="name"><span class="innerContentContainer">error: device not found	没有连接成功的设备</span></span><ul><li><span class="name"><span class="innerContentContainer">先将设备与 adb 连接成功</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">protocol failure	设备已断开连接</span></span><ul><li><span class="name"><span class="innerContentContainer">先将设备与 adb 连接成功</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Unknown option: -s	Android 2.2 以下不支持安装到 sdcard</span></span><ul><li><span class="name"><span class="innerContentContainer">不使用&nbsp;-s&nbsp;参数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">No space left on device	空间不足</span></span></li><li><span class="name"><span class="innerContentContainer">Permission denied ... sdcard ...	sdcard 不可用</span></span></li><li><span class="name"><span class="innerContentContainer">signatures do not match the previously installed version; ignoring!	已安装该应用且签名不一致</span></span><ul><li><span class="name"><span class="innerContentContainer">先卸载设备上的该应用，再安装</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">卸载APK：adb uninstall &lt;package&gt;. 参数 -k 表示保留数据和缓存目录.</span></span></li><li><span class="name"><span class="innerContentContainer">卸载app但保留数据和缓存文件：adb uninstall -k &lt;package&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">读出apk的packagename 和 classname:  aapt d badging &lt;apkfile&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">列出安装在设备上的应用:  adb shell pm list package</span></span></li><li><span class="name"><span class="innerContentContainer">列出系统应用: adb shell pm list package -s</span></span></li><li><span class="name"><span class="innerContentContainer">列出第三方应用:  adb shell pm list package -3</span></span></li><li><span class="name"><span class="innerContentContainer">列出应用包名及对应的apk名及存放位置: adb shell pm list package -f</span></span></li><li><span class="name"><span class="innerContentContainer">列出应用包名及其安装来源:   adb shell pm list package -f -3 -i zhihu</span></span><ul><li><span class="name"><span class="innerContentContainer">返回: package:/data/app/com.zhihu.android-1.apk=com.zhihu.android  installer=com.xiaomi.market</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">列出对应包名的 .apk 位置: adb shell pm path com.tencent.mobileqq</span></span></li><li><span class="name"><span class="innerContentContainer">列出指定应用的 dump 信息: adb shell pm dump com.tencent.mobileqq</span></span></li><li><span class="name"><span class="innerContentContainer">安装应用(apk 文件在Android 设备中): pm install</span></span></li><li><span class="name"><span class="innerContentContainer">清除应用数据:  pm clear &lt;packagename&gt;. 相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</span></span></li><li><span class="name"><span class="innerContentContainer">读出应用安装位置: pm get-install-location</span></span><ul><li><span class="name"><span class="innerContentContainer">[0/auto]：默认为自动</span></span></li><li><span class="name"><span class="innerContentContainer">[1/internal]：默认为安装在手机内部</span></span></li><li><span class="name"><span class="innerContentContainer">[2/external]：默认安装在外部存储</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity和service</span></span><ul><li><span class="name"><span class="innerContentContainer">启动应用：adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">启动一个 Activity: adb shell am start -n com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">先停止再启动:  adb shell am start -S com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">等待应用完成启动: adb shell am start -W com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">结束应用: am force-stop com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前界面的控件信息: adb shell uiautomator dump. 返回: </span></span><ul><li><span class="name"><span class="innerContentContainer">UI hierchary dumped to: /storage/emulated/legacy/window_dump.xml</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">列举所有services：adb shell service list</span></span></li><li><span class="name"><span class="innerContentContainer">启动一个服务: am startservice</span></span></li><li><span class="name"><span class="innerContentContainer">发送一个广播: am broadcast.  可以向所有组件广播，也可以只向指定组件广播。这个非常强大.</span></span><ul><li><span class="name"><span class="innerContentContainer">向所有组件广播&nbsp;BOOT_COMPLETED:</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">只向 com.tencent.mobileqq&nbsp;广播&nbsp;BOOT_COMPLETED：</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n com.tencent.mobileqq</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">部分系统预定义广播及正常触发时机：</span></span><ul><li><span class="name"><span class="innerContentContainer">android.net.conn.CONNECTIVITY_CHANGE	网络连接发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.SCREEN_ON	屏幕点亮</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.SCREEN_OFF	屏幕熄灭</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BATTERY_LOW	电量低，会弹出电量低提示框</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BATTERY_OKAY	电量恢复了</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BOOT_COMPLETED	设备启动完毕</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DEVICE_STORAGE_LOW	存储空间过低</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DEVICE_STORAGE_OK	存储空间恢复</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.PACKAGE_ADDED	安装了新的应用</span></span></li><li><span class="name"><span class="innerContentContainer">android.net.wifi.STATE_CHANGE	WiFi 连接状态发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.net.wifi.WIFI_STATE_CHANGED	WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BATTERY_CHANGED	电池电量发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.INPUT_METHOD_CHANGED	系统输入法发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.ACTION_POWER_CONNECTED	外部电源连接</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.ACTION_POWER_DISCONNECTED	外部电源断开连接</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DREAMING_STARTED	系统开始休眠</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DREAMING_STOPPED	系统停止休眠</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.WALLPAPER_CHANGED	壁纸发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.HEADSET_PLUG	插入耳机</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.MEDIA_UNMOUNTED	卸载外部介质</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.MEDIA_MOUNTED	挂载外部介质</span></span></li><li><span class="name"><span class="innerContentContainer">android.os.action.POWER_SAVE_MODE_CHANGED	省电模式开启</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">监控 crash 与 ANR:  am monitor </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">输入法和本地化</span></span><ul><li><span class="name"><span class="innerContentContainer">列出输入法: adb shell ime list -s, 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">com.google.android.inputmethod.pinyin/.PinyinIME</span></span></li><li><span class="name"><span class="innerContentContainer">com.baidu.input_mi/.ImeService</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出默认输入法: adb shell settings get secure default_input_method   // com.sohu.inputmethod.sogouoem/.SogouIME  默认搜狗输入法</span></span></li><li><span class="name"><span class="innerContentContainer">选择输入法:  adb shell ime set com.baidu.input_mi/.ImeService</span></span></li><li><span class="name"><span class="innerContentContainer">put命令更改默认输入法（将io.appium.android.ime/.UnicodeIME改为com.sohu.inputmethod.sogouoem/.SogouIME）</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell settings put secure default_input_method com.sohu.inputmethod.sogouoem/.SogouIME</span></span></li></ul></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">dumpsys</span></span><ul><li><span class="name"><span class="innerContentContainer">读出 dumpsys 支持的数据类型:  adb shell dumpsys -l</span></span></li><li><span class="name"><span class="innerContentContainer"><b>窗口列表: adb shell dumpsys&nbsp;window . Log内容说明: </b></span></span><ul><li><span class="name"><span class="innerContentContainer">lastanr:&nbsp;最后一次anr。如果有。</span></span></li><li><span class="name"><span class="innerContentContainer">policy： 系统Window策略。很多。</span></span><ul><li><span class="name"><span class="innerContentContainer">LockScreen: 锁屏相关</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">animator: 动画栈</span></span><ul><li><span class="name"><span class="innerContentContainer">所有动画是单独于window管理的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sessions： 刷新任务列表</span></span></li><li><span class="name"><span class="innerContentContainer">displays: 内容很多</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕分辨率</span></span></li><li><span class="name"><span class="innerContentContainer">task及其包含的activityRecord 列表</span></span></li><li><span class="name"><span class="innerContentContainer">display属性</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏属性</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">windows: window 栈</span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys window windows | grep windows: 返回当前window栈。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Input 设备信息: adb shell dumpsys input</span></span></li><li><span class="name"><span class="innerContentContainer">进程列表: adb shell dumpsys activity processes</span></span></li><li><span class="name"><span class="innerContentContainer">读出Activity信息: adb shell dumpsys activity activities</span></span><ul><li><span class="name"><span class="innerContentContainer">读出前台 Activity: adb shell "dumpsys activity activities | grep mFocusedActivity"</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前界面的Activity信息：adb shell dumpsys activity top</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前界面的Activity：adb shell dumpsys activity top | findstr ACTIVITY</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">打印当前系统所有service信息: adb shell dumpsys activity services</span></span><ul><li><span class="name"><span class="innerContentContainer">打印指定服务的信息: adb shell dumpsys service ***(指定服务名)</span></span></li><li><span class="name"><span class="innerContentContainer">列出当前运行的服务： adb shell dumpsys | findstr DUMP</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Provider列表: adb shell dumpsys activity providers</span></span></li><li><span class="name"><span class="innerContentContainer">读出package状态: adb shell dumpsys package, 可指定包名</span></span></li><li><span class="name"><span class="innerContentContainer">读出通知列表: adb shell dumpsys notification. 返回值是:</span></span><ul><li><span class="name"><span class="innerContentContainer">NotificationRecord(0x44217920: pkg=com.sohu.newsclient useron=0x7f0201b5 / com.tencent.news:drawable/icon</span></span></li><li><span class="name"><span class="innerContentContainer">pri=0 score=0</span></span></li><li><span class="name"><span class="innerContentContainer">contentIntent=PendingIntent{4294d748: PendingIntentRecord{44088e90 com.tencent.news startActivity}}</span></span></li><li><span class="name"><span class="innerContentContainer">deleteIntent=null</span></span></li><li><span class="name"><span class="innerContentContainer">tickerText=null</span></span></li><li><span class="name"><span class="innerContentContainer">contentView=android.widget.RemoteViews@441fc810</span></span></li><li><span class="name"><span class="innerContentContainer">defaults=0x00000001 flags=0x00000010</span></span></li><li><span class="name"><span class="innerContentContainer">sound=null</span></span></li><li><span class="name"><span class="innerContentContainer">vibrate=null</span></span></li><li><span class="name"><span class="innerContentContainer">led=0x00000000 onMs=0 offMs=0</span></span></li><li><span class="name"><span class="innerContentContainer">extras={</span></span><ul><li><span class="name"><span class="innerContentContainer">android.title=农业部:中国超级稻亩产超1吨</span></span></li><li><span class="name"><span class="innerContentContainer">android.subText=null</span></span></li><li><span class="name"><span class="innerContentContainer">android.showChronometer=false</span></span></li><li><span class="name"><span class="innerContentContainer">android.icon=2130837941</span></span></li><li><span class="name"><span class="innerContentContainer">android.text=农业部今日通报称,经专家测产,袁隆平领衔培育的中国“超级稻”亩产过千公斤,创造1026.7公斤新纪录。详情&gt;&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">android.progress=0</span></span></li><li><span class="name"><span class="innerContentContainer">android.progressMax=0</span></span></li><li><span class="name"><span class="innerContentContainer">android.showWhen=true</span></span></li><li><span class="name"><span class="innerContentContainer">android.infoText=null</span></span></li><li><span class="name"><span class="innerContentContainer">android.progressIndeterminate=false</span></span></li><li><span class="name"><span class="innerContentContainer">android.scoreModified=false</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出广播: adb shell dumpsys activity broadcasts</span></span></li><li><span class="name"><span class="innerContentContainer">读出intents消息: adb shell dumpsys activity intents</span></span></li><li><span class="name"><span class="innerContentContainer">提醒列表: adb shell dumpsys alarm</span></span></li><li><span class="name"><span class="innerContentContainer">读出内存状态:  adb shell dumpsys meminfo</span></span><ul><li><span class="name"><span class="innerContentContainer">要指定具体应用，可加上包名:  adb shell dumpsys meminfo PACKAGE_NAME</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看camera属性和状态: adb shell dumpsys media.camera</span></span><ul><li><span class="name"><span class="innerContentContainer">注意 stream[0], [1]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出位置状态: adb shell dumpsys location</span></span></li><li><span class="name"><span class="innerContentContainer">读出电话状态: adb shell dumpsys telephony.registry. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">mCallState值为0，表示待机状态、1表示来电未接听状态、2表示电话占线状态</span></span></li><li><span class="name"><span class="innerContentContainer">mCallForwarding=false   # 是否启用呼叫转移</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionState=2 #0：无数据连接 1：正在创建数据连接 2：已连接</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionPossible=true   # 是否有数据连接</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionApn=   # APN名称</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出CPU信息:  adb shell dumpsys cpuinfo</span></span></li><li><span class="name"><span class="innerContentContainer">读出磁盘使用情况: adb shell dumpsys diskstats</span></span><ul><li><span class="name"><span class="innerContentContainer">返回:</span></span></li><li><span class="name"><span class="innerContentContainer">Latency: 0ms [512B Data Write]</span></span></li><li><span class="name"><span class="innerContentContainer">Data-Free: 6589272K / 12258876K total = 53% free</span></span></li><li><span class="name"><span class="innerContentContainer">Cache-Free: 337720K / 420552K total = 80% free</span></span></li><li><span class="name"><span class="innerContentContainer">System-Free: 306024K / 1523568K total = 20% free</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys由 <a class="contentLink" target="_blank" rel="noreferrer" href="https://android.googlesource.com/platform/frameworks/native/+/master/cmds/dumpsys/dumpsys.cpp">frameworks/native/cmds/dumpsys/dumpsys.cpp</a> 文件中编译得到。</span></span></li><li><span class="name"><span class="innerContentContainer">入口即 dump().</span></span></li><li><span class="name"><span class="innerContentContainer">Binder支持 dump() 接口, 其实现由各个service 负责实现, 比如: DiskStatsService.dump().</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Logcat</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: logcat</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 包括4种log, 应用 + fwk log, event log, 射频通话log (暂不关注)</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 可分析应用和fwk层的所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 原生, 不依赖.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">adb logcat **。支持如下参数：</span></span></li><li><span class="name"><span class="innerContentContainer">默认值 = main + system</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-b main</b></span></span><ul><li><span class="name"><span class="innerContentContainer">默认, 主程序log. </span></span></li><li><span class="name"><span class="innerContentContainer">一般用户空间log将写入设备节点 /dev/log/main，包括 System.out.print 及 System.erro.print 等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-b system</span></span><ul><li><span class="name"><span class="innerContentContainer">fwk层log信息和debugging.</span></span></li><li><span class="name"><span class="innerContentContainer">为了防止mian缓存区溢出, 而从其中分离出来.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-b radio</span></span><ul><li><span class="name"><span class="innerContentContainer">射频通话相关信息.</span></span></li><li><span class="name"><span class="innerContentContainer">tag 为"HTC_RIL" "RILJ" "RILC" "RILD" "RIL" "AT" "GSM" "STK"的log信息将写入此节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>-c: 清除log缓存</b></span></span></li><li><span class="name"><span class="innerContentContainer">-v: 指定Log前缀格式, 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">brief: 默认</span></span></li><li><span class="name"><span class="innerContentContainer">process: 只有PID.</span></span></li><li><span class="name"><span class="innerContentContainer">tag: 只有优先级和PID</span></span></li><li><span class="name"><span class="innerContentContainer">time: 有日期时间, 优先级, 标签和PID</span></span></li><li><span class="name"><span class="innerContentContainer">threadtime: 仅time + thread id</span></span></li><li><span class="name"><span class="innerContentContainer">raw: 不显示前缀</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-d: 打印当前log后退出.</span></span></li><li><span class="name"><span class="innerContentContainer">-g: 打印缓冲区大小</span></span></li><li><span class="name"><span class="innerContentContainer"><b>过滤关键字</b>: adb logcat | findstr "***"</span></span><ul><li><span class="name"><span class="innerContentContainer">过滤多个关键字: findstr 后用空格分开.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">过滤关键字.方法2 --更好</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep *** "</span></span></li><li><span class="name"><span class="innerContentContainer">关键字支持正则表达式，同时可以输出到文件，所以推荐。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logcat 遇到 read: unexpected EOF!. 解决办法是:</span></span><ul><li><span class="name"><span class="innerContentContainer">adb logcat -G 16m</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: 自定义, 一般是 main-log, event-log等.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 每行log包括如下6个部分:</span></span><ul><li><span class="name"><span class="innerContentContainer">Tag</span></span></li><li><span class="name"><span class="innerContentContainer">时间戳</span></span></li><li><span class="name"><span class="innerContentContainer">PID, 进程ID</span></span></li><li><span class="name"><span class="innerContentContainer">TID, 线程ID</span></span></li><li><span class="name"><span class="innerContentContainer">log level</span></span></li><li><span class="name"><span class="innerContentContainer">log信息(代码中写入)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: 参见 log关键字 分类.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">App通过写入android.util.Log包来引入Log类，然后通过log方法写不同优先级的相关信息到log。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/base/core/java/android/util/Log.java</span></span></li><li><span class="name"><span class="innerContentContainer">主要方法有：</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.v();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.d();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.w();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.e();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.a();</span></span></li><li><span class="name"><span class="innerContentContainer">分别对应log级别：Assert，ERROR，WARN，INFO，DEBUG，VERBOSE。</span></span></li><li><span class="name"><span class="innerContentContainer">VERBOSE除了开发期间，是不应该被编译进APP的，DEBUG应该编译但在runtime被忽略，ERROR，WARN和INFO logs则一直被保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">jni层: frameworks/base/core/jni/android_util_Log.cpp, 关键函数是 android_util_Log_println_native()</span></span></li><li><span class="name"><span class="innerContentContainer">Native层: system/core/logcat/logcat.cpp. </span></span></li><li><span class="name"><span class="innerContentContainer">Native层打印log的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">包含system/core/include/cutils/log.h</span></span></li><li><span class="name"><span class="innerContentContainer">在模块Android.mk中添加：LOCAL_SHARED_LIBRARIES := liblog libcutils</span></span></li><li><span class="name"><span class="innerContentContainer">打印接口是: </span></span></li><li><span class="name"><span class="innerContentContainer">ALOGV</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGD</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGI</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGW</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGE</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logd 服务: 在开机过程中被init进程启动. </span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 system/core/logd</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\CommandListener.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\LogBuffer.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">底层: logging的kernel driver部分被称作”logger”</span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 kernel/drivers/staging/android/logger.c</span></span></li><li><span class="name"><span class="innerContentContainer">生成4个设备节点:</span></span><ul><li><span class="name"><span class="innerContentContainer">/dev/log/main</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/events</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/radio</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/system</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>logcat -b events</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: event, 系统事件log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: Event logs 文件存储在system/etc/event-log-tags中，通过cat system/etc/event-log-tags能查看其信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: Event logs是在 android.util.EventLog 中创建二进制log信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span></span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Traces  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: trace, 也即ANR, Application Not Responding</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用和framework</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 应用稳定性问题, 以ANR为主. </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">旧版本系统(&lt;=8.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">adb pull data/anr/traces.txt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">新版本系统(&gt;=9.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">一次anr一个log文件</span></span></li><li><span class="name"><span class="innerContentContainer">/data/anr/目录中有多个 anr_XXX文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写入ANR路径文件的位置：</span></span><ul><li><span class="name"><span class="innerContentContainer">读出: getprop dalvik.vm.stack -trace -file</span></span></li><li><span class="name"><span class="innerContentContainer">写入: setprop dalvik.vm.stack -trace -file /tmp/stack-traces.txt</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: traces.txt</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 以ANR堆栈为核心. Traces的主要问题是只能分析典型问题, 大部分问题单靠traces是分析不出来的, 还是要考 logcat.</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog发现系统30秒不响应, 就会打印 traces.txt .</span></span></li><li><span class="name"><span class="innerContentContainer">超过一分钟不响应则会打印类似如下的log, 名字如 races_SystemServer_WDT_${time}.txt  的文件,并重启 system_server.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">ANR in: 表明发生 anr 的模块.</span></span></li><li><span class="name"><span class="innerContentContainer">PID: 进程号。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Reason</b>: 表示原因. --有时候有用, 有时候没用.  有如下类型:</span></span><ul><li><span class="name"><span class="innerContentContainer">无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口暂停: Waiting because the [targetType] window is paused.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长].</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">targetType: 取值为”focused”或者”touched”</span></span></li><li><span class="name"><span class="innerContentContainer">Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE”</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>CPU占用率</b>: Load: 5.15 / 3.68 / 3.38, 表明, 5分钟，10分钟，15分钟内的 平均分别为：5.15 , 3.68 , 3.38</span></span><ul><li><span class="name"><span class="innerContentContainer">现在cpu一般是8核的, 所以累计的CPU占用率最高为 800%.</span></span></li><li><span class="name"><span class="innerContentContainer">一般占用率超过 400% 系统会比较卡顿, 超过 600%会出现反复的进程crash 和应用anr.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU usage from 602ms to -6091ms ago: .   后面一堆数据, cpu从602毫秒到6091毫秒之间的各进程的CPU使用情况。</span></span></li><li><span class="name"><span class="innerContentContainer">以上是系统概况信息, 一般价值不大, 定位原因主要看anr时的堆栈.</span></span></li><li><span class="name"><span class="innerContentContainer">gralloc： 进程内存占用情况。后面的数字即进程占用的全部内存。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>anr堆栈的分析方法</b></span></span><ul><li><span class="name"><span class="innerContentContainer">搜 Dalvik Threads 可直接定位到堆栈区.</span></span></li><li><span class="name"><span class="innerContentContainer">一般看 main 线程，即前台window所在的应用的主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">Blocked in handler on foreground thread (android.fg)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on main thread (main)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on display thread (android.display)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on ActivityManager (ActivityManager)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">main堆栈一般处在两种状态：</span></span><ul><li><span class="name"><span class="innerContentContainer">blocked状态。即在等锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，不要一看到等锁就是死锁问题。死锁是两个线程互相持有对方等的锁。</span></span></li><li><span class="name"><span class="innerContentContainer">单方面等锁非但不是死锁状态，反而是正常状态，而且非常常见。</span></span></li><li><span class="name"><span class="innerContentContainer">通过锁对象的hash可以判断是否是死锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">nativepollonce状态。即等待唤醒状态。</span></span><ul><li><span class="name"><span class="innerContentContainer">处在这种状态就是正常状态。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">main线程如果没有明显的异常，就要看其它线程的异常了。</span></span></li><li><span class="name"><span class="innerContentContainer">找对应的binder进程的堆栈. 比如 主线程id是8277,  则搜 Binder:8277_</span></span></li><li><span class="name"><span class="innerContentContainer">如果binder线程没也没有异常，那么trace文件就没啥价值了，应该回到 main log去分析。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">写anr log的代码在 ActivityManagerService.dumpStackTraces()</span></span></li><li><span class="name"><span class="innerContentContainer">traces在 ProcessRecord.java 中生成。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel Log</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Kernel Log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 底层所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell cat /proc/kmsg；kernel日志,每cat一次会清零</span></span></li><li><span class="name"><span class="innerContentContainer">adb dmesg -n 8，写入打印级别, 8是所有都打。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell dmesg: ernel日志, 开机信息.(通过var/log/demsg)</span></span></li><li><span class="name"><span class="innerContentContainer">同时抓取 Kernel log和logcat的方法:  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell logcat -v time -f /dev/kmsg | adb shell cat /proc/kmsg | tee kernel_logcat.txt</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: 自定义</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">格式较简单: 时间戳, 进程ID, 线程ID, 级别, Log内容</span></span></li><li><span class="name"><span class="innerContentContainer">例子: 2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5]</span></span></li><li><span class="name"><span class="innerContentContainer">问题：时间戳为开机的秒数，如何转成时分秒格式？/对齐时间戳</span></span><ul><li><span class="name"><span class="innerContentContainer">方法1： 在kernel日志中搜 "UTC", 或者 "rtc"。可找到时间的对应关系。--每20秒打印一次，基本够用。</span></span></li><li><span class="name"><span class="innerContentContainer">方法2：dmesg -T ，以当前时间的方式显示时间信息 --有效，但是要联机使用，问题不复现就没用了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">使用 printk()函数 进行Log输出。</span></span></li><li><span class="name"><span class="innerContentContainer">日志级别</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel log日志级别在 include/linux/kern_levels.h 定义. 字符串表示为一个尖括号中的整数，0-7，值越小优先级越高。</span></span></li><li><span class="name"><span class="innerContentContainer">优先级小于 console_loglevel 这个整数变量的消息才会打印。</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前日志级别: cat /system/sys/kernel/printk, 有4个数字，第一个表示当前日志级别。</span></span></li><li><span class="name"><span class="innerContentContainer">刷新系统日志级别: echo 8 &gt; /system/sys/kernel/printk</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">换行符，log行尾一定要加换行符。否则不会输出到控制台。</span></span></li><li><span class="name"><span class="innerContentContainer">如果系统运行了 klogd 和 syslogd，则所有内核消息都会被追加到 /var/log/messages 中。</span></span></li><li><span class="name"><span class="innerContentContainer">Log buffer 大小是写在代码中的，这个宏:LOG_BUF_SHIFT，所在文件为 /kernel/init/Kconfig。</span></span></li><li><span class="name"><span class="innerContentContainer">打印速度: printk_ratelimit().</span></span></li><li><span class="name"><span class="innerContentContainer">打印主次设备号: print_dev_t(), format_dev_t().</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">printk(KERN_ALERT "This is the log printed by printk in linux kernel space.");</span></span></li><li><span class="name"><span class="innerContentContainer">printk(KERN_ERR "%s: Invalid parameter\n", __func__);</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">bugreport</span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: bugreport</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用和fwk</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 稳定性问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: adb bugreport &gt; bugreport.log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">log中包含有dmesg，dumpstate和dumpsys: </span></span><ul><li><span class="name"><span class="innerContentContainer">dmesg: kernel log</span></span></li><li><span class="name"><span class="innerContentContainer">dumpstate: 系统状态信息，里面比较全</span></span></li><li><span class="name"><span class="innerContentContainer">dumpsys: 系统所有进程Process的基本属性.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Tombstones  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText"><b>问题</b>稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Tombstones</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 系统重启问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: 当系统 crash 的时候，会保存一个 tombstone 文件到 /data/tombstones目录下。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: tombstone</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 以死机堆栈为主体. 主要关注 backtrace 下面的内容, 它保存了发生 crash 时的堆栈。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">JNI ERROR: local reference table overflow, 局部引用表溢出</span></span><ul><li><span class="name"><span class="innerContentContainer">系统限制局部对象应用最大512个，超过则crash。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">包含发生问题的进程ID信息：</span></span></li><li><span class="name"><span class="innerContentContainer">I/DEBUG   (  241): pid: 244, tid: 244, name: mediaserver  &gt;&gt;&gt; /system/bin/mediaserver &lt;&lt;&lt;</span></span></li><li><span class="name"><span class="innerContentContainer">当 tid == pid 时，问题发生在父进程，反之问题发生在子进程。</span></span></li><li><span class="name"><span class="innerContentContainer">以及错误类型：</span></span></li><li><span class="name"><span class="innerContentContainer">F/libc    (  244): Fatal signal 11 (<b>SIGSEGV</b>), code 1, fault addr 0xdeadbaad in tid 244 (mediaserver)</span></span></li><li><span class="name"><span class="innerContentContainer">说明出现进程 Crash 的原因是因为程序产生了段错误的信号，访问了非法的内存空间，而访问的非法地址是 0xdeadbaad。</span></span></li><li><span class="name"><span class="innerContentContainer">OS层错误类型有：</span></span><ul><li><span class="name"><span class="innerContentContainer">SIGSEGV: Invalid memory reference，段地址非法异常。包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">尝试写入只读区域</span></span></li><li><span class="name"><span class="innerContentContainer">访问空指针</span></span></li><li><span class="name"><span class="innerContentContainer">写空悬指针</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SIGBUS: Access to an undefined portion of a memory object，内存地址异常。地址合法，但是不可访问。原因一般是字节不对齐。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGFPE: Arithmetic operation error, like divide by zero. 算数异常，包括浮点异常和除零异常。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGILL: Illegal instruction, like execute garbage or a privileged instruction。执行非法指令，通常因为二进制文件错误，或者尝试执行数据段。堆栈溢出可引起此问题。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGSYS: Bad system call. 非法的系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXCPU: CPU time limit exceeded. CPU时间片超时。时分系统才有。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXFSZ: File size limit exceeded. 文件大小超过系统限制。</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型定义在prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.8/sysroot/usr/include/bits/signum.h</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">arm芯片定义的异常</span></span><ul><li><span class="name"><span class="innerContentContainer">Preftch Abort：程序指针跑飞；</span></span></li><li><span class="name"><span class="innerContentContainer">Data Abort：内存指针跑飞；（最常见）</span></span></li><li><span class="name"><span class="innerContentContainer">Div by Zero：发生除零错误；</span></span></li><li><span class="name"><span class="innerContentContainer">Unknown sig：某个task收到未定义的信号；</span></span></li><li><span class="name"><span class="innerContentContainer">Error Fatal：代码进入error FATAL分支</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">线程dump文件  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，读出有两步：</span></span></li><li><span class="name"><span class="innerContentContainer">（1）读出线程pid，可以通过使用 jps 命令，在Linux环境下还可以使用 ps -ef | grep java</span></span></li><li><span class="name"><span class="innerContentContainer">（2）打印线程堆栈，可以通过使用 jstack pid命令，在Linux环境下还可以使用kill -3 pid</span></span></li><li><span class="name"><span class="innerContentContainer">另外提一点，Thread类提供了一个 getStackTrace()方法也可以用于读出线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次读出的是具体某个线程当前运行的堆栈.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SysTrace  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: SysTrace</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用, framework, 驱动. systrace负责收集系统各进程的各个线程的运行信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 性能</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">AS 进入Tools &gt; Android &gt; Monitor 抓取。</span></span></li><li><span class="name"><span class="innerContentContainer">或者使用 monitor.bat , 选择线程。</span></span></li><li><span class="name"><span class="innerContentContainer">选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。</span></span></li><li><span class="name"><span class="innerContentContainer">然后复现问题，抓对应的 systrace.</span></span></li><li><span class="name"><span class="innerContentContainer">配置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件），比如32M。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: SysTrace***</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">在R之前, chrome中打开 <a class="contentLink" target="_blank" rel="noreferrer" href="chrome://tracing">chrome://tracing</a>,  把文件拖进去即可.</span></span></li><li><span class="name"><span class="innerContentContainer">在R之后, 要用&nbsp;<a class="contentLink" target="_blank" rel="noreferrer" href="https://ui.perfetto.dev/">https://ui.perfetto.dev</a>&nbsp;打开。左侧3个按钮, 使用第二个按钮写入文件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">遍历使用的快捷键:</span></span><ul><li><span class="name"><span class="innerContentContainer">数字0: 恢复到最初状态</span></span></li><li><span class="name"><span class="innerContentContainer">数字1 表选中。可用鼠标选中一段操作，在屏幕下方看其细节。</span></span></li><li><span class="name"><span class="innerContentContainer">数字2 表示用鼠标上下左右浏览。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>f: 直接放大当前帧</b></span></span></li><li><span class="name"><span class="innerContentContainer">w: 放大</span></span></li><li><span class="name"><span class="innerContentContainer">s: 缩小</span></span></li><li><span class="name"><span class="innerContentContainer">a: 后退</span></span></li><li><span class="name"><span class="innerContentContainer">d: 前进</span></span></li><li><span class="name"><span class="innerContentContainer">方向键: 四处遍历</span></span></li><li><span class="name"><span class="innerContentContainer">m: 高亮当前</span></span></li><li><span class="name"><span class="innerContentContainer">v: 高亮整个 vsync</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">先找目标进程;</span></span></li><li><span class="name"><span class="innerContentContainer">再看UI Tread, 一般在第一个. 每个"F"都是一帧, 绿色表示不卡, 其它颜色表示卡.</span></span></li><li><span class="name"><span class="innerContentContainer">按下数字1, 用鼠标选中 UI thread 所在的绿条, 可以查看该段时间的执行细节, 比如 UI 线程执行了多久, 时间占比多少等等信息. 如果主要在UI线程执行, 那么需要进程自身代码优化性能. </span></span></li><li><span class="name"><span class="innerContentContainer">如果UI thread 主要在休眠, 那么就要往下找看哪个线程在执行. </span></span></li><li><span class="name"><span class="innerContentContainer">如果代码中打过点, 则会在该线程的横条的下方显示该函数的执行起止. </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">在java代码中加 systrace 打点的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();</span></span></li><li><span class="name"><span class="innerContentContainer">必须成对出现, 且在同一个线程.</span></span></li><li><span class="name"><span class="innerContentContainer">在 release 版本中也生效.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systrace模块代码由3部分组成：</span></span><ul><li><span class="name"><span class="innerContentContainer">内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</span></span></li><li><span class="name"><span class="innerContentContainer">数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读出统计信息然后交给数据分析工具来处理。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分析工具：<a class="contentLink" target="_blank" rel="noreferrer" href="http://Android提供一个systrace.py">Android提供一个systrace.py</a>（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来写入数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用 Trace类来使用 Systrace.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Hprof  <span class="contentTag" title="Filter #问题内存">#<span class="contentTagText"><b>问题</b>内存</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Hprof</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: framework, 应用层</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 可检测出泄漏的对象、activities、以及冗余重复的字符串。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: 手机要 remount. 然后使用:adb shell am dumpheap com.oppo.camera /data/1.hprof</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: *.hprof</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">Hprof最初是由J2SE支持的一种二进制堆对象转储格式。但Android的Hprof文件与标准的java Hprof文件格式不一样。</span></span></li><li><span class="name"><span class="innerContentContainer">用AS分析</span></span><ul><li><span class="name"><span class="innerContentContainer">在主窗口中点击 Captures按钮，或者选择&nbsp;View &gt; Tools Windows &gt; Captures，打开Captures窗口；</span></span></li><li><span class="name"><span class="innerContentContainer">打开堆快照文件夹；双击HPROF文件，打开查看工具界面；</span></span></li><li><span class="name"><span class="innerContentContainer">选择你想查看的堆:</span></span><ul><li><span class="name"><span class="innerContentContainer">App heap&nbsp;- 当前app使用的堆</span></span></li><li><span class="name"><span class="innerContentContainer">Image heap&nbsp;- 当前app在硬盘上的内存映射</span></span></li><li><span class="name"><span class="innerContentContainer">Zygote heap&nbsp;- zygote 复制时继承来的库、运行时类和常量的数据集。zygote空间设备启动时创建，从不分配这里的空间。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">选择你想查看的视图选项：</span></span><ul><li><span class="name"><span class="innerContentContainer">Class List View</span></span></li><li><span class="name"><span class="innerContentContainer">Package Tree View</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">转化成标准的HPROF文件</span></span><ul><li><span class="name"><span class="innerContentContainer">转化成标准的HPROF文件后可以使用Android Studio之外的分析工具来分析。</span></span></li><li><span class="name"><span class="innerContentContainer">在AS的C aptures窗口HPROF文件列表中选择文件，右键点击&nbsp;Export to standard .hprof</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用eclipse MAT 分析</span></span><ul><li><span class="name"><span class="innerContentContainer">先把文件转换，进入进入&nbsp;android-sdk-windows\tools目录,  hprof_conv 1.hprof 1-1.hprof。</span></span></li><li><span class="name"><span class="innerContentContainer">eclipse上安装MAT: help - install new software - Search "MAT"。</span></span></li><li><span class="name"><span class="innerContentContainer">打开MAT：在Eclipse中点击 Windows-&gt;Open Perspective-&gt;Other-&gt;Memory Analysis</span></span></li><li><span class="name"><span class="innerContentContainer">导入.hprof文件: 在MAT中点击&nbsp;File-&gt;Open File打开刚刚转换而得到的yyyyy.hprof文件，并Cancel掉自动生成报告,点击Dominator Tree，并按Package分组，选择自己所定义的Package类点右键，在弹出菜单中选择List objects-&gt;With incoming references。</span></span></li><li><span class="name"><span class="innerContentContainer">分析报告: 这时会列出所有可疑类，右键点击某一项，并选择Path to GC Roots-&gt;exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">Hprof会展示Java堆，包括如下信息：</span></span><ul><li><span class="name"><span class="innerContentContainer">按类展示实例对象的内存使用情况；</span></span></li><li><span class="name"><span class="innerContentContainer">每次垃圾回收事件的样本数据；</span></span></li><li><span class="name"><span class="innerContentContainer">帮助分析哪些对象类型也许会导致内存泄漏。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">Log包括如下信息：</span></span></li><li><span class="name"><span class="innerContentContainer">Class name	类名</span></span></li><li><span class="name"><span class="innerContentContainer">Total Count	该类的实例总数</span></span></li><li><span class="name"><span class="innerContentContainer">Heap Count	所选择的堆中该类的实例的数量</span></span></li><li><span class="name"><span class="innerContentContainer">Sizeof	单个实例所占空间大小（如果每个实例所占空间大小不一样则显示0）</span></span></li><li><span class="name"><span class="innerContentContainer">Shallow Size	堆里所有实例大小总和（Heap Count * Sizeof）</span></span></li><li><span class="name"><span class="innerContentContainer">Retained Size	该类所有实例所支配的内存大小</span></span></li><li><span class="name"><span class="innerContentContainer">Instance	具体的实例</span></span></li><li><span class="name"><span class="innerContentContainer">Reference Tree	所选实例的引用，以及指向该引用的引用。</span></span></li><li><span class="name"><span class="innerContentContainer">Depth	GC根节点到所选实例的最短路径的深度</span></span></li><li><span class="name"><span class="innerContentContainer">Shallow Size	所选实例的大小</span></span></li><li><span class="name"><span class="innerContentContainer">Dominating Size	所选实例所支配的内存大小</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">traceView  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: traceView</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: fwk 和 应用层</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 能够可视化观察CPU的执行情况, 找出耗时操作.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: ddms选择: call stack show</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: ddms</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log关键字">#<span class="contentTagText">Log关键字</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tcpdump  <span class="contentTag" title="Filter #问题网络">#<span class="contentTagText"><b>问题</b>网络</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">TCP/IP协议相关的log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell tcpdump -s 10000 -w /sdcard/capture.pcap</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">分析问题的首选方法  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">三现原则。log也算现场。</span></span></li><li><span class="name"><span class="innerContentContainer">利用dailybuild版本，将问题分而治之。</span></span></li><li><span class="name"><span class="innerContentContainer">花3-5分钟时间考虑思路，并写在纸上. 然后尽快开始做。</span></span></li><li><span class="name"><span class="innerContentContainer">配环境是难点，三个办法：</span></span><ul><li><span class="name"><span class="innerContentContainer">平时准备好；</span></span></li><li><span class="name"><span class="innerContentContainer">找现成的环境用；</span></span></li><li><span class="name"><span class="innerContentContainer">基本环境出问题, 不要自己琢磨, 直接找高手搞定. 不要把时间浪费在非关键问题上.</span></span><ul><li><span class="name"><span class="innerContentContainer">这意味着平时要维护一个高手的名单, 并和他们处好关系.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">加快闭环</span></span><ul><li><span class="name"><span class="innerContentContainer">code → compiler → install → test</span></span></li><li><span class="name"><span class="innerContentContainer">如果在定位问题，请保证每个小时出一次版本。</span></span></li><li><span class="name"><span class="innerContentContainer">我的经验是，一个较复杂的问题的定位，至少需要3个以上的测试版本，而写完一大段代码（300行以上）后进行功能验证，一般需要4-6个版本才能搞定（平均每个版本能解决两三个个bug）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB 相关问题，首选是Bus Hound；</span></span></li><li><span class="name"><span class="innerContentContainer">硬件问题：把线连出来，上示波器。要会用示波器。</span></span></li><li><span class="name"><span class="innerContentContainer">用trace 跟无问题，不跟才有，一般和踢狗相关。</span></span></li><li><span class="name"><span class="innerContentContainer">性能问题，先要流程分解成3-6个阶段，然后通过log 打印等方式得出各阶段的时耗，找到突破点。</span></span></li><li><span class="name"><span class="innerContentContainer">功耗问题，逐个器件拔。</span></span></li><li><span class="name"><span class="innerContentContainer">迅速缩小焦点：</span></span><ul><li><span class="name"><span class="innerContentContainer">FFA上有吗? 有, 就是高通的问题. 没有,则是我们的修改引入的.</span></span></li><li><span class="name"><span class="innerContentContainer">新版本有吗? 没有, 则已经解决.</span></span></li><li><span class="name"><span class="innerContentContainer">老版本有吗? 没有, 则是最近修改引入的. 有, 则是固有问题.</span></span></li><li><span class="name"><span class="innerContentContainer">新单板有吗? 没有, 则已经解决. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">老单板有吗? 没有, 则为硬件修改引入. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">第三方应用有吗? 有, 说明是底层问题. 没有, 说明是应用的问题. (非绝对)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时刻关注自己是在哪个层面上考虑问题：</span></span><ul><li><span class="name"><span class="innerContentContainer">是cpu层次（包括cpu、硬件寄存器、dma）</span></span></li><li><span class="name"><span class="innerContentContainer">是外设级别（要考虑时序、电源）</span></span></li><li><span class="name"><span class="innerContentContainer">还是task级别（sig、队列、task切换、堆栈、中断等）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">张建春的定位技巧  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">多看 MODEM SOFTWARE INTERFACE .pdf，学会对arm硬件寄存器的直接操作。</span></span></li><li><span class="name"><span class="innerContentContainer">下发“FALSH读”的指令：D.S SD:0X60000304 %LE %LONG 1；D.S SD:0X60000100 %LE %LONG 0x2。0X60000304&nbsp; 即 page read指令。</span></span></li><li><span class="name"><span class="innerContentContainer">写入读地址：D.S SD:0X60000300 %LE %LONG 0x0279c00；</span></span></li><li><span class="name"><span class="innerContentContainer">查看FALSH读写状态：0X60000308；</span></span></li><li><span class="name"><span class="innerContentContainer">查看ECC 纠错的位数：0X6000030C。0表示无错误；超过4个字节就无法正确纠正。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>通用调试桩方案</b> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">调试fwk的代码，可以在 PhoneWindowManager.java 的 interceptKeyBeforeQueueing(), 拦截音量上下键。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码打印堆栈 - 内存地址转函数名</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line 是把内存地址转化为代码行的工具。需要符号表。</span></span></li><li><span class="name"><span class="innerContentContainer">用法如下：</span></span></li><li><span class="name"><span class="innerContentContainer">如果想找这行错误：#08 pc 0013b3d5 /system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> (SkPNGImageDecoder::onDecodeSubset(SkBitmap*, SkIRect const&amp;)+604)</span></span></li><li><span class="name"><span class="innerContentContainer">先在符号表目录查找：<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a>。 比如在 ./symbols/system/lib/ 下。</span></span></li><li><span class="name"><span class="innerContentContainer">./bin/x86_64-linux-addr2line -e ./symbols/system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> 0013b3d5</span></span></li><li><span class="name"><span class="innerContentContainer">输出大致为： android/external/skia/src/images/SkImageDecoder_libpng.cpp:907</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">addr2line 的增强版： <a class="contentLink" target="_blank" rel="noreferrer" href="http://stack.py">stack.py</a></span></span><ul><li><span class="name"><span class="innerContentContainer">stack.py 能够把backtrace堆栈一次性对应到代码，也是利用addr2line。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： python stack.py --symbols-dir=[符号变目录] [tombstone文件]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ndk-stack</span></span><ul><li><span class="name"><span class="innerContentContainer">Android NDK 自从版本 r6开始, 提供了一个工具 ndk-stack。这个工具能自动分析 tombstone 文件, 能将崩溃时的调用内存地址和 c++ 代码一行一行对应起来。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： ndk-stack -sym &lt;path&gt; [-dump &lt;path&gt;]</span></span><ul><li><span class="name"><span class="innerContentContainer">dump 参数即 dump 下来的 log 文本文件.</span></span></li><li><span class="name"><span class="innerContentContainer">sym 参数即符号表。就是android项目目录下，编译成功之后，obj目录下的文件（android系统源码o 中带有符号信息的文件）。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>硬件基本速度指标</b>  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">执行一条指令：1 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从L1 cache中读出一个字：2 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从内存中读一个字：10 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘连续位置取一个字：200 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘任意位置取一个字：8000,000 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">双通道DDR4内存: 30GB/s</span></span></li><li><span class="name"><span class="innerContentContainer">PCIe SSD：3600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SATA SSD：600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">机械硬盘：200MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡：读写速度差异大，主流大约是读100MB/s, 写30MB/s.</span></span></li><li><span class="name"><span class="innerContentContainer">Nor FLASH 和 Nand FLASH 的速度对比</span></span><ul><li><span class="name"><span class="innerContentContainer">以美光（Micron）的NAND和NOR对比, 速度数据如下:</span></span></li><li><span class="name"><span class="innerContentContainer">读: Nor: 41MB/s;   Nand: 37MB/s (基本差不多)</span></span></li><li><span class="name"><span class="innerContentContainer">写: Nor: 0.178MB/s;   Nand: 5MB/s (<b>Nand 快了28倍</b>)</span></span></li><li><span class="name"><span class="innerContentContainer">擦一个块的时间: Nor: 750ms;   Nand: 2ms (<b>Nand 快了375倍</b>)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>性能问题-分析  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">性能问题, 首先要找到参照物. 和谁对比慢? 参照物的合理性在哪里?</span></span></li><li><span class="name"><span class="innerContentContainer">其次, 要找对目标. 性能问题没有尽头, 不可能无限优化下去. 比如: 华为应用启动速度目标：500ms，从点击图标到 activity ouResume的时间。</span></span></li><li><span class="name"><span class="innerContentContainer">基本做法是: 主流程砍几刀, 分别打点, 找出最耗时的操作, 确认哪些步骤水分最大，谁在等待、在等谁. 继续这个动作, 逐步深入.</span></span></li><li><span class="name"><span class="innerContentContainer">Android应用性能问题, 主要看丢帧.</span></span></li><li><span class="name"><span class="innerContentContainer">打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>android过度绘制 (overdraw)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">过度绘制指屏幕的某个像素在同一帧的时间内会绘制多次. 这是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用.</span></span></li><li><span class="name"><span class="innerContentContainer">android系统设计思路就是递归, 无论是底层, 还是上层, 都喜欢用递归来解决问题. 好处是用很小的投入就能推动了庞大的系统; 坏处是层次太多, 太多无效调用, 系统卡顿.</span></span></li><li><span class="name"><span class="innerContentContainer">造成过度绘制的原因:    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">布局存在重叠的部分;</span></span></li><li><span class="name"><span class="innerContentContainer">存在非必须的重叠背景;</span></span></li><li><span class="name"><span class="innerContentContainer">不可见的UI元素也在刷新界面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">检查方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员选项中有"调试GPU过度绘制", 打开它, 然后在应用界面上会显示各种颜色, 其中:</span></span></li><li><span class="name"><span class="innerContentContainer">没有颜色: 仅绘制1次.</span></span></li><li><span class="name"><span class="innerContentContainer">蓝色: 绘制2次 (可接受)</span></span></li><li><span class="name"><span class="innerContentContainer">绿: 绘制3次</span></span></li><li><span class="name"><span class="innerContentContainer">浅红: 绘制4次. 小块也可接受</span></span></li><li><span class="name"><span class="innerContentContainer">深红: 绘制5次或以上. 这种需要修复.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">频繁gc的标准</span></span><ul><li><span class="name"><span class="innerContentContainer">gc分为young gc 和 full gc两种。</span></span></li><li><span class="name"><span class="innerContentContainer">young gc 在4秒一次以上，pause 小于20ms，耗时小于400ms，算不频繁。</span></span></li><li><span class="name"><span class="innerContentContainer">full gc 越少越好，因为造成pause时间会达到秒级。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">oprofile： linux性能监控工具</span></span><ul><li><span class="name"><span class="innerContentContainer">特点是小巧，对运行影响小。android有一个简化的实现。</span></span></li><li><span class="name"><span class="innerContentContainer">oprofile使用方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">先打开宏：CONFIG_OPROFILE=Y，编译系统生成boot.img，下载到手机侧。</span></span></li><li><span class="name"><span class="innerContentContainer">用adb使能功能：opcontrol 等工具，抓取手机数据；</span></span></li><li><span class="name"><span class="innerContentContainer">然后将/data/oprofile/ 目录下的数据pull 回pc ；</span></span></li><li><span class="name"><span class="innerContentContainer">使用PC工具:opimport、opreport等进行分析。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码位置: </span></span><ul><li><span class="name"><span class="innerContentContainer">手机侧：/external/oprofile，负责收集数据；</span></span></li><li><span class="name"><span class="innerContentContainer">pc-linux侧，/prebuild/linux_x86/oprofile，负责分析数据。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU提频 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">提频也叫CPU boost。</span></span></li><li><span class="name"><span class="innerContentContainer">CPU分大小核，一般情况下，应用线程会跑在小核上。</span></span></li><li><span class="name"><span class="innerContentContainer">如果性能不够，可以将线程提频，即强制让它运行到大核上。</span></span></li><li><span class="name"><span class="innerContentContainer">查看当前CPU频率的adb命令</span></span><ul><li><span class="name"><span class="innerContentContainer">cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies</span></span></li><li><span class="name"><span class="innerContentContainer">显示的最后一个数字即是CPU速率，如 1152000即1.2G。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">是否提频，在systrace中搜 hypnus.</span></span></li><li><span class="name"><span class="innerContentContainer">动态调整cpu速率的驱动接口</span></span><ul><li><span class="name"><span class="innerContentContainer">申请提高CPU速率：clk_regime_register_for_cpu_resource()</span></span><ul><li><span class="name"><span class="innerContentContainer">由task调用，只有部分task有权利。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">申请恢复CPU速率: clk_regime_deregister_for_cpu_resource()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>拍照速度优化 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">拍照性能优化看5个点: 拍照开始的回调, 缩略图回帧的回调, 拍照回帧, 后期处理的回调, 保存文件的回调.</span></span></li><li><span class="name"><span class="innerContentContainer">拍照性能优化: 先显示后处理, 在缩略图没有存储时候提前显示缩略图. 给用户快的感觉.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">性能问题-优化 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>界面刷新速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">setAlpha() 要特别小心. 因为如果界面上有多个Alpha值, 绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作. </span></span></li><li><span class="name"><span class="innerContentContainer">减少页面 layout布局层级.</span></span></li><li><span class="name"><span class="innerContentContainer">减少过度绘制.   --参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/5d3ed8a3ec39">https://workflowy.com/#/5d3ed8a3ec39</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>如何解决过度绘制?  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?</span></span></li><li><span class="name"><span class="innerContentContainer">1. 合理选择控件容器</span></span><ul><li><span class="name"><span class="innerContentContainer">表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</span></span></li><li><span class="name"><span class="innerContentContainer">从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 去掉window的默认背景</span></span><ul><li><span class="name"><span class="innerContentContainer">使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者写入背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</span></span></li><li><span class="name"><span class="innerContentContainer">去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);</span></span></li><li><span class="name"><span class="innerContentContainer">或者在theme中添加 android:windowbackground="null"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 去掉其他不必要的背景</span></span><ul><li><span class="name"><span class="innerContentContainer">有时候为了方便会先给Layout写入一个整体的背景，再给子View写入背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别写入背景来减少重绘。</span></span></li><li><span class="name"><span class="innerContentContainer">如果采用的是 selector的背景，将normal状态的color 写入 “@android:color/transparent",也同样可以解决问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. ClipRect &amp; QuickReject</span></span><ul><li><span class="name"><span class="innerContentContainer">为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</span></span></li><li><span class="name"><span class="innerContentContainer">这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 使用ViewStub</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewStub是个什么东西？一句话总结：高效占位符。</span></span></li><li><span class="name"><span class="innerContentContainer">我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被写入属性。也就是说，会耗费内存等资源。</span></span></li><li><span class="name"><span class="innerContentContainer">推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</span></span></li><li><span class="name"><span class="innerContentContainer">想加载布局时，可以使用下面其中一种方法：</span></span></li><li><span class="name"><span class="innerContentContainer">((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);</span></span></li><li><span class="name"><span class="innerContentContainer">View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 使用Merge标签</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种情况下我们可以使用Merge标签来做容器控件。</span></span></li><li><span class="name"><span class="innerContentContainer">第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">Merge只能作为XML布局的根标签使用，当Inflate以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 善用draw9patch</span></span><ul><li><span class="name"><span class="innerContentContainer">你肯定遇到过这种需求，通常在ImageView后写入一张背景图，露出边框便完美解决问题，此时这个ImageView，写入了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分写入为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分写入成透明，也不会减少这次overdraw。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 慎用Alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一定做Alpha转化的话，可以采用缓存的方式。</span></span><ul><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_HARDWARE);</span></span></li><li><span class="name"><span class="innerContentContainer">doSmoeThing();</span></span></li><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_NONE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 避免“OverDesign”</span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难"，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">首先, 去掉非必要的步骤, 或者无用的步骤；</span></span></li><li><span class="name"><span class="innerContentContainer">合并步骤，批量处理；</span></span></li><li><span class="name"><span class="innerContentContainer">预处理；预读. <b>用户感知的动作</b>, 要提前准备数据, 必要时可读入无效数据, 冗余数据.</span></span></li><li><span class="name"><span class="innerContentContainer">按需处理。<b>用户无感知的动作</b>放在后面处理. 延迟读, 延迟写。</span></span></li><li><span class="name"><span class="innerContentContainer">大流程搞成多线程的, 串行改并行, 往往有奇效.</span></span></li><li><span class="name"><span class="innerContentContainer">双buffer，或多buffer ，保证并发；</span></span></li><li><span class="name"><span class="innerContentContainer">更大的 buffer. 读写buffer 超过 64K 就价值不大了; 复杂计算buffer超过一帧就价值不大了.</span></span></li><li><span class="name"><span class="innerContentContainer">同一个处理, 底层和应用都可以做, 那就放在底层做. </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>稳定性问题   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android ANR问题-基本分析方法 <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/082045769443">https://www.jianshu.com/p/082045769443</a> --还可以</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Trace文件分析过程   参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/28c7c7faaf64">https://workflowy.com/#/28c7c7faaf64</a></b></span></span></li><li><span class="name"><span class="innerContentContainer">应用与系统稳定性第一篇---ANR问题分析的一般套路 <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/18f16aba79dd">https://www.jianshu.com/p/18f16aba79dd</a>  --好文章</span></span></li><li><span class="name"><span class="innerContentContainer">Android卡顿分析中常见的log: <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html">https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html</a>  --比较全面</span></span></li><li><span class="name"><span class="innerContentContainer">系统定义的ANR超时门限</span></span><ul><li><span class="name"><span class="innerContentContainer">用户输入5S.  logKey：Input event dispatching timed out</span></span></li><li><span class="name"><span class="innerContentContainer">广播：前台10S，后台60S.  logKey：Timeout of broadcast BroadcastRecord</span></span></li><li><span class="name"><span class="innerContentContainer">服务：前台20S，后台200S.  logKey：Timeout executing service</span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider：10S.  logKey：timeout publishing content providers</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ANR出现的原因  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">主线程频繁进行耗时的操作：如数据库读写</span></span></li><li><span class="name"><span class="innerContentContainer">多线程操作的死锁，主线程被block；</span></span><ul><li><span class="name"><span class="innerContentContainer">关键字：waiting to lock</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主线程被Binder server block；</span></span><ul><li><span class="name"><span class="innerContentContainer">在 traces.txt 文件中确认，client端的main线程卡在 BinderPorxy.transactNative；</span></span></li><li><span class="name"><span class="innerContentContainer">通过binderinfo 文件查找 server端的进程号。</span></span></li><li><span class="name"><span class="innerContentContainer">然后再在traces.txt 文件中确认server端在干什么， 常见的情况是卡在 Android.os.MessageQueue.nativePollOnce, 即事件处理卡住了，这种一般需要驱动继续排查。</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种情况是server端进程出现WatchDog导致ANR.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">service binder的连接达到上线无法和和System Server通信</span></span></li><li><span class="name"><span class="innerContentContainer">系统资源已耗尽（CPU、IO、内存）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用卡死的原因包括:   <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">主线程忙</span></span><ul><li><span class="name"><span class="innerContentContainer">自身忙, 常见的包括解析错误的xml文件导致忙等.</span></span></li><li><span class="name"><span class="innerContentContainer">等待的外部资源迟迟不到位, 包括网络资源, 硬件设备, 比如打印机等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder调用卡死</span></span><ul><li><span class="name"><span class="innerContentContainer">Binder环境卡住, 包括binder线程池用光, 申请不到内存等.</span></span></li><li><span class="name"><span class="innerContentContainer">binder对端, 即系统service卡死. 比较少见.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">窗口失去焦点</span></span></li><li><span class="name"><span class="innerContentContainer">多线程之间锁死.</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger合成出问题导致界面没有绘制. 黑屏, 白屏一般是这个原因.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务启动时出现ANR 的原因</span></span><ul><li><span class="name"><span class="innerContentContainer">Service创建之前会延迟发送一个消息，而这个消息就是ANR的起源；</span></span></li><li><span class="name"><span class="innerContentContainer">Service创建完毕，在规定的时间之内执行完毕 onCreate()方法就移除这个消息，就不会产生ANR了；</span></span></li><li><span class="name"><span class="innerContentContainer">在规定的时间之内没有完成onCreate()的调用，消息被执行，ANR发生。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder问题分析  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText"><b>问题</b>稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">和应用层相关的binder问题主要有两类:</span></span><ul><li><span class="name"><span class="innerContentContainer">主线程被Binder 对端block导致anr;</span></span></li><li><span class="name"><span class="innerContentContainer">Binder被占满, 导致主线程无法启动binder引起异常.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,<a class="contentLink" target="_blank" rel="noreferrer" href="http://com.starbucks.cn">com.starbucks.cn</a>,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span></li><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer"><b>940: delay的时长(单位: 毫秒)   --关键</b></span></span></li><li><span class="name"><span class="innerContentContainer">com.starbucks.cn: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比.</span></span></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER FAILED TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/failed_transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTIONS</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/transactions</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER STATS</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/stats</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER PROCESS STATE</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/proc/*</span></span></li><li><span class="name"><span class="innerContentContainer">bind相关的一些状态</span></span></li></ul></li></ul></li></ul>
  </body>
</html>