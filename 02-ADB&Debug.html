<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>02-ADB&amp;Debug</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android log系统框图  <span class="contentTag" title="Filter @iImage">@<span class="contentTagText">iImage</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"></span></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>结构化分析问题</b></span></span><ul><li><span class="name"><span class="innerContentContainer">1. 缩小问题</span></span><ul><li><span class="name"><span class="innerContentContainer">通过直观信息（包括问题描述、录屏、用户反馈等），确认如下3件事:</span></span><ul><li><span class="name"><span class="innerContentContainer">主体模块</span></span></li><li><span class="name"><span class="innerContentContainer">用户操作流程</span></span></li><li><span class="name"><span class="innerContentContainer">问题发生的大致时间。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">目标: event的 log窗口以3分钟为宜，logcat的 log窗口以1分钟为宜。</span></span></li><li><span class="name"><span class="innerContentContainer">截屏log关键字: screenshot</span></span></li><li><span class="name"><span class="innerContentContainer">开始录屏、结束录屏关键字: startrecord|screenrecord</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 联机模式  --要重视联机模式。一些问题即使本地复现不了，正常log也有分析的必要</span></span><ul><li><span class="name"><span class="innerContentContainer">读出指定应用PID</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep 'Start proc' "   // 用于启动应用的场景</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell "ps | grep 'com.android.settings' "   // 用于应用已经启动起来的场景.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导出指定PID的log</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat -c"   // 清旧Log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep &lt;PID&gt; " &gt; 1.log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出焦点窗口</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "dumpsys window | grep -E 'mCurrentFocus|mFocusedApp'"</span></span></li><li><span class="name"><span class="innerContentContainer">mCurrentFocus 指前台窗口, mFocusedApp 指前台应用.</span></span></li><li><span class="name"><span class="innerContentContainer">在 mCurrentFocus 为systemui (systemui 是一个没有activity的view)时, 两者不一致. 此时mCurrentFocus 是 systemui, mFocusedApp 则为切换前的app.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出屏幕分辨率、应用窗口大小等</span></span><ul><li><span class="name"><span class="innerContentContainer">参见 屏幕分辨率</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 确定应用线程和包名</span></span><ul><li><span class="name"><span class="innerContentContainer">am_proc_start|wm_proc_start : 启动进程(应用). 各字段是:</span></span><ul><li><span class="name"><span class="innerContentContainer">user ID ， </span></span></li><li><span class="name"><span class="innerContentContainer">PID 和 UID，进程id和UID，非常关键。</span></span></li><li><span class="name"><span class="innerContentContainer">process name，包名</span></span></li><li><span class="name"><span class="innerContentContainer">type，进程类型，包括 activity, service, broadcast, provider</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">4. 跟踪窗口切换流。跟踪用户操作流，对理解问题本质价值很大，不要忽略。</span></span><ul><li><span class="name"><span class="innerContentContainer">am_create_activity|wm_create_activity : 启动activity。字段有: </span></span><ul><li><span class="name"><span class="innerContentContainer">user id，没用</span></span></li><li><span class="name"><span class="innerContentContainer">token，对象hash，很有用。</span></span></li><li><span class="name"><span class="innerContentContainer">task id，task栈id，即 am_create_task 创建的，两者有一一对应关系。</span></span></li><li><span class="name"><span class="innerContentContainer">component name，即包名</span></span></li><li><span class="name"><span class="innerContentContainer">action / mime / uri / flags，启动本activity的intent的4个属性。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_on_resume_called|wm_on_resume_called|am_set_resumed_activity|wm_set_resumed_activity : activity resume 完成，约等于已经显示在屏幕上。activity的create / restart / resume 都会经过这里。字段有：</span></span><ul><li><span class="name"><span class="innerContentContainer">user id</span></span></li><li><span class="name"><span class="innerContentContainer">compnent name: activity名</span></span></li><li><span class="name"><span class="innerContentContainer">reason: 只有两个，Resume和 lifecycler resume。价值不大。</span></span></li><li><span class="name"><span class="innerContentContainer">辅助打印: am_resume_activity, 以及 Displayed</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">wm_task_created|am_task_created : 创建并绑定 task和 stack。</span></span><ul><li><span class="name"><span class="innerContentContainer">task id</span></span></li><li><span class="name"><span class="innerContentContainer">stack id</span></span></li><li><span class="name"><span class="innerContentContainer">辅助打印: wm_stack_created， am_create_task, 仅打印 task id.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_focused_stack|wm_focused_stack: stack获得焦点。注意是stack获得焦点。</span></span><ul><li><span class="name"><span class="innerContentContainer">user id； 用户id. 后面还有一个数字，含义不清楚。</span></span></li><li><span class="name"><span class="innerContentContainer">new stack ID: 获得焦点的 stack id</span></span></li><li><span class="name"><span class="innerContentContainer">old stack ID: 失去焦点的 stack id</span></span></li><li><span class="name"><span class="innerContentContainer">reason: 原因。</span></span></li><li><span class="name"><span class="innerContentContainer">辅助打印: am_task_to_front,  am_focused_activity.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_pause_activity|wm_pause_activity : activity切换到后台. </span></span><ul><li><span class="name"><span class="innerContentContainer"> (User|1|5), (Token|1|5), (Component Name|3)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 稳定性问题，跟踪AMS杀进程的流程   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">am_finish_activity|wm_finish_activity : activity结束。字段有:</span></span><ul><li><span class="name"><span class="innerContentContainer">user id</span></span></li><li><span class="name"><span class="innerContentContainer">token</span></span></li><li><span class="name"><span class="innerContentContainer">task id</span></span></li><li><span class="name"><span class="innerContentContainer">component name</span></span></li><li><span class="name"><span class="innerContentContainer">reason</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_activity_launch_time|wm_activity_launch_time : activity从启动到显示花的时间, 最后一个数字表示毫秒数。</span></span></li><li><span class="name"><span class="innerContentContainer">am_anr : 发生anr。字段有:</span></span><ul><li><span class="name"><span class="innerContentContainer">user，没用。</span></span></li><li><span class="name"><span class="innerContentContainer">pid</span></span></li><li><span class="name"><span class="innerContentContainer">package name</span></span></li><li><span class="name"><span class="innerContentContainer">flags，没用。</span></span></li><li><span class="name"><span class="innerContentContainer">reason，原因。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_kill : am杀掉应用。字段有:</span></span><ul><li><span class="name"><span class="innerContentContainer">user</span></span></li><li><span class="name"><span class="innerContentContainer">pid</span></span></li><li><span class="name"><span class="innerContentContainer">process name</span></span></li><li><span class="name"><span class="innerContentContainer">oom adj，进程优先级。</span></span></li><li><span class="name"><span class="innerContentContainer">reason，原因。说明见后文。</span></span></li><li><span class="name"><span class="innerContentContainer">辅助打印： am_proc_died</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_crash : 应用crash。字段有：</span></span><ul><li><span class="name"><span class="innerContentContainer">user</span></span></li><li><span class="name"><span class="innerContentContainer">pid</span></span></li><li><span class="name"><span class="innerContentContainer">process name</span></span></li><li><span class="name"><span class="innerContentContainer">flags</span></span></li><li><span class="name"><span class="innerContentContainer">exception， message， file，line，异常说明</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_process_crashed_too_much : 进程短时间crash多次. 字段有: (User|1|5), (Name|3), (PID|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">am_wtf : 应用报错。严重的异常，但又没有crash。第二个参数是pid，第三个是包名。 --价值不大</span></span></li><li><span class="name"><span class="innerContentContainer">am_low_memory : lmk机制队列元素个数. 好像没啥用处.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 时刻关注丢帧, GC, Log溢出的情况。因为系统资源衰竭的时候, 各种奇怪的事都会发生   <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">丢帧： Choreographer: Skipped</span></span><ul><li><span class="name"><span class="innerContentContainer">当掉帧数超过SKIPPED_FRAME_WARNING_LIMIT（默认30帧）时会打印.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">垃圾回收： Starting a blocking GC Alloc|GC freed|force_gc</span></span><ul><li><span class="name"><span class="innerContentContainer">各字段的含义是:</span></span></li><li><span class="name"><span class="innerContentContainer">freed 1049k：表明在这次GC中回收了多少内存。</span></span></li><li><span class="name"><span class="innerContentContainer">60% free 2341k/9351K：表明回收后60%的Heap可用，存活的对象大小为2341kb，heap大小是9351kb。</span></span></li><li><span class="name"><span class="innerContentContainer">external 3502/6261K：是Native Memory的数据。存放Bitmap Pixel Data（位图数据）或者堆以外内存（NIO Direct Buffer）之类的数据。第一个值说明在Native Memory中已分配3502kb内存，第二个值是一个浮动的GC阈值，当分配内存达到这个值时，会触发一次GC。</span></span></li><li><span class="name"><span class="innerContentContainer">paused 3ms 3ms：表明GC的暂停时间，如果是Concurrent GC，会看到两个时间，一个开始，一个结束，且时间很短，如果是其他类型的GC，很可能只会看到一个时间，且这个时间是相对比较长的。并且，越大的Heap Size在GC时导致暂停的时间越长。</span></span></li><li><span class="name"><span class="innerContentContainer">force_gc (reason|3): gc的原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log溢出： identical \d+ line|expire \d+ line</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 警惕binder异常  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,<a class="contentLink" target="_blank" rel="noreferrer" href="http://com.starbucks.cn">com.starbucks.cn</a>,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span></li><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer"><b>940: delay的时长(单位: 毫秒) </b></span></span></li><li><span class="name"><span class="innerContentContainer">com.starbucks.cn: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比. (这个含义应该不对)</span></span></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder被对端卡住，要注意关注下系统广播的情况，如果出现广播风暴，则ams会被卡死，log参见: sendBroadcast </span></span></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">waitForResponse: binder卡住, 在堆栈中可见.</span></span></li><li><span class="name"><span class="innerContentContainer">audioserver_binder_timeout: binder超时 </span></span><ul><li><span class="name"><span class="innerContentContainer">(command|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binderDied：binder挂掉</span></span></li><li><span class="name"><span class="innerContentContainer">参见: Binder问题分析</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">官方Log注释</span></span><ul><li><span class="name"><span class="innerContentContainer">原生代码中其实有大量的关键log的文档. 这类文档叫 event.logtags.</span></span></li><li><span class="name"><span class="innerContentContainer">其数据格式是: event|1|5</span></span></li><li><span class="name"><span class="innerContentContainer">event表示含义;</span></span></li><li><span class="name"><span class="innerContentContainer">第一个数字表示数据类型, 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">1: int</span></span></li><li><span class="name"><span class="innerContentContainer">2: long</span></span></li><li><span class="name"><span class="innerContentContainer">3: string</span></span></li><li><span class="name"><span class="innerContentContainer">4: list</span></span></li><li><span class="name"><span class="innerContentContainer">5: float</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二个数字表示数据属性, 包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">1: Number of objects</span></span></li><li><span class="name"><span class="innerContentContainer">2: Number of bytes</span></span></li><li><span class="name"><span class="innerContentContainer">3: Number of milliseconds</span></span></li><li><span class="name"><span class="innerContentContainer">4: Number of allocations</span></span></li><li><span class="name"><span class="innerContentContainer">5: Id</span></span></li><li><span class="name"><span class="innerContentContainer">6: Percent</span></span></li><li><span class="name"><span class="innerContentContainer">s: Number of seconds (monotonic time)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Input Log关键字</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Input</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><a class="contentLink" target="_blank" rel="noreferrer" href="https://blog.csdn.net/DroidPhone/article/details/8432055">https://blog.csdn.net/DroidPhone/article/details/8432055</a></span></span></li><li><span class="name"><span class="innerContentContainer">常规： Inputreader|inputdispatcher|inputmanager_dispatch|InputTransport|PhoneWindowManager|processMotionEvent|dispatchPointerEvent</span></span></li><li><span class="name"><span class="innerContentContainer">View 处理触摸事件： processMotionEvent </span></span><ul><li><span class="name"><span class="innerContentContainer">Input log开关不打开时，这个打印也有，所以方便。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>input rawdata： Input event</b></span></span><ul><li><span class="name"><span class="innerContentContainer">其中: device 即设备ID</span></span></li><li><span class="name"><span class="innerContentContainer">Type, 事件类型.</span></span><ul><li><span class="name"><span class="innerContentContainer">0, EV_SYN，同步事件。因为一个事件要保上报多次，所以需要同步事件来确认整个事件上报完毕。</span></span></li><li><span class="name"><span class="innerContentContainer">1, EV_KEY，描述键盘，按键或者类似键盘设备的状态变化。</span></span></li><li><span class="name"><span class="innerContentContainer">2, EV_REL，用来描述相对坐标轴上数值的变化，例如：鼠标向左方移动了5个单位。</span></span></li><li><span class="name"><span class="innerContentContainer">3, EV_ABS, 用来描述坐标轴上数值的变化，例如：描述触摸屏上坐标的值。</span></span></li><li><span class="name"><span class="innerContentContainer">4, EV_MSC, 当不能匹配现有的类型时，使用该类型。</span></span></li><li><span class="name"><span class="innerContentContainer">5, EV_SW, 描述具备两种状态的输入开关。</span></span></li><li><span class="name"><span class="innerContentContainer">17, EV_LED, 控制设备上的LED灯的开和关。</span></span></li><li><span class="name"><span class="innerContentContainer">18, EV_SND, 用来给设备输出提示声音。</span></span></li><li><span class="name"><span class="innerContentContainer">20, EV_REP, 用于可以自动重复的设备（autorepeating）。</span></span></li><li><span class="name"><span class="innerContentContainer">21, EV_FF, 用来给输入设备发送强制回馈命令。</span></span></li><li><span class="name"><span class="innerContentContainer">22, EV_PWR, 用于电源开关的输入。</span></span></li><li><span class="name"><span class="innerContentContainer">23, EV_FF_STATUS, 用于接收设备的强制反馈状态。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">code，指键值，即键的ID. 含义依赖 type字段, 是type的进一步说明。包括: </span></span><ul><li><span class="name"><span class="innerContentContainer">EV_ABS，3。触摸事件</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_ABS事件描述了某一特性的绝对变化值。对于触摸事件即坐标。包括:</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_&lt;name&gt;: 用于描述多点触摸输入设备。详情请参考内核文档：multi-touch-protocol.txt。常见的键值包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">ABS_MT_POSITION_X：0x35，x轴</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_POSITION_Y：0x36，y轴</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_TOUCH_MAJOR：0x30，接触区域长轴的长度。</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_TOUCH_MINOR：0x31，接触区域短轴的长度。</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_WIDTH_MAJOR：0x32，手指轮廓长轴的长度。</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_WIDTH_MINOR：0x33，手指轮廓短轴的长度。</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_TRACKING_ID：0x39，事件的id值。</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_PRESSURE：0x3a，压力值。</span></span></li><li><span class="name"><span class="innerContentContainer">ABS_MT_DISTANCE：0x3b，手指到屏幕的距离，0表示接触，任何正数表示悬浮。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ABS_DISTANCE: 用来描述触摸工具离触摸表面的距离。这一事件应该只有当触摸工具在表面悬空滑过时发出，也就是说，在靠经触摸表面，但是 BTN_TOUCH的value是0的时候。</span></span></li><li><span class="name"><span class="innerContentContainer">如果输入设备可以工作在3维坐标时，应该考虑使用 ABS_Z会更好。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EV_KEY，1。按键手机</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式，比如，KEY_A代表键盘上的A键.</span></span></li><li><span class="name"><span class="innerContentContainer">当一个按键被按下时，一个带有按键编码和value为1的事件被发出。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个按键被释放时，一个value为0的事件被发出。</span></span></li><li><span class="name"><span class="innerContentContainer">有些硬件当按键重复时会发出事件，这些事件的value值为2。</span></span></li><li><span class="name"><span class="innerContentContainer">通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。</span></span></li><li><span class="name"><span class="innerContentContainer">常见的code有:</span></span></li><li><span class="name"><span class="innerContentContainer">0x14a, BTN_TOUCH, 触摸屏</span></span><ul><li><span class="name"><span class="innerContentContainer">用于触摸事件。当一个输入工具被判定为有意义的物理接触时，这一特性的value值应该设为1。</span></span></li><li><span class="name"><span class="innerContentContainer">所谓有意义的物理接触可以是任何的接触，又或者是满足某种定义条件的接触。</span></span></li><li><span class="name"><span class="innerContentContainer">例如，触摸板可以当触摸的压力达到某一个值以上时才把value设为1，一个用笔的平板当笔划过但没有接触到平板的表面时，把BTN_TOOL_PEN的value设为1，而把BTN_TOUCH的value设为0.</span></span></li><li><span class="name"><span class="innerContentContainer">出于历史的原因，用户空间会把带有BTN_TOOL_FINGER和 BTN_TOUCH的触摸设备解释为触摸板，而类似的不带BTN_TOOL_FINGER的触摸设备则被解释为触摸屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">116, 0x74, power键</span></span></li><li><span class="name"><span class="innerContentContainer">115, 0x73, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">114, 0x72, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_&lt;name&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">BTN_TOOL_PEN, 0x140</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_RUBBER, 0x141</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_BRUSH, 0x142</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_PENCIL, 0x143</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_AIRBRUSH, 0x144</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_FINGER, 0x145</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_MOUSE, 0x146</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_LENS, 0x147</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_QUINTTAP, 0x148</span></span></li><li><span class="name"><span class="innerContentContainer">这些codes用于配合触控板，平板和触摸屏这些设备的输入，这些设备可以使用手指，笔或者其它工具。</span></span></li><li><span class="name"><span class="innerContentContainer">当一个事件发生并且检测到某种工具在使用时，相应的BTN_TOOL_&lt;name&gt; code事件应该把value设为1，</span></span></li><li><span class="name"><span class="innerContentContainer">当该工具不再和输入设备进行交互时，value应该复位为0。</span></span></li><li><span class="name"><span class="innerContentContainer">所有的触控板，当事件发生时，平板和触摸屏映泰至少使用一种BTN_TOOL_&lt;name&gt; code。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">0x14b，BTN_STYLUS, 手写笔</span></span></li><li><span class="name"><span class="innerContentContainer">BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP,BTN_TOOL_TRIPLETAP, BTN_TOOL_QUADTAP</span></span><ul><li><span class="name"><span class="innerContentContainer">这些codes表明一个，两个，三个和四个手指参与触摸板和触摸屏的操作。</span></span></li><li><span class="name"><span class="innerContentContainer">如果用户使用两只手指在触摸板上试图滚动屏幕上的内容，在运动期间，应该发送value为1的BTN_TOOL_DOUBLETAP。</span></span></li><li><span class="name"><span class="innerContentContainer">在多手指触摸驱动中，应该使用input_mt_report_finger_count()函数来发出以上这些codes，详情请参看内核文档：multi-touch-protocol.txt。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EV_REL，2。鼠标滚轮事件</span></span><ul><li><span class="name"><span class="innerContentContainer">EV_REL事件描述了某种特性的相对变化量。例如，鼠标向左方移动了几个单位距离，但是他的绝对位置是未知的。</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们可以知道绝对位置，那我们应该使用EV_ABS而不是EV_REL。</span></span></li><li><span class="name"><span class="innerContentContainer">常见的值有:</span></span></li><li><span class="name"><span class="innerContentContainer">REL_WHEEL, REL_HWHEEL: 用于对应的垂直方向和水平方向的滚轮。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">value，指具体值</span></span><ul><li><span class="name"><span class="innerContentContainer">1 表示按下</span></span></li><li><span class="name"><span class="innerContentContainer">0 表示抬起</span></span></li><li><span class="name"><span class="innerContentContainer">触摸事件时，value表示坐标。x, y轴是分开上报的。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件上报： notifyMotion|notifyKey|dispatchMotion|dispatchKey</b></span></span><ul><li><span class="name"><span class="innerContentContainer">分为两组，前者在入队列前打印，后两者在分发前打印。两组内容基本一样，仅policyFlags可能会发生变化。</span></span></li><li><span class="name"><span class="innerContentContainer">各枚举字段的含义在 input.h 中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">eventTime, 事件上报时间</span></span></li><li><span class="name"><span class="innerContentContainer">downTime, down事件时间。down是所有事件的起点，所以downTime自然成了事件的时间戳，标识同一个事件的各个部分。非常重要。</span></span><ul><li><span class="name"><span class="innerContentContainer">过滤非法事件主要靠检查 downTime的各种不符合预期的情况。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">deviceId： 设备id。即hal层input设备id。</span></span><ul><li><span class="name"><span class="innerContentContainer">R版本上，注入的事件都写入 -1。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">source，设备类型</span></span><ul><li><span class="name"><span class="innerContentContainer">触屏： 0x1002</span></span></li><li><span class="name"><span class="innerContentContainer">键盘： 0x101</span></span></li><li><span class="name"><span class="innerContentContainer">鼠标： 0x2002</span></span></li><li><span class="name"><span class="innerContentContainer">手写笔： 0x4002</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>policyFlags</b>： 即wms窗口策略。</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 保持系统唤醒</span></span></li><li><span class="name"><span class="innerContentContainer">2, 是虚拟导航按键</span></span></li><li><span class="name"><span class="innerContentContainer">4, 是特殊功能修饰健（Ctrl、shift 之类）</span></span></li><li><span class="name"><span class="innerContentContainer">8, </span></span></li><li><span class="name"><span class="innerContentContainer">0x100 0000，注入的事件</span></span></li><li><span class="name"><span class="innerContentContainer">0x200 0000，可信的</span></span></li><li><span class="name"><span class="innerContentContainer">0x400 0000， 过滤的</span></span></li><li><span class="name"><span class="innerContentContainer">0x800 0000， 禁用自动重复事件。</span></span></li><li><span class="name"><span class="innerContentContainer">0x2000 0000，交互的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">0x4000 0000，事件要传递到应用层，即 PASS_TO_USER.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>action</b>: 事件类型。</span></span><ul><li><span class="name"><span class="innerContentContainer">0： down</span></span></li><li><span class="name"><span class="innerContentContainer">1： up</span></span></li><li><span class="name"><span class="innerContentContainer">2： move</span></span></li><li><span class="name"><span class="innerContentContainer">3： cancel</span></span></li><li><span class="name"><span class="innerContentContainer">4： outside</span></span></li><li><span class="name"><span class="innerContentContainer">7： hover move</span></span></li><li><span class="name"><span class="innerContentContainer">9： hover enter</span></span></li><li><span class="name"><span class="innerContentContainer">10： hover exit</span></span></li><li><span class="name"><span class="innerContentContainer">11： button press</span></span></li><li><span class="name"><span class="innerContentContainer">12： button release</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">actionButton： 按键类型，比如左键、中键、右键之类。</span></span></li><li><span class="name"><span class="innerContentContainer">flags： 标记</span></span><ul><li><span class="name"><span class="innerContentContainer">对于触摸事件，用于标记点位发生在屏幕边界，分上下左右。--不常用。</span></span></li><li><span class="name"><span class="innerContentContainer">对于按键事件，这个字段重要多了。</span></span><ul><li><span class="name"><span class="innerContentContainer">2，软键盘产生的事件。</span></span></li><li><span class="name"><span class="innerContentContainer">8, 事件来自系统，不可被应用屏蔽。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Precision: 分x、y轴, 屏幕密度，一般是1。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>keyCode: 按键键值(逻辑)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">在 Keycodes.h 和 KeyEvent.java 中定义，两者保持一一对应。</span></span></li><li><span class="name"><span class="innerContentContainer">在 InputEventLabels.h 中引用。如果要写入，这三处要保持一致。</span></span></li><li><span class="name"><span class="innerContentContainer">fwk和应用使用keyCode。</span></span></li><li><span class="name"><span class="innerContentContainer">常见键值包括：</span></span></li><li><span class="name"><span class="innerContentContainer">26, 0x1a, KEYCODE_POWER，power键</span></span></li><li><span class="name"><span class="innerContentContainer">24, 0x18, KEYCODE_VOLUME_UP, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">25, 0x19, KEYCODE_VOLUME_DOWN, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">4, KEYCODE_BACK</span></span></li><li><span class="name"><span class="innerContentContainer">3, KEYCODE_HOME</span></span></li><li><span class="name"><span class="innerContentContainer">187, 0xBB, KEYCODE_APP_SWITCH.</span></span></li><li><span class="name"><span class="innerContentContainer">82，0x52，KEYCODE_MENU.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>scanCode: 按键键值(硬件)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">输入设备上报的值。在 framework/base/data/keyboards 目录下的各 *.kl 文件中定义。</span></span></li><li><span class="name"><span class="innerContentContainer">116, 0x74, power键</span></span></li><li><span class="name"><span class="innerContentContainer">115, 0x73, 音量上</span></span></li><li><span class="name"><span class="innerContentContainer">114, 0x72, 音量下</span></span></li><li><span class="name"><span class="innerContentContainer">102, 0x66, home键</span></span></li><li><span class="name"><span class="innerContentContainer">158, 0x9e, back键</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">metaState: 键盘，标识 Ctrl、ALT等按键的状态。 参见 ameta_none</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>触摸屏报点： InputDispatcher:   Pointer</b></span></span><ul><li><span class="name"><span class="innerContentContainer">id：点的序号，从0开始，一些input事件有多个点。</span></span></li><li><span class="name"><span class="innerContentContainer">toolType： 触摸工具类型。</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 手指</span></span></li><li><span class="name"><span class="innerContentContainer">2, 手写笔</span></span></li><li><span class="name"><span class="innerContentContainer">3, 鼠标</span></span></li><li><span class="name"><span class="innerContentContainer">4, 橡皮擦 ？</span></span></li><li><span class="name"><span class="innerContentContainer">5, 手掌 ？</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">x, y： 点坐标</span></span></li><li><span class="name"><span class="innerContentContainer">pressure: 按下压力值。用于按压屏或者手写笔。</span></span></li><li><span class="name"><span class="innerContentContainer">size： 触摸区域的大小（近似值）。0到1之间。</span></span></li><li><span class="name"><span class="innerContentContainer">touchMajor, tohchMinor, 触摸区域的长轴和短轴（单位为像素）</span></span></li><li><span class="name"><span class="innerContentContainer">toolMajor, toolMinor, 触摸根工具的长轴和短轴 （单位为像素）</span></span></li><li><span class="name"><span class="innerContentContainer">这4个值一般一样。</span></span></li><li><span class="name"><span class="innerContentContainer">orientation: 屏幕方向，0表示竖屏。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">channel 发送事件的流程</span></span><ul><li><span class="name"><span class="innerContentContainer">enqueueDispatchCycle</span></span></li><li><span class="name"><span class="innerContentContainer">prepareDispatchCycle：准备发送</span></span></li><li><span class="name"><span class="innerContentContainer">startDispatchCycle：开始发送</span></span></li><li><span class="name"><span class="innerContentContainer">publishMotionEvent</span></span></li><li><span class="name"><span class="innerContentContainer">finishDispatchCycle：结束发送</span></span></li><li><span class="name"><span class="innerContentContainer">sendFinishedSignal：发送回执</span></span></li><li><span class="name"><span class="innerContentContainer">receiveFinishedSignal ：nput收到回执。标志处理完毕。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，errno=11 并不是什么错误。意思是当前处理过程被其它进程打断，后续调度回来会继续处理，不会影响业务。这种错误id很常见。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用收到事件：在 EarlyPostImeInputStage.processMotionEvent() 可加入log，确认应用层开始处理触摸事件。可只跟踪 down/up/cancel。</span></span><ul><li><span class="name"><span class="innerContentContainer">processMotionEvent。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用处理完事件： 在 ViewPostImeInputStage.processPointerEvent()可加入log，该函数执行完，即代表view处理完事件。 只跟踪 down/up/cancel。</span></span><ul><li><span class="name"><span class="innerContentContainer">dispatchPointerEvent handled=true，表示处理完；=false，表示非应用层处理。</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">设置input模式：setInputDispatchMode</span></span><ul><li><span class="name"><span class="innerContentContainer">包括正常，禁用，冻结三种模式</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>事件注入： injectInputEvent|should inject</b></span></span><ul><li><span class="name"><span class="innerContentContainer">injectorPid: 注入线程id</span></span></li><li><span class="name"><span class="innerContentContainer">injectorUid: 注入线程uid</span></span></li><li><span class="name"><span class="innerContentContainer">Finished with result to 0: 注入成功。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件拦截： interceptKeyBeforeQueueing|interceptKeyBeforeDispatching</span></span></li><li><span class="name"><span class="innerContentContainer">事件cancel： InputDispatcher: cancel</span></span><ul><li><span class="name"><span class="innerContentContainer">各字段含义和 notify Motion相同。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件cancel的原因：cancellation events</span></span><ul><li><span class="name"><span class="innerContentContainer">其中: channel, cancel</span></span></li><li><span class="name"><span class="innerContentContainer">synthesized，被cancel的事件的数量</span></span></li><li><span class="name"><span class="innerContentContainer">mode，cancel模式</span></span><ul><li><span class="name"><span class="innerContentContainer">1, 点事件</span></span></li><li><span class="name"><span class="innerContentContainer">2, 非点事件</span></span></li><li><span class="name"><span class="innerContentContainer">3, callback事件</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">事件被跳过： skipping inconsistent motion event</span></span></li><li><span class="name"><span class="innerContentContainer">事件删除： Dropping</span></span><ul><li><span class="name"><span class="innerContentContainer">第二个关键字是删除原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件过滤： filter|shouldInterceptEventLocked </span></span></li><li><span class="name"><span class="innerContentContainer">事件冲突： Conflicting pointer actions</span></span></li><li><span class="name"><span class="innerContentContainer">设备识别： Device added|New device|Input event</span></span><ul><li><span class="name"><span class="innerContentContainer">其中: id 后面用得比较多。</span></span></li><li><span class="name"><span class="innerContentContainer">classes 为设备类型，为掩码量。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">光标显示： unfade|fade|cursor</span></span></li><li><span class="name"><span class="innerContentContainer">小圆点: sprite，图层叫sprite. 可以有多个, 一个点一个图层。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Sensor</span></span><ul><li><span class="name"><span class="innerContentContainer">hal层上报数据：sensors-hal|ap_sensors</span></span></li><li><span class="name"><span class="innerContentContainer">服务： SensorManager|SensorService</span></span></li><li><span class="name"><span class="innerContentContainer">振动： Vibrator。 distance=5，远离；=0，接近。</span></span></li><li><span class="name"><span class="innerContentContainer">接近光： Proximity</span></span></li><li><span class="name"><span class="innerContentContainer">环境光：Ambient</span></span></li><li><span class="name"><span class="innerContentContainer">加速度： Accelerometer，横竖屏切换</span></span></li><li><span class="name"><span class="innerContentContainer">陀螺仪: Gyroscope</span></span></li><li><span class="name"><span class="innerContentContainer">重力传感器： gravity</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Activity / 进程 / window / view</b></span></span><ul><li><span class="name"><span class="innerContentContainer">启动应用: ActivityManager: Start proc|ActivityManager: START u0</span></span></li><li><span class="name"><span class="innerContentContainer">创建activity： Relayout Window|DecorView setVisibility</span></span></li><li><span class="name"><span class="innerContentContainer">activity启动：am_on_create_called|am_on_start_called|am_on_restart_called|am_relaunch_resume_activity|am_relaunch_activity</span></span></li><li><span class="name"><span class="innerContentContainer">窗口layout: WindowManager: Relayout Window</span></span></li><li><span class="name"><span class="innerContentContainer"><b>焦点窗口切换</b>： Set focused app to|Changing focus from|Focus entered window</span></span></li><li><span class="name"><span class="innerContentContainer"><b>启动activity耗时: am _activity_launch_time  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">am_activity_launch_time:[0, 225986022,  com.android.camera/.Camera, 19823]</span></span></li><li><span class="name"><span class="innerContentContainer">其中 19823 是绘制的毫秒数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity绘制时间： am_activity_fully_drawn_time <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">判断窗口是原生view还是 webview？</span></span><ul><li><span class="name"><span class="innerContentContainer">打开： 开发者选项 - 绘图 - 显示布局边界</span></span></li><li><span class="name"><span class="innerContentContainer">回到窗口界面，如果是原生view，页面中的每个元素周围都有红框，如果是webview，就整体显示一个大框。</span></span></li><li><span class="name"><span class="innerContentContainer">更新webview：Google在维护webview组件，一些问题可通过更新webview组件来解决。</span></span><ul><li><span class="name"><span class="innerContentContainer">先回退版本： 设置 - 应用管理 - 应用列表 - 点击右上菜单“显示系统程序” - 检索webview - 点击右上“卸载更新”</span></span></li><li><span class="name"><span class="innerContentContainer">然后去Google play升级webview。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">创建task stack： wm_stack_created</span></span><ul><li><span class="name"><span class="innerContentContainer">StackId: 指activity task ID</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">移除task： wm_task_removed</span></span><ul><li><span class="name"><span class="innerContentContainer">(TaskId|1|5),  (Reason|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Reason: 移除原因</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将window移动到top ： wm_task_moved</span></span><ul><li><span class="name"><span class="innerContentContainer">(TaskId|1|5), (ToTop|1), (Index|1)</span></span></li><li><span class="name"><span class="innerContentContainer">Totop: 1表示top，0表示bottom</span></span></li><li><span class="name"><span class="innerContentContainer">index： target position的值。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_restart_activity, activity 重新切换到前台. 字段有: (User|1|5), (Token|1|5), (Task ID|1|5), (Component Name|3)</span></span></li><li><span class="name"><span class="innerContentContainer">已经存在的activity接受新的intent: am_new_intent, 字段有:</span></span><ul><li><span class="name"><span class="innerContentContainer">(User|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(Token|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(Task ID|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(Component Name|3), </span></span></li><li><span class="name"><span class="innerContentContainer">(Action|3), (MIME Type|3), (URI|3), (Flags|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">activity结束： am_finish_activity|am_destroy_activity|am_stop_activity|am_on_stop_called|am_on_destroy_called</span></span><ul><li><span class="name"><span class="innerContentContainer">am_destroy_activity 有reasen字段.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">进程优先级调整: adj \ d+</span></span></li><li><span class="name"><span class="innerContentContainer">activity从栈中被移除： am_remove_task</span></span><ul><li><span class="name"><span class="innerContentContainer">数据是两个整数，前者是task id，后者是stack id。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Application 线程绑定到工作队列: am_proc_bound</span></span></li><li><span class="name"><span class="innerContentContainer">Stack focus: am_focused_stack</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (Display Id|1|5), (Focused Stack Id|1|5), (Last Focused Stack Id|1|5), (Reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">回调onActivityResult: am_on_activity_result_called</span></span></li><li><span class="name"><span class="innerContentContainer">暂停activity: am_pause_activity|am_on_paused_called|am_set_resumed_activity</span></span></li><li><span class="name"><span class="innerContentContainer">activity启动异常: am_proc_bad|am_process_start_timeout|am_failed_to_pause|am_proc_bad</span></span></li><li><span class="name"><span class="innerContentContainer">activity恢复正常: am_proc_good</span></span></li><li><span class="name"><span class="innerContentContainer">应用启动： Start proc|New app record|am_proc_start|am_pre_boot</span></span></li><li><span class="name"><span class="innerContentContainer">进程处理事件： handleMessage, what   --有的有, 有的没有.</span></span></li><li><span class="name"><span class="innerContentContainer">应用清理（会造成应用退出）： Clearing app   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">Task 被压缩: am_compact</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (Pid|1|5),(Process Name|3),(Action|3),(BeforeRssTotal|2|2),(BeforeRssFile|2|2),(BeforeRssAnon|2|2),(BeforeRssSwap|2|2),(DeltaRssTotal|2|2),(DeltaRssFile|2|2),(DeltaRssAnon|2|2),(DeltaRssSwap|2|2),(Time|2|3),(LastAction|1|2),(LastActionTimestamp|2|3),(setAdj|1|2),(procState|1|2),(BeforeZRAMFree|2|2),(DeltaZRAMFree|2|2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">The activity's onTopResumedActivityChanged(true) has been called: am_on_top_resumed_gained_called</span></span></li><li><span class="name"><span class="innerContentContainer">The activity's onTopResumedActivityChanged(false) has been called:  am_on_top_resumed_lost_called</span></span></li><li><span class="name"><span class="innerContentContainer">An activity been add into stopping list: am_add_to_stopping</span></span></li><li><span class="name"><span class="innerContentContainer">any processes of a uid have started running:  am_uid_running</span></span></li><li><span class="name"><span class="innerContentContainer">all processes of a uid have stopped:  am_uid_stopped</span></span></li><li><span class="name"><span class="innerContentContainer">the state of a uid has become active:  am_uid_active</span></span></li><li><span class="name"><span class="innerContentContainer">the state of a uid has become idle (background check enforced):  am_uid_idle</span></span></li><li><span class="name"><span class="innerContentContainer">a service is being forcibly stopped because its app went idle:  am_stop_idle_service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">surface / 渲染</span></span><ul><li><span class="name"><span class="innerContentContainer">surface: surfaceflinger</span></span></li><li><span class="name"><span class="innerContentContainer">surfaces内存溢出: wm_no_surface_memory <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">(Window|3),(PID|1|5),(Operation|3) </span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>屏幕 / 背光 / 亮灭屏</b></span></span><ul><li><span class="name"><span class="innerContentContainer">窗口大小： Rect</span></span></li><li><span class="name"><span class="innerContentContainer">偏红、偏黄等，以及花屏问题</span></span><ul><li><span class="name"><span class="innerContentContainer">停用硬件gpu叠加，如果问题不再出现，则说明问题出在gpu合成上。关闭方法: 设置 - 开发者选项 - 停用hw叠加。</span></span></li><li><span class="name"><span class="innerContentContainer">也有相反的情况，如果概率问题在停用硬件gpu叠加后变成必现，就说明有部分图层不支持gpu，导致合成问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分辨率/屏幕大小： 搜 width，height，crop</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕宽度一般是1080，直接搜1080</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">刷新率: fps</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏切换： orientation， 0, 竖屏； 1, 横屏</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏切换： Device reconfigured</span></span><ul><li><span class="name"><span class="innerContentContainer">其中: size： 屏幕坐标</span></span></li><li><span class="name"><span class="innerContentContainer">orientation： 0表示竖屏, 1表示横屏。</span></span></li><li><span class="name"><span class="innerContentContainer">mode： 设备模式，参见 DeviceMode.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏: <b>screen_toggled</b> (screen_state|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">0 : screen off，灭屏</span></span></li><li><span class="name"><span class="innerContentContainer">1 : screen on，亮屏到锁屏界面</span></span></li><li><span class="name"><span class="innerContentContainer">2 : 完成解锁</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏： onScreenChanged|PowerManagetService</span></span></li><li><span class="name"><span class="innerContentContainer">亮灭屏原因： power_screen_state</span></span><ul><li><span class="name"><span class="innerContentContainer">1. offOrOn: 0, 灭；1，亮</span></span></li><li><span class="name"><span class="innerContentContainer">2. because: 亮灭屏原因</span></span><ul><li><span class="name"><span class="innerContentContainer">参见 PowerManager.java， 300行。</span></span></li><li><span class="name"><span class="innerContentContainer">亮屏</span></span><ul><li><span class="name"><span class="innerContentContainer">0, 其它原因</span></span></li><li><span class="name"><span class="innerContentContainer">1, 按键</span></span></li><li><span class="name"><span class="innerContentContainer">2, 应用</span></span></li><li><span class="name"><span class="innerContentContainer">3, 设备插入</span></span></li><li><span class="name"><span class="innerContentContainer">4, 手势</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灭屏</span></span><ul><li><span class="name"><span class="innerContentContainer">0, 应用请求</span></span></li><li><span class="name"><span class="innerContentContainer">2, 屏幕超时</span></span></li><li><span class="name"><span class="innerContentContainer">4, power键</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">亮灭屏广播： power_screen_broadcast_send|power_screen_broadcast_done</span></span><ul><li><span class="name"><span class="innerContentContainer">wakelockCount: 发送广播的数量</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕亮度变化： Brightness</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕亮度变化： auto_brightness_adj</span></span><ul><li><span class="name"><span class="innerContentContainer">其中: old_lux: 旧的环境光度</span></span></li><li><span class="name"><span class="innerContentContainer">old_brightness： 旧的屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer">new_lux：新的环境光度</span></span></li><li><span class="name"><span class="innerContentContainer">new_brightness： 新的屏幕亮度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ams点亮屏幕（开机过程）： boot_progress_enable_screen  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService calls enableScreenAfterBoot().</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">灭屏时被清空的应用持有唤醒数量： power_sleep_requested</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systemui / 状态栏 / 通知栏</span></span><ul><li><span class="name"><span class="innerContentContainer">Usb对话框： showMtpDialog : mode</span></span></li><li><span class="name"><span class="innerContentContainer">SystemUi</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏： StatusBar</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏</span></span><ul><li><span class="name"><span class="innerContentContainer">通知被取消： notification_cancel</span></span></li><li><span class="name"><span class="innerContentContainer">通知被点击： notification_action_clicked</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏被点击： notification_clicked</span></span></li><li><span class="name"><span class="innerContentContainer">通知栏扩展或收缩： notification_expansion</span></span></li><li><span class="name"><span class="innerContentContainer">新通知显示状态改变： notification_visibility_changed</span></span><ul><li><span class="name"><span class="innerContentContainer">新的显示状态，旧的显示状态</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">显示通知栏： notification_panel_revealed</span></span></li><li><span class="name"><span class="innerContentContainer">隐藏通知栏： notification_panel_hidden</span></span></li><li><span class="name"><span class="innerContentContainer">模块全部通知取消： notification_cancel_all</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： cancel原因，监听者</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通知取消： notification_cancel</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： cancel原因，监听者</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通知： notification_enqueue</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： uid, pid, 包名，id, tag, userid, notificatin, status(0=post, 1=update, 2=ignored)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">sysui_view_visibility (category|1|5),(visible|1|6)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_action (category|1|5),(pkg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_multi_action (content|4)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_count (name|3),(increment|1)</span></span></li><li><span class="name"><span class="innerContentContainer">sysui_histogram (name|3),(bucket|1)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">桌面 / 锁屏 / KeyGuard</span></span><ul><li><span class="name"><span class="innerContentContainer">桌面： launcher</span></span></li><li><span class="name"><span class="innerContentContainer">桌面应用点击： Launcher.ItemClickHandler</span></span></li><li><span class="name"><span class="innerContentContainer">锁屏： KeyGuard</span></span></li><li><span class="name"><span class="innerContentContainer">锁屏类型: lock_screen_type (type|3)</span></span><ul><li><span class="name"><span class="innerContentContainer">包括 pin、password、pattern</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">全局手势 / 手势导航 / 虚拟导航栏</span></span><ul><li><span class="name"><span class="innerContentContainer">虚拟导航栏： NavigationBar</span></span></li><li><span class="name"><span class="innerContentContainer">recent(运行历史)显示： startRecentsActivity</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">talkback / 盲人模式 / 无障碍</span></span><ul><li><span class="name"><span class="innerContentContainer">talkback功能启动后，屏幕右下角会出现一个小人举起双臂的图标。</span></span></li><li><span class="name"><span class="innerContentContainer">一些应用为了实现自己的需求也会遮遮掩掩的引导用户打开talkback，以实现一些特殊功能，比如各应用市场的“一键安装”。</span></span></li><li><span class="name"><span class="innerContentContainer">如何关闭： 设置 - 其它设置 - 无障碍 - 关闭 。</span></span></li><li><span class="name"><span class="innerContentContainer">log： talkback</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">稳定性 Log关键字 <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><b>ANR</b>： am_anr|ANR in|Input event dispatching timed out</span></span><ul><li><span class="name"><span class="innerContentContainer">am_anr 有个字段是reason，可识别anr的直接原因。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>死锁卡死冻屏</b>: held by|blocked|caused by|locked|waiting on|locked</span></span></li><li><span class="name"><span class="innerContentContainer"><b>应用闪退/crash</b>: am_crash|am_kill|service crashed|shutting down vm|crash|fatal|backtrace|Death received</span></span><ul><li><span class="name"><span class="innerContentContainer">am_crash: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Exception|3), (Message|3), (File|3), (Line|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">shutting down vm：虚拟机重启</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Android重启</b>：exit zygote</span></span></li><li><span class="name"><span class="innerContentContainer">应用异常（优先级不高）： Androidruntime|java.lang.runtimeexception|unexpected|System.err|java.lang</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager:&nbsp;Killing&nbsp;\d+:com.android.settings</span></span></li><li><span class="name"><span class="innerContentContainer">am_drop_process, attach进程失败(找不到pid). </span></span></li><li><span class="name"><span class="innerContentContainer"><b>AMS杀进程: am_kill</b></span></span><ul><li><span class="name"><span class="innerContentContainer">am_kill 是event log，数据是： (User|1|5), (PID|1|5), (Process Name|3), (OomAdj|1|5), (<b>Reason</b>|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Killing 是logcat。</span></span></li><li><span class="name"><span class="innerContentContainer">这两个log是一一对应的。</span></span></li><li><span class="name"><span class="innerContentContainer">最有价值的字段是reason。常见的有：</span></span><ul><li><span class="name"><span class="innerContentContainer">user request after error： 进程遇到错误自杀.</span></span></li><li><span class="name"><span class="innerContentContainer">cached： 后台进程被lmk杀掉。</span></span></li><li><span class="name"><span class="innerContentContainer">background： 使用设置菜单杀进程</span></span></li><li><span class="name"><span class="innerContentContainer">remove task: 通过APP switch杀应用</span></span></li><li><span class="name"><span class="innerContentContainer">isolated not needed: 不再需要的独立进程</span></span></li><li><span class="name"><span class="innerContentContainer">empty: 空进程被清理</span></span></li><li><span class="name"><span class="innerContentContainer">stop: 被强制杀死。比如通过 adb shell kill 这种。</span></span></li><li><span class="name"><span class="innerContentContainer">anr： 应用失去响应</span></span></li><li><span class="name"><span class="innerContentContainer">scheduleCrash for: 进程之前已经死掉</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中间的数字是adj。999就是空进程。</span></span></li><li><span class="name"><span class="innerContentContainer">如果杀进程的log太多，可只看指定进程的：</span></span></li><li><span class="name"><span class="innerContentContainer">ActivityManager:&nbsp;Killing&nbsp;\d+:com.android.settings</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">am_wtf: 异常</span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (User|1|5), (PID|1|5), (Process Name|3), (Flags|1|5), (Tag|3), (Message|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Watchdog</span></span><ul><li><span class="name"><span class="innerContentContainer">进程踢狗: tickle (authority|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog (Service|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_proc_pss (Process|3),(Pid|1|5),(Pss|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_soft_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2),(Skip|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_hard_reset (Process|3),(Pid|1|5),(MaxPss|1|2),(Pss|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_pss_stats (EmptyPss|1|2),(EmptyCount|1|1),(BackgroundPss|1|2),(BackgroundCount|1|1),(ServicePss|1|2),(ServiceCount|1|1),(VisiblePss|1|2),(VisibleCount|1|1),(ForegroundPss|1|2),(ForegroundCount|1|1),(NoPssCount|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_proc_stats (DeathsInOne|1|1),(DeathsInTwo|1|1),(DeathsInThree|1|1),(DeathsInFour|1|1),(DeathsInFive|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_scheduled_reboot (Now|2|1),(Interval|1|3),(StartTime|1|3),(Window|1|3),(Skip|3)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_meminfo (MemFree|1|2),(Buffers|1|2),(Cached|1|2),(Active|1|2),(Inactive|1|2),(AnonPages|1|2),(Mapped|1|2),(Slab|1|2),(SReclaimable|1|2),(SUnreclaim|1|2),(PageTables|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_vmstat (runtime|2|3),(pgfree|1|1),(pgactivate|1|1),(pgdeactivate|1|1),(pgfault|1|1),(pgmajfault|1|1)</span></span></li><li><span class="name"><span class="innerContentContainer">watchdog_requested_reboot (NoWait|1|1),(ScheduleInterval|1|3),(RecheckInterval|1|3),(StartTime|1|3),(Window|1|3),(MinScreenOff|1|3),(MinNextAlarm|1|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低内存杀进程: lowmemorykiller</span></span><ul><li><span class="name"><span class="innerContentContainer">lowmemorykiller: Killing ':accountservice' (15215) (tgid 15215), adj 965,</span></span><ul><li><span class="name"><span class="innerContentContainer">: to free 121500kB on behalf of 'kswapd0' (90) because</span></span></li><li><span class="name"><span class="innerContentContainer">: cache 1925820kB is below limit 347440kB for oom score 606</span></span></li><li><span class="name"><span class="innerContentContainer">: Free memory is -28000kB above reserved.</span></span></li><li><span class="name"><span class="innerContentContainer">: Free CMA is 17836kB</span></span></li><li><span class="name"><span class="innerContentContainer">: Total reserve is 133660kB</span></span></li><li><span class="name"><span class="innerContentContainer">: Total free pages is 150736kB</span></span></li><li><span class="name"><span class="innerContentContainer">: Total file cache is 2844160kB</span></span></li><li><span class="name"><span class="innerContentContainer">: GFP mask is 0x14000c0</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Total free pages is 150736kB，剩余内存仅有约150M。cache 1925820kB is below limit 347440kB，1925820kB &lt; 347440kB，显然矛盾。for oom score 606与adj 965也不一致。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">低内存杀进程: killinfo</span></span><ul><li><span class="name"><span class="innerContentContainer">(Pid|1|5), (Uid|1|5), (OomAdj|1), (MinOomAdj|1), (TaskSize|1), (enum kill_reasons|1|5), (MemFree|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(Cached|1), (SwapCached|1), (Buffers|1), (Shmem|1), (Unevictable|1), (SwapTotal|1), (SwapFree|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(ActiveAnon|1), (InactiveAnon|1), (ActiveFile|1), (InactiveFile|1), (SReclaimable|1), (SUnreclaim|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(KernelStack|1), (PageTables|1), (IonHeap|1), (IonHeapPool|1), (CmaFree|1), (MsSinceEvent|1), </span></span></li><li><span class="name"><span class="innerContentContainer">(MsSincePrevWakeup|1), (WakeupsSinceEvent|1), (SkippedWakeups|1)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">性能 Log关键字  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">丢帧： Choreographer: Skipped</span></span><ul><li><span class="name"><span class="innerContentContainer">当掉帧数超过SKIPPED_FRAME_WARNING_LIMIT（默认30帧）时会打印.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Log溢出： identical \d+ line|expire \d+ line</span></span></li><li><span class="name"><span class="innerContentContainer">CPU占用率: cpu</span></span><ul><li><span class="name"><span class="innerContentContainer">(total|1|6),(user|1|6),(system|1|6),(iowait|1|6),(irq|1|6),(softirq|1|6)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU占用率： CPU usage</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其他模块 Log关键字</span></span><ul><li><span class="name"><span class="innerContentContainer">应用</span></span><ul><li><span class="name"><span class="innerContentContainer">GMS拒绝注册: gms_unknown</span></span></li><li><span class="name"><span class="innerContentContainer">联系人数量和查询时间: contacts_aggregation (aggregation time|2|3), (count|1|1)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">查询阶段 count为负，合并阶段 count为正.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单项被选中: menu_item_selected</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (Menu type where 0 is options and 1 is context|1|5), (Menu item title|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">菜单打开: menu_opened</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (Menu type where 0 is options and 1 is context|1|5)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">系统</span></span><ul><li><span class="name"><span class="innerContentContainer">输入法： inputmethod</span></span></li><li><span class="name"><span class="innerContentContainer">音量调节： volume_changed| VOLUME_CHANGED_ACTION</span></span></li><li><span class="name"><span class="innerContentContainer">开机动画播放完成： wm_boot_animation_done  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">允许安装未知来源的应用： unknown_sources_enabled</span></span><ul><li><span class="name"><span class="innerContentContainer">1为允许</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">恢复出厂设置</span></span><ul><li><span class="name"><span class="innerContentContainer">重置统计： rescue_note</span></span></li><li><span class="name"><span class="innerContentContainer">重置等级： rescue_level</span></span></li><li><span class="name"><span class="innerContentContainer">重置成功： rescue_success</span></span></li><li><span class="name"><span class="innerContentContainer">重置失败： rescue_failure</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">存储分区统计： storage_state</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： uuid, old state, new state, 可用空间，总空间</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统重启： beginning of main|beginning of system </span></span></li><li><span class="name"><span class="innerContentContainer">底层模块启动: boot_progress_start (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">ZygoteInit 启动各模块: boot_progress_preload_start (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">ZygoteInit 启动结束: boot_progress_preload_end (time|2|3)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">启动Dalvik: dvm_lock_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式:  (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动ART: art_hidden_api_access</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (access_method|1),(flags|1),(class|3),(member|3),(type_signature|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ams就绪： boot_progress_ams_ready (数字是毫秒数)  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">ActivityManagerService.systemReady() starts</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SystemServer 启动: boot_progress_system_run</span></span></li><li><span class="name"><span class="innerContentContainer">SystemServer 启动: system_server_start</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (start_count|1), (uptime|2|3), (elapse_time|2|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统进入桌面： system now ready  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">写系统文件: commit_sys_config_file (name|3),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">配置改变: configuration_changed</span></span></li><li><span class="name"><span class="innerContentContainer">切换用户（多用户, 子用户）</span></span><ul><li><span class="name"><span class="innerContentContainer">am_switch_user，切换用户，字段即用户id。</span></span></li><li><span class="name"><span class="innerContentContainer">am_user_state_changed，切换用户状态，字段为用户id和状态id(含义不明)。</span></span></li><li><span class="name"><span class="innerContentContainer">USER_SWITCHED，切换用户广播。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">账户: sync</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (id|3), (event|1|5), (source|1|5), </span></span></li><li><span class="name"><span class="innerContentContainer">(account|1|5), account是账号名的hash值.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">功耗 / 充电 / 电池</span></span><ul><li><span class="name"><span class="innerContentContainer">功耗service： PowerManagetService</span></span></li><li><span class="name"><span class="innerContentContainer">过滤power: intercept_power (action|3),(mPowerKeyHandled|1),(mPowerKeyPressCounter|1)</span></span></li><li><span class="name"><span class="innerContentContainer">电池电量： battery_level</span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式： 电量，电压，温度</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电状态： battery_status</span></span><ul><li><span class="name"><span class="innerContentContainer">第一个参数： 2，充电；3，放电；4，未充电；5，充满电。</span></span></li><li><span class="name"><span class="innerContentContainer">第二个参数：2，电池正常；3，过热；4，电池损坏；5，电压过高；6，未知故障；7，电池过冷。</span></span></li><li><span class="name"><span class="innerContentContainer">第三个参数：1，放电；0，充电</span></span></li><li><span class="name"><span class="innerContentContainer">第四个参数：1，AC直充；2，USB充电；4，无线充电</span></span></li><li><span class="name"><span class="innerContentContainer">第五个参数：电池类型，li-ion，锂电池。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">放电状态： battery_discharge</span></span><ul><li><span class="name"><span class="innerContentContainer">放电时长，最低电流，最高电量</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">广播</span></span><ul><li><span class="name"><span class="innerContentContainer">接收广播： received broadcast|onReceive， 太多，请直接搜广播名</span></span></li><li><span class="name"><span class="innerContentContainer">忽略特定广播： am_broadcast_discard_filter|am_broadcast_discard_app</span></span><ul><li><span class="name"><span class="innerContentContainer">数据： (User|1|5),(Broadcast|1|5),(Action|3),(Receiver Number|1|1),(BroadcastFilter|1|5) / (App|3)</span></span></li><li><span class="name"><span class="innerContentContainer">原因可能是: timeout/ANR/crash.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">音频</span></span><ul><li><span class="name"><span class="innerContentContainer">AudioFlinger| AudioTrack|AudioPolicy</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Service</span></span><ul><li><span class="name"><span class="innerContentContainer">创建： am_create_service, 字段有:</span></span><ul><li><span class="name"><span class="innerContentContainer">(User|1|5), (Service Record|1|5), (Name|3), (UID|1|5), (PID|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">销毁： am_destroy_service, 字段有: (User|1|5), (Service Record|1|5), (PID|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">启动： startService</span></span></li><li><span class="name"><span class="innerContentContainer">Service多次crash： am_service_crashed_too_much . 字段有:</span></span><ul><li><span class="name"><span class="innerContentContainer">(User|1|5), (Crash Count|1|1), (Component Name|3), (PID|1|5)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">绑定, 解绑：  bindService|unbindService</span></span></li><li><span class="name"><span class="innerContentContainer">统计绑定了多少个客户端： total connections for service</span></span></li><li><span class="name"><span class="innerContentContainer">重启： am_schedule_service_restart</span></span></li><li><span class="name"><span class="innerContentContainer">访问统计: service_manager_stats (call_count|1), (total_time|1|3), (duration|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">响应迟缓: service_manager_slow (time|1|3), (service|3)</span></span></li><li><span class="name"><span class="innerContentContainer">服务空闲而关闭： am_stop_idle_service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通话 / 语音 / phone / 电话</span></span><ul><li><span class="name"><span class="innerContentContainer">通话log在radio log中。</span></span></li><li><span class="name"><span class="innerContentContainer">通话log关键字: callState|phoneState|onPhoneStateChanged|update phone state</span></span></li><li><span class="name"><span class="innerContentContainer">来电/响铃：ringing</span></span></li><li><span class="name"><span class="innerContentContainer">对端响铃：dialing</span></span></li><li><span class="name"><span class="innerContentContainer">拒接：offhook|disconnect</span></span></li><li><span class="name"><span class="innerContentContainer">对方拒接：disconnect</span></span></li><li><span class="name"><span class="innerContentContainer">接听：active</span></span></li><li><span class="name"><span class="innerContentContainer">挂断：disconnect</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">热 / 温控</span></span><ul><li><span class="name"><span class="innerContentContainer">thermal</span></span></li><li><span class="name"><span class="innerContentContainer">temperature</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Camera</span></span><ul><li><span class="name"><span class="innerContentContainer">前后置切换: connect call</span></span><ul><li><span class="name"><span class="innerContentContainer">camera id 0: 后置</span></span></li><li><span class="name"><span class="innerContentContainer">camera id 1: 强制</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">闪光灯状态: </span></span></li><li><span class="name"><span class="innerContentContainer">生成缩略图: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Provider / SQL</span></span><ul><li><span class="name"><span class="innerContentContainer">数据库写入： onSharedPreferenceChanged</span></span></li><li><span class="name"><span class="innerContentContainer">provider没有准备好：am_provider_lost_process. 字段有: (User|1|5), (Package Name|3), (UID|1|5), (Name|3)</span></span></li><li><span class="name"><span class="innerContentContainer">数据库操作: db_sample  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">数据格式: (db|3),(sql|3),(time|1|3),(blocking_package|3),(sample_percent|1|6)</span></span></li><li><span class="name"><span class="innerContentContainer">db：数据库的文件名</span></span></li><li><span class="name"><span class="innerContentContainer">sql：已执行的查询（无查询参数）</span></span></li><li><span class="name"><span class="innerContentContainer">time：cpu时间戳，单位毫秒，包括锁定获取  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">blocking_package：如果在主线程上，则为程序包名称，否则为“”</span></span></li><li><span class="name"><span class="innerContentContainer">sample_percent：记录此查询的可能性百分比</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">数据库写入： ***_upgrade_receiver (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_current (current|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_max (max|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_alarm_alloc_attempt (attempts|1|4)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_mem_released (Memory released|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">sqlite_db_corrupt (Database file corrupt|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">Selinux 权限检验失败  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">denied {execute/read/write} for </span></span></li><li><span class="name"><span class="innerContentContainer">其中校验目标即 comm字段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">security_adb_shell_interactive</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_shell_command&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(command|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_sync_recv&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_adb_sync_send&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_app_process_start&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(process|3),(start_time|2|3),(uid|1),(pid|1),(seinfo|3),(sha256|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_dismissed</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_dismiss_auth_attempt&nbsp; &nbsp;(success|1),(method_strength|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_secured</span></span></li><li><span class="name"><span class="innerContentContainer">security_os_startup&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (boot_state|3),(verity_mode|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_os_shutdown</span></span></li><li><span class="name"><span class="innerContentContainer">security_logging_started</span></span></li><li><span class="name"><span class="innerContentContainer">security_logging_stopped</span></span></li><li><span class="name"><span class="innerContentContainer">security_media_mounted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3),(label|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_media_unmounted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(path|3),(label|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_log_buffer_size_critical</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_expiration_set&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(timeout|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_complexity_set&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(length|1),(quality|1),(num_letters|1),(num_non_letters|1),(num_numeric|1),(num_uppercase|1),(num_lowercase|1),(num_symbols|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_password_history_length_set&nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(length|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_max_screen_lock_timeout_set&nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(timeout|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_max_password_attempts_set&nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1),(num_failures|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_keyguard_disabled_features_set&nbsp; (package|3),(admin_user|1),(target_user|1),(features|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_remote_lock&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1),(target_user|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_wipe_failed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(package|3),(admin_user|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_generated&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_imported&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_destroyed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(success|1),(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_user_restriction_added&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (package|3),(admin_user|1),(restriction|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_user_restriction_removed&nbsp; &nbsp; &nbsp; &nbsp; (package|3),(admin_user|1),(restriction|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_authority_installed&nbsp; &nbsp; &nbsp; &nbsp; (success|1),(subject|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_authority_removed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (success|1),(subject|3)</span></span></li><li><span class="name"><span class="innerContentContainer">security_crypto_self_test_completed&nbsp; &nbsp; &nbsp; (success|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_key_integrity_violation&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key_id|3),(uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">security_cert_validation_failure&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reason|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PackageManagerService，PMS</span></span><ul><li><span class="name"><span class="innerContentContainer">Package Manager starts: boot_progress_pms_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan starts: boot_progress_pms_system_scan_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan starts: boot_progress_pms_data_scan_start (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager .apk scan ends: boot_progress_pms_scan_end (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager ready: boot_progress_pms_ready (time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">check activity_launch_time for Home app: Value of "unknown sources" setting at app install time:  unknown_sources_enabled (value|1)</span></span></li><li><span class="name"><span class="innerContentContainer">Package Manager critical info: pm_critical_info (msg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">Disk usage stats for verifying quota correctness: pm_package_stats </span></span><ul><li><span class="name"><span class="innerContentContainer">数据: (manual_time|2|3),(quota_time|2|3),(manual_data|2|2),(quota_data|2|2),(manual_cache|2|2),(quota_cache|2|2)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">WiFi / 网络</span></span><ul><li><span class="name"><span class="innerContentContainer">网络流量统计： netstats_mobile_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">字段太多，网上补充</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">网络慢 / 网络超时：  http|busy|timeout</span></span></li><li><span class="name"><span class="innerContentContainer">Wifi 流量统计： netstats_wifi_sample</span></span><ul><li><span class="name"><span class="innerContentContainer">字段太多，网上补充</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">wifi状态改变: wifi_state_changed (wifi_state|3)</span></span></li><li><span class="name"><span class="innerContentContainer">事件分发: wifi_event_handled (wifi_event|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">[15 - 0] HSM event (as defined in WifiStateTracker.java)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Supplicant状态改变: wifi_supplicant_state_changed (supplicant_state|1|5)</span></span><ul><li><span class="name"><span class="innerContentContainer">[8 - 0] Supplicant state (as defined in SupplicantState.java)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Location</span></span><ul><li><span class="name"><span class="innerContentContainer">定位成功, 上报位置数据: location_controller</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Web / HTTP / WebView</span></span><ul><li><span class="name"><span class="innerContentContainer">NTP成功: ntp_success (server|3),(rtt|2),(offset|2)</span></span></li><li><span class="name"><span class="innerContentContainer">NTP失败: ntp_failure (server|3),(msg|3)</span></span></li><li><span class="name"><span class="innerContentContainer">http_stats (useragent|3),(response|2|3),(processing|2|3),(tx|1|2),(rx|1|2)</span></span></li><li><span class="name"><span class="innerContentContainer">viewroot_layout (Layout time|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">view_build_drawing_cache (View created drawing cache|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">view_use_drawing_cache (View drawn using bitmap cache|1|5)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_zoom_level_change (start level|1|5),(end level|1|5),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">viewroot_draw (Draw time|1|3)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_double_tap_duration (duration|1|3),(time|2|3)</span></span></li><li><span class="name"><span class="innerContentContainer">browser_snap_center</span></span></li><li><span class="name"><span class="innerContentContainer">exp_det_attempt_to_call_object_getclass (app_signature|3)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LibC异常</span></span><ul><li><span class="name"><span class="innerContentContainer">bionic_event_memcpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcat_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_memmov_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncat_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_memset_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcpy_buffer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strcat_integer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_strncat_integer_overflow (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_old_response (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_wrong_server (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">bionic_event_resolver_wrong_query (uid|1)</span></span></li><li><span class="name"><span class="innerContentContainer">exp_det_cert_pin_failure (certs|4)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时区</span></span><ul><li><span class="name"><span class="innerContentContainer">时区： timezone</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_trigger_received (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_read_from_data_app (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_uninstall (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_install (token_bytes|3)</span></span></li><li><span class="name"><span class="innerContentContainer">timezone_check_request_nothing (token_bytes|3), (success|1)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>常见ADB命令</b></span></span><ul><li><span class="name"><span class="innerContentContainer">user版本不支持 grep过滤，可使用Windows的过滤关键字 findstr。用法和grep类似。</span></span><ul><li><span class="name"><span class="innerContentContainer">不支持正则表达式。</span></span></li><li><span class="name"><span class="innerContentContainer">多关键字用如下格式： "key1 key2" 。空格是或的关系。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过文件名搜路径： find -name <a class="contentLink" target="_blank" rel="noreferrer" href="http://hidl.so">hidl.so</a></span></span></li><li><span class="name"><span class="innerContentContainer">打开指针位置： adb shell settings put system pointer_location 1</span></span></li><li><span class="name"><span class="innerContentContainer">打开布局边界： adb shell setprop debug.layout true</span></span></li><li><span class="name"><span class="innerContentContainer">更改屏幕休眠时间: adb shell settings put system screen_off_timeout 300000    // 半小时</span></span></li><li><span class="name"><span class="innerContentContainer">写入屏幕亮度: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">启动 Monkey：adb shell monkey -v -p &lt;apk&gt; 50000</span></span></li><li><span class="name"><span class="innerContentContainer">截图/截屏：adb exec-out screencap -p &gt; sc.png</span></span><ul><li><span class="name"><span class="innerContentContainer">老方法: adb shell screencap /sdcard/DCIM/1.png. 然后 adb push.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">录屏:  adb shell screenrecord /sdcard/record.mp4  --bugreport</span></span><ul><li><span class="name"><span class="innerContentContainer">最长录制时间是 180 秒。</span></span></li><li><span class="name"><span class="innerContentContainer">bugreport参数会在视频中添加时间戳。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">发送文本内容(不能发中文):  adb shell input text test123456</span></span></li><li><span class="name"><span class="innerContentContainer">压缩文件（压缩log）： tar -cvf</span></span></li><li><span class="name"><span class="innerContentContainer">重启及刷机</span></span><ul><li><span class="name"><span class="innerContentContainer">adb reboot</span></span></li><li><span class="name"><span class="innerContentContainer">高通EDL模式(快速刷机): adb reboot edl</span></span></li><li><span class="name"><span class="innerContentContainer">刷机: fastboot</span></span><ul><li><span class="name"><span class="innerContentContainer">fastboot 刷机即线刷，通过USB刷机。要求在PC上有刷机工具。</span></span></li><li><span class="name"><span class="innerContentContainer">重启到bootloader：adb reboot bootloader</span></span></li><li><span class="name"><span class="innerContentContainer">在fastboot 中也可以进 EDL: fastboot oem edl</span></span></li><li><span class="name"><span class="innerContentContainer">下载一个分区： fastboot flash boot boot.img</span></span></li><li><span class="name"><span class="innerContentContainer">重启到recovery，即恢复模式：adb reboot recovery</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">刷机: recovery</span></span><ul><li><span class="name"><span class="innerContentContainer">recovery 刷机即卡刷，通过sd卡刷机。</span></span></li><li><span class="name"><span class="innerContentContainer">adb reboot recovery</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">导出应用的apk文件</span></span><ul><li><span class="name"><span class="innerContentContainer">找包名： adb shell pm list package</span></span></li><li><span class="name"><span class="innerContentContainer">找apk安装路径： adb shell pm path &lt;包名&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">adb pull 即可。</span></span></li><li><span class="name"><span class="innerContentContainer">Google play商店的包名是： com.android.vending </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>模拟按键</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>模拟按键事件:  adb shell input keyevent &lt;KEYCODE&gt;</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>KEYCODE</b>在 KeyEvent.java 中定义，有：</span></span></li><li><span class="name"><span class="innerContentContainer">3	HOME 键</span></span></li><li><span class="name"><span class="innerContentContainer">4	返回键</span></span></li><li><span class="name"><span class="innerContentContainer">5	打开拨号应用</span></span></li><li><span class="name"><span class="innerContentContainer">6	挂断电话</span></span></li><li><span class="name"><span class="innerContentContainer">24	增加音量</span></span></li><li><span class="name"><span class="innerContentContainer">25	降低音量</span></span></li><li><span class="name"><span class="innerContentContainer">26	电源键</span></span></li><li><span class="name"><span class="innerContentContainer">27	拍照（打开拍照应用）</span></span></li><li><span class="name"><span class="innerContentContainer">64	打开浏览器</span></span></li><li><span class="name"><span class="innerContentContainer">82	菜单键</span></span></li><li><span class="name"><span class="innerContentContainer">85	播放/暂停</span></span></li><li><span class="name"><span class="innerContentContainer">86	停止播放</span></span></li><li><span class="name"><span class="innerContentContainer">87	播放下一首</span></span></li><li><span class="name"><span class="innerContentContainer">88	播放上一首</span></span></li><li><span class="name"><span class="innerContentContainer">122	移动光标到行首或列表顶部</span></span></li><li><span class="name"><span class="innerContentContainer">123	移动光标到行末或列表底部</span></span></li><li><span class="name"><span class="innerContentContainer">126	恢复播放</span></span></li><li><span class="name"><span class="innerContentContainer">127	暂停播放</span></span></li><li><span class="name"><span class="innerContentContainer">164	静音</span></span></li><li><span class="name"><span class="innerContentContainer">176	打开系统设置</span></span></li><li><span class="name"><span class="innerContentContainer">187	切换应用</span></span></li><li><span class="name"><span class="innerContentContainer">207	打开联系人</span></span></li><li><span class="name"><span class="innerContentContainer">208	打开日历</span></span></li><li><span class="name"><span class="innerContentContainer">209	打开音乐</span></span></li><li><span class="name"><span class="innerContentContainer">210	打开计算器</span></span></li><li><span class="name"><span class="innerContentContainer">220	降低屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer">221	提高屏幕亮度</span></span></li><li><span class="name"><span class="innerContentContainer"><b>223	 系统休眠</b></span></span></li><li><span class="name"><span class="innerContentContainer"><b>224	 点亮屏幕</b></span></span></li><li><span class="name"><span class="innerContentContainer">231	打开语音助手</span></span></li><li><span class="name"><span class="innerContentContainer">276	如果没有 wakelock 则让系统休眠</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">模拟触摸事件:  adb shell input tap 500 500</span></span></li><li><span class="name"><span class="innerContentContainer">模拟滑动解锁(前提是没有设锁屏密码): adb shell input swipe 300 1000 300 500</span></span></li><li><span class="name"><span class="innerContentContainer">模拟滑动事件:  adb shell input swipe 900 500 100 500</span></span></li><li><span class="name"><span class="innerContentContainer">模拟长按事件: adb shell input swipe 500 500 501 501 2000</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Prop项&amp;Features</span></span><ul><li><span class="name"><span class="innerContentContainer">写入prop项（重启不失效）： pull 到本地，用写字板写入，然后再push回去，改权限644，最后重启。</span></span></li><li><span class="name"><span class="innerContentContainer">读出prop值:  adb shell getprop ro.build.version.sdk</span></span></li><li><span class="name"><span class="innerContentContainer">写入prop项： adb shell setprop ***=0/1/true/false</span></span><ul><li><span class="name"><span class="innerContentContainer">重启后失效</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出feature值: </span></span><ul><li><span class="name"><span class="innerContentContainer">有两个命令。结果不太一样。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell pm list features</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell dumpsys package f</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕</span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕分辨率</span></span><ul><li><span class="name"><span class="innerContentContainer">读出命令1: adb shell wm size，返回物理分辨率 Physical size: 1080x1920</span></span></li><li><span class="name"><span class="innerContentContainer">读出命令2: adb shell " dumpsys window displays | grep init"， 也是物理分辨率</span></span></li><li><span class="name"><span class="innerContentContainer">读出命令3: adb shell dumpsys SurfaceFlinger  // 搜 Source Crop 可得应用分辨率。 --强大</span></span></li><li><span class="name"><span class="innerContentContainer">写入分辨率: adb shell wm size 800x1600</span></span></li><li><span class="name"><span class="innerContentContainer">复原分辨率: adb shell wm size reset</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕刷新率</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell " while( true); do dumpsys SurfaceFlinger | grep refresh-rate; sleep 1; done"</span></span></li><li><span class="name"><span class="innerContentContainer">R版本后，开发者选项 - 显示刷新率, 会显示在屏幕左上角。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">像素密度, density</span></span><ul><li><span class="name"><span class="innerContentContainer">写入: adb shell wm density n (n=1, 2, 3)</span></span></li><li><span class="name"><span class="innerContentContainer">复原: adb shell wm densit reset</span></span></li><li><span class="name"><span class="innerContentContainer">读出: adb shell wm density</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕密度: adb shell getprop&nbsp;ro.sf.lcd_density</span></span></li><li><span class="name"><span class="innerContentContainer">读出屏幕状态:  adb shell dumpsys display</span></span><ul><li><span class="name"><span class="innerContentContainer">返回值大概是:</span></span></li><li><span class="name"><span class="innerContentContainer">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span></span><ul><li><span class="name"><span class="innerContentContainer">Display: mDisplayId=0</span></span></li><li><span class="name"><span class="innerContentContainer">init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span></span></li><li><span class="name"><span class="innerContentContainer">deferred=false layoutNeeded=false</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其中: mDisplayId&nbsp;为 显示屏编号，init&nbsp;是初始分辨率和屏幕密度，app&nbsp;的高度比&nbsp;init&nbsp;里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出亮度模式: adb shell settings get system screen_brightness_mode</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前亮度值: adb shell settings get system screen_brightness</span></span></li><li><span class="name"><span class="innerContentContainer">读出屏幕休眠时间: adb shell settings get system screen_off_timeout</span></span></li><li><span class="name"><span class="innerContentContainer">更改亮度值（亮度值在0—255之间）: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">更改休眠时间，10分钟: adb shell settings put system screen_off_timeout 600000</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏和导航栏的显示隐藏: adb shell settings put global policy_control &lt;key-values&gt;</span></span><ul><li><span class="name"><span class="innerContentContainer">key-values 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">immersive.full	同时隐藏</span></span></li><li><span class="name"><span class="innerContentContainer">immersive.status	隐藏状态栏</span></span></li><li><span class="name"><span class="innerContentContainer">immersive.navigation	隐藏导航栏</span></span></li><li><span class="name"><span class="innerContentContainer">immersive.preconfirms	?</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这些键对应的值可则如下值用逗号组合：</span></span><ul><li><span class="name"><span class="innerContentContainer">apps	所有应用</span></span></li><li><span class="name"><span class="innerContentContainer">所有界面</span></span></li><li><span class="name"><span class="innerContentContainer">packagename	指定应用</span></span></li><li><span class="name"><span class="innerContentContainer">-packagename	排除指定应用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例如: adb shell settings put global policy_control immersive.full=*</span></span><ul><li><span class="name"><span class="innerContentContainer">表示设置应用在所有界面下都同时隐藏状态栏和导航栏。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Settings，系统设置</b></span></span><ul><li><span class="name"><span class="innerContentContainer">设置数据库位置</span></span><ul><li><span class="name"><span class="innerContentContainer">M版本及之前在： /data/data/com.android.providers.settings/databases</span></span></li><li><span class="name"><span class="innerContentContainer">M版本之后在： /data/system/users/0/，一个表一个XML，类似 settings_secure.xml。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">对字段进行读写</span></span><ul><li><span class="name"><span class="innerContentContainer">读出设置项： adb shell settings get &lt;表名&gt; &lt;字段名&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">写入配置项： adb shell settings put &lt;表名&gt; &lt;字段名&gt; &lt;值&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">表名有： global, secure, system, config 等。</span></span></li><li><span class="name"><span class="innerContentContainer">字段名在 android.provider.Settings 中定义。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见读出命令</span></span><ul><li><span class="name"><span class="innerContentContainer">读出屏幕休眠时间: adb shell settings get system screen_off_timeout</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前亮度值: adb shell settings get system screen_brightness</span></span></li><li><span class="name"><span class="innerContentContainer">读出亮度模式: adb shell settings get system screen_brightness_mode</span></span></li><li><span class="name"><span class="innerContentContainer">读出 android_id: adb shell settings get secure android_id.  返回: 51b6be48bac8c569</span></span></li><li><span class="name"><span class="innerContentContainer">读出通过网络获取时间的状态: adb shell settings get global auto_time.   // 1为允许, 0为不允许</span></span></li><li><span class="name"><span class="innerContentContainer">读出默认输入法: adb shell settings get secure default_input_method   // com.sohu.inputmethod.sogouoem/.SogouIME  默认搜狗输入法</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见写入命令</span></span><ul><li><span class="name"><span class="innerContentContainer">关闭 USB 调试模式: adb shell settings put global adb_enabled 0</span></span></li><li><span class="name"><span class="innerContentContainer">打开指针位置： adb shell settings put system pointer_location 1</span></span></li><li><span class="name"><span class="innerContentContainer">更改屏幕休眠时间: adb shell settings put system screen_off_timeout 300000    // 半小时</span></span></li><li><span class="name"><span class="innerContentContainer">写入屏幕亮度: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">更改亮度值（亮度值在0—255之间）: adb shell settings put system screen_brightness 150</span></span></li><li><span class="name"><span class="innerContentContainer">更改休眠时间，10分钟: adb shell settings put system screen_off_timeout 600000</span></span></li><li><span class="name"><span class="innerContentContainer">状态栏和导航栏的显示隐藏: adb shell settings put global policy_control &lt;key-values&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">写入通过网络获取时间的状态: adb shell settings put global auto_time 1</span></span></li><li><span class="name"><span class="innerContentContainer">put命令更改默认输入法（将io.appium.android.ime/.UnicodeIME改为com.sohu.inputmethod.sogouoem/.SogouIME）</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell settings put secure default_input_method com.sohu.inputmethod.sogouoem/.SogouIME</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">直接打开指定页面</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 adb shell am start  &lt;页面&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">常见页面</span></span><ul><li><span class="name"><span class="innerContentContainer">开发者设置: com.android.settings.DevelopmentSettings</span></span></li><li><span class="name"><span class="innerContentContainer">设置主页面: adb shell am start com.android.settings/com.android.settings.Settings</span></span></li><li><span class="name"><span class="innerContentContainer">安全: adb shell am start com.android.settings/com.android.settings.SecuritySettings</span></span></li><li><span class="name"><span class="innerContentContainer">手机无线信息: adb shell am start com.android.settings/com.android.settings.RadioInfo</span></span></li><li><span class="name"><span class="innerContentContainer">电池信息: com.android.settings.BatteryInfo</span></span></li><li><span class="name"><span class="innerContentContainer">日期和时间设置: com.android.settings.DateTimeSettings</span></span></li><li><span class="name"><span class="innerContentContainer">关于手机: com.android.settings.DeviceInfoSettings</span></span></li><li><span class="name"><span class="innerContentContainer">选择手机语言: com.android.settings.LocalePicker</span></span></li><li><span class="name"><span class="innerContentContainer">正在运行的程序（服务）: com.android.settings.RunningServices</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它页面</span></span><ul><li><span class="name"><span class="innerContentContainer">com.android.settings.AccessibilitySettings: 辅助功能设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ActivityPicker: 选择活动</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ApnSettings: APN设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ApplicationSettings: 应用程序设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.BandMode: 设置GSM/UMTS波段</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DateTimeSettingsSetupWizard: 日期和时间设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DeviceAdminSettings: 设备管理器</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.Display: 显示-设置显示字体大小及预览</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DisplaySettings: 显示设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.DockSettings: 底座设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.IccLockSettings: SIM卡锁定设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.InstalledAppDetails: 安装应用信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.LanguageSettings: 语言和键盘设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.LocalePickerInSetupWizard: 选择手机语言</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ManageApplications: 已下载（安装）软件列表</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.MasterClear: 恢复出厂设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.MediaFormat: 格式化手机闪存</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.PhysicalKeyboardSettings: 设置键盘</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.PrivacySettings: 隐私设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.ProxySelector: 代理设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.RadioInfo: 手机信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.SecuritySettings: 位置和安全设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.Settings: 系统设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.WirelessSettings: 无线和网络设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.SettingsSafetyLegalActivity: 安全信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.SoundSettings: 声音设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.TestingSettings: 测试-显示手机信息、电池信息、使用情况统计、Wifi information、服务信息</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.TetherSettings: 绑定与便携式热点</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.TextToSpeechSettings: 文字转语音设置</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.UsageStats: 使用情况统计</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.UserDictionarySettings: 用户词典</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.settings.VoiceInputOutputSettings: 语音输入与输出设置</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">其它ADB命令</span></span><ul><li><span class="name"><span class="innerContentContainer">安全模式: 开机过程中，显示静态logo时按下音量下，进入安全模式。</span></span></li><li><span class="name"><span class="innerContentContainer">ADB连接</span></span><ul><li><span class="name"><span class="innerContentContainer">读出ADB版本: adb version</span></span></li><li><span class="name"><span class="innerContentContainer">等待设备连接上: adb wait-for-device</span></span></li><li><span class="name"><span class="innerContentContainer">以root方式运行: adb root</span></span></li><li><span class="name"><span class="innerContentContainer">查看连接中的设备：adb devices.  返回 device-ID 列表. 可用于其它命令. 适用于多设备连接的场景.</span></span></li><li><span class="name"><span class="innerContentContainer">指定设备: 所有adb命令都支持 -s &lt;device-ID&gt;开关, 以指定设备.</span></span></li><li><span class="name"><span class="innerContentContainer">读出设备序列号：adb get-serialno</span></span></li><li><span class="name"><span class="innerContentContainer">读出设备状态: adb get-state</span></span><ul><li><span class="name"><span class="innerContentContainer">设备的状态有 3 钟，device&nbsp;,&nbsp;offline&nbsp;,&nbsp;unknown</span></span></li><li><span class="name"><span class="innerContentContainer">device：设备正常连接</span></span></li><li><span class="name"><span class="innerContentContainer">offline：连接出现异常，设备无响应</span></span></li><li><span class="name"><span class="innerContentContainer">unknown：没有连接设备</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">终止adb服务进程：adb kill-server</span></span></li><li><span class="name"><span class="innerContentContainer">重启adb服务进程：adb start-server</span></span></li><li><span class="name"><span class="innerContentContainer">查看ADB帮助：adb help</span></span></li><li><span class="name"><span class="innerContentContainer">问题解决: 5037端口被占用</span></span><ul><li><span class="name"><span class="innerContentContainer">报错： cannot connect to 127.0.0.1:5037</span></span></li><li><span class="name"><span class="innerContentContainer">解决办法：netstat -ano | findstr "3037"  。 找到进程号后，杀掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">将PC上的某个端口重定向到设备的某个端口:  db forward tcp:1314 tcp:8888</span></span></li><li><span class="name"><span class="innerContentContainer">关闭 USB 调试模式: adb shell settings put global adb_enabled 0</span></span></li><li><span class="name"><span class="innerContentContainer">无线连接 ADB 方法1</span></span><ul><li><span class="name"><span class="innerContentContainer">手机、PC处于相同的网络下，手机 root ，安装应用 adbWireless ，启动应用后点击界面中间的按钮</span></span></li><li><span class="name"><span class="innerContentContainer">运行 adb connect 192.168.1.102&nbsp;, 即可通过无线的方式连接手机，缺点是速度比较慢</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">无线连接 ADB 方法2</span></span><ul><li><span class="name"><span class="innerContentContainer">usb连接接手机, 输入命令: adb tcpip 5555</span></span><ul><li><span class="name"><span class="innerContentContainer">restarting in TCP mode port: 5555</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">拔掉手机, 输入命令: adb connect 192.168.0.44:5555  (手机IP地址)</span></span><ul><li><span class="name"><span class="innerContentContainer">connected to 192.168.11.117:5555</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">无线连接 ADB 方法3</span></span><ul><li><span class="name"><span class="innerContentContainer">上面两个方法都需要usb支持, 本方法不需要.</span></span></li><li><span class="name"><span class="innerContentContainer">在 Android 设备上安装一个终端模拟器。下载地址是: <a class="contentLink" target="_blank" rel="noreferrer" href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></span></span></li><li><span class="name"><span class="innerContentContainer">将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</span></span></li><li><span class="name"><span class="innerContentContainer">打开 Android 设备上的终端模拟器执行：su setprop service.adb.tcp.port 5555</span></span><ul><li><span class="name"><span class="innerContentContainer">如果失败, restart adbd</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">找到 Android 设备的 IP 地址。</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell ifconfig | grep Mask ，读出</span></span></li><li><span class="name"><span class="innerContentContainer">也可在 设置 - 关于手机 - 状态信息 - IP地址 中查询.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在电脑上通过 adb 和 IP 地址连接 Android 设备: adb connect &lt;device-ip-address&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">如果能看到&nbsp;connected to &lt;device-ip-address&gt;:5555&nbsp;这样的输出则表示连接成功。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Activity和service</span></span><ul><li><span class="name"><span class="innerContentContainer">启动应用：adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">启动一个 Activity: adb shell am start -n com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">先停止再启动:  adb shell am start -S com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">等待应用完成启动: adb shell am start -W com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">结束应用: am force-stop com.android.camera/.Camera</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前界面的控件信息: adb shell uiautomator dump. 返回: </span></span><ul><li><span class="name"><span class="innerContentContainer">UI hierchary dumped to: /storage/emulated/legacy/window_dump.xml</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">列举所有services：adb shell service list</span></span></li><li><span class="name"><span class="innerContentContainer">启动一个服务: am startservice</span></span></li><li><span class="name"><span class="innerContentContainer">发送一个广播: am broadcast.  可以向所有组件广播，也可以只向指定组件广播。这个非常强大.</span></span><ul><li><span class="name"><span class="innerContentContainer">向所有组件广播&nbsp;BOOT_COMPLETED:</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">只向 com.tencent.mobileqq&nbsp;广播&nbsp;BOOT_COMPLETED：</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n com.tencent.mobileqq</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">部分系统预定义广播及正常触发时机：</span></span><ul><li><span class="name"><span class="innerContentContainer">android.net.conn.CONNECTIVITY_CHANGE	网络连接发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.SCREEN_ON	屏幕点亮</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.SCREEN_OFF	屏幕熄灭</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BATTERY_LOW	电量低，会弹出电量低提示框</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BATTERY_OKAY	电量恢复了</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BOOT_COMPLETED	设备启动完毕</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DEVICE_STORAGE_LOW	存储空间过低</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DEVICE_STORAGE_OK	存储空间恢复</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.PACKAGE_ADDED	安装了新的应用</span></span></li><li><span class="name"><span class="innerContentContainer">android.net.wifi.STATE_CHANGE	WiFi 连接状态发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.net.wifi.WIFI_STATE_CHANGED	WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.BATTERY_CHANGED	电池电量发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.INPUT_METHOD_CHANGED	系统输入法发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.ACTION_POWER_CONNECTED	外部电源连接</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.ACTION_POWER_DISCONNECTED	外部电源断开连接</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DREAMING_STARTED	系统开始休眠</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.DREAMING_STOPPED	系统停止休眠</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.WALLPAPER_CHANGED	壁纸发生变化</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.HEADSET_PLUG	插入耳机</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.MEDIA_UNMOUNTED	卸载外部介质</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.MEDIA_MOUNTED	挂载外部介质</span></span></li><li><span class="name"><span class="innerContentContainer">android.os.action.POWER_SAVE_MODE_CHANGED	省电模式开启</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">监控 crash 与 ANR:  am monitor </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">APK包管理</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>安装APK：adb install &lt;apkfile&gt; . 参数有: </b></span></span><ul><li><span class="name"><span class="innerContentContainer">-r	允许覆盖安装</span></span></li><li><span class="name"><span class="innerContentContainer">-s	将应用安装到 sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">-d	允许降级覆盖安装</span></span></li><li><span class="name"><span class="innerContentContainer">-g	授予所有运行时权限</span></span></li><li><span class="name"><span class="innerContentContainer">-l	将应用安装到保护目录 /mnt/asec</span></span></li><li><span class="name"><span class="innerContentContainer">-t	允许安装 AndroidManifest.xml 里 application 指定&nbsp;android:testOnly="true"&nbsp;的应用</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">常见安装失败输出代码、含义及可能的解决办法如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_ALREADY_EXISTS	应用已经存在，或卸载了但没卸载干净</span></span><ul><li><span class="name"><span class="innerContentContainer">adb install&nbsp;时使用&nbsp;-r&nbsp;参数，或者先&nbsp;adb uninstall &lt;packagename&gt;&nbsp;再安装</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INVALID_APK	无效的 APK 文件</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INVALID_URI	无效的 APK 文件名</span></span><ul><li><span class="name"><span class="innerContentContainer">确保 APK 文件名里无中文</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INSUFFICIENT_STORAGE	  空间不足</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_DUPLICATE_PACKAGE	已经存在同名程序</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_NO_SHARED_USER	请求的共享用户不存在</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_UPDATE_INCOMPATIBLE	以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</span></span><ul><li><span class="name"><span class="innerContentContainer">先&nbsp;adb uninstall &lt;packagename&gt;&nbsp;再安装</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_SHARED_USER_INCOMPATIBLE	请求的共享用户存在但签名不一致</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_MISSING_SHARED_LIBRARY	安装包使用了设备上不可用的共享库</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_REPLACE_COULDNT_DELETE	替换时无法删除</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_DEXOPT	dex 优化验证失败或空间不足</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_OLDER_SDK	设备系统版本低于应用要求</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_CONFLICTING_PROVIDER	设备里已经存在与应用里同名的 content provider</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_NEWER_SDK	设备系统版本高于应用要求</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_TEST_ONLY	应用是 test-only 的，但安装时没有指定&nbsp;-t&nbsp;参数</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_CPU_ABI_INCOMPATIBLE	包含不兼容设备 CPU 应用程序二进制接口的 native code</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_MISSING_FEATURE	应用使用了设备不可用的功能</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_CONTAINER_ERROR	1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用。</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INVALID_INSTALL_LOCATION	1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用。</span></span><ul><li><span class="name"><span class="innerContentContainer">1. 切换安装位置，添加或删除&nbsp;-s&nbsp;参数;  2. 打包时不与 ROM 使用相同签名。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_MEDIA_UNAVAILABLE	安装位置不可用</span></span><ul><li><span class="name"><span class="innerContentContainer">一般为 sdcard，确认 sdcard 可用或安装到内置存储</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_VERIFICATION_TIMEOUT	验证安装包超时</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_VERIFICATION_FAILURE	验证安装包失败</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_PACKAGE_CHANGED	应用与调用程序期望的不一致</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_UID_CHANGED	以前安装过该应用，与本次分配的 UID 不一致</span></span><ul><li><span class="name"><span class="innerContentContainer">清除以前安装过的残留文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_VERSION_DOWNGRADE	已经安装了该应用更高版本</span></span><ul><li><span class="name"><span class="innerContentContainer">使用&nbsp;-d&nbsp;参数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE	已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_NOT_APK	指定路径不是文件，或不是以&nbsp;.apk&nbsp;结尾</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_BAD_MANIFEST	无法解析的 AndroidManifest.xml 文件</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION	解析器遇到异常</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_NO_CERTIFICATES	安装包没有签名</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES	已安装该应用，且签名与 APK 文件不一致	先卸载设备上的该应用，再安装</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING	解析 APK 文件时遇到&nbsp;CertificateEncodingException</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME	manifest 文件里没有或者使用了无效的包名</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID	manifest 文件里指定了无效的共享用户 ID</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_MANIFEST_MALFORMED	解析 manifest 文件时遇到结构性错误</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_PARSE_FAILED_MANIFEST_EMPTY	在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_INTERNAL_ERROR	因系统问题安装失败</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_USER_RESTRICTED	用户被限制安装应用</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_DUPLICATE_PERMISSION	应用尝试定义一个已经存在的权限名称</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_NO_MATCHING_ABIS	应用包含设备的应用程序二进制接口不支持的 native code</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_CANCELED_BY_USER	应用安装需要在设备上确认，但未操作设备或点了取消	在设备上同意安装</span></span></li><li><span class="name"><span class="innerContentContainer">INSTALL_FAILED_ACWF_INCOMPATIBLE	应用程序与设备不兼容</span></span></li><li><span class="name"><span class="innerContentContainer">does not contain AndroidManifest.xml	无效的 APK 文件</span></span></li><li><span class="name"><span class="innerContentContainer">is not a valid zip file	无效的 APK 文件</span></span></li><li><span class="name"><span class="innerContentContainer">Offline	设备未连接成功	先将设备与 adb 连接成功</span></span></li><li><span class="name"><span class="innerContentContainer">unauthorized	设备未授权允许调试</span></span></li><li><span class="name"><span class="innerContentContainer">error: device not found	没有连接成功的设备</span></span><ul><li><span class="name"><span class="innerContentContainer">先将设备与 adb 连接成功</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">protocol failure	设备已断开连接</span></span><ul><li><span class="name"><span class="innerContentContainer">先将设备与 adb 连接成功</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Unknown option: -s	Android 2.2 以下不支持安装到 sdcard</span></span><ul><li><span class="name"><span class="innerContentContainer">不使用&nbsp;-s&nbsp;参数</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">No space left on device	空间不足</span></span></li><li><span class="name"><span class="innerContentContainer">Permission denied ... sdcard ...	sdcard 不可用</span></span></li><li><span class="name"><span class="innerContentContainer">signatures do not match the previously installed version; ignoring!	已安装该应用且签名不一致</span></span><ul><li><span class="name"><span class="innerContentContainer">先卸载设备上的该应用，再安装</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">卸载APK：adb uninstall &lt;package&gt;. 参数 -k 表示保留数据和缓存目录.</span></span></li><li><span class="name"><span class="innerContentContainer">卸载app但保留数据和缓存文件：adb uninstall -k &lt;package&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">读出apk的packagename 和 classname:  aapt d badging &lt;apkfile&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">列出安装在设备上的应用:  adb shell pm list package</span></span></li><li><span class="name"><span class="innerContentContainer">列出系统应用: adb shell pm list package -s</span></span></li><li><span class="name"><span class="innerContentContainer">列出第三方应用:  adb shell pm list package -3</span></span></li><li><span class="name"><span class="innerContentContainer">列出应用包名及对应的apk名及存放位置: adb shell pm list package -f</span></span></li><li><span class="name"><span class="innerContentContainer">列出应用包名及其安装来源:   adb shell pm list package -f -3 -i zhihu</span></span><ul><li><span class="name"><span class="innerContentContainer">返回: package:/data/app/com.zhihu.android-1.apk=com.zhihu.android  installer=com.xiaomi.market</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">列出对应包名的 .apk 位置: adb shell pm path com.tencent.mobileqq</span></span></li><li><span class="name"><span class="innerContentContainer">列出指定应用的 dump 信息: adb shell pm dump com.tencent.mobileqq</span></span></li><li><span class="name"><span class="innerContentContainer">安装应用(apk 文件在Android 设备中): pm install</span></span></li><li><span class="name"><span class="innerContentContainer">清除应用数据:  pm clear &lt;packagename&gt;. 相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</span></span></li><li><span class="name"><span class="innerContentContainer">读出应用安装位置: pm get-install-location</span></span><ul><li><span class="name"><span class="innerContentContainer">[0/auto]：默认为自动</span></span></li><li><span class="name"><span class="innerContentContainer">[1/internal]：默认为安装在手机内部</span></span></li><li><span class="name"><span class="innerContentContainer">[2/external]：默认安装在外部存储</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">进程</span></span><ul><li><span class="name"><span class="innerContentContainer">查看进程列表：adb shell ps</span></span></li><li><span class="name"><span class="innerContentContainer">读出指定进程号： adb shell "ps | grep camera"</span></span></li><li><span class="name"><span class="innerContentContainer">查看指定进程状态：adb shell ps -x [PID]</span></span></li><li><span class="name"><span class="innerContentContainer">杀死一个进程：adb shell kill [pid]</span></span></li><li><span class="name"><span class="innerContentContainer">读出线程数的上限: adb shell cat /proc/sys/kernel/threads_max</span></span><ul><li><span class="name"><span class="innerContentContainer">FindX 是 57798</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出同时打开文件数上限: adb shell cat /proc/sys/fs/file_max</span></span><ul><li><span class="name"><span class="innerContentContainer">FindX 是732094</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关闭 java 虚拟机: adb shell stop</span></span></li><li><span class="name"><span class="innerContentContainer">打开 java 虚拟机: adb shell start</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全</span></span><ul><li><span class="name"><span class="innerContentContainer">解锁 （执行remount前要解锁）</span></span><ul><li><span class="name"><span class="innerContentContainer">设置 - 开发者选项 - OEM解锁，打开</span></span><ul><li><span class="name"><span class="innerContentContainer">OEM解锁在第一屏，如果灰掉，说明已经解锁(读出解锁状态)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb reboot bootloader</span></span></li><li><span class="name"><span class="innerContentContainer">fastboot flashing unlock, 然后按音量+选择unlock。</span></span></li><li><span class="name"><span class="innerContentContainer">fastboot reboot</span></span></li><li><span class="name"><span class="innerContentContainer">对于已经解锁的机器，也需要从这里开始执行。</span></span></li><li><span class="name"><span class="innerContentContainer">adb root</span></span></li><li><span class="name"><span class="innerContentContainer">adb disable-verity  // 禁用 dm_verity</span></span></li><li><span class="name"><span class="innerContentContainer">adb reboot</span></span></li><li><span class="name"><span class="innerContentContainer">adb root</span></span></li><li><span class="name"><span class="innerContentContainer">adb remount</span></span><ul><li><span class="name"><span class="innerContentContainer">成功时返回： remount succeeded</span></span></li><li><span class="name"><span class="innerContentContainer">如果失败，再执行一次，有时解决问题。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">启用 dm_verity: adb enable-verity</span></span></li><li><span class="name"><span class="innerContentContainer">查看SELinux状态： adb shell getenforce</span></span></li><li><span class="name"><span class="innerContentContainer">写入SELinux状态： adb shell setenforce 0/1</span></span><ul><li><span class="name"><span class="innerContentContainer">0 表示关闭</span></span></li><li><span class="name"><span class="innerContentContainer">1 表示打开</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出账号状态: adb shell dumpsys account</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>查看设备cpu和内存占用情况：adb shell top</b></span></span><ul><li><span class="name"><span class="innerContentContainer">输出示例：</span></span></li><li><span class="name"><span class="innerContentContainer">User 0%, System 6%, IOW 0%, IRQ 0%</span></span></li><li><span class="name"><span class="innerContentContainer">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span></span></li><li><span class="name"><span class="innerContentContainer">算式： user + sys + iow + irq + sirq = cpu(8核是 800%) - idle</span></span></li><li><span class="name"><span class="innerContentContainer">下面是各进程的明细情况：</span></span></li><li><span class="name"><span class="innerContentContainer">PID PR CPU% S  # THR     VSS     RSS PCY UID      Name</span></span></li><li><span class="name"><span class="innerContentContainer">8763  0   3% R     1  10640K   1064K  fg shell    top</span></span></li><li><span class="name"><span class="innerContentContainer">131  0   3% S     1      0K      0K  fg root     dhd_dpc</span></span></li><li><span class="name"><span class="innerContentContainer">6144  0   0% S   115 1682004K 115916K  fg system   system_server</span></span></li><li><span class="name"><span class="innerContentContainer">217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd</span></span></li><li><span class="name"><span class="innerContentContainer">其中各字段的含义是: </span></span><ul><li><span class="name"><span class="innerContentContainer">PID: 进程 ID</span></span></li><li><span class="name"><span class="innerContentContainer">PR: 优先级</span></span></li><li><span class="name"><span class="innerContentContainer">CPU%: 当前瞬间占用 CPU 百分比</span></span></li><li><span class="name"><span class="innerContentContainer">S: 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</span></span></li><li><span class="name"><span class="innerContentContainer"># THR: 线程数</span></span></li><li><span class="name"><span class="innerContentContainer">VSS	Virtual Set Size: 虚拟耗用内存（包含共享库占用的内存）</span></span></li><li><span class="name"><span class="innerContentContainer">RSS	Resident Set Size: 实际使用物理内存（包含共享库占用的内存）</span></span></li><li><span class="name"><span class="innerContentContainer">PCY: 调度策略优先级，SP_BACKGROUND/SPFOREGROUND</span></span></li><li><span class="name"><span class="innerContentContainer">UID: 进程所有者的用户 ID</span></span></li><li><span class="name"><span class="innerContentContainer">NAME: 进程名</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看占用内存前6的app：adb shell top -m 6</span></span></li><li><span class="name"><span class="innerContentContainer">刷新一次内存数据，然后返回：adb shell top -n 1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>查看当前内存占用：adb shell cat /proc/meminfo</b></span></span><ul><li><span class="name"><span class="innerContentContainer">MemTotal:        1027424 kB    // 设备的总内存</span></span></li><li><span class="name"><span class="innerContentContainer">MemFree:          486564 kB   // 当前空闲内存</span></span></li><li><span class="name"><span class="innerContentContainer">Buffers:           15224 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Cached:            72464 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SwapCached:        24152 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Active:           110572 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Inactive:         259060 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Active(anon):      79176 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Inactive(anon):   207736 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Active(file):      31396 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Inactive(file):    51324 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Unevictable:        3948 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Mlocked:               0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">HighTotal:        409600 kB</span></span></li><li><span class="name"><span class="innerContentContainer">HighFree:         132612 kB</span></span></li><li><span class="name"><span class="innerContentContainer">LowTotal:         617824 kB</span></span></li><li><span class="name"><span class="innerContentContainer">LowFree:          353952 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SwapTotal:        262140 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SwapFree:         207572 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Dirty:                 0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Writeback:             0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">AnonPages:        265324 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Mapped:            47072 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Shmem:              1020 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Slab:              57372 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SReclaimable:       7692 kB</span></span></li><li><span class="name"><span class="innerContentContainer">SUnreclaim:        49680 kB</span></span></li><li><span class="name"><span class="innerContentContainer">KernelStack:        4512 kB</span></span></li><li><span class="name"><span class="innerContentContainer">PageTables:         5912 kB</span></span></li><li><span class="name"><span class="innerContentContainer">NFS_Unstable:          0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Bounce:                0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">WritebackTmp:          0 kB</span></span></li><li><span class="name"><span class="innerContentContainer">CommitLimit:      775852 kB</span></span></li><li><span class="name"><span class="innerContentContainer">Committed_AS:   13520632 kB</span></span></li><li><span class="name"><span class="innerContentContainer">VmallocTotal:     385024 kB</span></span></li><li><span class="name"><span class="innerContentContainer">VmallocUsed:       61004 kB</span></span></li><li><span class="name"><span class="innerContentContainer">VmallocChunk:     209668 kB</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">每个应用程序的内存上限: adb shell getprop dalvik.vm.heapsize</span></span></li><li><span class="name"><span class="innerContentContainer">查询各进程内存使用情况：adb shell procrank</span></span></li><li><span class="name"><span class="innerContentContainer">查看IO内存分区：adb shell cat /proc/iomem</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU</span></span><ul><li><span class="name"><span class="innerContentContainer">CPU信息: adb shell cat /proc/cpuinfo</span></span><ul><li><span class="name"><span class="innerContentContainer">输出范例如:</span></span></li><li><span class="name"><span class="innerContentContainer">Processor       : ARMv7 Processor rev 0 (v7l)</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 0</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 1</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 2</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">processor       : 3</span></span></li><li><span class="name"><span class="innerContentContainer">BogoMIPS        : 38.40</span></span></li><li><span class="name"><span class="innerContentContainer">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</span></span></li><li><span class="name"><span class="innerContentContainer">CPU implementer : 0x51</span></span></li><li><span class="name"><span class="innerContentContainer">CPU architecture: 7</span></span></li><li><span class="name"><span class="innerContentContainer">CPU variant     : 0x2</span></span></li><li><span class="name"><span class="innerContentContainer">CPU part        : 0x06f</span></span></li><li><span class="name"><span class="innerContentContainer">CPU revision    : 0</span></span></li><li><span class="name"><span class="innerContentContainer">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</span></span></li><li><span class="name"><span class="innerContentContainer">Revision        : 000b</span></span></li><li><span class="name"><span class="innerContentContainer">Serial          : 0000000000000000</span></span></li><li><span class="name"><span class="innerContentContainer">这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是&nbsp;Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是&nbsp;ARMv7 Processor rev 0 (v71)。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU型号: adb shell getprop ro.product.board</span></span></li><li><span class="name"><span class="innerContentContainer">CPU 支持的 abi 列表: adb shell getprop ro.product.cpu.abilist</span></span></li><li><span class="name"><span class="innerContentContainer">CPU 支持的 abi 列表: adb shell cat /system/build.prop | grep ro.product.cpu.abi</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">充电</span></span><ul><li><span class="name"><span class="innerContentContainer">读出设备电池状态: adb shell dumpsys battery / batterystats. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">Current Battery Service state:</span></span></li><li><span class="name"><span class="innerContentContainer">AC powered: false</span></span></li><li><span class="name"><span class="innerContentContainer">USB powered: true</span></span></li><li><span class="name"><span class="innerContentContainer">Wireless powered: false</span></span></li><li><span class="name"><span class="innerContentContainer">status: 2   // 电池状态</span></span></li><li><span class="name"><span class="innerContentContainer">health: 2</span></span></li><li><span class="name"><span class="innerContentContainer">present: true</span></span></li><li><span class="name"><span class="innerContentContainer"><b>level: 34   // 当前电量. 最重要.</b></span></span></li><li><span class="name"><span class="innerContentContainer">scale: 100  // 最大电量</span></span></li><li><span class="name"><span class="innerContentContainer">voltage: 3848</span></span></li><li><span class="name"><span class="innerContentContainer">current now: -427943</span></span></li><li><span class="name"><span class="innerContentContainer">temperature: 280   // 电池温度</span></span></li><li><span class="name"><span class="innerContentContainer">technology: Li-ion</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出电源管理状态: adb shell dumpsys power. 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">是否处于锁屏状态：mWakefulness=Asleep或者mScreenOn=false</span></span></li><li><span class="name"><span class="innerContentContainer">亮度值：mScreenBrightness=255</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕休眠时间：Screen off timeout: 60000 ms</span></span></li><li><span class="name"><span class="innerContentContainer">屏幕分辨率：mDisplayWidth=1440，mDisplayHeight=2560</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">关闭充电功能： adb shell dumpsys battery unplug</span></span></li><li><span class="name"><span class="innerContentContainer">写入电量： adb shell dumpsys battery set level 19</span></span></li><li><span class="name"><span class="innerContentContainer">恢复充电功能： adb shell dumpsys battery reset</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">WIFI</span></span><ul><li><span class="name"><span class="innerContentContainer">打开WiFi: adb shell svc wifi enable</span></span></li><li><span class="name"><span class="innerContentContainer">关闭WiFi: adb shell svc wifi disable</span></span></li><li><span class="name"><span class="innerContentContainer">读出wifi状态: adb shell dumpsys wifi. 可以读出到当前连接的wifi名、搜索到的wifi列表、wifi强度等</span></span></li><li><span class="name"><span class="innerContentContainer">查看wifi密码：adb shell cat /data/misc/wifi/*.conf</span></span></li><li><span class="name"><span class="innerContentContainer">读出设备名称：adb shell cat /system/build.prop</span></span></li><li><span class="name"><span class="innerContentContainer">读出、写入wifi状态（wifi_on）、飞行模式（airlpane_mode_on）等，这里也是appium中 getNetworkConnection读出设备网络状态的方法。</span></span></li><li><span class="name"><span class="innerContentContainer">读出通过网络获取时间的状态: adb shell settings get global auto_time.   // 1为允许, 0为不允许</span></span></li><li><span class="name"><span class="innerContentContainer">写入通过网络获取时间的状态: adb shell settings put global auto_time 1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设备</span></span><ul><li><span class="name"><span class="innerContentContainer">读出 android_id: adb shell settings get secure android_id.  返回: 51b6be48bac8c569</span></span></li><li><span class="name"><span class="innerContentContainer">设备型号: adb shell getprop ro.product.model . 返回: Nexus 5</span></span></li><li><span class="name"><span class="innerContentContainer">Android 系统版本: adb shell getprop ro.build.version.release. 返回: 5.0.2</span></span></li><li><span class="name"><span class="innerContentContainer">SDK版本号: adb shell getprop ro.build.version.sdk</span></span></li><li><span class="name"><span class="innerContentContainer">Android 安全补丁程序级别: adb shell getprop ro.build.version.security_patch</span></span></li><li><span class="name"><span class="innerContentContainer">品牌: adb shell getprop ro.product.brand</span></span></li><li><span class="name"><span class="innerContentContainer">设备名: adb shell getprop <a class="contentLink" target="_blank" rel="noreferrer" href="http://ro.product.name">ro.product.name</a></span></span></li><li><span class="name"><span class="innerContentContainer">是否支持 OTG: adb shell getprop persist.sys.isUsbOtgEnabled</span></span></li><li><span class="name"><span class="innerContentContainer">IMEI: adb shell su service call iphonesubinfo 1</span></span><ul><li><span class="name"><span class="innerContentContainer">输出的是二进制流, 要注意转化.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IP地址: adb shell ifconfig | grep Mask</span></span></li><li><span class="name"><span class="innerContentContainer">WiFi局域网IP: adb shell ifconfig wlan0</span></span></li><li><span class="name"><span class="innerContentContainer">国家码： getprop <a class="contentLink" target="_blank" rel="noreferrer" href="http://ro.com.google.clientidbase.ms">ro.com.google.clientidbase.ms</a></span></span><ul><li><span class="name"><span class="innerContentContainer">中国是 android-cn</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">综合网络状态: adb shell netcfg, 部分设备有效.</span></span></li><li><span class="name"><span class="innerContentContainer">MAC地址：adb shell cat /sys/class/net/wlan0/address</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分区和文件</span></span><ul><li><span class="name"><span class="innerContentContainer">将system分区重新挂载为可读写分区：adb remount</span></span></li><li><span class="name"><span class="innerContentContainer">从本地复制文件到设备：adb push &lt;local&gt; &lt;remote&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">从设备复制文件到本地：adb pull &lt;remote&gt;&nbsp; &lt;local&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">查看文件内容：adb shell cat &lt;file&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">输入法和本地化</span></span><ul><li><span class="name"><span class="innerContentContainer">列出输入法: adb shell ime list -s, 返回:</span></span><ul><li><span class="name"><span class="innerContentContainer">com.google.android.inputmethod.pinyin/.PinyinIME</span></span></li><li><span class="name"><span class="innerContentContainer">com.baidu.input_mi/.ImeService</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出默认输入法: adb shell settings get secure default_input_method   // com.sohu.inputmethod.sogouoem/.SogouIME  默认搜狗输入法</span></span></li><li><span class="name"><span class="innerContentContainer">选择输入法:  adb shell ime set com.baidu.input_mi/.ImeService</span></span></li><li><span class="name"><span class="innerContentContainer">put命令更改默认输入法（将io.appium.android.ime/.UnicodeIME改为com.sohu.inputmethod.sogouoem/.SogouIME）</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell settings put secure default_input_method com.sohu.inputmethod.sogouoem/.SogouIME</span></span></li></ul></li></ul></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">调试工具包</span></span><ul><li><span class="name"><span class="innerContentContainer">AVD：&nbsp;(android virtual machine):安卓虚拟设备,就是安卓的模拟器 --性能差，基本不可用</span></span></li><li><span class="name"><span class="innerContentContainer">ADT：&nbsp;(android development tools)安卓开发工具</span></span></li><li><span class="name"><span class="innerContentContainer">DDMS：(dalvik debug monitor service)安卓调试工具</span></span></li><li><span class="name"><span class="innerContentContainer">adb：安卓调试桥, 在sdk的platform-tools目录下.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Dumpsys</b></span></span><ul><li><span class="name"><span class="innerContentContainer">读出 dumpsys 支持的数据类型:  adb shell dumpsys -l</span></span></li><li><span class="name"><span class="innerContentContainer"><b>窗口列表: adb shell dumpsys&nbsp;window </b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>adb shell "dumpsys window windows | grep 'Window #' " : 返回系统window栈。</b></span></span></li><li><span class="name"><span class="innerContentContainer">dumpsys window l : 打印last anr</span></span><ul><li><span class="name"><span class="innerContentContainer">WINDOW MANAGER LAST ANR (dumpsys window lastanr)</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;no ANR has occurred since boot&gt; // 获取ANR的信息，具体log可见 /data/anr/ 路径下</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">policy： 系统Window策略。很多。</span></span><ul><li><span class="name"><span class="innerContentContainer">LockScreen: 锁屏相关</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">animator: 动画栈</span></span><ul><li><span class="name"><span class="innerContentContainer">所有动画是单独于window管理的。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sessions： 刷新任务列表</span></span></li><li><span class="name"><span class="innerContentContainer"><b>displays: 内容多</b></span></span><ul><li><span class="name"><span class="innerContentContainer">屏幕分辨率</span></span></li><li><span class="name"><span class="innerContentContainer">task及其包含的activityRecord 列表</span></span></li><li><span class="name"><span class="innerContentContainer">Z order： 按z坐标读出显示区域坐标</span></span><ul><li><span class="name"><span class="innerContentContainer">坐标值参见 bounds 字段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">display属性</span></span></li><li><span class="name"><span class="innerContentContainer">横竖屏属性</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>SurfaceFlinger:  adb shell dumpsys SurfaceFlinger</b></span></span><ul><li><span class="name"><span class="innerContentContainer">读出屏幕静态帧信息: Static screen stats:</span></span><ul><li><span class="name"><span class="innerContentContainer">&lt; 1 frames: 0.335 s (1.5%) // 每帧的耗时情况</span></span></li><li><span class="name"><span class="innerContentContainer">&lt; 2 frames: 2.049 s (9.1%)</span></span></li><li><span class="name"><span class="innerContentContainer">7+ frames: 19.625 s (87.1%)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出BufferLayer（缓冲区）情况: </span></span><ul><li><span class="name"><span class="innerContentContainer">BufferLayer (WindowToken{3c467fd android.os.BinderProxy@3eec54}#0)</span></span></li><li><span class="name"><span class="innerContentContainer">Region TransparentRegion (this=a2fed158 count=1)</span></span><ul><li><span class="name"><span class="innerContentContainer">[0,   0,   0,   0]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Region VisibleRegion (this=a2fed008 count=1)</span></span><ul><li><span class="name"><span class="innerContentContainer">[0,   0,   0,   0]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Region SurfaceDamageRegion (this=a2fed044 count=1)</span></span><ul><li><span class="name"><span class="innerContentContainer">[0,   0,   0,   0]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">layerStack = 0, z= 0, pos=(0,0), size=(2560,2560), crop=[0,   0,  -1,  -1], finalCrop=[0,   0,  -1,  -1], isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=RGBx_8888, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[1.00, 0.00][0.00, 1.00]</span></span></li><li><span class="name"><span class="innerContentContainer">parent=mAboveAppWindowsContainers#0  // 所属父类</span></span></li><li><span class="name"><span class="innerContentContainer">zOrderRelativeOf=none</span></span></li><li><span class="name"><span class="innerContentContainer">activeBuffer=[0x   0:   0,Unknown/None], queued-frames=0, mRefreshPending=0, windowType=-1, appId=-1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Displays信息（比如屏幕分辨率）</span></span><ul><li><span class="name"><span class="innerContentContainer">DisplayDevice: Built-in Screen</span></span></li><li><span class="name"><span class="innerContentContainer">type=0, hwcId=0, layerStack=0, (1280x 720), ANativeWindow=0xa52e7808 (8:8:8:8), orient= 0 (type=00000000), flips=280, isSecure=1, powerMode=2, activeConfig=0, numLayers=2</span></span><ul><li><span class="name"><span class="innerContentContainer">v:[0,0,1280,720], f:[0,0,1280,720], s:[0,0,1280,720],transform:[[1.000,0.000,-0.000][0.000,1.000,-0.000][0.000,0.000,1.000]]</span></span></li><li><span class="name"><span class="innerContentContainer">wideColorGamut=0, hdr10=0, colorMode=ColorMode::NATIVE, dataspace: Default (0)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">FramebufferSurface: dataspace: Default(0)</span></span></li><li><span class="name"><span class="innerContentContainer">default-size=[1280x720] default-format=1 transform-hint=00 frame-counter=280 // 屏幕分辨率信息</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其他信息</span></span><ul><li><span class="name"><span class="innerContentContainer">EGL implementation : 1.4 Linux-r8p0-01rel0 // EGL 版本</span></span></li><li><span class="name"><span class="innerContentContainer">GLES: ARM, Mali-450 MP, OpenGL ES 2.0 3d6a80e // OpenGL 架构信息</span></span></li><li><span class="name"><span class="innerContentContainer">refresh-rate              : 60.000002 fps // 刷新率</span></span></li><li><span class="name"><span class="innerContentContainer">x-dpi                     : 160.156998 // x dpi</span></span></li><li><span class="name"><span class="innerContentContainer">y-dpi                     : 160.421005 // y dpi</span></span></li><li><span class="name"><span class="innerContentContainer">VSYNC state: disabled // 垂直同步状态</span></span></li><li><span class="name"><span class="innerContentContainer">soft-vsync: disabled // 当屏幕亮着的，就是disabled，如果关闭屏幕，这里为enabled</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Activity信息</b></span></span><ul><li><span class="name"><span class="innerContentContainer">前台 Activity: adb shell "dumpsys activity a | grep mFocusedActivity"</span></span></li><li><span class="name"><span class="innerContentContainer">当前界面的Activity信息：adb shell dumpsys activity top</span></span></li><li><span class="name"><span class="innerContentContainer">当前界面的Activity：adb shell "dumpsys activity top | grep ACTIVITY"</span></span></li><li><span class="name"><span class="innerContentContainer">进程列表: adb shell dumpsys activity processes</span></span></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity o : OOM等级信息，home进程、上一次的进程内容</span></span><ul><li><span class="name"><span class="innerContentContainer">generic_x86:/ $ dumpsys activity o</span></span></li><li><span class="name"><span class="innerContentContainer">OOM levels: -900: SYSTEM_ADJ (   32,768K) 。。。</span></span></li><li><span class="name"><span class="innerContentContainer">mHomeProcess: ProcessRecord{a3cea50 18515:com.android.launcher3/u0a19}</span></span></li><li><span class="name"><span class="innerContentContainer">mPreviousProcess: ProcessRecord{3758933 23311:com.android.settings/1000}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity a : 从顶部到底部打印 TaskRecord（activity） 信息</span></span><ul><li><span class="name"><span class="innerContentContainer">包含：当前生命周期、包、className、被谁启动的、进程名、intent、启动模式等</span></span></li><li><span class="name"><span class="innerContentContainer">TaskRecord{9e6567 #150 A=com.android.settings U=0 StackId=1 sz=2}</span></span></li><li><span class="name"><span class="innerContentContainer">Hist #1: ActivityRecord{e5fb34f u0 com.android.settings/.Settings$MemorySettingsActivity t150}</span></span></li><li><span class="name"><span class="innerContentContainer">packageName=com.android.settings processName=com.android.settings</span></span></li><li><span class="name"><span class="innerContentContainer">launchedFromUid=1000 launchedFromPackage=com.android.settings userId=0</span></span></li><li><span class="name"><span class="innerContentContainer">app=ProcessRecord{3758933 23311:com.android.settings/1000}</span></span></li><li><span class="name"><span class="innerContentContainer">Intent { flg=0x8000 cmp=com.android.settings/.Settings$MemorySettingsActivity (has extras) }</span></span></li><li><span class="name"><span class="innerContentContainer">frontOfTask=false task=TaskRecord{9e6567 #150 A=com.android.settings U=0 StackId=1 sz=2}</span></span></li><li><span class="name"><span class="innerContentContainer">taskAffinity=null</span></span></li><li><span class="name"><span class="innerContentContainer">realActivity=com.android.settings/.Settings$MemorySettingsActivity</span></span></li><li><span class="name"><span class="innerContentContainer">baseDir=/system/priv-app/Settings/Settings.apk</span></span></li><li><span class="name"><span class="innerContentContainer">dataDir=/data/user_de/0/com.android.settings</span></span></li><li><span class="name"><span class="innerContentContainer">state=RESUMED stopped=false delayedResume=false finishing=false</span></span></li><li><span class="name"><span class="innerContentContainer">fullscreen=true noDisplay=false immersive=false launchMode=2</span></span><ul><li><span class="name"><span class="innerContentContainer">launchMode: 启动模式. 并不是我们manifest中配置的那样。这里列一下对应的实际状态，即2对应的是singleTask.</span></span></li><li><span class="name"><span class="innerContentContainer">public class ActivityInfo extends ComponentInfo implements Parcelable {</span></span><ul><li><span class="name"><span class="innerContentContainer">/** * Constant corresponding to &lt;code&gt;standard&lt;/code&gt; in * the {@link android.R.attr#launchMode} attribute. */</span></span></li><li><span class="name"><span class="innerContentContainer">public static final int LAUNCH_MULTIPLE = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">/** * Constant corresponding to &lt;code&gt;singleTop&lt;/code&gt; in * the {@link android.R.attr#launchMode} attribute. */</span></span></li><li><span class="name"><span class="innerContentContainer">public static final int LAUNCH_SINGLE_TOP = 1;</span></span></li><li><span class="name"><span class="innerContentContainer">/** * Constant corresponding to &lt;code&gt;singleTask&lt;/code&gt; in * the {@link android.R.attr#launchMode} attribute. */</span></span></li><li><span class="name"><span class="innerContentContainer">public static final int LAUNCH_SINGLE_TASK = 2;</span></span></li><li><span class="name"><span class="innerContentContainer">/** * Constant corresponding to &lt;code&gt;singleInstance&lt;/code&gt; in * the {@link android.R.attr#launchMode} attribute. */</span></span></li><li><span class="name"><span class="innerContentContainer">public static final int LAUNCH_SINGLE_INSTANCE = 3;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity r ; 打印最近的TaskRecord信息，信息内容与a参数的类似</span></span></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity b &lt;包名&gt; : 打印指定包创建的进程信息，包含已经注册的广播接收器action信息，创建的handler</span></span><ul><li><span class="name"><span class="innerContentContainer">generic_x86:/ $ dumpsys activity b com.google.android.ext.services</span></span></li><li><span class="name"><span class="innerContentContainer">ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts)</span></span></li><li><span class="name"><span class="innerContentContainer">mBroadcastsScheduled [foreground]=false</span></span></li><li><span class="name"><span class="innerContentContainer">mBroadcastsScheduled [background]=false</span></span></li><li><span class="name"><span class="innerContentContainer">mHandler:</span></span></li><li><span class="name"><span class="innerContentContainer">Handler (com.android.server.am.ActivityManagerService$MainHandler) {32cc7bf} @ 26049725</span></span></li><li><span class="name"><span class="innerContentContainer">Looper (ActivityManager, tid 16) {ba76e8c}</span></span></li><li><span class="name"><span class="innerContentContainer">Message 0: { when=+8m0s963ms what=27 target=com.android.server.am.ActivityManagerService$MainHandler }</span></span></li><li><span class="name"><span class="innerContentContainer">Message 1: { when=+10m14s258ms callback=com.android.server.am.ActiveServices$1 target=com.android.server.am.ActivityManagerService$MainHandler }</span></span></li><li><span class="name"><span class="innerContentContainer">Message 2: { when=+23m38s921ms callback=com.android.server.AppOpsService$1 target=com.android.server.am.ActivityManagerService$MainHandler }</span></span></li><li><span class="name"><span class="innerContentContainer">(Total messages: 3, polling=true, quitting=false)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity p &lt;包名&gt; : 打印指定包创建的进程信息</span></span><ul><li><span class="name"><span class="innerContentContainer">requiredAbi：要求的架构</span></span></li><li><span class="name"><span class="innerContentContainer">lastSwapPss：内存使用情况</span></span></li><li><span class="name"><span class="innerContentContainer">lastRequestedGc：上次GC请求</span></span></li><li><span class="name"><span class="innerContentContainer">generic_x86:/ $ dumpsys activity p com.google.android.ext.services</span></span></li><li><span class="name"><span class="innerContentContainer">ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)</span></span></li><li><span class="name"><span class="innerContentContainer">requiredAbi=x86 instructionSet=null</span></span></li><li><span class="name"><span class="innerContentContainer">adjSeq=18970 lruSeq=0 lastPss=4.1MB lastSwapPss=0.00 lastCachedPss=0.00 lastCachedSwapPss=0.00</span></span></li><li><span class="name"><span class="innerContentContainer">lastRequestedGc=-4h9m54s33ms lastLowMemory=-4h9m54s33ms reportLowMemory=false ....</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity s : 打印ServiceRecord信息</span></span><ul><li><span class="name"><span class="innerContentContainer">intent：intent信息</span></span></li><li><span class="name"><span class="innerContentContainer">packageName：包名</span></span></li><li><span class="name"><span class="innerContentContainer">IntentBindRecord：已绑定该服务的信息</span></span></li><li><span class="name"><span class="innerContentContainer">ServiceRecord{a4d66c6 u0 com.android.chrome/org.chromium.chrome.browser.omaha.OmahaClient}</span></span></li><li><span class="name"><span class="innerContentContainer">intent={act=org.chromium.chrome.browser.omaha.ACTION_REGISTER_REQUEST cmp=com.android.chrome/org.chromium.chrome.browser.omaha.OmahaClient}</span></span></li><li><span class="name"><span class="innerContentContainer">packageName=com.android.chrome ....</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity settings: 打印ServiceRecord信息</span></span><ul><li><span class="name"><span class="innerContentContainer">intent：intent信息</span></span></li><li><span class="name"><span class="innerContentContainer">packageName：包名</span></span></li><li><span class="name"><span class="innerContentContainer">IntentBindRecord：已绑定该服务的信息</span></span></li><li><span class="name"><span class="innerContentContainer">generic_x86:/ $ dumpsys activity settings</span></span></li><li><span class="name"><span class="innerContentContainer">TASK com.android.settings id=150</span></span></li><li><span class="name"><span class="innerContentContainer">ACTIVITY com.android.settings/.Settings$MemorySettingsActivity e5fb34f pid=23311</span></span></li><li><span class="name"><span class="innerContentContainer">Local Activity ebdaec State:</span></span></li><li><span class="name"><span class="innerContentContainer">mResumed=true mStopped=false mFinished=false .....</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity starter : 打印对应的启动者</span></span><ul><li><span class="name"><span class="innerContentContainer">mStartActivity:</span></span></li><li><span class="name"><span class="innerContentContainer">packageName=com.demo.Activity processName=com.demo</span></span></li><li><span class="name"><span class="innerContentContainer">launchedFromUid=10043 launchedFromPackage=com.demo.OtherActivity userId=0</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb dumpsys activity lastanr : 打印 ANR list信息</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">屏幕物理信息: adb shell dumpsys display</span></span><ul><li><span class="name"><span class="innerContentContainer">mDefaultViewport=DisplayViewport{valid=true, displayId=0, orientation=0, logicalFrame=Rect(0, 0 - 1080, 1920), physicalFrame=Rect(0, 0 - 1080, 1920), deviceWidth=1080, deviceHeight=1920}</span></span><ul><li><span class="name"><span class="innerContentContainer">mExternalTouchViewport=DisplayViewport{valid=false, displayId=0, orientation=0, logicalFrame=Rect(0, 0 - 0, 0), physicalFrame=Rect(0, 0 - 0, 0), deviceWidth=0, deviceHeight=0}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">mDisplayInfos=</span></span><ul><li><span class="name"><span class="innerContentContainer">PhysicalDisplayInfo{1920 x 1080, 60.000004 fps, density 1.5, 159.895 x 160.421 dpi, secure true, appVsyncOffset 1000000, bufferDeadline 16666666}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">读出overlay的包状态: adb shell dumpsys overlay</span></span><ul><li><span class="name"><span class="innerContentContainer">com.android.systemui.theme.dark:0 {</span></span><ul><li><span class="name"><span class="innerContentContainer">mPackageName.......: com.android.systemui.theme.dark  //overlay 的apk 包名</span></span></li><li><span class="name"><span class="innerContentContainer">mUserId............: 0</span></span></li><li><span class="name"><span class="innerContentContainer">mTargetPackageName.: com.android.systemui // 目标包名</span></span></li><li><span class="name"><span class="innerContentContainer">mBaseCodePath......: /vendor/overlay/SysuiDarkTheme/SysuiDarkThemeOverlay.apk // overlay的apk路径</span></span></li><li><span class="name"><span class="innerContentContainer">mState.............: STATE_DISABLED</span></span></li><li><span class="name"><span class="innerContentContainer">mIsEnabled.........: false</span></span></li><li><span class="name"><span class="innerContentContainer">mIsStatic..........: false</span></span></li><li><span class="name"><span class="innerContentContainer">mPriority..........: 1</span></span></li><li><span class="name"><span class="innerContentContainer">mCategory..........: null</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Input 设备信息: adb shell dumpsys input</span></span></li><li><span class="name"><span class="innerContentContainer">读出内存状态:  adb shell dumpsys meminfo</span></span><ul><li><span class="name"><span class="innerContentContainer">要指定具体应用，可加上包名:  adb shell dumpsys meminfo PACKAGE_NAME</span></span></li><li><span class="name"><span class="innerContentContainer">Total PSS by process:</span></span><ul><li><span class="name"><span class="innerContentContainer">36,511K: system (pid 1929)</span></span></li><li><span class="name"><span class="innerContentContainer">3,903K: android.ext.services (pid 2881)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Total PSS by OOM adjustment:</span></span><ul><li><span class="name"><span class="innerContentContainer">76,848K: Native</span></span></li><li><span class="name"><span class="innerContentContainer">4,411K: zygote (pid 1676)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Total PSS by category:</span></span><ul><li><span class="name"><span class="innerContentContainer">78,104K: Native</span></span></li><li><span class="name"><span class="innerContentContainer">22,149K: Dalvik</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Total RAM:   991,316K (status critical)</span></span><ul><li><span class="name"><span class="innerContentContainer">Free RAM:   412,181K (   10,761K cached pss +   144,448K cached kernel +   256,972K free)</span></span></li><li><span class="name"><span class="innerContentContainer">Used RAM:   433,189K (  326,881K used pss +   106,308K kernel)</span></span></li><li><span class="name"><span class="innerContentContainer">Lost RAM:   193,772K</span></span></li><li><span class="name"><span class="innerContentContainer">ZRAM:    16,628K physical used for    74,012K in swap (  317,216K total swap)</span></span></li><li><span class="name"><span class="innerContentContainer">Tuning: 128 (large 256), oom   184,320K, restore limit    61,440K (low-ram)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">读出CPU信息:  adb shell dumpsys cpuinfo</span></span><ul><li><span class="name"><span class="innerContentContainer">CPU usage from 1251999ms to 351197ms ago (2020-02-23 17:21:02.541 to 2020-02-23 17:36:03.343):</span></span><ul><li><span class="name"><span class="innerContentContainer">4.2% 20215/com.android.chrome:sandboxed_process0: 1.1% user + 3% kernel / faults: 396490 minor 1 major</span></span></li><li><span class="name"><span class="innerContentContainer">6.6% TOTAL: 1.2% user + 4.9% kernel + 0% iowait + 0% irq + 0.3% softirq</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">读出磁盘使用情况: adb shell dumpsys diskstats</span></span><ul><li><span class="name"><span class="innerContentContainer">Latency: 0ms [512B Data Write]</span></span></li><li><span class="name"><span class="innerContentContainer">Data-Free: 6589272K / 12258876K total = 53% free</span></span></li><li><span class="name"><span class="innerContentContainer">Cache-Free: 337720K / 420552K total = 80% free</span></span></li><li><span class="name"><span class="innerContentContainer">System-Free: 306024K / 1523568K total = 20% free</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看IP等网络信息: adb shell dumpsys ethernet</span></span><ul><li><span class="name"><span class="innerContentContainer">onNewDhcpResults({IP address 172.19.110.23/24 Gateway 172.19.110.1  DNS servers: [ 10.254.254.254 ] Domains <a class="contentLink" target="_blank" rel="noreferrer" href="http://gz.cvte.cn">gz.cvte.cn</a> DHCP server /10.22.4.10 Vendor info null lease 7200 seconds})</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出系统service信息: adb shell dumpsys activity services</span></span><ul><li><span class="name"><span class="innerContentContainer">打印指定服务的信息: adb shell dumpsys service ***(指定服务名)</span></span></li><li><span class="name"><span class="innerContentContainer">列出当前运行的服务： adb shell dumpsys | findstr DUMP</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出Provider列表: adb shell dumpsys activity providers</span></span></li><li><span class="name"><span class="innerContentContainer">dumpsys procstats : 可以查看应用运行时的 PSS、USS数据，包括最小值、平均值、最大值，例如查看过去一小时内存使用情况，其中数据部分是按照（最小PSS-平均PSS-最大PSS/最小USS-平均USS-最大USS）的格式显示出PSS和USS</span></span><ul><li><span class="name"><span class="innerContentContainer">generic_x86:/ $ dumpsys procstats --hours 1</span></span></li><li><span class="name"><span class="innerContentContainer">AGGREGATED OVER LAST 1 HOURS:</span></span><ul><li><span class="name"><span class="innerContentContainer">com.android.inputmethod.latin / u0a56 / v24:</span></span></li><li><span class="name"><span class="innerContentContainer">TOTAL: 100% (17MB-14MB-17MB/14MB-14MB-14MB over 2)</span></span></li><li><span class="name"><span class="innerContentContainer">Imp Bg: 100% (17MB-14MB-17MB/14MB-14MB-14MB over 2)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Memory usage:</span></span><ul><li><span class="name"><span class="innerContentContainer">...	 // 系统内存占比情况</span></span></li><li><span class="name"><span class="innerContentContainer">CchEmty: 109MB (16 samples)</span></span></li><li><span class="name"><span class="innerContentContainer">TOTAL  : 516MB</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>读出package状态: adb shell dumpsys package</b></span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys package l : 列举已知的lib库</span></span><ul><li><span class="name"><span class="innerContentContainer">Libraries: android.test.base -&gt;  (jar) /system/framework/android.test.base.jar ....</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package f : 列举设备支持的功能</span></span><ul><li><span class="name"><span class="innerContentContainer">Features: android.software.leanback_only ......</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package r : 列举 所有的&nbsp;[activity|service|receiver|content]&nbsp;intent 解析器，其中包含各个应用的入口，action对应的组件</span></span><ul><li><span class="name"><span class="innerContentContainer">Activity Resolver Table: // activity 入口</span></span></li><li><span class="name"><span class="innerContentContainer">Non-Data Actions:</span></span></li><li><span class="name"><span class="innerContentContainer">android.settings.HOME_SETTINGS:  // action</span></span></li><li><span class="name"><span class="innerContentContainer">c25027 com.android.tv.settings/.EmptyStubActivity  // 响应该action的组件</span></span></li><li><span class="name"><span class="innerContentContainer">MIME Typed Actions:</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.INSTALL_PACKAGE:</span></span></li><li><span class="name"><span class="innerContentContainer">7215b10 com.android.packageinstaller/.InstallStart</span></span></li><li><span class="name"><span class="innerContentContainer">Receiver Resolver Table:  // 广播接收器</span></span></li><li><span class="name"><span class="innerContentContainer">Non-Data Actions:</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.LOCALE_CHANGED:</span></span></li><li><span class="name"><span class="innerContentContainer">1a15a84 com.android.providers.media/.MediaScannerReceiver</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package permission [permissionName] : 列举所有申明该权限的应用信息，其中可以查看应用的版本信息，标签，使用的lib库和jar路径，首次安装时间，更新时间，签名信息，已经获取的权限，安装需要的权限以及overlay文件的路径</span></span><ul><li><span class="name"><span class="innerContentContainer">xxxx:/ $ dumpsys package permission android.permission.VIBRATE</span></span></li><li><span class="name"><span class="innerContentContainer">Packages:</span></span></li><li><span class="name"><span class="innerContentContainer">pkg=Package{a077660 com.ecloud.eshare.server}</span></span></li><li><span class="name"><span class="innerContentContainer">codePath=/system/priv-app/eshare-service</span></span></li><li><span class="name"><span class="innerContentContainer">versionCode=20190820 minSdk=8 targetSdk=8</span></span></li><li><span class="name"><span class="innerContentContainer">versionName=v5.8.20</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package preferred-xml : 列举首选应用的设置，以xml的方式输出</span></span><ul><li><span class="name"><span class="innerContentContainer">xxxx:/ $ dumpsys package preferred-xml</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;preferred-activities /&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package prov : 列举所有的内容提供者信息</span></span><ul><li><span class="name"><span class="innerContentContainer">xxxx:/ $ dumpsys package prov</span></span></li><li><span class="name"><span class="innerContentContainer">Registered ContentProviders:</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.systemui/.keyguard.KeyguardSliceProvider:</span></span></li><li><span class="name"><span class="innerContentContainer">Provider{b98064f com.android.systemui/.keyguard.KeyguardSliceProvider}</span></span></li><li><span class="name"><span class="innerContentContainer">com.android.browser/.homepages.HomeProvider:</span></span></li><li><span class="name"><span class="innerContentContainer">Provider{1c0f1dc com.android.browser/.homepages.HomeProvider}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package p : 获取所有已经安装的apk包信息，内容展示的格式与&nbsp;dumpsys package permission&nbsp;类似，这里就不做举例</span></span></li><li><span class="name"><span class="innerContentContainer">dumpsys package&nbsp;&lt;<a class="contentLink" target="_blank" rel="noreferrer" href="http://package.name">package.name</a>&gt; : 获取指定包的信息，可以获取到四大组件的信息，包信息（版本信息，lib库），已经请求的权限，安装需要的权限，运行时权限，shareUser信息（可以判断是否是系统应用）</span></span><ul><li><span class="name"><span class="innerContentContainer">xxxx:/ # dumpsys package com.ecloud.eshare.server</span></span></li><li><span class="name"><span class="innerContentContainer">Activity Resolver Table:</span></span></li><li><span class="name"><span class="innerContentContainer">Non-Data Actions:</span></span></li><li><span class="name"><span class="innerContentContainer">android.intent.action.MAIN:</span></span></li><li><span class="name"><span class="innerContentContainer">9baa84b com.ecloud.eshare.server/.CifsClientActivity filter 6b0c11f</span></span></li><li><span class="name"><span class="innerContentContainer">Action: "android.intent.action.MAIN"</span></span></li><li><span class="name"><span class="innerContentContainer">Category: "android.intent.category.LAUNCHER"</span></span></li><li><span class="name"><span class="innerContentContainer">Shared users:</span></span></li><li><span class="name"><span class="innerContentContainer">SharedUser [android.uid.system] (db280e1):</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package s : 列举shared uses的信息，权限，对应的gid</span></span><ul><li><span class="name"><span class="innerContentContainer">xxxx:/ # dumpsys package s</span></span></li><li><span class="name"><span class="innerContentContainer">Shared users:</span></span></li><li><span class="name"><span class="innerContentContainer">SharedUser [android.uid.system] (d6d5db):</span></span></li><li><span class="name"><span class="innerContentContainer">userId=10012</span></span></li><li><span class="name"><span class="innerContentContainer">install permissions:</span></span></li><li><span class="name"><span class="innerContentContainer">android.permission.ACCESS_CACHE_FILESYSTEM: granted=true</span></span></li><li><span class="name"><span class="innerContentContainer">User 0:</span></span></li><li><span class="name"><span class="innerContentContainer">gids=[2001, 1065, 1023, 3003, 3007, 1024]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys package check-permission&nbsp;&lt;permission&gt; &lt;package&gt; : 检查对应的包是否已经获得对应的权限</span></span><ul><li><span class="name"><span class="innerContentContainer">Hi3751V350:/ # dumpsys package check-permission android.permission.WRITE_EXTERNAL_STORAGE com.demo.test</span></span></li><li><span class="name"><span class="innerContentContainer">0</span></span></li><li><span class="name"><span class="innerContentContainer">Hi3751V350:/ # dumpsys package check-permission android.permission.INTERNET com.demo.test</span></span></li><li><span class="name"><span class="innerContentContainer">-1</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">读出通知列表: adb shell dumpsys notification. 返回值是:</span></span><ul><li><span class="name"><span class="innerContentContainer">NotificationRecord(0x44217920: pkg=com.sohu.newsclient useron=0x7f0201b5 / com.tencent.news:drawable/icon</span></span></li><li><span class="name"><span class="innerContentContainer">pri=0 score=0</span></span></li><li><span class="name"><span class="innerContentContainer">contentIntent=PendingIntent{4294d748: PendingIntentRecord{44088e90 com.tencent.news startActivity}}</span></span></li><li><span class="name"><span class="innerContentContainer">deleteIntent=null</span></span></li><li><span class="name"><span class="innerContentContainer">tickerText=null</span></span></li><li><span class="name"><span class="innerContentContainer">contentView=android.widget.RemoteViews@441fc810</span></span></li><li><span class="name"><span class="innerContentContainer">defaults=0x00000001 flags=0x00000010</span></span></li><li><span class="name"><span class="innerContentContainer">sound=null</span></span></li><li><span class="name"><span class="innerContentContainer">vibrate=null</span></span></li><li><span class="name"><span class="innerContentContainer">led=0x00000000 onMs=0 offMs=0</span></span></li><li><span class="name"><span class="innerContentContainer">extras={</span></span><ul><li><span class="name"><span class="innerContentContainer">android.title=农业部:中国超级稻亩产超1吨</span></span></li><li><span class="name"><span class="innerContentContainer">android.subText=null</span></span></li><li><span class="name"><span class="innerContentContainer">android.showChronometer=false</span></span></li><li><span class="name"><span class="innerContentContainer">android.icon=2130837941</span></span></li><li><span class="name"><span class="innerContentContainer">android.text=农业部今日通报称,经专家测产,袁隆平领衔培育的中国“超级稻”亩产过千公斤,创造1026.7公斤新纪录。详情&gt;&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">android.progress=0</span></span></li><li><span class="name"><span class="innerContentContainer">android.progressMax=0</span></span></li><li><span class="name"><span class="innerContentContainer">android.showWhen=true</span></span></li><li><span class="name"><span class="innerContentContainer">android.infoText=null</span></span></li><li><span class="name"><span class="innerContentContainer">android.progressIndeterminate=false</span></span></li><li><span class="name"><span class="innerContentContainer">android.scoreModified=false</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出广播: adb shell dumpsys activity broadcasts</span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys | grep BroadcastRecord</span></span><ul><li><span class="name"><span class="innerContentContainer">Historical Broadcast background #3:</span></span></li><li><span class="name"><span class="innerContentContainer">BroadcastRecord{4c46ab u-1 android.net.wifi.RSSI_CHANGED} to user -1</span></span></li><li><span class="name"><span class="innerContentContainer">Intent { act=android.net.wifi.RSSI_CHANGED flg=0x4000010 (has extras) }</span></span><ul><li><span class="name"><span class="innerContentContainer">extras: Bundle[{newRssi=-56}]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">caller=android 1933:system/1000 pid=1933 uid=1000</span></span></li><li><span class="name"><span class="innerContentContainer">enqueueClockTime=۲۰۲۲-۰۳-۱۹ ۰۷:۴۹:۳۰ dispatchClockTime=۲۰۲۲-۰۳-۱۹ ۰۷:۴۹:۳۰</span></span></li><li><span class="name"><span class="innerContentContainer">dispatchTime=-2m19s724ms (+1ms since enq) finishTime=-2m19s724ms (0 since disp)</span></span></li><li><span class="name"><span class="innerContentContainer">resultAbort=false ordered=false sticky=true initialSticky=false</span></span></li><li><span class="name"><span class="innerContentContainer">Deliver #0: BroadcastFilter{4239f13 u0 ReceiverList{46da02 2647 com.ecloud.eshare.server/1000/u0 remote:9fd7f4d}}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">读出intents消息: adb shell dumpsys activity intents</span></span></li><li><span class="name"><span class="innerContentContainer">提醒列表: adb shell dumpsys alarm</span></span></li><li><span class="name"><span class="innerContentContainer">电池信息: adb shell dumpsys power</span></span><ul><li><span class="name"><span class="innerContentContainer">mBatteryLevel=100 // 电量</span></span></li><li><span class="name"><span class="innerContentContainer">mLowPowerModeEnabled=false //是否处于省电模式</span></span></li><li><span class="name"><span class="innerContentContainer">mBatteryLevelLow=false //电池是否底</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出camera属性和状态: adb shell dumpsys media.camera</span></span><ul><li><span class="name"><span class="innerContentContainer">注意 stream[0], [1]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">读出位置状态: adb shell dumpsys location</span></span></li><li><span class="name"><span class="innerContentContainer">读出电话状态: adb shell dumpsys telephony.registry</span></span><ul><li><span class="name"><span class="innerContentContainer">mCallState值为0，表示待机状态、1表示来电未接听状态、2表示电话占线状态</span></span></li><li><span class="name"><span class="innerContentContainer">mCallForwarding=false   # 是否启用呼叫转移</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionState=2 #0：无数据连接 1：正在创建数据连接 2：已连接</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionPossible=true   # 是否有数据连接</span></span></li><li><span class="name"><span class="innerContentContainer">mDataConnectionApn=   # APN名称</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">dumpsys由 <a class="contentLink" target="_blank" rel="noreferrer" href="https://android.googlesource.com/platform/frameworks/native/+/master/cmds/dumpsys/dumpsys.cpp">frameworks/native/cmds/dumpsys/dumpsys.cpp</a> 文件中编译得到。</span></span></li><li><span class="name"><span class="innerContentContainer">入口即 dump().</span></span></li><li><span class="name"><span class="innerContentContainer">Binder支持 dump() 接口, 其实现由各个service 负责实现, 比如: DiskStatsService.dump().</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Logcat</b> <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: logcat</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 包括3种log, 应用 + fwk log, event log, 射频通话log (暂不关注)</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: 最常见的log.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 可分析应用和fwk层的所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 原生, 不依赖.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">adb logcat **。支持如下参数：</span></span></li><li><span class="name"><span class="innerContentContainer">默认值 = main + system</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-b main</b></span></span><ul><li><span class="name"><span class="innerContentContainer">默认, 主程序log. </span></span></li><li><span class="name"><span class="innerContentContainer">一般用户空间log将写入设备节点 /dev/log/main，包括 System.out.print 及 System.erro.print 等.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-b system</span></span><ul><li><span class="name"><span class="innerContentContainer">fwk层log信息和debugging.</span></span></li><li><span class="name"><span class="innerContentContainer">为了防止mian缓存区溢出, 而从其中分离出来.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-b radio</span></span><ul><li><span class="name"><span class="innerContentContainer">射频通话相关信息.</span></span></li><li><span class="name"><span class="innerContentContainer">tag 为"HTC_RIL" "RILJ" "RILC" "RILD" "RIL" "AT" "GSM" "STK"的log信息将写入此节点.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>-c: 清除log缓存</b></span></span></li><li><span class="name"><span class="innerContentContainer">-v: 指定Log前缀格式, 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">brief: 默认</span></span></li><li><span class="name"><span class="innerContentContainer">process: 只有PID.</span></span></li><li><span class="name"><span class="innerContentContainer">tag: 只有优先级和PID</span></span></li><li><span class="name"><span class="innerContentContainer">time: 有日期时间, 优先级, 标签和PID</span></span></li><li><span class="name"><span class="innerContentContainer">threadtime: 仅time + thread id</span></span></li><li><span class="name"><span class="innerContentContainer">raw: 不显示前缀</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">-d: 打印当前log后退出.</span></span></li><li><span class="name"><span class="innerContentContainer">-g: 打印缓冲区大小</span></span></li><li><span class="name"><span class="innerContentContainer"><b>过滤关键字</b>: adb logcat | findstr "***"</span></span><ul><li><span class="name"><span class="innerContentContainer">过滤多个关键字: findstr 后用空格分开.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">过滤关键字.方法2 --更好</span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell "logcat | grep *** "</span></span></li><li><span class="name"><span class="innerContentContainer">关键字支持正则表达式，同时可以输出到文件，所以推荐。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logcat 遇到 read: unexpected EOF!. 解决办法是:</span></span><ul><li><span class="name"><span class="innerContentContainer">adb logcat -G 16m</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: 自定义, 一般是 main-log, event-log等.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: 每行log包括如下6个部分:</span></span><ul><li><span class="name"><span class="innerContentContainer">Tag</span></span></li><li><span class="name"><span class="innerContentContainer">时间戳</span></span></li><li><span class="name"><span class="innerContentContainer">PID, 进程ID</span></span></li><li><span class="name"><span class="innerContentContainer">TID, 线程ID</span></span></li><li><span class="name"><span class="innerContentContainer">log level</span></span></li><li><span class="name"><span class="innerContentContainer">log信息(代码中写入)</span></span></li><li><span class="name"><span class="innerContentContainer">具体关键字参见 各问题主题.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">App通过写入android.util.Log包来引入Log类，然后通过log方法写不同优先级的相关信息到log。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/base/core/java/android/util/Log.java</span></span></li><li><span class="name"><span class="innerContentContainer">主要方法有：</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.v();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.d();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.w();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.e();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.a();</span></span></li><li><span class="name"><span class="innerContentContainer">分别对应log级别：Assert，ERROR，WARN，INFO，DEBUG，VERBOSE。</span></span></li><li><span class="name"><span class="innerContentContainer">VERBOSE除了开发期间，是不应该被编译进APP的，DEBUG应该编译但在runtime被忽略，ERROR，WARN和INFO logs则一直被保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">jni层: frameworks/base/core/jni/android_util_Log.cpp, 关键函数是 android_util_Log_println_native()</span></span></li><li><span class="name"><span class="innerContentContainer">Native层: system/core/logcat/logcat.cpp. </span></span></li><li><span class="name"><span class="innerContentContainer">Native层打印log的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">包含system/core/include/cutils/log.h</span></span></li><li><span class="name"><span class="innerContentContainer">在模块Android.mk中添加：LOCAL_SHARED_LIBRARIES := liblog libcutils</span></span></li><li><span class="name"><span class="innerContentContainer">打印接口是: </span></span></li><li><span class="name"><span class="innerContentContainer">ALOGV</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGD</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGI</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGW</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGE</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logd 服务: 在开机过程中被init进程启动. </span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 system/core/logd</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\CommandListener.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\LogBuffer.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">底层: logging的kernel driver部分被称作”logger”</span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 kernel/drivers/staging/android/logger.c</span></span></li><li><span class="name"><span class="innerContentContainer">生成4个设备节点:</span></span><ul><li><span class="name"><span class="innerContentContainer">/dev/log/main</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/events</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/radio</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/system</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Events</b> <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: event log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: fwk</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>:  系统事件log, 主要是framework中各service的正常流程打印, 尤其是ams/wms.</span></span><ul><li><span class="name"><span class="innerContentContainer">event打印较少，所有log窗口比logcat大得多，几m log可以保存几天的操作信息，而且不会移除(存疑)，所以是梳理应用流和activity流的好工具。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 应用, fwk, 应用crash问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: Event logs 文件存储在system/etc/event-log-tags 中。</span></span><ul><li><span class="name"><span class="innerContentContainer">通过 cat system/etc/event-log-tags能读出系统支持哪些event，并给出其格式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>:  event log总是以小写字母单词开始，常见各log主题。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">Event logs是在 android.util.EventLog 中创建二进制log信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel Log <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Kernel Log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 底层所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell cat /proc/kmsg；kernel日志,每cat一次会清零</span></span></li><li><span class="name"><span class="innerContentContainer">adb dmesg -n 8，写入打印级别, 8是所有都打。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell dmesg: ernel日志, 开机信息.(通过var/log/demsg)</span></span></li><li><span class="name"><span class="innerContentContainer">同时抓取 Kernel log和logcat的方法:  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">adb shell logcat -v time -f /dev/kmsg | adb shell cat /proc/kmsg | tee kernel_logcat.txt</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: 自定义</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">格式较简单: 时间戳, 进程ID, 线程ID, 级别, Log内容</span></span></li><li><span class="name"><span class="innerContentContainer">例子: 2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5]</span></span></li><li><span class="name"><span class="innerContentContainer">问题：时间戳为开机秒数，转成为时分秒格式 /对齐时间戳</span></span><ul><li><span class="name"><span class="innerContentContainer">方法1： 在kernel日志中搜 "UTC", 或者 "rtc"。可找到时间的对应关系。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意我们是东八区，utc + 8才是时分秒。</span></span></li><li><span class="name"><span class="innerContentContainer">这个log每20秒打印一次，够用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">方法2：dmesg -T ，以当前时间的方式显示时间信息 --有效，但是要联机使用，问题不复现就没用了。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">使用 printk()函数 进行Log输出。</span></span></li><li><span class="name"><span class="innerContentContainer">日志级别</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel log日志级别在 include/linux/kern_levels.h 定义. 字符串表示为一个尖括号中的整数，0-7，值越小优先级越高。</span></span></li><li><span class="name"><span class="innerContentContainer">优先级小于 console_loglevel 这个整数变量的消息才会打印。</span></span></li><li><span class="name"><span class="innerContentContainer">读出当前日志级别: cat /system/sys/kernel/printk, 有4个数字，第一个表示当前日志级别。</span></span></li><li><span class="name"><span class="innerContentContainer">刷新系统日志级别: echo 8 &gt; /system/sys/kernel/printk</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">换行符，log行尾一定要加换行符。否则不会输出到控制台。</span></span></li><li><span class="name"><span class="innerContentContainer">如果系统运行了 klogd 和 syslogd，则所有内核消息都会被追加到 /var/log/messages 中。</span></span></li><li><span class="name"><span class="innerContentContainer">Log buffer 大小是写在代码中的，这个宏:LOG_BUF_SHIFT，所在文件为 /kernel/init/Kconfig。</span></span></li><li><span class="name"><span class="innerContentContainer">打印速度: printk_ratelimit().</span></span></li><li><span class="name"><span class="innerContentContainer">打印主次设备号: print_dev_t(), format_dev_t().</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">printk(KERN_ALERT "This is the log printed by printk in linux kernel space.");</span></span></li><li><span class="name"><span class="innerContentContainer">printk(KERN_ERR "%s: Invalid parameter\n", __func__);</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>Tombstones  </b> <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span>  <b><span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Tombstones</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: 以死机堆栈和寄存器为主体. crash时系统所有线程的堆栈和寄存器。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 系统重启问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: 当系统 crash 的时候，会保存一个 tombstone 文件到 /data/tombstones目录下。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: tombstone</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">发生crash的进程ID：I/DEBUG   (  241): pid: 244, tid: 244, name: mediaserver  &gt;&gt;&gt; /system/bin/mediaserver &lt;&lt;&lt;</span></span><ul><li><span class="name"><span class="innerContentContainer">当 tid == pid 时，问题发生在父进程，反之问题发生在子进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel定义的错误类型</span></span><ul><li><span class="name"><span class="innerContentContainer">SIGSEGV: Invalid memory reference，地址非法异常。原因包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">尝试写入只读区域</span></span></li><li><span class="name"><span class="innerContentContainer">访问空指针</span></span></li><li><span class="name"><span class="innerContentContainer">写入空悬指针</span></span></li><li><span class="name"><span class="innerContentContainer">被访问的非法地址见 fault addr 字段。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SIGBUS: Access to an undefined portion of a memory object，内存地址异常。地址合法，但是不可访问。原因一般是字节不对齐。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGFPE: Arithmetic operation error, like divide by zero. 算数异常，包括浮点异常和除零异常。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGILL: Illegal instruction, like execute garbage or a privileged instruction。执行非法指令，通常因为二进制文件错误，或者尝试执行数据段。堆栈溢出可引起此问题。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGSYS: Bad system call. 非法的系统调用。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXCPU: CPU time limit exceeded. CPU时间片超时。时分系统才有。</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXFSZ: File size limit exceeded. 文件大小超过系统限制。</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型定义在prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.8/sysroot/usr/include/bits/signum.h</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">arm芯片定义的错误类型</span></span><ul><li><span class="name"><span class="innerContentContainer">Preftch Abort：程序指针跑飞；</span></span></li><li><span class="name"><span class="innerContentContainer">Data Abort：内存指针跑飞；（最常见）</span></span></li><li><span class="name"><span class="innerContentContainer">Div by Zero：发生除零错误；</span></span></li><li><span class="name"><span class="innerContentContainer">Unknown sig：某个task收到未定义的信号；</span></span></li><li><span class="name"><span class="innerContentContainer">Error Fatal：代码进入error FATAL分支</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">memory near pc： 异常时pc寄存器。</span></span></li><li><span class="name"><span class="innerContentContainer">backtrace： crash 时的堆栈。</span></span></li><li><span class="name"><span class="innerContentContainer">JNI ERROR: local reference table overflow, 局部引用表溢出</span></span><ul><li><span class="name"><span class="innerContentContainer">系统限制局部对象应用最大512个，超过则crash。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Dropbox  <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Dropbox</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: kernel，fwk, 应用</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: 保存最近1000次crash的堆栈（只有堆栈）。最新的放在最后面，直接搜时间快速定位。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: crash问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: adb push</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: /data/system/dropbox</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本工具.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">DropBoxManagerService.java</span></span></li><li><span class="name"><span class="innerContentContainer">关键函数是 <b>add</b>()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">BugReport  <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: Bugreport</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用和fwk</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 稳定性问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: R上好像不再提供bugreport。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: adb bugreport &gt; bugreport.log</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: Bugreport内容较多, 推荐使用 ChkBugReport 工具进行预解析.</span></span><ul><li><span class="name"><span class="innerContentContainer">下载地址: <a class="contentLink" target="_blank" rel="noreferrer" href="https://github.com/sonyxperiadev/ChkBugReport">https://github.com/sonyxperiadev/ChkBugReport</a> , 很长时间未维护, 建议自行编译.</span></span></li><li><span class="name"><span class="innerContentContainer">使用: java -jar chkbugreport.jar bugreport.txt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">bugreport 内容较多，是几种log的混合体。包括:</span></span></li><li><span class="name"><span class="innerContentContainer">系统build相关信息</span></span><ul><li><span class="name"><span class="innerContentContainer">dumpstate: date</span></span></li><li><span class="name"><span class="innerContentContainer">Build: getprop ro.build.display.id</span></span></li><li><span class="name"><span class="innerContentContainer">Build fingerprint: getprop ro.build.fingerprint</span></span></li><li><span class="name"><span class="innerContentContainer">Bootloader: getprop ro.bootloader</span></span></li><li><span class="name"><span class="innerContentContainer">Radio: getprop ro.baseband</span></span></li><li><span class="name"><span class="innerContentContainer">Network: getprop gsm.operator.alpha</span></span></li><li><span class="name"><span class="innerContentContainer">Kernel: dump_file /proc/version</span></span></li><li><span class="name"><span class="innerContentContainer">Command line: cat /proc/cmdline</span></span></li><li><span class="name"><span class="innerContentContainer">up time：系统运行时长</span></span></li><li><span class="name"><span class="innerContentContainer">idle time：系统空闲时长</span></span></li><li><span class="name"><span class="innerContentContainer">sleep time：系统休眠时长</span></span></li><li><span class="name"><span class="innerContentContainer">elapsed：uptime指令执行时长</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存/CPU/进程等信息</span></span><ul><li><span class="name"><span class="innerContentContainer">UPTIME MMC PERF (/sys/block/mmcblk0/): 硬盘分区信息</span></span></li><li><span class="name"><span class="innerContentContainer">MEMORY INFO (/proc/meminfo)</span></span></li><li><span class="name"><span class="innerContentContainer">CPU INFO (top -n 1 -d 1 -m 30 -t)</span></span></li><li><span class="name"><span class="innerContentContainer">PROCRANK (procrank)</span></span></li><li><span class="name"><span class="innerContentContainer">VIRTUAL MEMORY STATS (/proc/vmstat)</span></span></li><li><span class="name"><span class="innerContentContainer">VMALLOC INFO (/proc/vmallocinfo)</span></span></li><li><span class="name"><span class="innerContentContainer">SLAB INFO (/proc/slabinfo)</span></span></li><li><span class="name"><span class="innerContentContainer">ZONEINFO (/proc/zoneinfo)</span></span></li><li><span class="name"><span class="innerContentContainer">PAGETYPEINFO (/proc/pagetypeinfo)</span></span></li><li><span class="name"><span class="innerContentContainer">BUDDYINFO (/proc/buddyinfo)</span></span></li><li><span class="name"><span class="innerContentContainer">FRAGMENTATION INFO (/d/extfrag/unusable_index)</span></span></li><li><span class="name"><span class="innerContentContainer">KERNEL WAKELOCKS (/proc/wakelocks)</span></span></li><li><span class="name"><span class="innerContentContainer">KERNEL WAKE SOURCES (/d/wakeup_sources: 1970-01-01 08:00:00)</span></span></li><li><span class="name"><span class="innerContentContainer">KERNEL CPUFREQ (/sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state)</span></span></li><li><span class="name"><span class="innerContentContainer">KERNEL SYNC (/d/sync)</span></span></li><li><span class="name"><span class="innerContentContainer">PROCESSES (ps -P)</span></span></li><li><span class="name"><span class="innerContentContainer">PROCESSES AND THREADS (ps -t -p -P)</span></span></li><li><span class="name"><span class="innerContentContainer">PROCESSES (SELINUX LABELS) (ps -Z)</span></span></li><li><span class="name"><span class="innerContentContainer">LIBRANK (librank)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">KERNEL LOG (dmesg)</span></span></li><li><span class="name"><span class="innerContentContainer">lsof: 所有进程打开的文件</span></span><ul><li><span class="name"><span class="innerContentContainer">LIST OF OPEN FILES (/system/xbin/su root lsof)</span></span></li><li><span class="name"><span class="innerContentContainer">COMMAND  PID  USER  FD  TYPE  DEVICE  SIZE/OFF  NODE   NAME</span></span></li><li><span class="name"><span class="innerContentContainer">zygote   286  root  mem  ???   b3:17   16384   2827  /system/vendor/lib/libc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">show map: 所有进程的show map</span></span><ul><li><span class="name"><span class="innerContentContainer">SHOW MAP 1 (/init) (/system/xbin/su root showmap 1)</span></span></li><li><span class="name"><span class="innerContentContainer">SHOW MAP 2 () (/system/xbin/su root showmap 2)</span></span></li><li><span class="name"><span class="innerContentContainer">SHOW MAP 3649 () (/system/xbin/su root showmap 3649)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Wait-Channels: 所有线程的Wait-Channels，记录着所有线程最后停留所在位置</span></span><ul><li><span class="name"><span class="innerContentContainer">BLOCKED PROCESS WAIT-CHANNELS</span></span></li><li><span class="name"><span class="innerContentContainer">1    /init     SyS_epoll_wait    // 表示进程init，最后blocked在SyS_epoll_wait方法内。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SYSTEM LOG (logcat -v threadtime -d *:v)</span></span></li><li><span class="name"><span class="innerContentContainer">EVENT LOG (logcat -b events -v threadtime -d *:v) </span></span></li><li><span class="name"><span class="innerContentContainer">RADIO LOG (logcat -b radio -v threadtime -d *:v)</span></span></li><li><span class="name"><span class="innerContentContainer">OG STATISTICS (logcat -b all -S): 记录main/radio/events/system/crash/kernel各个log使用情况</span></span></li><li><span class="name"><span class="innerContentContainer">vm traces</span></span><ul><li><span class="name"><span class="innerContentContainer">just now的栈信息: ”VM TRACES JUST NOW”，数据来源”/data/anr/traces.txt.bugreport”</span></span></li><li><span class="name"><span class="innerContentContainer">last ANR的栈信息: ”VM TRACES AT LAST ANR”，数据来源”/data/anr/traces.txt”。</span></span><ul><li><span class="name"><span class="innerContentContainer">如果没有anr则输出 NO ANR VM TRACES FILE</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">tombstones信息</span></span><ul><li><span class="name"><span class="innerContentContainer">TOMBSTONE (/data/tombstones/tombstone_01: 2016-06-18 11:16:18)</span></span></li><li><span class="name"><span class="innerContentContainer">如果没有tombstones, 则输出: NO TOMBSTONES to dump</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">network</span></span><ul><li><span class="name"><span class="innerContentContainer">NETWORK DEV INFO (/proc/net/dev)</span></span></li><li><span class="name"><span class="innerContentContainer">QTAGUID NETWORK INTERFACES INFO (/proc/net/xt_qtaguid/iface_stat_all)</span></span></li><li><span class="name"><span class="innerContentContainer">QTAGUID NETWORK INTERFACES INFO (xt) (/proc/net/xt_qtaguid/iface_stat_fmt)</span></span></li><li><span class="name"><span class="innerContentContainer">QTAGUID CTRL INFO (/proc/net/xt_qtaguid/ctrl)</span></span></li><li><span class="name"><span class="innerContentContainer">QTAGUID STATS INFO (/proc/net/xt_qtaguid/stats)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LAST KMSG (/proc/last_kmsg): &nbsp;last kernel log</span></span></li><li><span class="name"><span class="innerContentContainer">LAST LOGCAT (logcat -L -v threadtime -b all -d *:v): last system log</span></span></li><li><span class="name"><span class="innerContentContainer">IP相关</span></span><ul><li><span class="name"><span class="innerContentContainer">NETWORK INTERFACES (ip link)</span></span></li><li><span class="name"><span class="innerContentContainer">IPv4 ADDRESSES (ip -4 addr show)</span></span></li><li><span class="name"><span class="innerContentContainer">IPv6 ADDRESSES (ip -6 addr show)</span></span></li><li><span class="name"><span class="innerContentContainer">IP RULES (ip rule show)</span></span></li><li><span class="name"><span class="innerContentContainer">IP RULES v6 (ip -6 rule show)</span></span></li><li><span class="name"><span class="innerContentContainer">RT_TABLES (/data/misc/net/rt_tables: 2016-06-08 22:21:12)</span></span></li><li><span class="name"><span class="innerContentContainer">ROUTE TABLE IPv4 (ip -4 route show table 255)</span></span></li><li><span class="name"><span class="innerContentContainer">ROUTE TABLE IPv6 (ip -6 route show table 255)</span></span></li><li><span class="name"><span class="innerContentContainer">ARP CACHE (ip -4 neigh show)</span></span></li><li><span class="name"><span class="innerContentContainer">IPv6 ND CACHE (ip -6 neigh show)</span></span></li><li><span class="name"><span class="innerContentContainer">IPTABLES (/system/xbin/su root iptables -L -nvx)</span></span></li><li><span class="name"><span class="innerContentContainer">IP6TABLES (/system/xbin/su root ip6tables -L -nvx)</span></span></li><li><span class="name"><span class="innerContentContainer">IPTABLE NAT (/system/xbin/su root iptables -t nat -L -nvx)</span></span></li><li><span class="name"><span class="innerContentContainer">IPTABLE RAW (/system/xbin/su root iptables -t raw -L -nvx)</span></span></li><li><span class="name"><span class="innerContentContainer">IP6TABLE RAW (/system/xbin/su root ip6tables -t raw -L -nvx)</span></span></li><li><span class="name"><span class="innerContentContainer">WIFI NETWORKS (/system/xbin/su root wpa_cli IFNAME=wlan0 list_networks)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">中断向量表</span></span><ul><li><span class="name"><span class="innerContentContainer">INTERRUPTS (1) (/proc/interrupts)</span></span></li><li><span class="name"><span class="innerContentContainer">NETWORK DIAGNOSTICS (dumpsys connectivity --diag)</span></span></li><li><span class="name"><span class="innerContentContainer">INTERRUPTS (2) (/proc/interrupts)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SYSTEM PROPERTIES: property信息</span></span><ul><li><span class="name"><span class="innerContentContainer">VOLD DUMP (vdc dump)</span></span></li><li><span class="name"><span class="innerContentContainer">SECURE CONTAINERS (vdc asec list)</span></span></li><li><span class="name"><span class="innerContentContainer">FILESYSTEMS &amp; FREE SPACE (df)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">LAST RADIO LOG (parse_radio_log /proc/last_radio_log): &nbsp;last radio log</span></span></li><li><span class="name"><span class="innerContentContainer">BACKLIGHTS: 背光信息</span></span><ul><li><span class="name"><span class="innerContentContainer">LCD brightness= dump_file /sys/class/leds/lcd-backlight/brightness</span></span></li><li><span class="name"><span class="innerContentContainer">Button brightness= dump_file /sys/class/leds/button-backlight/brightness</span></span></li><li><span class="name"><span class="innerContentContainer">Keyboard brightness= dump_file /sys/class/leds/keyboard-backlight/brightness</span></span></li><li><span class="name"><span class="innerContentContainer">ALS mode= dump_file /sys/class/leds/lcd-backlight/als</span></span></li><li><span class="name"><span class="innerContentContainer">LCD driver registers: dump_file /sys/class/leds/lcd-backlight/registers</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder相关</span></span><ul><li><span class="name"><span class="innerContentContainer">BINDER FAILED TRANSACTION LOG (/sys/kernel/debug/binder/failed_transaction_log)</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTION LOG (/sys/kernel/debug/binder/transaction_log)</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTIONS (/sys/kernel/debug/binder/transactions)</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER STATS (/sys/kernel/debug/binder/stats)</span></span></li><li><span class="name"><span class="innerContentContainer">BINDER STATE (/sys/kernel/debug/binder/state)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">DUMP VENDOR RIL LOGS (/system/xbin/su root vril-dump): ril dump</span></span></li><li><span class="name"><span class="innerContentContainer">DUMPSYS (dumpsys)</span></span><ul><li><span class="name"><span class="innerContentContainer">通过dumpsys -l可查看系统所有服务，不带参数的dumpsys命令会输出系统中所有的服务：每个服务开头信息：</span></span></li><li><span class="name"><span class="innerContentContainer">DUMP OF SERVICE SurfaceFlinger:</span></span></li><li><span class="name"><span class="innerContentContainer">DUMP OF SERVICE alarm:</span></span></li><li><span class="name"><span class="innerContentContainer">DUMP OF SERVICE cpuinfo:</span></span></li><li><span class="name"><span class="innerContentContainer">DUMP OF SERVICE dropbox:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys checkin: 电池统计，内存、网络统计、进程、使用情况、包这些统计类信息。</span></span><ul><li><span class="name"><span class="innerContentContainer">CHECKIN BATTERYSTATS (dumpsys batterystats -c)</span></span></li><li><span class="name"><span class="innerContentContainer">CHECKIN MEMINFO (dumpsys meminfo --checkin)</span></span></li><li><span class="name"><span class="innerContentContainer">CHECKIN NETSTATS (dumpsys netstats --checkin)</span></span></li><li><span class="name"><span class="innerContentContainer">CHECKIN PROCSTATS (dumpsys procstats -c)</span></span></li><li><span class="name"><span class="innerContentContainer">CHECKIN USAGESTATS (dumpsys usagestats -c)</span></span></li><li><span class="name"><span class="innerContentContainer">CHECKIN PACKAGE (dumpsys package --checkin)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">dumpsys app相关: activity信息以及service和provider信息。</span></span><ul><li><span class="name"><span class="innerContentContainer">APP ACTIVITIES (dumpsys activity all)</span></span></li><li><span class="name"><span class="innerContentContainer">APP SERVICES (dumpsys activity service all)</span></span></li><li><span class="name"><span class="innerContentContainer">APP SERVICES (dumpsys activity provider all)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">线程dump文件  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，读出有两步：</span></span></li><li><span class="name"><span class="innerContentContainer">（1）读出线程pid，可以通过使用 jps 命令，在Linux环境下还可以使用 ps -ef | grep java</span></span></li><li><span class="name"><span class="innerContentContainer">（2）打印线程堆栈，可以通过使用 jstack pid命令，在Linux环境下还可以使用kill -3 pid</span></span></li><li><span class="name"><span class="innerContentContainer">另外提一点，Thread类提供了一个 getStackTrace()方法也可以用于读出线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次读出的是具体某个线程当前运行的堆栈.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Traces  <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: trace, 也即ANR, Application Not Responding</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用和framework</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: 以ANR堆栈为核心. Traces的主要问题是只能分析典型问题, 大部分问题单靠traces是分析不出来的, 还是要考 logcat.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 应用稳定性问题, 以ANR为主. </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">旧版本系统(&lt;=8.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">adb pull data/anr/traces.txt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">新版本系统(&gt;=9.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">一次anr一个log文件</span></span></li><li><span class="name"><span class="innerContentContainer">/data/anr/目录中有多个 anr_XXX文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写入ANR路径文件的位置：</span></span><ul><li><span class="name"><span class="innerContentContainer">读出: getprop dalvik.vm.stack -trace -file</span></span></li><li><span class="name"><span class="innerContentContainer">写入: setprop dalvik.vm.stack -trace -file /tmp/stack-traces.txt</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: traces.txt</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: 文本编辑器即可. 比如 Sublime.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog发现系统30秒不响应, 就会打印 traces.txt .</span></span></li><li><span class="name"><span class="innerContentContainer">超过一分钟不响应则会打印类似如下的log, 名字如 races_SystemServer_WDT_${time}.txt  的文件,并重启 system_server.</span></span></li><li><span class="name"><span class="innerContentContainer">ANR in: 表明发生 anr 的模块.</span></span></li><li><span class="name"><span class="innerContentContainer">PID: 进程号。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Reason</b>: 表示原因. --有时候有用, 有时候没用.  有如下类型:</span></span><ul><li><span class="name"><span class="innerContentContainer">无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口暂停: Waiting because the [targetType] window is paused.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长].</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">targetType: 取值为”focused”或者”touched”</span></span></li><li><span class="name"><span class="innerContentContainer">Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE”</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>CPU占用率</b>: Load: 5.15 / 3.68 / 3.38, 表明, 5分钟，10分钟，15分钟内的 平均分别为：5.15 , 3.68 , 3.38</span></span><ul><li><span class="name"><span class="innerContentContainer">现在cpu一般是8核的, 所以累计的CPU占用率最高为 800%.</span></span></li><li><span class="name"><span class="innerContentContainer">一般占用率超过 400% 系统会比较卡顿, 超过 600%会出现反复的进程crash 和应用anr.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU usage from 602ms to -6091ms ago: .   后面一堆数据, cpu从602毫秒到6091毫秒之间的各进程的CPU使用情况。</span></span></li><li><span class="name"><span class="innerContentContainer">以上是系统概况信息, 一般价值不大, 定位原因主要看anr时的堆栈.</span></span></li><li><span class="name"><span class="innerContentContainer">gralloc： 进程内存占用情况。后面的数字即进程占用的全部内存。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>anr堆栈的分析方法</b></span></span><ul><li><span class="name"><span class="innerContentContainer">搜 Dalvik Threads 可直接定位到堆栈区.</span></span></li><li><span class="name"><span class="innerContentContainer">一般看 main 线程，即前台window所在的应用的主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">Blocked in handler on foreground thread (android.fg)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on main thread (main)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on display thread (android.display)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on ActivityManager (ActivityManager)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">main堆栈一般处在两种状态：</span></span><ul><li><span class="name"><span class="innerContentContainer">blocked状态。即在等锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">注意，不要一看到等锁就是死锁问题。死锁是两个线程互相持有对方等的锁。</span></span></li><li><span class="name"><span class="innerContentContainer">单方面等锁非但不是死锁状态，反而是正常状态，而且非常常见。</span></span></li><li><span class="name"><span class="innerContentContainer">通过锁对象的hash可以判断是否是死锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">nativepollonce状态。即等待唤醒状态。</span></span><ul><li><span class="name"><span class="innerContentContainer">处在这种状态就是正常状态。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">main线程如果没有明显的异常，就要看其它线程的异常了。</span></span></li><li><span class="name"><span class="innerContentContainer">找对应的binder进程的堆栈. 比如 主线程id是8277,  则搜 Binder:8277_</span></span></li><li><span class="name"><span class="innerContentContainer">如果binder线程没也没有异常，那么trace文件就没啥价值了，应该回到 main log去分析。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">写anr log的代码在 ActivityManagerService.dumpStackTraces()</span></span></li><li><span class="name"><span class="innerContentContainer">traces在 ProcessRecord.java 中生成。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SysTrace <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span>   <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">参见 systrace系列文章  --非常强大。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: SysTrace</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: 应用, framework, 驱动. systrace负责收集系统各进程的各个线程的运行信息。</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: 为二进制文件, 需要专门的工具解析.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 性能问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">AS 进入Tools &gt; Android &gt; Monitor 抓取。</span></span></li><li><span class="name"><span class="innerContentContainer">或者使用 monitor.bat , 选择线程。</span></span></li><li><span class="name"><span class="innerContentContainer">选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。</span></span></li><li><span class="name"><span class="innerContentContainer">然后复现问题，抓对应的 systrace.</span></span></li><li><span class="name"><span class="innerContentContainer">配置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件），比如32M。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: SysTrace***</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">在R之前, chrome中打开 <a class="contentLink" target="_blank" rel="noreferrer" href="chrome://tracing">chrome://tracing</a>,  把文件拖进去即可.</span></span></li><li><span class="name"><span class="innerContentContainer">在R之后, 要用&nbsp;<a class="contentLink" target="_blank" rel="noreferrer" href="https://ui.perfetto.dev/">https://ui.perfetto.dev</a>打开。左侧3个按钮, open trace file 加载文件。如果更习惯旧界面，点击 open with legacy UI 即可新开窗口用旧界面显示。</span></span></li><li><span class="name"><span class="innerContentContainer">浏览快捷键 --用好键盘能极大的提高分析效率。</span></span><ul><li><span class="name"><span class="innerContentContainer">数字0: 恢复到最初状态</span></span></li><li><span class="name"><span class="innerContentContainer">数字1 表选中。可用鼠标选中一段操作，在屏幕下方看其细节。</span></span></li><li><span class="name"><span class="innerContentContainer">数字2 表示用鼠标上下左右浏览。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>f: 直接放大当前帧</b></span></span></li><li><span class="name"><span class="innerContentContainer">w: 放大</span></span></li><li><span class="name"><span class="innerContentContainer">s: 缩小</span></span></li><li><span class="name"><span class="innerContentContainer">a: 后退</span></span></li><li><span class="name"><span class="innerContentContainer">d: 前进</span></span></li><li><span class="name"><span class="innerContentContainer">方向键: 四处遍历</span></span></li><li><span class="name"><span class="innerContentContainer">m: 高亮当前</span></span></li><li><span class="name"><span class="innerContentContainer">v: 高亮整个 vsync</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">界面上有如下内容：</span></span></li><li><span class="name"><span class="innerContentContainer">1. interactions: input response的情况。</span></span></li><li><span class="name"><span class="innerContentContainer">2. CPU usage: CPU负荷曲线。</span></span></li><li><span class="name"><span class="innerContentContainer">3. kernel：8个CPU分别在执行什么代码。</span></span></li><li><span class="name"><span class="innerContentContainer">4. surfaceflinger： 屏幕渲染线程。包括开始时间和渲染耗时。</span></span></li><li><span class="name"><span class="innerContentContainer">5. idle (pid 0)： 硬件中断和软中断的情况，包括 i2c，irsq，softirq 等。</span></span></li><li><span class="name"><span class="innerContentContainer">6. system_Server： 这是重点。有时候进程名不显示，但它在 idle下面，而且pid较小（一般一千多），所以也不难找到。各子项包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">heap size： 系统heap占用</span></span></li><li><span class="name"><span class="innerContentContainer">iq：整个系统中待处理的事件的累计值。如果有卡顿，这个值会越来越大。非常重要。</span></span></li><li><span class="name"><span class="innerContentContainer">oq:包名：该应用的 outBoundQueue队列中事件的数量。一个应用一个。</span></span></li><li><span class="name"><span class="innerContentContainer">wq:包名：该应用的 waitQueue队列中事件的数量。一个应用一个。</span></span></li><li><span class="name"><span class="innerContentContainer">InputDispatcher：该线程。部分log显示不出来进程名，可通过屏幕右侧数据区的函数名推断，什么 dispatchMotionEvent，肯定是InputDispatcher线程了。这个线程在有用户输入时非常繁忙，找颜色最斑驳的横条就是了。</span></span></li><li><span class="name"><span class="innerContentContainer">InputReader：该线程。有些log中没见这个线程的数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 后面是各个三方应用，表头是：进程名 (pid ***)。这是重点分析对象。各子项包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">aq:进程名：进程的input队列中事件的数量。正常值应该是有事件时是1，无事件时是0。应用卡顿时数值会越来越大。</span></span></li><li><span class="name"><span class="innerContentContainer">aq:pending：进程名：进程的 PendingInputEventQueue 中事件的数量。点击色块，屏幕下方显示详细信息，包括当前activity的包名，value是1表示有一个事件。如果应用卡顿，则这个值会越来越大。</span></span></li><li><span class="name"><span class="innerContentContainer">frames：帧刷新情况，其中每个"F"都是一帧, 绿色表示不卡, 其它颜色表示卡，深红色表示非常卡顿。</span></span></li><li><span class="name"><span class="innerContentContainer">deliverInputEvent: 标识APP的 UI thread 处理input 事件的过程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">一个input事件在systrace中呈现的过程。重要。</span></span><ul><li><span class="name"><span class="innerContentContainer">input事件到来，inputreader线程被唤醒读取事件进行处理；</span></span></li><li><span class="name"><span class="innerContentContainer">inputdispatcher线程被inputreader唤醒，进行事件的分发；</span></span></li><li><span class="name"><span class="innerContentContainer">事件先放到应用的 OutboundQueued队列；</span></span></li><li><span class="name"><span class="innerContentContainer">事件发给应用主线程后，事件copy到waitQueue 队列，数量+1；等事件被消费后，数量-1 。</span></span></li><li><span class="name"><span class="innerContentContainer">如果UI thread发生卡顿，waitQueue 队列中的事件数量会变多。一般超过5个用户就会感到烦躁。</span></span></li><li><span class="name"><span class="innerContentContainer">在应用自身的板块，UI thread 被唤醒处理事件。</span></span></li><li><span class="name"><span class="innerContentContainer">aq:pending 中记录要被处理的事件的个数，应用处理后，这里就变成0。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">定位思路是：</span></span><ul><li><span class="name"><span class="innerContentContainer">先找到目标进程，看它的UI Tread, 找到卡顿最严重的帧。</span></span></li><li><span class="name"><span class="innerContentContainer">然后按下数字1, 用鼠标选中 UI thread 所在的绿条, 可以查看该段时间的执行细节, 比如 UI 线程执行了多久, 时间占比多少等等信息. 如果主要在UI线程执行, 那么需要进程自身代码优化性能. </span></span></li><li><span class="name"><span class="innerContentContainer">如果UI thread 主要在休眠, 那么就要往下找看哪个线程在执行. </span></span></li><li><span class="name"><span class="innerContentContainer">如果代码中打过点, 则会在该线程的横条的下方显示该函数的执行起止. </span></span></li><li><span class="name"><span class="innerContentContainer">排除UI thread&nbsp;之后，主要看gc的情况，io的情况。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span><ul><li><span class="name"><span class="innerContentContainer">在java代码中加 systrace 打点的方法</span></span><ul><li><span class="name"><span class="innerContentContainer">代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();</span></span></li><li><span class="name"><span class="innerContentContainer">必须成对出现, 且在同一个线程.</span></span></li><li><span class="name"><span class="innerContentContainer">在 release 版本中也生效.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systrace模块代码由3部分组成：</span></span><ul><li><span class="name"><span class="innerContentContainer">内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</span></span></li><li><span class="name"><span class="innerContentContainer">数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读出统计信息然后交给数据分析工具来处理。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分析工具：<a class="contentLink" target="_blank" rel="noreferrer" href="http://Android提供一个systrace.py">Android提供一个systrace.py</a>（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来写入数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用 Trace类来使用 Systrace.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">TraceView  <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span>  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log名称">#<span class="contentTagText">Log名称</span><span class="contentTagNub"></span></span>: TraceView</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log层次">#<span class="contentTagText">Log层次</span><span class="contentTagNub"></span></span>: fwk 和 应用层</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log简介">#<span class="contentTagText">Log简介</span><span class="contentTagNub"></span></span>: 能够可视化观察CPU的执行情况, 找出耗时操作.</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #用于解决哪类问题">#<span class="contentTagText">用于解决哪类问题</span><span class="contentTagNub"></span></span>: 性能问题</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #是否依赖特定平台">#<span class="contentTagText">是否依赖特定平台</span><span class="contentTagNub"></span></span>: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #抓取方法">#<span class="contentTagText">抓取方法</span><span class="contentTagNub"></span></span>: ddms选择: call stack show</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log文件名">#<span class="contentTagText">Log文件名</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #查看工具">#<span class="contentTagText">查看工具</span><span class="contentTagNub"></span></span>: ddms</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log内容">#<span class="contentTagText">Log内容</span><span class="contentTagNub"></span></span>: </span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #Log打印代码">#<span class="contentTagText">Log打印代码</span><span class="contentTagNub"></span></span>: </span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">TcpDump  <span class="contentTag" title="Filter @0010">@<span class="contentTagText">0010</span><span class="contentTagNub"></span></span>   <span class="contentTag" title="Filter #问题网络">#<span class="contentTagText"><b>问题</b>网络</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">TCP/IP协议相关的log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell tcpdump -s 10000 -w /sdcard/capture.pcap</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer"><b>ANR问题   <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android ANR问题-基本分析方法 <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/082045769443">https://www.jianshu.com/p/082045769443</a> --还可以</span></span></li><li><span class="name"><span class="innerContentContainer"><b>Trace文件分析过程   参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/28c7c7faaf64">https://workflowy.com/#/28c7c7faaf64</a></b></span></span></li><li><span class="name"><span class="innerContentContainer">应用与系统稳定性第一篇---ANR问题分析的一般套路 <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.jianshu.com/p/18f16aba79dd">https://www.jianshu.com/p/18f16aba79dd</a>  --好文章</span></span></li><li><span class="name"><span class="innerContentContainer">Android卡顿分析中常见的log: <a class="contentLink" target="_blank" rel="noreferrer" href="https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html">https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html</a>  --比较全面</span></span></li><li><span class="name"><span class="innerContentContainer">ANR出现的原因  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">主线程进行耗时的操作, 如数据库读写, 解析xml文件, 阻塞了窗口刷新;</span></span></li><li><span class="name"><span class="innerContentContainer">主线程进行了依赖外部资源的操作, 但是该资源迟迟不到位, 包括网络资源, 硬件设备, 比如打印机等.</span></span></li><li><span class="name"><span class="innerContentContainer">多线程操作的死锁，主线程被block；</span></span><ul><li><span class="name"><span class="innerContentContainer">关键字：waiting to lock</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主线程被 Binder server端阻塞, 一般是系统侧出问题；</span></span><ul><li><span class="name"><span class="innerContentContainer">在 traces.txt 文件中确认，client端的main线程卡在 BinderPorxy.transactNative；</span></span></li><li><span class="name"><span class="innerContentContainer">通过binderinfo 文件查找 server端的进程号。</span></span></li><li><span class="name"><span class="innerContentContainer">然后再在traces.txt 文件中确认server端在干什么， 常见的情况是卡在 Android.os.MessageQueue.nativePollOnce() , 即事件处理卡住了，这种一般需要fwk继续排查。</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种情况是server端进程出现WatchDog导致ANR.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder环境卡住, 包括binder线程池用光, 申请不到内存等.</span></span></li><li><span class="name"><span class="innerContentContainer">系统资源已耗尽（CPU、IO、内存）.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口失去焦点. </span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger 合成出问题导致界面没有绘制. 黑屏, 白屏一般是这个原因.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">各ANR超时门限</span></span><ul><li><span class="name"><span class="innerContentContainer">用户输入5S.  logKey：Input event dispatching timed out</span></span></li><li><span class="name"><span class="innerContentContainer">广播：前台10S，后台60S.  logKey：Timeout of broadcast BroadcastRecord</span></span></li><li><span class="name"><span class="innerContentContainer">服务：前台20S，后台200S.  logKey：Timeout executing service</span></span></li><li><span class="name"><span class="innerContentContainer">ContentProvider：10S.  logKey：timeout publishing content providers</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务启动时出现ANR 的原因</span></span><ul><li><span class="name"><span class="innerContentContainer">Service创建之前会延迟发送一个消息，而这个消息就是ANR的起源；</span></span></li><li><span class="name"><span class="innerContentContainer">Service创建完毕，在规定的时间之内执行完毕 onCreate()方法就移除这个消息，就不会产生ANR了；</span></span></li><li><span class="name"><span class="innerContentContainer">在规定的时间之内没有完成onCreate()的调用，消息被执行，ANR发生。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Binder问题分析  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText"><b>问题</b>稳定性</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">和应用层相关的binder问题主要有两类:</span></span><ul><li><span class="name"><span class="innerContentContainer">主线程被Binder 对端block导致anr;</span></span></li><li><span class="name"><span class="innerContentContainer">Binder被占满, 导致主线程无法启动binder引起异常.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,<a class="contentLink" target="_blank" rel="noreferrer" href="http://com.starbucks.cn">com.starbucks.cn</a>,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span></li><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer"><b>940: delay的时长(单位: 毫秒) </b></span></span></li><li><span class="name"><span class="innerContentContainer">com.starbucks.cn: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比. (这个含义应该不对)</span></span></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER FAILED TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/failed_transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTIONS</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/transactions</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER STATS</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/stats</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER PROCESS STATE</span></span><ul><li><span class="name"><span class="innerContentContainer">读出该log:读出文件/proc/binder/proc/*</span></span></li><li><span class="name"><span class="innerContentContainer">bind相关的一些状态</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SNR问题  <span class="contentTag" title="Filter #问题稳定性">#<span class="contentTagText">问题稳定性</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">snr即系统不响应问题，即system_server 中的系统服务出现不响应的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">应用anr由input消息处理机制来管理，用户不操作就不管它响应不响应，系统服务则更为重要，所以采用 watchdog来管理。每个系统服务都指定一个时间间隔，服务定期去踢狗，超过间隔未去踢狗，则视为该服务停止响应。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析问题的首选方法  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">三现原则。log也算现场。</span></span></li><li><span class="name"><span class="innerContentContainer">利用dailybuild版本，将问题分而治之。</span></span></li><li><span class="name"><span class="innerContentContainer">花3-5分钟时间考虑思路，并写在纸上. 然后尽快开始做。</span></span></li><li><span class="name"><span class="innerContentContainer">配环境是难点，三个办法：</span></span><ul><li><span class="name"><span class="innerContentContainer">平时准备好；</span></span></li><li><span class="name"><span class="innerContentContainer">找现成的环境用；</span></span></li><li><span class="name"><span class="innerContentContainer">基本环境出问题, 不要自己琢磨, 直接找高手搞定. 不要把时间浪费在非关键问题上.</span></span><ul><li><span class="name"><span class="innerContentContainer">这意味着平时要维护一个高手的名单, 并和他们处好关系.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">加快闭环</span></span><ul><li><span class="name"><span class="innerContentContainer">code → compiler → install → test</span></span></li><li><span class="name"><span class="innerContentContainer">如果在定位问题，请保证每个小时出一次版本。</span></span></li><li><span class="name"><span class="innerContentContainer">我的经验是，一个较复杂的问题的定位，至少需要3个以上的测试版本，而写完一大段代码（300行以上）后进行功能验证，一般需要4-6个版本才能搞定（平均每个版本能解决两三个个bug）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB 相关问题，首选是Bus Hound；</span></span></li><li><span class="name"><span class="innerContentContainer">硬件问题：把线连出来，上示波器。要会用示波器。</span></span></li><li><span class="name"><span class="innerContentContainer">用trace 跟无问题，不跟才有，一般和踢狗相关。</span></span></li><li><span class="name"><span class="innerContentContainer">性能问题，先要流程分解成3-6个阶段，然后通过log 打印等方式得出各阶段的时耗，找到突破点。</span></span></li><li><span class="name"><span class="innerContentContainer">功耗问题，逐个器件拔。</span></span></li><li><span class="name"><span class="innerContentContainer">迅速缩小焦点：</span></span><ul><li><span class="name"><span class="innerContentContainer">FFA上有吗? 有, 就是高通的问题. 没有,则是我们的修改引入的.</span></span></li><li><span class="name"><span class="innerContentContainer">新版本有吗? 没有, 则已经解决.</span></span></li><li><span class="name"><span class="innerContentContainer">老版本有吗? 没有, 则是最近修改引入的. 有, 则是固有问题.</span></span></li><li><span class="name"><span class="innerContentContainer">新单板有吗? 没有, 则已经解决. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">老单板有吗? 没有, 则为硬件修改引入. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">第三方应用有吗? 有, 说明是底层问题. 没有, 说明是应用的问题. (非绝对)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时刻关注自己是在哪个层面上考虑问题：</span></span><ul><li><span class="name"><span class="innerContentContainer">是cpu层次（包括cpu、硬件寄存器、dma）</span></span></li><li><span class="name"><span class="innerContentContainer">是外设级别（要考虑时序、电源）</span></span></li><li><span class="name"><span class="innerContentContainer">还是task级别（sig、队列、task切换、堆栈、中断等）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">张建春的定位技巧  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">多看 MODEM SOFTWARE INTERFACE .pdf，学会对arm硬件寄存器的直接操作。</span></span></li><li><span class="name"><span class="innerContentContainer">下发“FALSH读”的指令：D.S SD:0X60000304 %LE %LONG 1；D.S SD:0X60000100 %LE %LONG 0x2。0X60000304&nbsp; 即 page read指令。</span></span></li><li><span class="name"><span class="innerContentContainer">写入读地址：D.S SD:0X60000300 %LE %LONG 0x0279c00；</span></span></li><li><span class="name"><span class="innerContentContainer">查看FALSH读写状态：0X60000308；</span></span></li><li><span class="name"><span class="innerContentContainer">查看ECC 纠错的位数：0X6000030C。0表示无错误；超过4个字节就无法正确纠正。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>通用调试桩方案</b> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">调试fwk的代码，可以在 PhoneWindowManager.java 的 interceptKeyBeforeQueueing(), 拦截音量上下键。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">C代码打印堆栈 - 内存地址转函数名</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line 是把内存地址转化为代码行的工具。需要符号表。</span></span></li><li><span class="name"><span class="innerContentContainer">用法如下：</span></span></li><li><span class="name"><span class="innerContentContainer">如果想找这行错误：#08 pc 0013b3d5 /system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> (SkPNGImageDecoder::onDecodeSubset(SkBitmap*, SkIRect const&amp;)+604)</span></span></li><li><span class="name"><span class="innerContentContainer">先在符号表目录查找：<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a>。 比如在 ./symbols/system/lib/ 下。</span></span></li><li><span class="name"><span class="innerContentContainer">./bin/x86_64-linux-addr2line -e ./symbols/system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> 0013b3d5</span></span></li><li><span class="name"><span class="innerContentContainer">输出大致为： android/external/skia/src/images/SkImageDecoder_libpng.cpp:907</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">addr2line 的增强版： <a class="contentLink" target="_blank" rel="noreferrer" href="http://stack.py">stack.py</a></span></span><ul><li><span class="name"><span class="innerContentContainer">stack.py 能够把backtrace堆栈一次性对应到代码，也是利用addr2line。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： python stack.py --symbols-dir=[符号变目录] [tombstone文件]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ndk-stack</span></span><ul><li><span class="name"><span class="innerContentContainer">Android NDK 自从版本 r6开始, 提供了一个工具 ndk-stack。这个工具能自动分析 tombstone 文件, 能将崩溃时的调用内存地址和 c++ 代码一行一行对应起来。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： ndk-stack -sym &lt;path&gt; [-dump &lt;path&gt;]</span></span><ul><li><span class="name"><span class="innerContentContainer">dump 参数即 dump 下来的 log 文本文件.</span></span></li><li><span class="name"><span class="innerContentContainer">sym 参数即符号表。就是android项目目录下，编译成功之后，obj目录下的文件（android系统源码o 中带有符号信息的文件）。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>硬件基本速度指标</b>  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">执行一条指令：1 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从L1 cache中读出一个字：2 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从内存中读一个字：10 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘连续位置取一个字：200 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘任意位置取一个字：8000,000 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">双通道DDR4内存: 30GB/s</span></span></li><li><span class="name"><span class="innerContentContainer">PCIe SSD：3600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SATA SSD：600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">机械硬盘：200MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡：读写速度差异大，主流大约是读100MB/s, 写30MB/s.</span></span></li><li><span class="name"><span class="innerContentContainer">Nor FLASH 和 Nand FLASH 的速度对比</span></span><ul><li><span class="name"><span class="innerContentContainer">以美光（Micron）的NAND和NOR对比, 速度数据如下:</span></span></li><li><span class="name"><span class="innerContentContainer">读: Nor: 41MB/s;   Nand: 37MB/s (基本差不多)</span></span></li><li><span class="name"><span class="innerContentContainer">写: Nor: 0.178MB/s;   Nand: 5MB/s (<b>Nand 快了28倍</b>)</span></span></li><li><span class="name"><span class="innerContentContainer">擦一个块的时间: Nor: 750ms;   Nand: 2ms (<b>Nand 快了375倍</b>)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>性能问题-分析  <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">性能问题, 首先要找到参照物. 和谁对比慢? 参照物的合理性在哪里?</span></span></li><li><span class="name"><span class="innerContentContainer">其次, 要找对目标. 性能问题没有尽头, 不可能无限优化下去. 比如: 华为应用启动速度目标：500ms，从点击图标到 activity ouResume的时间。</span></span></li><li><span class="name"><span class="innerContentContainer">基本做法是: 主流程砍几刀, 分别打点, 找出最耗时的操作, 确认哪些步骤水分最大，谁在等待、在等谁. 继续这个动作, 逐步深入.</span></span></li><li><span class="name"><span class="innerContentContainer">Android应用性能问题, 主要看丢帧.</span></span></li><li><span class="name"><span class="innerContentContainer">打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>android过度绘制 (overdraw)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">过度绘制指屏幕的某个像素在同一帧的时间内会绘制多次. 这是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用.</span></span></li><li><span class="name"><span class="innerContentContainer">android系统设计思路就是递归, 无论是底层, 还是上层, 都喜欢用递归来解决问题. 好处是用很小的投入就能推动了庞大的系统; 坏处是层次太多, 太多无效调用, 系统卡顿.</span></span></li><li><span class="name"><span class="innerContentContainer">造成过度绘制的原因:    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">布局存在重叠的部分;</span></span></li><li><span class="name"><span class="innerContentContainer">存在非必须的重叠背景;</span></span></li><li><span class="name"><span class="innerContentContainer">不可见的UI元素也在刷新界面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">检查方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">开发者选项中有"调试GPU过度绘制", 打开它, 然后在应用界面上会显示各种颜色, 其中:</span></span></li><li><span class="name"><span class="innerContentContainer">没有颜色: 仅绘制1次.</span></span></li><li><span class="name"><span class="innerContentContainer">蓝色: 绘制2次 (可接受)</span></span></li><li><span class="name"><span class="innerContentContainer">绿: 绘制3次</span></span></li><li><span class="name"><span class="innerContentContainer">浅红: 绘制4次. 小块也可接受</span></span></li><li><span class="name"><span class="innerContentContainer">深红: 绘制5次或以上. 这种需要修复.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">频繁gc(内存回收)的标准</span></span><ul><li><span class="name"><span class="innerContentContainer">gc分为young gc 和 full gc两种。</span></span></li><li><span class="name"><span class="innerContentContainer">young gc 在4秒一次以上，pause 小于20ms，耗时小于400ms，算不频繁。</span></span></li><li><span class="name"><span class="innerContentContainer">full gc 越少越好，因为造成pause时间会达到秒级。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">oprofile： linux性能监控工具</span></span><ul><li><span class="name"><span class="innerContentContainer">特点是小巧，对运行影响小。android有一个简化的实现。</span></span></li><li><span class="name"><span class="innerContentContainer">oprofile使用方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">先打开宏：CONFIG_OPROFILE=Y，编译系统生成boot.img，下载到手机侧。</span></span></li><li><span class="name"><span class="innerContentContainer">用adb使能功能：opcontrol 等工具，抓取手机数据；</span></span></li><li><span class="name"><span class="innerContentContainer">然后将/data/oprofile/ 目录下的数据pull 回pc ；</span></span></li><li><span class="name"><span class="innerContentContainer">使用PC工具:opimport、opreport等进行分析。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码位置: </span></span><ul><li><span class="name"><span class="innerContentContainer">手机侧：/external/oprofile，负责收集数据；</span></span></li><li><span class="name"><span class="innerContentContainer">pc-linux侧，/prebuild/linux_x86/oprofile，负责分析数据。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU提频 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">提频也叫CPU boost。</span></span></li><li><span class="name"><span class="innerContentContainer">CPU分大小核，一般情况下，应用线程会跑在小核上。</span></span></li><li><span class="name"><span class="innerContentContainer">如果性能不够，可以将线程提频，即强制让它运行到大核上。</span></span></li><li><span class="name"><span class="innerContentContainer">查看当前CPU频率的adb命令</span></span><ul><li><span class="name"><span class="innerContentContainer">cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies</span></span></li><li><span class="name"><span class="innerContentContainer">显示的最后一个数字即是CPU速率，如 1152000即1.2G。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">是否提频，在systrace中搜 hypnus.</span></span></li><li><span class="name"><span class="innerContentContainer">动态调整cpu速率的驱动接口</span></span><ul><li><span class="name"><span class="innerContentContainer">申请提高CPU速率：clk_regime_register_for_cpu_resource()</span></span><ul><li><span class="name"><span class="innerContentContainer">由task调用，只有部分task有权利。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">申请恢复CPU速率: clk_regime_deregister_for_cpu_resource()</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>拍照速度优化 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText">问题性能</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">拍照性能优化看5个点: 拍照开始的回调, 缩略图回帧的回调, 拍照回帧, 后期处理的回调, 保存文件的回调.</span></span></li><li><span class="name"><span class="innerContentContainer">拍照性能优化: 先显示后处理, 在缩略图没有存储时候提前显示缩略图. 给用户快的感觉.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">性能问题-优化 <span class="contentTag" title="Filter #问题性能">#<span class="contentTagText"><b>问题</b>性能</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>界面刷新速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">setAlpha() 要特别小心. 因为如果界面上有多个Alpha值, 绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作. </span></span></li><li><span class="name"><span class="innerContentContainer">减少页面 layout布局层级.</span></span></li><li><span class="name"><span class="innerContentContainer">减少过度绘制.   --参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/5d3ed8a3ec39">https://workflowy.com/#/5d3ed8a3ec39</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>如何解决过度绘制?  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?</span></span></li><li><span class="name"><span class="innerContentContainer">1. 合理选择控件容器</span></span><ul><li><span class="name"><span class="innerContentContainer">表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</span></span></li><li><span class="name"><span class="innerContentContainer">从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 去掉window的默认背景</span></span><ul><li><span class="name"><span class="innerContentContainer">使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者写入背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</span></span></li><li><span class="name"><span class="innerContentContainer">去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);</span></span></li><li><span class="name"><span class="innerContentContainer">或者在theme中添加 android:windowbackground="null"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 去掉其他不必要的背景</span></span><ul><li><span class="name"><span class="innerContentContainer">有时候为了方便会先给Layout写入一个整体的背景，再给子View写入背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别写入背景来减少重绘。</span></span></li><li><span class="name"><span class="innerContentContainer">如果采用的是 selector的背景，将normal状态的color 写入 “@android:color/transparent",也同样可以解决问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. ClipRect &amp; QuickReject</span></span><ul><li><span class="name"><span class="innerContentContainer">为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</span></span></li><li><span class="name"><span class="innerContentContainer">这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 使用ViewStub</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewStub是个什么东西？一句话总结：高效占位符。</span></span></li><li><span class="name"><span class="innerContentContainer">我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被写入属性。也就是说，会耗费内存等资源。</span></span></li><li><span class="name"><span class="innerContentContainer">推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</span></span></li><li><span class="name"><span class="innerContentContainer">想加载布局时，可以使用下面其中一种方法：</span></span></li><li><span class="name"><span class="innerContentContainer">((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);</span></span></li><li><span class="name"><span class="innerContentContainer">View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 使用Merge标签</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种情况下我们可以使用Merge标签来做容器控件。</span></span></li><li><span class="name"><span class="innerContentContainer">第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">Merge只能作为XML布局的根标签使用，当Inflate以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 善用draw9patch</span></span><ul><li><span class="name"><span class="innerContentContainer">你肯定遇到过这种需求，通常在ImageView后写入一张背景图，露出边框便完美解决问题，此时这个ImageView，写入了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分写入为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分写入成透明，也不会减少这次overdraw。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 慎用Alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一定做Alpha转化的话，可以采用缓存的方式。</span></span><ul><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_HARDWARE);</span></span></li><li><span class="name"><span class="innerContentContainer">doSmoeThing();</span></span></li><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_NONE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 避免“OverDesign”</span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难"，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">首先, 去掉非必要的步骤, 或者无用的步骤；</span></span></li><li><span class="name"><span class="innerContentContainer">合并步骤，批量处理；</span></span></li><li><span class="name"><span class="innerContentContainer">预处理；预读. <b>用户感知的动作</b>, 要提前准备数据, 必要时可读入无效数据, 冗余数据.</span></span></li><li><span class="name"><span class="innerContentContainer">按需处理。<b>用户无感知的动作</b>放在后面处理. 延迟读, 延迟写。</span></span></li><li><span class="name"><span class="innerContentContainer">大流程搞成多线程的, 串行改并行, 往往有奇效.</span></span></li><li><span class="name"><span class="innerContentContainer">双buffer，或多buffer ，保证并发；</span></span></li><li><span class="name"><span class="innerContentContainer">更大的 buffer. 读写buffer 超过 64K 就价值不大了; 复杂计算buffer超过一帧就价值不大了.</span></span></li><li><span class="name"><span class="innerContentContainer">同一个处理, 底层和应用都可以做, 那就放在底层做. </span></span></li></ul></li></ul>
  </body>
</html>