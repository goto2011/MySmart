<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><b>07-</b>Binder-Broadcast</span><ul><li><span class="name">Binder是Android系统中的进程间通讯方式之一. 也可用于进程内通讯.</span></li><li><span class="name">IPC传统上有如下方式:</span><ul><li><span class="name">socket: 通用接口, 传输效率低, 多用于跨网络或本机的低速通讯.</span></li><li><span class="name">消息队列和管道采取存储-转发方式, 至少需要两次拷贝.</span></li><li><span class="name">共享内存无需拷贝, 但是控制复杂, 难以使用和扩展.</span></li></ul></li><li><span class="name">传统IPC的缺点: 主要是没有安全机制, 无法获得访问线程的可靠的UID/PID, 无法鉴别对方身份. 而且传统IPC访问接入点是开放的, 无法建立私有通道.</span></li><li><span class="name">Binder的优势是:</span><ul><li><span class="name">性能高(数据只拷贝1次, 消息队列和管道至少两次).</span></li><li><span class="name">安全(添加UID/PID, 并支持匿名Binder).</span></li><li><span class="name">和共享内存比, 控制简单. </span></li></ul></li><li><span class="name">Binder 3要素</span><ul><li><span class="name">提供业务能力的server; server 提供的访问接入点; 比如: ip地址+端口号</span></li><li><span class="name">使用业务的client; client 具有探测访问接入点的能力;</span></li><li><span class="name">双方的通讯协议. IBinder的扩展类. </span></li></ul></li><li><span class="name">Binder的后台实体</span><ul><li><span class="name">Binder驱动: 位于核心态. </span><ul><li><span class="name">设备节点是 /dev/Binder, 主要通过 ioctl() 接口对上提供能力.  </span></li><li><span class="name">代码在 drivers/misc/binder.c</span></li></ul></li><li><span class="name">ServiceManager (SMgr)</span><ul><li><span class="name">它的功能类似于互联网的域名服务器DNS, 作用是将字符串格式的Binder名字转化为Client中对Binder server的应用, 以完成寻址.</span></li></ul></li></ul></li><li><span class="name">通讯过程</span><ul><li><span class="name">先定义一个抽象接口类封装 server 的所有功能, 其中包含一系列纯虚函数, 待server和client分别实现. </span></li><li><span class="name">server 创建Binder实体, 并命名; 然后定义一个抽象类来处理client的Binder请求, 其中最重要的是函数是 onTransact(). 它负责完成逻辑分发. </span></li><li><span class="name">server 向SMgr 注册自己.</span></li><li><span class="name">SMgr 向 Binder驱动注册该server.</span></li><li><span class="name">Binder驱动为这个Binder创建位于内核的实体节点, 以及SMgr对实体节点的引用(对驱动而言, 引用就是0,1,2,...这样的整数, 相当于是函数的序号. 所以server和client要事先约定好函数顺序). 并把这些信息返回给SMgr.</span></li><li><span class="name">SMgr收到信息后, 把名称和引用填入查找表. </span></li><li><span class="name">Client向SMgr查询server是否存在; </span></li><li><span class="name">Client调用Binder方法, 获取对Binder实体的引用; </span></li><li><span class="name">Client调用各接口, </span></li></ul></li><li><span class="name">这里有个问题, 系统第一次binder调用, server 如何和 SMgr 通讯呢? 此时Binder还没有定义.</span><ul><li><span class="name">此时, SMgr是server, 而各业务server是client. 它们之间的Binder已经由系统定义好了. 当一个进程建立Binder时, 使用 BINDER_SET_CONTEXT_MGR 来发起和SMgr的通讯, 完成注册自己. </span></li><li><span class="name">这个Binder的引用固定为0, 不需要寻址.</span></li></ul></li><li><span class="name">匿名Binder</span><ul><li><span class="name">不向SMgr注册名字的Binder即位匿名Binder.</span></li><li><span class="name">其通讯方式为通过已经建立的Binder连接将新的Binder实体传递给client. 它要求server和client之间至少已经存在了一个实名Binder.</span></li><li><span class="name">匿名Binder无法被第三方破解, 比较安全.</span></li></ul></li><li><span class="name">通讯过程(L2)</span><ul><li><span class="name">一般采用proxy模式.</span></li><li><span class="name">server/client/Binder驱动, 都使用 binder_tansaction_data 结构来封装信息. 下面的通讯过程必须对照字段来讲解:</span><ul><li><span class="name"><b>code</b>, 整数, Binder方法的句柄.</span></li><li><span class="name"><b>data_buffer</b>, 存放参数.</span></li><li><span class="name"><b>traget</b>, 这个字段比较复杂. 它是一个联合体, 在server侧, 它是 ptr, 指向被调用的Binder对象的地址. 在client端, 它是handle, 指向BinderProxy对象的句柄.</span></li></ul></li><li><span class="name">client端, 确认了server的存在后, 就开始调用其接口来使用其业务能力. 调用命令中, 要调用的函数写入code, 函数参数写入data_buffer, binder引用地址写入 traget.handle.  </span></li><li><span class="name">命令发出后, 如果是同步调用(一般是), client端线程会被挂起, 直到收到 reply.</span></li><li><span class="name">该命令首先发给 Binder驱动, 驱动会根据 traget.handle 往 traget<b>.</b>ptr 字段中填写相应的Binder对象的地址. 并把它转给server. </span></li><li><span class="name">server收到命令后, 取出traget.ptr指针, reinterpret_cast 强转为Binder抽象类, 然后调用它的 onTransact() 方法. 在该方法中根据code调用具体的binder方法.</span></li><li><span class="name">server的执行结果会通过binder驱动返回给 client.</span></li></ul></li><li><span class="name">通讯过程(L3)</span><ul><li><span class="name">server端代码</span><ul><li><span class="name">Class myService extends Binder {</span><ul><li><span class="name">protected boolean OnTransact (int code, Parcel data, Parcel reply, int flags) throws RemoteException {...}</span></li></ul></li><li><span class="name">关键是实现OnTransact(), 根据code实现逻辑分发.</span></li></ul></li><li><span class="name">Client端代码</span><ul><li><span class="name">IBinder myBinder = getService("...");   // 一般针对系统service</span></li><li><span class="name">myBinder.transact(code, data, reply, 0);    // 执行完这一步, 线程会挂起</span></li><li><span class="name">reply.readException();</span></li></ul></li></ul></li><li><span class="name">Binder与service类</span></li><li><span class="name">Binder与intent</span></li><li><span class="name">Binder和AIDL</span><ul><li><span class="name">AIDL相当于Binder脚本.</span></li></ul></li></ul>
  </body>
</html>