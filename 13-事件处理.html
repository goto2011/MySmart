<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">11-事件处理</span></span><ul><li><span class="name"><span class="innerContentContainer">Android的事件处理分为 基于监听的机制, 以及基于回调的机制.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>基于监听的机制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">实现方式有多种: </span></span></li><li><span class="name"><span class="innerContentContainer"> 用匿名内部类, 最常见.</span></span><ul><li><span class="name"><span class="innerContentContainer">最常用的一种:直接 setXxxListener后, 重写里面的方法即可.</span></span></li><li><span class="name"><span class="innerContentContainer">使用场景: 匿名类临时使用一次, 复用性不高. 匿名类最大的好处是免得为取名字而费脑筋.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btnshow;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow = (Button) findViewById(R.id.btnshow);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow.<b>setOnClickListener</b>(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">//重写点击事件的处理方法onClick()</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">//显示Toast信息</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "你点击了按钮", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">用内部类, 比较常见.</span></span><ul><li><span class="name"><span class="innerContentContainer">对监听类进行命名. </span></span></li><li><span class="name"><span class="innerContentContainer">目的是复用. 如果本activity中的多个控件使用同一个监听器类, 则会节省很多代码.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btnshow;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow = (Button) findViewById(R.id.btnshow);</span></span></li><li><span class="name"><span class="innerContentContainer">//直接new一个内部类对象作为参数</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow.<b>setOnClickListener</b>(new BtnClickListener());</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法</span></span></li><li><span class="name"><span class="innerContentContainer">class <b>BtnClickListener </b>implements View.OnClickListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">使用外部类</span></span><ul><li><span class="name"><span class="innerContentContainer">这种形式用的比较少！因为外部类不能直接访问用户界面类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁.</span></span></li><li><span class="name"><span class="innerContentContainer">使用场景是多个activity共用同一个监听器类, 则可以这么用. 但是这样耦合性太高, 不建议.</span></span></li><li><span class="name"><span class="innerContentContainer">将内部类外部化即可, 不累述.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">直接使用Activity作为事件监听器</span></span><ul><li><span class="name"><span class="innerContentContainer">需要让Activity类实现XxxListener事件监听接口, 在Activity中定义重写对应的事件处理器方法.</span></span></li><li><span class="name"><span class="innerContentContainer">// 让Activity方法实现OnClickListener接口</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity implements <b>OnClickListener </b>{</span></span><ul><li><span class="name"><span class="innerContentContainer">private Button btnshow;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow = (Button) findViewById(R.id.btnshow);</span></span></li><li><span class="name"><span class="innerContentContainer">// 直接写个this</span></span></li><li><span class="name"><span class="innerContentContainer">btnshow.<b>setOnClickListener</b>(<b>this</b>);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 重写接口中的抽象方法</span></span></li><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "点击了按钮", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">直接绑定到布局文件</span></span><ul><li><span class="name"><span class="innerContentContainer">就是直接在xml布局文件中对应得Activity中定义一个事件处理方法</span></span></li><li><span class="name"><span class="innerContentContainer">// 布局文件</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">xmlns:tools="http://schemas.android.com/tools"</span></span><ul><li><span class="name"><span class="innerContentContainer">android:id="@+id/LinearLayout1"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:orientation="vertical" &gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;Button</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="按钮"</span></span></li><li><span class="name"><span class="innerContentContainer">// 直接使用函数名</span></span></li><li><span class="name"><span class="innerContentContainer">android:onClick="<b>myclick</b>"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">&lt;/LinearLayout&gt;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 代码</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 自定义一个方法,传入一个view组件作为参数</span></span></li><li><span class="name"><span class="innerContentContainer">public void <b>myclick</b>(View source) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>基于回调的机制  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #高级面试题">#<span class="contentTagText">高级面试题</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">主要使用场景是自定义view.</span></span></li><li><span class="name"><span class="innerContentContainer">当用户在GUI组件上激发某个事件时, 组件有自己特定的方法会负责处理该事件. 通常用法:继承基本的GUI组件,重写该组件的事件处理方法,即自定义view.</span></span></li><li><span class="name"><span class="innerContentContainer">注意: 在xml布局中使用自定义的view时,需要使用"全限定类名".</span></span></li><li><span class="name"><span class="innerContentContainer">常见的回调方法有:</span></span><ul><li><span class="name"><span class="innerContentContainer">在该组件上触发屏幕事件: boolean&nbsp;<b>onTouchEvent</b>(MotionEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">在该组件上按下某个按钮时: boolean&nbsp;<b>onKeyDown</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">松开组件上的某个按钮时: boolean&nbsp;<b>onKeyUp</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">长按组件某个按钮时: boolean&nbsp;<b>onKeyLongPress</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">键盘快捷键事件发生: boolean&nbsp;<b>onKeyShortcut</b>(int keyCode,KeyEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">在组件上触发轨迹球屏事件: boolean&nbsp;onTrackballEvent(MotionEvent event);</span></span></li><li><span class="name"><span class="innerContentContainer">当组件的焦点发生改变,和前面的6个不同,这个方法只能够在View中重写哦！ protected void&nbsp;<b>onFocusChanged</b>(boolean gainFocus, int direction, Rect previously FocusedRect)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">自定义view使用事件回调的例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">// 布局</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</span></span><ul><li><span class="name"><span class="innerContentContainer">xmlns:tools="http://schemas.android.com/tools"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_width="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="match_parent"</span></span></li><li><span class="name"><span class="innerContentContainer">tools:context=".MyActivity"&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">&lt;example.jay.com.mybutton.MyButton</span></span><ul><li><span class="name"><span class="innerContentContainer">android:layout_width="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:layout_height="wrap_content"</span></span></li><li><span class="name"><span class="innerContentContainer">android:text="按钮"/&gt;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">// MyButton.java</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyButton extends Button{</span></span><ul><li><span class="name"><span class="innerContentContainer">private static String TAG = "呵呵";</span></span></li><li><span class="name"><span class="innerContentContainer">public MyButton(Context context, AttributeSet attrs) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super(context, attrs);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//重写键盘按下触发的事件</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onKeyDown(int keyCode, KeyEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onKeyDown(keyCode,event);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG, "onKeyDown方法被调用");</span></span></li><li><span class="name"><span class="innerContentContainer"><b>return true;</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//重写弹起键盘触发的事件</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onKeyUp(int keyCode, KeyEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onKeyUp(keyCode,event);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onKeyUp方法被调用");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//组件被触摸了</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouchEvent(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onTouchEvent(event);</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i(TAG,"onTouchEvent方法被调用");</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>冒泡事件传播</b></span></span><ul><li><span class="name"><span class="innerContentContainer">这个概念非常关键, 但是理解有难度. 注意好好掌握. </span></span></li><li><span class="name"><span class="innerContentContainer">事件传播的顺序:</span></span><ul><li><span class="name"><span class="innerContentContainer">触发组件绑定的事件监听器</span></span></li><li><span class="name"><span class="innerContentContainer">触发组件提供的回调;</span></span></li><li><span class="name"><span class="innerContentContainer">传播到父view, 也是先事件监听器, 后回调;</span></span></li><li><span class="name"><span class="innerContentContainer">传播到组件所在的activity.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">这个链条的每个方法的返回值都是 Boolean, 用于表示该事件是否处理完了. 如果返回 True, 则表示处理完了. 如果返回 False, 则会继续传递.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">复杂事件处理: OnTouchListener, 包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">onTouch(View v, MotionEvent event):这里面的参数依次是触发触摸事件的组件,触碰事件event 封装了触发事件的详细信息，同样包括事件的类型、触发时间等信息。比如event.getX(),event.getY()</span></span></li><li><span class="name"><span class="innerContentContainer">我们也可以对触摸的动作类型进行判断,使用event.getAction( )再进行判断;如:</span></span></li><li><span class="name"><span class="innerContentContainer">event.getAction == MotionEvent.ACTION_DOWN：按下事件</span></span></li><li><span class="name"><span class="innerContentContainer">event.getAction == MotionEvent.ACTION_MOVE:移动事件</span></span></li><li><span class="name"><span class="innerContentContainer">event.getAction == MotionEvent.ACTION_UP:弹起事件</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">public class MyView extends View{</span></span><ul><li><span class="name"><span class="innerContentContainer">public float X = 50;</span></span></li><li><span class="name"><span class="innerContentContainer">public float Y = 50;</span></span></li><li><span class="name"><span class="innerContentContainer">//创建画笔</span></span></li><li><span class="name"><span class="innerContentContainer">Paint paint = new Paint();</span></span></li><li><span class="name"><span class="innerContentContainer">public MyView(Context context,AttributeSet set)</span></span></li><li><span class="name"><span class="innerContentContainer">{</span></span><ul><li><span class="name"><span class="innerContentContainer">super(context,set);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onDraw(Canvas canvas) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onDraw(canvas);</span></span></li><li><span class="name"><span class="innerContentContainer">paint.setColor(Color.BLUE);</span></span></li><li><span class="name"><span class="innerContentContainer">canvas.drawCircle(X,Y,30,paint);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouchEvent(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">this.X = event.getX();</span></span></li><li><span class="name"><span class="innerContentContainer">this.Y = event.getY();</span></span></li><li><span class="name"><span class="innerContentContainer">//通知组件进行重绘</span></span></li><li><span class="name"><span class="innerContentContainer">this.invalidate();</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">多点触碰</span></span><ul><li><span class="name"><span class="innerContentContainer">多点触碰就是多个手指在屏幕上进行操作，用的最多的估计是放大缩功能吧，比如很多的图片浏览器都支持缩放！理论上Android系统本身可以处理多达256个手指的触摸，当然这取决于手机硬件的支持.</span></span></li><li><span class="name"><span class="innerContentContainer">前面两点都有用到 MotionEvent，可根据event.getAction() &amp; MotionEvent.ACTION_MASK 来判断是哪种操作, 包括按下, 抬起, 移动.</span></span></li><li><span class="name"><span class="innerContentContainer">除了上面介绍的三种单点操作外，还有两个多点专用的操作：</span></span><ul><li><span class="name"><span class="innerContentContainer">MotionEvent.ACTION_POINTER_DOWN:当屏幕上已经有一个点被按住，此时再按下其他点时触发。</span></span></li><li><span class="name"><span class="innerContentContainer">MotionEvent.ACTION_POINTER_UP:当屏幕上有多个点被按住，松开其中一个点时触发（即非最后一个点被放开时）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">事件上报流程:</span></span><ul><li><span class="name"><span class="innerContentContainer">当我们一个手指触摸屏幕 --&gt; 触发ACTION_DOWN事件</span></span></li><li><span class="name"><span class="innerContentContainer">接着有另一个手指也触摸屏幕 --&gt; 触发ACTION_POINTER_DOWN事件,如果还有其他手指触摸，继续触发</span></span></li><li><span class="name"><span class="innerContentContainer">有一个手指离开屏幕 --&gt; 触发ACTION_POINTER_UP事件，继续有手指离开，继续触发</span></span></li><li><span class="name"><span class="innerContentContainer">当最后一个手指离开屏幕 --&gt; 触发ACTION_UP事件</span></span></li><li><span class="name"><span class="innerContentContainer">而且在整个过程中，ACTION_MOVE事件会一直不停地被触发.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">可以通过 event.getX(int)或者 event.getY(int)来获得不同触摸点的位置： 比如 event.getX(0)可以获得第一个接触点的X坐标，event.getX(1)获得第二个接触点的X坐标这样.</span></span></li><li><span class="name"><span class="innerContentContainer">可以通过 MotionEvent.getPointerCount()方法判断当前有多少个手指在触摸. 例如：</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity implements OnTouchListener {</span></span><ul><li><span class="name"><span class="innerContentContainer">private ImageView img_test;</span></span></li><li><span class="name"><span class="innerContentContainer">// 縮放控制</span></span></li><li><span class="name"><span class="innerContentContainer">private Matrix matrix = new Matrix();</span></span></li><li><span class="name"><span class="innerContentContainer">private Matrix savedMatrix = new Matrix();</span></span></li><li><span class="name"><span class="innerContentContainer">// 不同状态的表示：</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int NONE = 0;</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int DRAG = 1;</span></span></li><li><span class="name"><span class="innerContentContainer">private static final int ZOOM = 2;</span></span></li><li><span class="name"><span class="innerContentContainer">private int mode = NONE;</span></span></li><li><span class="name"><span class="innerContentContainer">// 定义第一个按下的点，两只接触点的重点，以及出事的两指按下的距离：</span></span></li><li><span class="name"><span class="innerContentContainer">private PointF startPoint = new PointF();</span></span></li><li><span class="name"><span class="innerContentContainer">private PointF midPoint = new PointF();</span></span></li><li><span class="name"><span class="innerContentContainer">private float oriDis = 1f;</span></span></li><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span><ul><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">img_test = (ImageView) this.findViewById(R.id.img_test);</span></span></li><li><span class="name"><span class="innerContentContainer">img_test.setOnTouchListener(this);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public boolean onTouch(View v, MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">ImageView view = (ImageView) v;</span></span><ul><li><span class="name"><span class="innerContentContainer">switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {</span></span></li><li><span class="name"><span class="innerContentContainer">// 单指</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_DOWN:</span></span><ul><li><span class="name"><span class="innerContentContainer">matrix.set(view.getImageMatrix());</span></span></li><li><span class="name"><span class="innerContentContainer">savedMatrix.set(matrix);</span></span></li><li><span class="name"><span class="innerContentContainer">startPoint.set(event.getX(), event.getY());</span></span></li><li><span class="name"><span class="innerContentContainer">mode = DRAG;</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 双指</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_POINTER_DOWN:</span></span><ul><li><span class="name"><span class="innerContentContainer">oriDis = distance(event);</span></span></li><li><span class="name"><span class="innerContentContainer">if (oriDis &gt; 10f) {</span></span><ul><li><span class="name"><span class="innerContentContainer">savedMatrix.set(matrix);</span></span></li><li><span class="name"><span class="innerContentContainer">midPoint = middle(event);</span></span></li><li><span class="name"><span class="innerContentContainer">mode = ZOOM;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 手指放开</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_UP:</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_POINTER_UP:</span></span><ul><li><span class="name"><span class="innerContentContainer">mode = NONE;</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">// 单指滑动事件</span></span></li><li><span class="name"><span class="innerContentContainer">case MotionEvent.ACTION_MOVE:</span></span><ul><li><span class="name"><span class="innerContentContainer">if (mode == DRAG) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 是一个手指拖动</span></span></li><li><span class="name"><span class="innerContentContainer">matrix.set(savedMatrix);</span></span></li><li><span class="name"><span class="innerContentContainer">matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">} else if (mode == ZOOM) {</span></span><ul><li><span class="name"><span class="innerContentContainer">// 两个手指滑动</span></span></li><li><span class="name"><span class="innerContentContainer">float newDist = distance(event);</span></span></li><li><span class="name"><span class="innerContentContainer">if (newDist &gt; 10f) {</span></span><ul><li><span class="name"><span class="innerContentContainer">matrix.set(savedMatrix);</span></span></li><li><span class="name"><span class="innerContentContainer">float scale = newDist / oriDis;</span></span></li><li><span class="name"><span class="innerContentContainer">matrix.postScale(scale, scale, midPoint.x, midPoint.y);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">break;</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 设置ImageView的Matrix</span></span></li><li><span class="name"><span class="innerContentContainer">view.setImageMatrix(matrix);</span></span></li><li><span class="name"><span class="innerContentContainer">return true;</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 计算两个触摸点之间的距离</span></span></li><li><span class="name"><span class="innerContentContainer">private float distance(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">float x = event.getX(0) - event.getX(1);</span></span><ul><li><span class="name"><span class="innerContentContainer">float y = event.getY(0) - event.getY(1);</span></span></li><li><span class="name"><span class="innerContentContainer">return FloatMath.sqrt(x * x + y * y);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">// 计算两个触摸点的中点</span></span></li><li><span class="name"><span class="innerContentContainer">private PointF middle(MotionEvent event) {</span></span><ul><li><span class="name"><span class="innerContentContainer">float x = event.getX(0) + event.getX(1);</span></span><ul><li><span class="name"><span class="innerContentContainer">float y = event.getY(0) + event.getY(1);</span></span></li><li><span class="name"><span class="innerContentContainer">return new PointF(x / 2, y / 2);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">响应系统设置的事件(Configuration类)</span></span><ul><li><span class="name"><span class="innerContentContainer">Configuration类是用来描述手机设备的配置信息的，比如屏幕方向，触摸屏的触摸方式等，代码在 frameworks/base/core/java/android/content/res/Configuration.java.</span></span></li><li><span class="name"><span class="innerContentContainer">方法列表</span></span><ul><li><span class="name"><span class="innerContentContainer">densityDpi：屏幕密度</span></span></li><li><span class="name"><span class="innerContentContainer">fontScale：当前用户设置的字体的缩放因子</span></span></li><li><span class="name"><span class="innerContentContainer">hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：</span></span><ul><li><span class="name"><span class="innerContentContainer">HARDKEYBOARDHIDDEN_NO,  十六进制的0</span></span></li><li><span class="name"><span class="innerContentContainer">HARDKEYBOARDHIDDEN_YES，十六进制的1</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">keyboard：获取当前关联额键盘类型：该属性的返回值：KEYBOARD_12KEY（只有12个键的小键盘）、KEYBOARD_NOKEYS、KEYBOARD_QWERTY（普通键盘）</span></span></li><li><span class="name"><span class="innerContentContainer">keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。</span></span></li><li><span class="name"><span class="innerContentContainer">locale：获取用户当前的语言环境</span></span></li><li><span class="name"><span class="innerContentContainer">mcc：获取移动信号的国家码</span></span></li><li><span class="name"><span class="innerContentContainer">mnc：获取移动信号的网络码</span></span></li><li><span class="name"><span class="innerContentContainer">ps:国家代码和网络代码共同确定当前手机网络运营商</span></span></li><li><span class="name"><span class="innerContentContainer">navigation：判断系统上方向导航设备的类型。该属性的返回值：NAVIGATION_NONAV（无导航）、 NAVIGATION_DPAD(DPAD导航）NAVIGATION_TRACKBALL（轨迹球导航）、NAVIGATION_WHEEL（滚轮导航）</span></span></li><li><span class="name"><span class="innerContentContainer">orientation：获取系统屏幕的方向。该属性的返回值：ORIENTATION_LANDSCAPE（横向屏幕）、ORIENTATION_PORTRAIT（竖向屏幕）</span></span></li><li><span class="name"><span class="innerContentContainer">screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示</span></span></li><li><span class="name"><span class="innerContentContainer">touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_NOTOUCH（无触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_STYLUS（触摸笔式触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_FINGER（接收手指的触摸屏）</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">// 在AndroidManifest.xml添加下述内容</span></span></li><li><span class="name"><span class="innerContentContainer">权限:&nbsp;&lt; uses-permission android:name="android.permission.CHANGE_CONFIGURATION" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">在&lt; activity标签中添加:android:configChanges="orientation"&nbsp;将targetSdkVersion改为12以上的,12也可以.</span></span></li><li><span class="name"><span class="innerContentContainer">public class MainActivity extends Activity {</span></span><ul><li><span class="name"><span class="innerContentContainer">protected void onCreate(Bundle savedInstanceState) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onCreate(savedInstanceState);</span></span></li><li><span class="name"><span class="innerContentContainer">setContentView(R.layout.activity_main);</span></span></li><li><span class="name"><span class="innerContentContainer">Button btn = (Button) findViewById(R.id.btncahange);</span></span></li><li><span class="name"><span class="innerContentContainer">btn.setOnClickListener(new OnClickListener() {</span></span><ul><li><span class="name"><span class="innerContentContainer">public void onClick(View v) {</span></span><ul><li><span class="name"><span class="innerContentContainer">Configuration config = getResources().getConfiguration();</span></span></li><li><span class="name"><span class="innerContentContainer">//如果是横屏的话切换成竖屏</span></span></li><li><span class="name"><span class="innerContentContainer">if(config.orientation == Configuration.ORIENTATION_LANDSCAPE) {</span></span><ul><li><span class="name"><span class="innerContentContainer">MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">//如果竖屏的话切换成横屏</span></span></li><li><span class="name"><span class="innerContentContainer">if(config.orientation == Configuration.ORIENTATION_PORTRAIT) {</span></span><ul><li><span class="name"><span class="innerContentContainer">MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">});</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li><li><span class="name"><span class="innerContentContainer">public void onConfigurationChanged(Configuration newConfig) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onConfigurationChanged(newConfig);</span></span></li><li><span class="name"><span class="innerContentContainer">String screen = newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE?"横屏":"竖屏";</span></span></li><li><span class="name"><span class="innerContentContainer">Toast.makeText(MainActivity.this, "系统屏幕方向发生改变 \n 修改后的方向为" + screen, Toast.LENGTH_SHORT).show();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Configuration: 系统状态事件</span></span><ul><li><span class="name"><span class="innerContentContainer">Configuration类是用来描述手机设备的配置信息的，比如屏幕方向， 触摸屏的触摸方式等.</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/base/core/java/android/content/res/Configuration.java</span></span></li><li><span class="name"><span class="innerContentContainer">有如下方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">densityDpi：屏幕密度</span></span></li><li><span class="name"><span class="innerContentContainer">fontScale：当前用户设置的字体的缩放比</span></span></li><li><span class="name"><span class="innerContentContainer">hardKeyboardHidden：判断硬键盘是否可见，有两个可选值：HARDKEYBOARDHIDDEN_NO,HARDKEYBOARDHIDDEN_YES，分别是十六进制的0和1</span></span></li><li><span class="name"><span class="innerContentContainer">keyboard：获取当前关联额键盘类型：该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">KEYBOARD_12KEY（只有12个键的小键盘）</span></span></li><li><span class="name"><span class="innerContentContainer">KEYBOARD_NOKEYS (没有键盘)</span></span></li><li><span class="name"><span class="innerContentContainer">KEYBOARD_QWERTY（普通键盘）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">keyboardHidden：该属性返回一个boolean值用于标识当前键盘是否可用。该属性不仅会判断系统的硬件键盘，也会判断系统的软键盘（位于屏幕）。</span></span></li><li><span class="name"><span class="innerContentContainer">locale：获取用户当前的语言环境</span></span></li><li><span class="name"><span class="innerContentContainer">mcc：获取移动信号的国家码</span></span></li><li><span class="name"><span class="innerContentContainer">mnc：获取移动信号的网络码</span></span></li><li><span class="name"><span class="innerContentContainer">ps:国家代码和网络代码共同确定当前手机网络运营商</span></span></li><li><span class="name"><span class="innerContentContainer">navigation：判断系统中方向导航设备的类型 (都已经不支持了)。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">NAVIGATION_NONAV（无导航）</span></span></li><li><span class="name"><span class="innerContentContainer"> NAVIGATION_DPAD (DPAD导航）</span></span></li><li><span class="name"><span class="innerContentContainer">NAVIGATION_TRACKBALL（轨迹球导航）</span></span></li><li><span class="name"><span class="innerContentContainer">NAVIGATION_WHEEL（滚轮导航）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">orientation：获取系统屏幕的方向。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">ORIENTATION_LANDSCAPE（横向屏幕）</span></span></li><li><span class="name"><span class="innerContentContainer">ORIENTATION_PORTRAIT（竖向屏幕）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">screenHeightDp，screenWidthDp：屏幕可用高和宽，用dp表示</span></span></li><li><span class="name"><span class="innerContentContainer">touchscreen：获取系统触摸屏的触摸方式。该属性的返回值：</span></span><ul><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_NOTOUCH（无触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_STYLUS（触摸笔式触摸屏）</span></span></li><li><span class="name"><span class="innerContentContainer">TOUCHSCREEN_FINGER（接收手指的触摸屏）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">例子:</span></span></li><li><span class="name"><span class="innerContentContainer">// 在AndroidManifest.xml中申请权限权限</span></span></li><li><span class="name"><span class="innerContentContainer">&lt; uses-permission android:name="android.permission.CHANGE_CONFIGURATION" /&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">// 监听系统属性变化</span></span></li><li><span class="name"><span class="innerContentContainer">public void onConfigurationChanged(Configuration newConfig) {</span></span><ul><li><span class="name"><span class="innerContentContainer">super.onConfigurationChanged(newConfig);</span></span></li><li><span class="name"><span class="innerContentContainer">String screen = {(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) ? "横屏" : "竖屏");</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">}</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Gestures(手势)</span></span><ul><li><span class="name"><span class="innerContentContainer">在应用中通过手势来操作会大大提升用户体验.</span></span></li><li><span class="name"><span class="innerContentContainer">手势交互的执行顺序</span></span><ul><li><span class="name"><span class="innerContentContainer">1.手指触碰屏幕时，触发MotionEvent事件.</span></span></li><li><span class="name"><span class="innerContentContainer">2.该事件被OnTouchListener监听，可在它的onTouch()方法中获得该MotionEvent对象.</span></span></li><li><span class="name"><span class="innerContentContainer">3.通过GestureDetector转发MotionEvent对象给OnGestureListener.</span></span></li><li><span class="name"><span class="innerContentContainer">4.我们可以通过OnGestureListener获得该对象，然后获取相关信息，以及做相关处理.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GestureListener 提供了下述回调方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。</span></span></li><li><span class="name"><span class="innerContentContainer">抛掷（onFling）： 手指在触摸屏上迅速移动，并松开的动作。</span></span></li><li><span class="name"><span class="innerContentContainer">长按（onLongPress）： 手指按在持续一段时间，并且没有松开。</span></span></li><li><span class="name"><span class="innerContentContainer">滚动（onScroll）： 手指在触摸屏上滑动。</span></span></li><li><span class="name"><span class="innerContentContainer">按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。</span></span></li><li><span class="name"><span class="innerContentContainer">抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">知道了 GestureListener的相关方法后，实现手势检测也很简单，步骤如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">创建GestureDetector对象，创建时需实现GestureListener传入</span></span></li><li><span class="name"><span class="innerContentContainer">将Activity或者特定组件上的TouchEvent的事件交给GestureDetector处理.</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导航栏事件</span></span><ul><li><span class="name"><span class="innerContentContainer">点击home键后, 系统会发出一个 Intent_Action_Close_System_Dialogs 的广播.</span></span></li></ul></li></ul>
  </body>
</html>