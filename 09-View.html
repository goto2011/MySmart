<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name">09-View</span><ul><li><span class="name">Android  View模型</span><ul><li><span class="name">Android 定义屏幕的左上角为坐标原点(0, 0), 向右为x轴, 向下为y轴, 向上为z轴. 都是正数.</span></li><li><span class="name">几个基本单位:</span></li><li><span class="name">dp(dip):&nbsp;device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。</span></li><li><span class="name">px: pixels(像素). 不同设备显示效果相同.</span></li><li><span class="name">pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业.</span></li><li><span class="name">sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。size和dp相同.</span></li><li><span class="name">FPS: 帧数(界面刷新)</span></li></ul></li><li><span class="name">Android的图形界面都是由 View和 ViewGroup以及他们的子类构成的.</span><ul><li><span class="name">View：所有可视化控件的父类,提供组件描绘和时间处理方法.</span></li><li><span class="name">ViewGroup：View类的子类，可以拥有子控件,可以看作是容器.</span></li></ul></li><li><span class="name"><b>6大布局</b></span><ul><li><span class="name">LinearLayout(线性布局)</span><ul><li><span class="name">weight(权重)属性，等比例划分, 非常强大.</span></li><li><span class="name">缺点: 当界面比较复杂的时候，需要嵌套多层的 LinearLayout,这样就会降低UI Render的效率(渲染速度),而且如果是 listview或者 GridView上的 item,效率会更低.</span></li></ul></li><li><span class="name">RelativeLayout(相对布局)  --推荐用这个</span><ul><li><span class="name">优点: 很复杂的界面, 也可以一层搞定.</span></li><li><span class="name">根据父容器定位</span></li><li><span class="name">根据兄弟组件定位</span></li><li><span class="name">margin与padding的区别</span><ul><li><span class="name">margin代表的是偏移,比如 marginleft = "5dp"表示组件离容器左边缘偏移5dp; </span></li><li><span class="name">padding代表的则是填充,而填充的对象针对的是组件中的元素,比如为 TextView 设置paddingleft = "5dp", 是在组件里的元素的左边填充5dp的空间.</span></li><li><span class="name">margin针对的是容器中的组件，而padding针对的是组件中的元素.</span></li></ul></li></ul></li><li><span class="name">TableLayout(表格布局)</span><ul><li><span class="name">如果我们直接往 TableLayout 中添加组件的话,那么这个组件将占满一行.</span></li><li><span class="name">如果我们想一行上有多个组件的话,就要添加一个 TableRow 的容器,把组件都丢到里面.</span></li><li><span class="name">tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定.</span></li><li><span class="name">tablerow的 layout_width 属性, 默认是 fill_parent 的, 设置成其他的值也不会生效. 但是layout_height默认是wrapten-content的,我们却可以自己设置大小.</span></li></ul></li><li><span class="name">FrameLayout(帧布局)</span><ul><li><span class="name">这个布局直接在屏幕上开辟出一块空白的区域,当我们往里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式.</span></li></ul></li><li><span class="name">AbsoluteLayout(绝对布局)  --不要使用这个</span></li><li><span class="name">GridLayout(网格布局)&nbsp;</span><ul><li><span class="name">GridLayout 相当于 TableLayout的升级版, 较之后者更好用. 比如: </span><ul><li><span class="name">可以自己设置布局中组件的排列方式</span></li><li><span class="name">可以自定义网格布局有多少行,多少列</span></li><li><span class="name">可以直接设置组件位于某行某列</span></li><li><span class="name">可以设置组件横跨几行或者几列</span></li></ul></li><li><span class="name">GridLayout是4.0新增的, 低版本sdk如何使用 GridLayout?</span><ul><li><span class="name">只需要导入v7包的gridlayout包即可! v7包一般在sdk下的:sdk\extras\android\support\v7\gridlayout目录下.</span></li><li><span class="name">用的时候,标签却是这样写的:  &lt;android.support.v7.widget.GridLayout&gt;</span></li></ul></li></ul></li></ul></li><li><span class="name">TextView(文本框)</span><ul><li><span class="name"><b>id：</b>为TextView设置一个组件id，根据id，我们可以在Java代码中通过findViewById()的方法获取到该对象，然后进行相关属性的设置，又或者使用RelativeLayout时，参考组件用的也是id！</span></li><li><span class="name"><b>layout_width：</b>组件的宽度，一般写：**wrap_content**或者**match_parent(fill_parent)**，前者是控件显示的内容多大，控件就多大，而后者会填满该控件所在的父容器；当然也可以设置成特定的大小，比如我这里为了显示效果，设置成了200dp。</span></li><li><span class="name"><b>layout_height：</b>组件的宽度，内容同上。</span></li><li><span class="name"><b>gravity：</b>设置控件中内容的对齐方向，TextView中是文字，ImageView中是图片等等。</span></li><li><span class="name"><b>text：</b>设置显示的文本内容，一般我们是把字符串写到string.xml文件中，然后通过@String/xxx取得对应的字符串内容的.</span></li><li><span class="name"><b>textColor：</b>设置字体颜色，同上，通过 colors.xml资源来引用，别直接这样写！</span></li><li><span class="name"><b>textStyle：</b>设置字体风格，三个可选值：normal(无效果)，bold(加粗)，italic(斜体)</span></li><li><span class="name"><b>textSize：</b>字体大小，单位一般是用sp</span></li><li><span class="name"><b>background：</b>控件的背景颜色，可以理解为填充整个控件的颜色，可以是图片.</span></li><li><span class="name">&lt;solid&nbsp;android:color = "xxx"&gt; 这个是设置背景颜色的</span></li><li><span class="name">&lt;stroke&nbsp;android:width = "xdp" android:color="xxx"&gt; 这个是设置边框的粗细,以及边框颜色的</span></li><li><span class="name">&lt;padding&nbsp;androidLbottom = "xdp"...&gt; 这个是设置边距的</span></li><li><span class="name">&lt;corners&nbsp;android:topLeftRadius="10px"...&gt; 这个是设置圆角的</span></li><li><span class="name">&lt;gradient&gt; 这个是设置渐变色的,可选属性有:&nbsp;</span><ul><li><span class="name">startColor:起始颜色</span></li><li><span class="name">endColor:结束颜色</span></li><li><span class="name">centerColor:中间颜色</span></li><li><span class="name">angle:方向角度,等于0时,从左到右,然后逆时针方向转,当 angle = 90度时从下往上</span></li><li><span class="name">type:设置渐变的类型</span></li></ul></li><li><span class="name">&lt;corners   // 设置四个圆角的半径</span><ul><li><span class="name">android:bottomLeftRadius="10px"</span></li><li><span class="name">android:bottomRightRadius="10px"</span></li><li><span class="name">android:topLeftRadius="10px"</span></li><li><span class="name">android:topRightRadius="10px" /&gt;</span></li></ul></li></ul></li><li><span class="name">EditText(输入框)</span><ul><li><span class="name">EditText可以接受用户输入.</span></li><li><span class="name">android:hint="默认提示文本"</span></li><li><span class="name">android:textColorHint="#95A1AA"  // 设置提示文本的颜色</span></li><li><span class="name">android:selectAllOnFocus="true"   // 获得焦点后全选组件内所有文本内容</span></li><li><span class="name">android:inputType="phone"    // 限制 EditText输入类型. 类型相当多, </span></li><li><span class="name">android:maxLines="3"   // 设置最大的行数</span></li><li><span class="name">android:windowSoftInputMode   &nbsp;// Activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题. 这个属性可影响两件事:</span><ul><li><span class="name">当有焦点产生时，软键盘是隐藏还是显示</span></li><li><span class="name">是否减少活动主窗口大小以便腾出空间放软键盘. </span></li><li><span class="name">相关属性较多, 可以同时设多个, 如下:</span></li><li><span class="name">stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置</span></li><li><span class="name">stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示</span></li><li><span class="name">stateHidden：用户选择activity时，软键盘总是被隐藏</span></li><li><span class="name">stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的</span></li><li><span class="name">stateVisible：软键盘通常是可见的</span></li><li><span class="name">stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态</span></li><li><span class="name">adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示</span></li><li><span class="name">adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间</span></li><li><span class="name">adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分</span></li></ul></li></ul></li><li><span class="name">Button(按钮)与ImageButton(图像按钮)</span><ul><li><span class="name">Button是TextView的子类，所以TextView上很多属性也可以应用到Button 上.</span></li><li><span class="name">StateListDrawable是Drawable资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点&nbsp;&lt; selector &gt;，我们只需要将Button的background属性设置为该drawable资源即可轻松实现，按下 按钮时不同的按钮颜色或背景.</span></li><li><span class="name">drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~</span></li><li><span class="name">state_focused:是否获得焦点</span></li><li><span class="name">state_window_focused:是否获得窗口焦点</span></li><li><span class="name">state_enabled:控件是否可用</span></li><li><span class="name">state_checkable:控件可否被勾选, eg:checkbox</span></li><li><span class="name">state_checked:控件是否被勾选</span></li><li><span class="name">state_selected:控件是否被选择,针对有滚轮的情况</span></li><li><span class="name">state_pressed:控件是否被按下</span></li><li><span class="name">state_active:控件是否处于活动状态,eg:slidingTab</span></li><li><span class="name">state_single:控件包含多个子控件时,确定是否只显示一个子控件</span></li><li><span class="name">state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态</span></li><li><span class="name">state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态</span></li><li><span class="name">state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态</span></li></ul></li><li><span class="name">ImageView(图像视图)</span><ul><li><span class="name">ImageView有两个可以设置图片的属性，分别是：src和 background</span><ul><li><span class="name">background通常指的都是背景,而src指的是内容</span></li><li><span class="name">当使用src填入图片时,是按照图片大小直接填充,并不会进行拉伸</span></li><li><span class="name">而使用 background填入图片,则是会根据 ImageView给定的宽度来进行拉伸</span></li></ul></li><li><span class="name">src + background 可以实现融入效果.</span><ul><li><span class="name">找一张透明的png图片 + 设置一个黑色的背景</span></li><li><span class="name">&lt;ImageView</span><ul><li><span class="name">android:layout_width="150dp"</span></li><li><span class="name">android:layout_height="wrap_content"</span></li><li><span class="name">android:src="@drawable/pig"</span></li><li><span class="name">android:background="#6699FF" /&gt;</span></li></ul></li></ul></li><li><span class="name">Java代码中设置 blackground和 src属性</span><ul><li><span class="name">前景(对应src属性): setImageDrawable( );</span></li><li><span class="name">背景(对应background属性): setBackgroundDrawable( );</span></li></ul></li><li><span class="name">adjustViewBounds设置缩放是否保存原图长宽比</span><ul><li><span class="name">ImageView为我们提供了adjustViewBounds属性，用于设置缩放时是否保持原图长宽比！ 单独设置不起作用，需要配合maxWidth和maxHeight属性一起使用！而后面这两个属性 也是需要adjustViewBounds为true才会生效的~</span></li><li><span class="name">android:maxHeight:设置ImageView的最大高度</span></li><li><span class="name">android:maxWidth:设置ImageView的最大宽度</span></li></ul></li><li><span class="name">scaleType设置缩放类型</span><ul><li><span class="name">android:scaleType用于设置显示的图片如何缩放或者移动以适应ImageView的大小 Java代码中可以通过imageView.setScaleType(ImageView.ScaleType.CENTER);来设置~ 可选值如下：</span></li><li><span class="name">fitXY:对图像的横向与纵向进行独立缩放,使得该图片完全适应ImageView,但是图片的横纵比可能会发生改变</span></li><li><span class="name">fitStart:保持纵横比缩放图片,知道较长的边与Image的编程相等,缩放完成后将图片放在ImageView的左上角</span></li><li><span class="name">fitCenter:同上,缩放后放于中间;</span></li><li><span class="name">fitEnd:同上,缩放后放于右下角;</span></li><li><span class="name">center:保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。</span></li><li><span class="name">centerCrop:保持横纵比缩放图片,知道完全覆盖ImageView,可能会出现图片的显示不完全</span></li><li><span class="name">centerInside:保持横纵比缩放图片,直到ImageView能够完全地显示图片</span></li><li><span class="name">matrix:默认值，不改变原图的大小，从ImageView的左上角开始绘制原图， 原图超过ImageView的部分作裁剪处理</span></li></ul></li></ul></li><li><span class="name">RadioButton(单选按钮)&amp;Checkbox(复选框)</span><ul><li><span class="name">&lt;RadioGroup</span><ul><li><span class="name">android:id="@+id/radioGroup"</span></li><li><span class="name">android:layout_width="wrap_content"</span></li><li><span class="name">android:layout_height="wrap_content"</span></li><li><span class="name">android:orientation="horizontal"&gt;</span></li><li><span class="name">&lt;RadioButton</span><ul><li><span class="name">android:id="@+id/btnMan"</span></li><li><span class="name">android:layout_width="wrap_content"</span></li><li><span class="name">android:layout_height="wrap_content"</span></li><li><span class="name">android:text="男"</span></li><li><span class="name">android:checked="true"/&gt;</span></li></ul></li><li><span class="name">&lt;RadioButton</span><ul><li><span class="name">android:id="@+id/btnWoman"</span></li><li><span class="name">android:layout_width="wrap_content"</span></li><li><span class="name">android:layout_height="wrap_content"</span></li><li><span class="name">android:text="女"/&gt;</span></li></ul></li></ul></li><li><span class="name">&lt;/RadioGroup&gt;</span></li><li><span class="name">获得选中的值：</span><ul><li><span class="name">第一种是为RadioButton设置一个事件监听器setOnCheckChangeListener</span><ul><li><span class="name">RadioGroup radgroup = (RadioGroup) findViewById(R.id.radioGroup);</span></li><li><span class="name">radgroup.setOnCheckedChangeListener(new OnCheckedChangeListener() {</span><ul><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void onCheckedChanged(RadioGroup group, int checkedId) {</span><ul><li><span class="name">RadioButton radbtn = (RadioButton) findViewById(checkedId);</span></li><li><span class="name">Toast.makeText(getApplicationContext(), "按钮组值发生改变,你选了" + radbtn.getText(), Toast.LENGTH_LONG).show();</span></li></ul></li><li><span class="name">}</span></li></ul></li><li><span class="name">});</span></li></ul></li><li><span class="name">第二种方法是通过单击其他按钮获取选中单选按钮的值</span><ul><li><span class="name">RadioButton rd = (RadioButton) radgroup.getChildAt(i);</span></li></ul></li><li><span class="name">改变文字与选择框的相对位置</span><ul><li><span class="name">1.&nbsp;android:button="@null"</span></li><li><span class="name">2.&nbsp;android:drawableTop="@android:drawable/btn_radio"</span></li></ul></li><li><span class="name">修改文字与选择框的距离</span><ul><li><span class="name">1. 在XML代码中控制： 使用android:paddingXxx = "xxx" 来控制距离</span></li><li><span class="name">2. 在Java代码中，稍微好一点，动态计算paddingLeft.</span></li></ul></li></ul></li></ul></li><li><span class="name">开关按钮ToggleButton和开关Switch</span><ul><li><span class="name">ToggleButton(开关按钮) 有如下属性:</span></li><li><span class="name">android:disabledAlpha：设置按钮在禁用时的透明度</span></li><li><span class="name">android:textOff：按钮没有被选中时显示的文字</span></li><li><span class="name">android:textOn：按钮被选中时显示的文字 另外，除了这个我们还可以自己写个selector，然后设置下Background属性即可~</span></li><li><span class="name">Switch(开关)</span></li><li><span class="name">android:showText：设置on/off的时候是否显示文字,boolean</span></li><li><span class="name">android:splitTrack：是否设置一个间隙，让滑块与底部图片分隔,boolean</span></li><li><span class="name">android:switchMinWidth：设置开关的最小宽度</span></li><li><span class="name">android:switchPadding：设置滑块内文字的间隔</span></li><li><span class="name">android:switchTextAppearance：设置开关的文字外观，暂时没发现有什么用...</span></li><li><span class="name">android:textOff：按钮没有被选中时显示的文字</span></li><li><span class="name">android:textOn：按钮被选中时显示的文字</span></li><li><span class="name">android:textStyle：文字风格，粗体，斜体写划线那些</span></li><li><span class="name">android:track：底部的图片</span></li><li><span class="name">android:thumb：滑块的图片</span></li><li><span class="name">android:typeface：设置字体，默认支持这三种:sans, serif, monospace</span></li><li><span class="name">还可以使用 其他字体文件(*.ttf)，首先要将字体文件保存在 assets/fonts/目录下，然后在 Java代码中设置：</span><ul><li><span class="name">Typeface typeFace =Typeface.createFromAsset(getAssets(),"fonts/HandmadeTypewriter.ttf"); textView.setTypeface(typeFace);</span></li></ul></li></ul></li><li><span class="name">ProgressBar(进度条)</span><ul><li><span class="name">ProgressBar继承与 View类，直接子类有 AbsSeekBar和 ContentLoadingProgressBar， 其中 AbsSeekBar的子类有 SeekBar和 RatingBar</span></li><li><span class="name">android:max：进度条的最大值</span></li><li><span class="name">android:progress：进度条已完成进度值</span></li><li><span class="name">android:progressDrawable：设置轨道对应的Drawable对象</span></li><li><span class="name">android:indeterminate：如果设置成true，则进度条不精确显示进度</span></li><li><span class="name">android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象</span></li><li><span class="name">android:indeterminateDuration：设置不精确显示进度的持续时间</span></li><li><span class="name">android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置</span></li></ul></li><li><span class="name">SeekBar(拖动条)</span><ul><li><span class="name">android:max="100" //滑动条的最大值</span></li><li><span class="name">android:progress="60" //滑动条的当前值</span></li><li><span class="name">android:secondaryProgress="70" //二级滑动条的进度</span></li><li><span class="name">android:thumb&nbsp;= "@mipmap/sb_icon" //滑块的drawable</span></li><li><span class="name">SeekBar的事件，SeekBar.OnSeekBarChangeListener&nbsp;我们只需重写三个对应的方法：</span><ul><li><span class="name">onProgressChanged：进度发生改变时会触发</span></li><li><span class="name">onStartTrackingTouch：按住SeekBar时会触发</span></li><li><span class="name">onStopTrackingTouch：放开SeekBar时触发</span></li></ul></li></ul></li><li><span class="name">RatingBar(星级评分条)</span><ul><li><span class="name">android:isIndicator：是否用作指示，用户无法更改，默认false</span></li><li><span class="name">android:numStars：显示多少个星星，必须为整数</span></li><li><span class="name">android:rating：默认评分值，必须为浮点数</span></li><li><span class="name">android:stepSize：&nbsp;评分每次增加的值，必须为浮点数</span></li><li><span class="name">除了上面这些，还有两种样式供我们选择咧，但是不建议使用，因为这两种样式都好丑... 他们分别是：</span></li><li><span class="name">style="?android:attr/ratingBarStyleSmall"</span></li><li><span class="name">style="?android:attr/ratingBarStyleIndicator"</span></li><li><span class="name">——事件处理：&nbsp;只需为RatingBar设置OnRatingBarChangeListener事件，然后重写下onRatingChanged()方法即可！</span></li></ul></li><li><span class="name">ScrollView(滚动条)</span><ul><li><span class="name">ScrollView(滚动条)，应该叫它竖直滚动条，对应的另外一个水平方向上的滚动条：HorizontalScrollView.</span></li><li><span class="name">滚动到底部</span><ul><li><span class="name">利用ScrollView给我们提供的:fullScroll()方法：</span></li><li><span class="name">scrollView.fullScroll(ScrollView.FOCUS_DOWN);滚动到底部</span></li><li><span class="name">scrollView.fullScroll(ScrollView.FOCUS_UP);滚动到顶部</span></li><li><span class="name">另外用这玩意的时候要小心异步的玩意，就是addView后，有可能还没有显示完， 如果这个时候直接调用该方法的话，可能会无效，这就需要自己写handler来更新了~</span></li></ul></li><li><span class="name">设置滚动的滑块图片</span><ul><li><span class="name">垂直方向滑块：android:scrollbarThumbVertical</span></li><li><span class="name">水平方向滑块：android:scrollbarThumbHorizontal</span></li></ul></li><li><span class="name">隐藏滑块</span><ul><li><span class="name">方法有两种： 1.android:scrollbars="none"</span></li><li><span class="name">2.Java代码设置：scrollview.setVerticalScrollBarEnabled(false);</span></li></ul></li><li><span class="name">设置滚动速度</span><ul><li><span class="name">没有可以直接设置的方法，需要继承ScrollView，然后重写一个 public void fling (int velocityY)的方法：</span></li><li><span class="name"><span class="contentTag" title="Filter @Override">@<span class="contentTagText">Override</span><span class="contentTagNub"></span></span></span></li><li><span class="name">public void fling(int velocityY) {</span><ul><li><span class="name">super.fling(velocityY / 2);    //速度变为原来的一半</span></li></ul></li><li><span class="name">}</span></li></ul></li></ul></li><li><span class="name">Date &amp; Time组件(时间相关)</span><ul><li><span class="name"><b>显示时间的控件有：TextClock，AnalogClock，Chronometer.  </b></span></li><li><span class="name">TextClock(文本时钟)</span><ul><li><span class="name">TextClock提供的 is24HourModeEnabled()方法来查看系统是否在使用24进制时间显示</span></li><li><span class="name">android:format12Hour, 设置12时制的格式</span></li><li><span class="name">android:format24Hour, 设置24时制的格式</span></li><li><span class="name">android:timeZone, 设置时区</span></li></ul></li><li><span class="name">AnalogClock(模拟时钟)</span><ul><li><span class="name">android:dial="@mipmap/ic_c_bg"   // 背景</span></li><li><span class="name">android:hand_hour="@mipmap/zhen_shi"   // 时针</span></li><li><span class="name">android:hand_minute="@mipmap/zhen_fen  // 分针</span></li></ul></li><li><span class="name">Chronometer(计时器)</span></li><li><span class="name"><b>选择时间的控件有: DatePicker(日期选择器)，TimePicker(时间选择器)，CalendarView(日期视图).</b></span></li><li><span class="name">DatePicker(日期选择器)</span><ul><li><span class="name">android:calendarTextColor&nbsp;： 日历列表的文本的颜色</span></li><li><span class="name">android:calendarViewShown：是否显示日历视图</span></li><li><span class="name">android:datePickerMode：组件外观，可选值:spinner，calendar 前者效果如下，默认效果</span></li><li><span class="name">android:dayOfWeekBackground：顶部星期几的背景颜色</span></li><li><span class="name">android:dayOfWeekTextAppearance：顶部星期几的文字颜色</span></li><li><span class="name">android:endYear：去年(内容)比如2010</span></li><li><span class="name">android:firstDayOfWeek：设置日历列表以星期几开头</span></li><li><span class="name">android:headerBackground：整个头部的背景颜色</span></li><li><span class="name">android:headerDayOfMonthTextAppearance：头部日期字体的颜色</span></li><li><span class="name">android:headerMonthTextAppearance：头部月份的字体颜色</span></li><li><span class="name">android:headerYearTextAppearance：头部年的字体颜色</span></li><li><span class="name">android:maxDate：最大日期显示在这个日历视图mm / dd / yyyy格式</span></li><li><span class="name">android:minDate：最小日期显示在这个日历视图mm / dd / yyyy格式</span></li><li><span class="name">android:spinnersShown：是否显示spinner</span></li><li><span class="name">android:startYear：设置第一年(内容)，比如19940年</span></li><li><span class="name">android:yearListItemTextAppearance：列表的文本出现在列表中。</span></li><li><span class="name">android:yearListSelectorColor：年列表选择的颜色</span></li><li><span class="name">DatePicker的事件：&nbsp;DatePicker.OnDateChangedListener</span></li></ul></li><li><span class="name">TimePicker(时间选择器)</span><ul><li><span class="name">官方提供的属性只有一个：&nbsp;android:timePickerMode：组件外观，同样可选值为: spinner和 clock(默认) 前者是旧版本的TimePicker</span></li><li><span class="name">对应的监听事件是：TimePicker.OnTimeChangedListener</span></li></ul></li><li><span class="name">CalendarView(日期视图)</span><ul><li><span class="name">android:firstDayOfWeek：设置一个星期的第一天</span></li><li><span class="name">android:maxDate&nbsp;：最大的日期显示在这个日历视图mm / dd / yyyy格式</span></li><li><span class="name">android:minDate：最小的日期显示在这个日历视图mm / dd / yyyy格式</span></li><li><span class="name">android:weekDayTextAppearance：工作日的文本出现在日历标题缩写</span></li><li><span class="name">对应的日期改变事件是：CalendarView.OnDateChangeListener</span></li></ul></li></ul></li><li><span class="name">ListView </span><ul><li><span class="name">ListView 适用于搭复杂界面的框架, 所以最好按MVC模型进行组织. 其中关键是controller, 一般采用 adapter模型. 例子:</span><ul><li><span class="name">// 要显示的数据.  建议使用数组资源文件存放.</span></li><li><span class="name">String[] strs = {"基神","B神","翔神","曹神","J神"};</span></li><li><span class="name">// 创建 ArrayAdapter</span></li><li><span class="name">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1, strs);</span></li><li><span class="name">// 获取ListView对象，通过调用setAdapter方法为ListView设置Adapter设置适配器</span></li><li><span class="name">ListView list_test = (ListView) findViewById(R.id.list_test);</span></li><li><span class="name">list_test.setAdapter(adapter);</span></li></ul></li><li><span class="name">对于数组资源, 创建 ArrayAdapter 是用: </span><ul><li><span class="name">ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.<b>createFromResource</b>(this, R.array.myarray, android.R.layout.simple_list_item_multiple_choice);</span></li></ul></li><li><span class="name">还有一个简写的方式, 在 ListView 的layout中直接应用:  android:entries="@array/myarray";</span></li><li><span class="name">实例化ArrayAdapter的第二个参数：&nbsp;android.R.layout.simple_expandable_list_item_1 是定义 ListView的界面风格, 值域有:</span><ul><li><span class="name">simple_list_item_1 : 单独一行的文本框</span></li><li><span class="name">simple_list_item_2 : 两个文本框组成</span></li><li><span class="name">simple_list_item_checked : 每项都是由一个已选中的列表项</span></li><li><span class="name">simple_list_item_multiple_choice : 都带有一个复选框</span></li><li><span class="name">simple_list_item_single_choice : 都带有一个单选钮</span></li></ul></li></ul></li><li><span class="name">查看当前窗口的Layout</span><ul><li><span class="name">AS/IDEA: Layout Inspector</span></li><li><span class="name">AS monitor: Open Perspective - Hierarchy View - Tree View</span></li></ul></li><li><span class="name">TextureView </span></li><li><span class="name">SurfaceView</span></li><li><span class="name"><a class="contentLink" target="_blank" rel="noreferrer" href="https://www.runoob.com/w3cnote/android-tutorial-button-imagebutton.html">https://www.runoob.com/w3cnote/android-tutorial-button-imagebutton.html</a></span></li></ul>
  </body>
</html>