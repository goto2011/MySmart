<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer"><b>06-Debug</b></span></span><ul><li><span class="name"><span class="innerContentContainer"><b>Android有几种Log?  <span class="contentTag" title="Filter @iPanorama">@<span class="contentTagText">iPanorama</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">Android log系统框图  <span class="contentTag" title="Filter @iChart">@<span class="contentTagText">iChart</span><span class="contentTagNub"></span></span> </span></span></li><li><span class="name"><span class="innerContentContainer">模板</span></span><ul><li><span class="name"><span class="innerContentContainer">1. log名称:</span></span></li><li><span class="name"><span class="innerContentContainer">2. log层次:</span></span></li><li><span class="name"><span class="innerContentContainer">3. 常用于解决哪类问题:</span></span></li><li><span class="name"><span class="innerContentContainer">4. 是否依赖特定平台:</span></span></li><li><span class="name"><span class="innerContentContainer">5. 抓取方法:</span></span></li><li><span class="name"><span class="innerContentContainer">6. log文件名:</span></span></li><li><span class="name"><span class="innerContentContainer">7. 查看工具:</span></span></li><li><span class="name"><span class="innerContentContainer">8. log内容:</span></span></li><li><span class="name"><span class="innerContentContainer">9. 核心log是什么，一般的分析方法是什么:</span></span></li><li><span class="name"><span class="innerContentContainer">10. log打印的原理:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>logcat</b></span></span><ul><li><span class="name"><span class="innerContentContainer">1. log名称: logcat</span></span></li><li><span class="name"><span class="innerContentContainer">2. log层次: 包括4种log, 应用log, fwk log, 射频通话log (暂不关注), 系统事件log(单列)</span></span></li><li><span class="name"><span class="innerContentContainer">3. 常用于解决哪类问题: 分析应用和fwk层的所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 是否依赖特定平台: 原生, 不依赖.</span></span></li><li><span class="name"><span class="innerContentContainer">5. 抓取方法:   <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/5b0049f4afdc">https://workflowy.com/#/5b0049f4afdc</a></span></span></li><li><span class="name"><span class="innerContentContainer">6. log文件名:  自定义</span></span></li><li><span class="name"><span class="innerContentContainer">7. 查看工具: 普通文本编辑器即可. 比如 Sublime, notepad++</span></span></li><li><span class="name"><span class="innerContentContainer">8. log内容: </span></span><ul><li><span class="name"><span class="innerContentContainer">•Logcat是一行一行的, 单条log不能跨行(其实也可以, 但是一般不建议这么做). </span></span></li><li><span class="name"><span class="innerContentContainer">每行log包括如下6个部分:</span></span><ul><li><span class="name"><span class="innerContentContainer">Tag</span></span></li><li><span class="name"><span class="innerContentContainer">时间戳</span></span></li><li><span class="name"><span class="innerContentContainer">PID, 进程ID</span></span></li><li><span class="name"><span class="innerContentContainer">TID, 线程ID</span></span></li><li><span class="name"><span class="innerContentContainer">log level</span></span></li><li><span class="name"><span class="innerContentContainer">log信息(代码中写入)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 核心log是什么，一般的分析方法是什么: 无特定方法, 一行行的看就完了.</span></span></li><li><span class="name"><span class="innerContentContainer">10. log打印的原理:</span></span><ul><li><span class="name"><span class="innerContentContainer">App通过导入android.util.Log包来引入Log类，然后通过log方法写不同优先级的相关信息到log。</span></span></li><li><span class="name"><span class="innerContentContainer">代码在: frameworks/base/core/java/android/util/Log.java</span></span></li><li><span class="name"><span class="innerContentContainer">主要方法有：</span></span><ul><li><span class="name"><span class="innerContentContainer">Log.v();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.d();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.i();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.w();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.e();</span></span></li><li><span class="name"><span class="innerContentContainer">Log.a();</span></span></li><li><span class="name"><span class="innerContentContainer">分别对应log级别：Assert，ERROR，WARN，INFO，DEBUG，VERBOSE。</span></span></li><li><span class="name"><span class="innerContentContainer">VERBOSE除了开发期间，是不应该被编译进APP的，DEBUG应该编译但在runtime被忽略，ERROR，WARN和INFO logs则一直被保留。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">jni层: frameworks/base/core/jni/android_util_Log.cpp, 关键函数是 android_util_Log_println_native()</span></span></li><li><span class="name"><span class="innerContentContainer">Native层: system/core/logcat/logcat.cpp. </span></span></li><li><span class="name"><span class="innerContentContainer">Native层打印log的方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">包含system/core/include/cutils/log.h</span></span></li><li><span class="name"><span class="innerContentContainer">在模块Android.mk中添加：LOCAL_SHARED_LIBRARIES := liblog libcutils</span></span></li><li><span class="name"><span class="innerContentContainer">打印接口是: </span></span></li><li><span class="name"><span class="innerContentContainer">ALOGV</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGD</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGI</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGW</span></span></li><li><span class="name"><span class="innerContentContainer">ALOGE</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">logd 服务: 在开机过程中被init进程启动. </span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 system/core/logd</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\CommandListener.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">system\core\logd\LogBuffer.cpp</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">底层: logging的kernel driver部分被称作”logger”</span></span><ul><li><span class="name"><span class="innerContentContainer">代码在 kernel/drivers/staging/android/logger.c</span></span></li><li><span class="name"><span class="innerContentContainer">生成4个设备节点:</span></span><ul><li><span class="name"><span class="innerContentContainer">/dev/log/main</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/events</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/radio</span></span></li><li><span class="name"><span class="innerContentContainer">/dev/log/system</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>logcat -b </b>events</span></span><ul><li><span class="name"><span class="innerContentContainer">系统事件log.</span></span></li><li><span class="name"><span class="innerContentContainer">Event logs是在 android.util.EventLog.class 中创建二进制log信息。Log条目由二进制tag代码和二进制参数构成。</span></span></li><li><span class="name"><span class="innerContentContainer">Event logs 文件存储在system/etc/event-log-tags中，通过cat system/etc/event-log-tags能查看其信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">kernel log</span></span><ul><li><span class="name"><span class="innerContentContainer">1. log名称: kernel log</span></span></li><li><span class="name"><span class="innerContentContainer">2. log层次: kernel</span></span></li><li><span class="name"><span class="innerContentContainer">3. 常用于解决哪类问题: 底层所有问题.</span></span></li><li><span class="name"><span class="innerContentContainer">4. 是否依赖特定平台: 不依赖</span></span></li><li><span class="name"><span class="innerContentContainer">5. 抓取方法: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/caa3eb4cf060">https://workflowy.com/#/caa3eb4cf060</a></span></span></li><li><span class="name"><span class="innerContentContainer">6. log文件名: 自定义</span></span></li><li><span class="name"><span class="innerContentContainer">7. 查看工具: 普通文本编辑器即可. 比如 Sublime, notepad++</span></span></li><li><span class="name"><span class="innerContentContainer">8. log内容: </span></span><ul><li><span class="name"><span class="innerContentContainer">较简单: 2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5]</span></span></li><li><span class="name"><span class="innerContentContainer">分别是 进程ID, 线程ID, 级别, Log内容</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 核心log是什么，一般的分析方法是什么: 无</span></span></li><li><span class="name"><span class="innerContentContainer">10. log打印的原理:</span></span><ul><li><span class="name"><span class="innerContentContainer">使用 printk()函数 进行Log输出。</span></span></li><li><span class="name"><span class="innerContentContainer">日志级别</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel log日志级别在 include/linux/kern_levels.h 定义. 字符串表示为一个尖括号中的整数，0-7，值越小优先级越高。</span></span></li><li><span class="name"><span class="innerContentContainer">优先级小于 console_loglevel 这个整数变量的消息才会打印。</span></span></li><li><span class="name"><span class="innerContentContainer">获取当前日志级别: cat /system/sys/kernel/printk, 有4个数字，第一个表示当前日志级别。</span></span></li><li><span class="name"><span class="innerContentContainer">刷新系统日志级别: echo 8 &gt; /system/sys/kernel/printk</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">换行符，log行尾一定要加换行符。否则不会输出到控制台。</span></span></li><li><span class="name"><span class="innerContentContainer">如果系统运行了 klogd 和 syslogd，则所有内核消息都会被追加到 /var/log/messages 中。</span></span></li><li><span class="name"><span class="innerContentContainer">Log buffer 大小是写在代码中的，这个宏:LOG_BUF_SHIFT，所在文件为 /kernel/init/Kconfig。</span></span></li><li><span class="name"><span class="innerContentContainer">打印速度: printk_ratelimit().</span></span></li><li><span class="name"><span class="innerContentContainer">打印主次设备号: print_dev_t(), format_dev_t().</span></span></li><li><span class="name"><span class="innerContentContainer">例子:</span></span><ul><li><span class="name"><span class="innerContentContainer">printk(KERN_ALERT "This is the log printed by printk in linux kernel space.");</span></span></li><li><span class="name"><span class="innerContentContainer">printk(KERN_ERR "%s: Invalid parameter\n", __func__);</span></span></li></ul></li><li><span class="name"></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">binder log</span></span><ul><li><span class="name"><span class="innerContentContainer">和应用层相关的binder问题主要有两类:</span></span><ul><li><span class="name"><span class="innerContentContainer">主线程被Binder 对端block导致anr;</span></span></li><li><span class="name"><span class="innerContentContainer">Binder被占满, 导致主线程无法启动binder引起异常.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>binder_sample</b>: binder通讯过程超过门限(默认500毫秒)时打印:</span></span><ul><li><span class="name"><span class="innerContentContainer">binder_sample: [android.app.IActivityManager,13,940,com.starbucks.cn,100]</span></span></li><li><span class="name"><span class="innerContentContainer">其中:</span></span><ul><li><span class="name"><span class="innerContentContainer">android.app.IActivityManager: 被调用方</span></span></li><li><span class="name"><span class="innerContentContainer">13: 方法的序号</span></span></li><li><span class="name"><span class="innerContentContainer">940: delay的时长(单位: 毫秒)</span></span></li><li><span class="name"><span class="innerContentContainer">com.starbucks.cn: 调用方</span></span></li><li><span class="name"><span class="innerContentContainer">100: 被卡住的百分比.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">相关代码在: android_util_Binder.cpp, conditionally_log_binder_call()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">binder thread: binder线程池耗尽, 且持续时间超过门限时打印</span></span><ul><li><span class="name"><span class="innerContentContainer">binder thread&nbsp;pool (16&nbsp;threads) starved for 100 ms</span></span></li><li><span class="name"><span class="innerContentContainer">含义是: 线程池已满的持续长达100ms</span></span></li><li><span class="name"><span class="innerContentContainer">还有一个binder资源耗尽的log , binder_alloc_buf, no vma</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER FAILED TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/failed_transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTION LOG</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/transaction_log</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER TRANSACTIONS</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/transactions</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER STATS</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/stats</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">BINDER PROCESS STATE</span></span><ul><li><span class="name"><span class="innerContentContainer">获取该log:读取文件/proc/binder/proc/*</span></span></li><li><span class="name"><span class="innerContentContainer">bind相关的一些状态</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">systrace</span></span></li><li><span class="name"><span class="innerContentContainer">hprof</span></span></li><li><span class="name"><span class="innerContentContainer">anr</span></span></li><li><span class="name"><span class="innerContentContainer">traces</span></span></li><li><span class="name"><span class="innerContentContainer">tombstones</span></span></li><li><span class="name"><span class="innerContentContainer">traceView</span></span></li><li><span class="name"><span class="innerContentContainer">过度绘制</span></span></li><li><span class="name"><span class="innerContentContainer">tcpdump</span></span><ul><li><span class="name"><span class="innerContentContainer">TCP/IP协议相关的log</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell tcpdump -s 10000 -w /sdcard/capture.pcap</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">显示相关知识参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/56a8ba6ce429">https://workflowy.com/#/56a8ba6ce429</a></span></span></li><li><span class="name"><span class="innerContentContainer"><b>硬件基本速度指标 <span class="contentTag" title="Filter @iPanorama">@<span class="contentTagText">iP</span><span class="contentTagNub"></span></span></b><span class="contentTag" title="Filter @iPanorama"><span class="contentTagText">anorama</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">执行一条指令：1 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从L1 cache中获取一个字：2 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从内存中读一个字：10 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘连续位置取一个字：200 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">从磁盘任意位置取一个字：8000,000 指令周期</span></span></li><li><span class="name"><span class="innerContentContainer">双通道DDR4内存: 30GB/s</span></span></li><li><span class="name"><span class="innerContentContainer">PCIe SSD：3600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SATA SSD：600MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">机械硬盘：200MB/s</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡：读写速度差异大，主流大约是读100MB/s, 写30MB/s.</span></span></li><li><span class="name"><span class="innerContentContainer">Nor FLASH 和 Nand FLASH 的速度对比</span></span><ul><li><span class="name"><span class="innerContentContainer">以美光（Micron）的NAND和NOR对比, 速度数据如下:</span></span></li><li><span class="name"><span class="innerContentContainer">读: Nor: 41MB/s;   Nand: 37MB/s (基本差不多)</span></span></li><li><span class="name"><span class="innerContentContainer">写: Nor: 0.178MB/s;   Nand: 5MB/s (<b>Nand 快了28倍</b>)</span></span></li><li><span class="name"><span class="innerContentContainer">擦一个块的时间: Nor: 750ms;   Nand: 2ms (<b>Nand 快了375倍</b>)</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>性能问题优化经验  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">性能问题, 首先要找到参照物. 和谁对比慢? 参照物的合理性在哪里?</span></span></li><li><span class="name"><span class="innerContentContainer">其次, 要找对目标. 性能问题没有尽头, 不可能无限优化下去. 比如: 华为应用启动速度目标：500ms，从点击图标到 activity ouResume的时间。</span></span></li><li><span class="name"><span class="innerContentContainer">基本做法是: 主流程砍几刀, 分别打点, 找出最耗时的操作, 确认哪些步骤水分最大，谁在等待、在等谁. 继续这个动作, 逐步深入.</span></span></li><li><span class="name"><span class="innerContentContainer">首先, 去掉非必要的步骤；</span></span></li><li><span class="name"><span class="innerContentContainer">合并步骤，批量处理；</span></span></li><li><span class="name"><span class="innerContentContainer">预处理；预读. <b>用户感知的动作</b>, 要提前准备数据, 必要时可读入无效数据, 冗余数据.</span></span></li><li><span class="name"><span class="innerContentContainer">按需处理。<b>用户无感知的动作</b>放在后面处理. 延迟读, 延迟写。</span></span></li><li><span class="name"><span class="innerContentContainer">大流程搞成多线程的, 串行改并行, 往往有奇效.</span></span></li><li><span class="name"><span class="innerContentContainer">buffer管理: </span></span><ul><li><span class="name"><span class="innerContentContainer">双buffer，或多buffer ，保证并发；</span></span></li><li><span class="name"><span class="innerContentContainer">更大的 buffer.</span></span><ul><li><span class="name"><span class="innerContentContainer">经验: 读写buffer 超过 64K 就价值不大了; 复杂计算buffer超过一帧就价值不大了.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">同一个处理, 底层和应用都可以做, 那就放在底层做. </span></span></li><li><span class="name"><span class="innerContentContainer"><b>界面刷新速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">setAlpha() 要特别小心. 因为如果界面上有多个Alpha值, 绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作. </span></span></li><li><span class="name"><span class="innerContentContainer">减少页面 layout布局层级.</span></span></li><li><span class="name"><span class="innerContentContainer">减少过度绘制.   --参见: <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/5d3ed8a3ec39">https://workflowy.com/#/5d3ed8a3ec39</a></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>拍照速度优化</b></span></span><ul><li><span class="name"><span class="innerContentContainer">拍照性能优化看5个点: 拍照开始的回调, 缩略图回帧的回调, 拍照回帧, 后期处理的回调, 保存文件的回调.</span></span></li><li><span class="name"><span class="innerContentContainer">拍照性能优化: 先显示后处理, 在缩略图没有存储时候提前显示缩略图. 给用户快的感觉.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">性能问题工具</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>android过度绘制 (overdraw)</b></span></span><ul><li><span class="name"><span class="innerContentContainer">过度绘制指屏幕的某个像素在同一帧的时间内会绘制多次. 这是种浪费, 因为前面的绘制都是无效的, 只有最后一次绘制有用.</span></span></li><li><span class="name"><span class="innerContentContainer">android系统设计思路就是递归, 无论是底层, 还是上层, 都喜欢用递归来解决问题. 好处是用很小的投入就能推动了庞大的系统; 坏处是层次太多, 太多无效调用, 系统低效臃肿.</span></span></li><li><span class="name"><span class="innerContentContainer">造成过度绘制的原因:    <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">布局存在重叠的部分;</span></span></li><li><span class="name"><span class="innerContentContainer">存在非必须的重叠背景;</span></span></li><li><span class="name"><span class="innerContentContainer">不可见的UI元素也在刷新界面.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>如何解决过度绘制?  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </b></span></span><ul><li><span class="name"><span class="innerContentContainer">总的原则就是：尽量避免重叠不可见元素的绘制. 怎么做?</span></span></li><li><span class="name"><span class="innerContentContainer">1. 合理选择控件容器</span></span><ul><li><span class="name"><span class="innerContentContainer">表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。</span></span></li><li><span class="name"><span class="innerContentContainer">LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</span></span></li><li><span class="name"><span class="innerContentContainer">从减少overdraw的角度来看，LinearLayout会增加控件数的层级，则RelativeLayout更优，但是当某一界面在使用LinearLayout并不会带来更多的控件数和控件层级时，LinearLayout则是首选。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">2. 去掉window的默认背景</span></span><ul><li><span class="name"><span class="innerContentContainer">使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background就是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</span></span></li><li><span class="name"><span class="innerContentContainer">去掉window的背景可以在onCreate()中setContentView()之后调用: getWindow().setBackgroundDrawable(null);</span></span></li><li><span class="name"><span class="innerContentContainer">或者在theme中添加 android:windowbackground="null"</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">3. 去掉其他不必要的背景</span></span><ul><li><span class="name"><span class="innerContentContainer">有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。</span></span></li><li><span class="name"><span class="innerContentContainer">如果采用的是 selector的背景，将normal状态的color设置为“@android:color/transparent",也同样可以解决问题。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">4. ClipRect &amp; QuickReject</span></span><ul><li><span class="name"><span class="innerContentContainer">为了减轻Overdraw，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，也就无法完成自动优化.</span></span></li><li><span class="name"><span class="innerContentContainer">可通过 canvas.clipRect() 来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</span></span></li><li><span class="name"><span class="innerContentContainer">这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">5. 使用ViewStub</span></span><ul><li><span class="name"><span class="innerContentContainer">ViewStub是个什么东西？一句话总结：高效占位符。</span></span></li><li><span class="name"><span class="innerContentContainer">我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。</span></span></li><li><span class="name"><span class="innerContentContainer">这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点是耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</span></span></li><li><span class="name"><span class="innerContentContainer">推荐的做法是使用 android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</span></span></li><li><span class="name"><span class="innerContentContainer">想加载布局时，可以使用下面其中一种方法：</span></span></li><li><span class="name"><span class="innerContentContainer">((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE);</span></span></li><li><span class="name"><span class="innerContentContainer">View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate();</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">6. 使用Merge标签</span></span><ul><li><span class="name"><span class="innerContentContainer">有两种情况下我们可以使用Merge标签来做容器控件。</span></span></li><li><span class="name"><span class="innerContentContainer">第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">Merge只能作为XML布局的根标签使用，当Inflate以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">7. 善用draw9patch</span></span><ul><li><span class="name"><span class="innerContentContainer">你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。</span></span></li><li><span class="name"><span class="innerContentContainer">优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">8. 慎用Alpha</span></span><ul><li><span class="name"><span class="innerContentContainer">对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一定做Alpha转化的话，可以采用缓存的方式。</span></span><ul><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_HARDWARE);</span></span></li><li><span class="name"><span class="innerContentContainer">doSmoeThing();</span></span></li><li><span class="name"><span class="innerContentContainer">view.setLayerType(LAYER_TYPE_NONE);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">9. 避免“OverDesign”</span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难"，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">检查方法: </span></span><ul><li><span class="name"><span class="innerContentContainer">开发人员选项中有"调试GPU过度绘制", 打开它, 然后在应用界面上会显示各种颜色, 其中:</span></span></li><li><span class="name"><span class="innerContentContainer">没有颜色: 仅绘制1次.</span></span></li><li><span class="name"><span class="innerContentContainer">蓝色: 绘制2次 (可接受)</span></span></li><li><span class="name"><span class="innerContentContainer">绿: 绘制3次</span></span></li><li><span class="name"><span class="innerContentContainer">浅红: 绘制4次. 小块也可接受</span></span></li><li><span class="name"><span class="innerContentContainer">深红: 绘制5次或以上. 这种需要修复.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>systrace: 分析性能问题  --异常强大的工具 <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></b></span></span><ul><li><span class="name"><span class="innerContentContainer">systrace负责收集Android关键子系统（如surfaceflinger、wms等Framework模块、服务，View系统等）的运行信息。</span></span></li><li><span class="name"><span class="innerContentContainer">systrace模块由3部分组成：</span></span><ul><li><span class="name"><span class="innerContentContainer">内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</span></span></li><li><span class="name"><span class="innerContentContainer">数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</span></span></li><li><span class="name"><span class="innerContentContainer">数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录 /tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 </span></span></li><li><span class="name"><span class="innerContentContainer">从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">抓取方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">AS 进入Tools &gt; Android &gt; Monitor 抓取。</span></span></li><li><span class="name"><span class="innerContentContainer">或者使用 monitor.bat , 选择线程。</span></span></li><li><span class="name"><span class="innerContentContainer">选择标签：这个看情况，一般选择Graphic，View System，CPU这几个。</span></span></li><li><span class="name"><span class="innerContentContainer">然后复现问题，抓对应的 systrace.</span></span></li><li><span class="name"><span class="innerContentContainer">设置大的缓冲区可以避免事件的丢失（通常表现为某些CPU在跟踪中的某个点之后没有任何事件），比如32M。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">chrome中打开 chrome://tracing,  把文件拖进去</span></span></li><li><span class="name"><span class="innerContentContainer">找对应的线程</span></span></li><li><span class="name"><span class="innerContentContainer">遍历快捷键:</span></span><ul><li><span class="name"><span class="innerContentContainer">w: 放大</span></span></li><li><span class="name"><span class="innerContentContainer">s: 缩小</span></span></li><li><span class="name"><span class="innerContentContainer">a: 后退</span></span></li><li><span class="name"><span class="innerContentContainer">d: 前进</span></span></li><li><span class="name"><span class="innerContentContainer">方向键: 四处遍历</span></span></li><li><span class="name"><span class="innerContentContainer">f: 直接放大当前</span></span></li><li><span class="name"><span class="innerContentContainer">m: 高亮当前</span></span></li><li><span class="name"><span class="innerContentContainer">v: 高亮整个 vsync</span></span></li><li><span class="name"><span class="innerContentContainer">0(数字): 恢复到最初状态</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">卡顿看 UIThread , 每个"F"都是一帧, 绿色表示不卡, 其它颜色表示卡.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">界面刷新一般包括如下几个步骤：</span></span><ul><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的 EventThread 唤醒了应用程序UI线程，表明现在是渲染新帧的时候了。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序使用CPU和GPU资源在UI线程，RenderThread 和 hwuiTasks 中渲染帧。这部分占UI的大部分。</span></span></li><li><span class="name"><span class="innerContentContainer">应用程序通过binder将绘制好的帧发送到SurfaceFlinger并进入睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger中的第二个EventThread 负责唤醒SurfaceFlinger来触发组合和显示输出。</span></span></li><li><span class="name"><span class="innerContentContainer">如果SurfaceFlinger确定没有任何工作要完成，它将返回睡眠状态。</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过HWC / HWC2或GL处理组合。 HWC / HWC2组合更快，更低的功耗，但会受到SOC的限制。这一步通常需要4-6ms，但是可以与步骤2重叠，因为Android应用程序总是三重缓冲。 （虽然应用程序总是三重缓冲，但在SurfaceFlinger中只能有一个待处理帧，因此和双重缓存差不多。）</span></span></li><li><span class="name"><span class="innerContentContainer">SurfaceFlinger通过驱动程序调度最终输出，并返回睡眠状态，等待EventThread唤醒。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">systrace 加点</span></span><ul><li><span class="name"><span class="innerContentContainer">代码中分别加 Trace.traceBegin(msg);  Trace.traceEnd();</span></span></li><li><span class="name"><span class="innerContentContainer">必须成对出现, 且在同一个线程.</span></span></li><li><span class="name"><span class="innerContentContainer">在 release 版本中也生效.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">traceView</span></span><ul><li><span class="name"><span class="innerContentContainer">使用工具 traceView 观察CPU的执行情况, 找出耗时操作.</span></span></li><li><span class="name"><span class="innerContentContainer">选择: call stack show</span></span></li><li><span class="name"><span class="innerContentContainer">打开 开发者选项 - 在屏幕上显示为条形图, 可看到实时的CPU绘制信息, 中间一条绿色的横线, 代表16ms, 超过这条线即表示有丢帧.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">oprofile： linux性能监控工具</span></span><ul><li><span class="name"><span class="innerContentContainer">特点是小巧，对运行影响小。android有一个简化的实现。</span></span></li><li><span class="name"><span class="innerContentContainer">oprofile使用方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">先打开宏：CONFIG_OPROFILE=Y，编译系统生成boot.img，下载到手机侧。</span></span></li><li><span class="name"><span class="innerContentContainer">用adb使能功能：opcontrol 等工具，抓取手机数据；</span></span></li><li><span class="name"><span class="innerContentContainer">然后将/data/oprofile/ 目录下的数据pull 回pc ；</span></span></li><li><span class="name"><span class="innerContentContainer">使用PC工具:opimport、opreport等进行分析。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">代码位置: </span></span><ul><li><span class="name"><span class="innerContentContainer">手机侧：/external/oprofile，负责收集数据；</span></span></li><li><span class="name"><span class="innerContentContainer">pc-linux侧，/prebuild/linux_x86/oprofile，负责分析数据。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">CPU提频</span></span><ul><li><span class="name"><span class="innerContentContainer">提频也叫CPU boost。</span></span></li><li><span class="name"><span class="innerContentContainer">CPU分大小核，一般情况下，应用线程会跑在小核上。</span></span></li><li><span class="name"><span class="innerContentContainer">如果性能不够，可以将线程提频，即强制让它运行到大核上。</span></span></li><li><span class="name"><span class="innerContentContainer">是否提频，在systrace中搜 hypnus</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">应用ANR问题</span></span><ul><li><span class="name"><span class="innerContentContainer">Android ANR问题（一）-基本分析方法 https://www.jianshu.com/p/082045769443 --还可以</span></span></li><li><span class="name"><span class="innerContentContainer">ANR：Application Not Responding</span></span></li><li><span class="name"><span class="innerContentContainer">ANR出现的原因  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">主线程频繁进行耗时的操作：如数据库读写</span></span></li><li><span class="name"><span class="innerContentContainer">多线程操作的死锁，主线程被block；</span></span><ul><li><span class="name"><span class="innerContentContainer">关键字：waiting to lock</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">主线程被Binder server block；</span></span><ul><li><span class="name"><span class="innerContentContainer">在 traces.txt 文件中确认，client端的main线程卡在 BinderPorxy.transactNative；</span></span></li><li><span class="name"><span class="innerContentContainer">通过binderinfo 文件查找 server端的进程号。</span></span></li><li><span class="name"><span class="innerContentContainer">然后再在traces.txt 文件中确认server端在干什么， 常见的情况是卡在 Android.os.MessageQueue.nativePollOnce, 即事件处理卡住了，这种一般需要驱动继续排查。</span></span></li><li><span class="name"><span class="innerContentContainer">还有一种情况是server端进程出现WatchDog导致ANR.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">service binder的连接达到上线无法和和System Server通信</span></span></li><li><span class="name"><span class="innerContentContainer">系统资源已耗尽（CPU、IO、内存）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">获取ANR日志</span></span><ul><li><span class="name"><span class="innerContentContainer">旧版本系统(&lt;=8.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">adb pull data/anr/traces.txt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">新版本系统(&gt;=9.0)</span></span><ul><li><span class="name"><span class="innerContentContainer">一次anr一个log文件</span></span></li><li><span class="name"><span class="innerContentContainer">/data/anr/目录中有多个 anr_XXX文件</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">设置ANR路径文件的位置：</span></span><ul><li><span class="name"><span class="innerContentContainer">读取: getprop dalvik.vm.stack -trace -file</span></span></li><li><span class="name"><span class="innerContentContainer">配置: setprop dalvik.vm.stack -trace -file /tmp/stack-traces.txt</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Log中的ANR reason（仅供参考）</span></span><ul><li><span class="name"><span class="innerContentContainer">无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口暂停: Waiting because the [targetType] window is paused.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed.</span></span></li><li><span class="name"><span class="innerContentContainer">窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</span></span></li><li><span class="name"><span class="innerContentContainer">非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长].</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span></li><li><span class="name"><span class="innerContentContainer">targetType: 取值为”focused”或者”touched”</span></span></li><li><span class="name"><span class="innerContentContainer">Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE”</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统定义的超时时间</span></span><ul><li><span class="name"><span class="innerContentContainer">用户输入5S</span></span><ul><li><span class="name"><span class="innerContentContainer">logKey：Input event dispatching timed out</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">广播：前台10S，后台60S</span></span><ul><li><span class="name"><span class="innerContentContainer">logKey：Timeout of broadcast BroadcastRecord</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">服务：前台20S，后台200S</span></span><ul><li><span class="name"><span class="innerContentContainer">logKey：Timeout executing service</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ContentProvider：10S</span></span><ul><li><span class="name"><span class="innerContentContainer">logKey：timeout publishing content providers</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">服务启动时ANR 的原因</span></span><ul><li><span class="name"><span class="innerContentContainer">Service创建之前会延迟发送一个消息，而这个消息就是ANR的起源；</span></span></li><li><span class="name"><span class="innerContentContainer">Service创建完毕，在规定的时间之内执行完毕onCreate()方法就移除这个消息，就不会产生ANR了；</span></span></li><li><span class="name"><span class="innerContentContainer">在规定的时间之内没有完成onCreate()的调用，消息被执行，ANR发生。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">写anr log的代码在 ActivityManagerService.dumpStackTraces()</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统稳定性问题</span></span><ul><li><span class="name"><span class="innerContentContainer">https://www.jianshu.com/p/18f16aba79dd  --好文章</span></span></li><li><span class="name"><span class="innerContentContainer">Android卡顿分析中常见的log: https://www.itdaan.com/blog/2018/05/09/f879f77fc19a05aeded8e753f995d852.html  --比较全面</span></span></li><li><span class="name"><span class="innerContentContainer">traces.txt 文件</span></span><ul><li><span class="name"><span class="innerContentContainer">watchdog发现系统30秒不响应, 就会打印 traces.txt .</span></span></li><li><span class="name"><span class="innerContentContainer">超过一分钟不响应则会打印类似如下的log, 名字如races_SystemServer_WDT_${time}.txt 的文件,并重启 system_server.</span></span></li><li><span class="name"><span class="innerContentContainer">traces.txt 保存系统crash 时的堆栈信息。其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">sysTid 即进程号。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析方法：</span></span><ul><li><span class="name"><span class="innerContentContainer">一般看 main 线程，即主线程。</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型包括:</span></span><ul><li><span class="name"><span class="innerContentContainer">Blocked in handler on foreground thread (android.fg)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on main thread (main)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on display thread (android.display)</span></span></li><li><span class="name"><span class="innerContentContainer">Blocked in handler on ActivityManager (ActivityManager)</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">tombstone -- 死机问题</span></span><ul><li><span class="name"><span class="innerContentContainer">当系统 crash 的时候，会保存一个 tombstone 文件到 /data/tombstones目录下。</span></span></li><li><span class="name"><span class="innerContentContainer">它包含了发生问题的进程ID信息：</span></span><ul><li><span class="name"><span class="innerContentContainer">I/DEBUG   (  241): pid: 244, tid: 244, name: mediaserver  &gt;&gt;&gt; /system/bin/mediaserver &lt;&lt;&lt;</span></span></li><li><span class="name"><span class="innerContentContainer">当 tid == pid 时，问题发生在父进程，反之问题发生在子进程。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">以及错误类型：</span></span><ul><li><span class="name"><span class="innerContentContainer">F/libc    (  244): Fatal signal 11 (SIGSEGV), code 1, fault addr 0xdeadbaad in tid 244 (mediaserver)</span></span></li><li><span class="name"><span class="innerContentContainer">说明出现进程 Crash 的原因是因为程序产生了段错误的信号，访问了非法的内存空间，而访问的非法地址是 0xdeadbaad。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">系统支持的错误类型有：</span></span><ul><li><span class="name"><span class="innerContentContainer">SIGSEGV	Invalid memory reference.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGBUS	Access to an undefined portion of a memory object.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGFPE	Arithmetic operation error, like divide by zero.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGILL	Illegal instruction, like execute garbage or a privileged instruction</span></span></li><li><span class="name"><span class="innerContentContainer">SIGSYS	Bad system call.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXCPU	CPU time limit exceeded.</span></span></li><li><span class="name"><span class="innerContentContainer">SIGXFSZ	File size limit exceeded.</span></span></li><li><span class="name"><span class="innerContentContainer">错误类型定义在prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.8/sysroot/usr/include/bits/signum.h</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">分析方法</span></span><ul><li><span class="name"><span class="innerContentContainer">主要关注 backtrace 下面的内容。它保存了发生 crash 时的堆栈。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">c代码堆栈信息只有内存地址, 没有函数名和行号, 需要一些工具转.</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line</span></span><ul><li><span class="name"><span class="innerContentContainer">addr2line 是把内存地址转化为代码行的工具。需要符号表。</span></span></li><li><span class="name"><span class="innerContentContainer">用法如下：</span></span></li><li><span class="name"><span class="innerContentContainer">如果想找这行错误：#08 pc 0013b3d5 /system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> (SkPNGImageDecoder::onDecodeSubset(SkBitmap*, SkIRect const&amp;)+604)</span></span></li><li><span class="name"><span class="innerContentContainer">先在符号表目录查找：<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a>。 比如在 ./symbols/system/lib/ 下。</span></span></li><li><span class="name"><span class="innerContentContainer">./bin/x86_64-linux-addr2line -e ./symbols/system/lib/<a class="contentLink" target="_blank" rel="noreferrer" href="http://libskia.so">libskia.so</a> 0013b3d5</span></span></li><li><span class="name"><span class="innerContentContainer">输出大致为： android/external/skia/src/images/SkImageDecoder_libpng.cpp:907</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">addr2line 的增强版： <a class="contentLink" target="_blank" rel="noreferrer" href="http://stack.py">stack.py</a></span></span><ul><li><span class="name"><span class="innerContentContainer">stack.py 能够把backtrace堆栈一次性对应到代码，也是利用addr2line。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： python stack.py --symbols-dir=[符号变目录] [tombstone文件]</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">ndk-stack</span></span><ul><li><span class="name"><span class="innerContentContainer">Android NDK 自从版本 r6开始, 提供了一个工具 ndk-stack。这个工具能自动分析 tombstone 文件, 能将崩溃时的调用内存地址和 c++ 代码一行一行对应起来。</span></span></li><li><span class="name"><span class="innerContentContainer">命令： ndk-stack -sym &lt;path&gt; [-dump &lt;path&gt;]</span></span><ul><li><span class="name"><span class="innerContentContainer">dump 参数即 dump 下来的 log 文本文件.</span></span></li><li><span class="name"><span class="innerContentContainer">sym 参数即符号表。就是android项目目录下，编译成功之后，obj目录下的文件（android系统源码o 中带有符号信息的文件）。</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">底层死机原因</span></span><ul><li><span class="name"><span class="innerContentContainer">Preftch Abort：程序指针跑飞；</span></span></li><li><span class="name"><span class="innerContentContainer">Data Abort：内存指针跑飞；（最常见）</span></span></li><li><span class="name"><span class="innerContentContainer">Div by Zero：发生除零错误；</span></span></li><li><span class="name"><span class="innerContentContainer">Unknown sig：某个task收到未定义的信号；</span></span></li><li><span class="name"><span class="innerContentContainer">Error Fatal：代码进入error FATAL分支（可能是assert）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">内存泄漏  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/2ec2e50f9992">https://workflowy.com/#/2ec2e50f9992</a></span></span></li><li><span class="name"><span class="innerContentContainer">功耗问题  --参见 <a class="contentLink" target="_blank" rel="noreferrer" href="https://workflowy.com/#/a5573305b407">https://workflowy.com/#/a5573305b407</a></span></span></li><li><span class="name"><span class="innerContentContainer">Monkey</span></span></li><li><span class="name"><span class="innerContentContainer">CTS</span></span></li><li><span class="name"><span class="innerContentContainer">分析问题的首选方法  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">三现原则。log也算现场。</span></span></li><li><span class="name"><span class="innerContentContainer">利用dailybuild版本，将问题分而治之。</span></span></li><li><span class="name"><span class="innerContentContainer">花3-5分钟时间考虑思路，并写在纸上. 然后尽快开始做。</span></span></li><li><span class="name"><span class="innerContentContainer">配环境是难点，三个办法：</span></span><ul><li><span class="name"><span class="innerContentContainer">平时准备好；</span></span></li><li><span class="name"><span class="innerContentContainer">找现成的环境用；</span></span></li><li><span class="name"><span class="innerContentContainer">基本环境出问题, 不要自己琢磨, 直接找高手搞定. 不要把时间浪费在非关键问题上.</span></span><ul><li><span class="name"><span class="innerContentContainer">这意味着平时要维护一个高手的名单, 并和他们处好关系.</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">加快闭环</span></span><ul><li><span class="name"><span class="innerContentContainer">code → compiler → install → test</span></span></li><li><span class="name"><span class="innerContentContainer">如果在定位问题，请保证每个小时出一次版本。</span></span></li><li><span class="name"><span class="innerContentContainer">我的经验是，一个较复杂的问题的定位，至少需要3个以上的测试版本，而写完一大段代码（300行以上）后进行功能验证，一般需要4-6个版本才能搞定（平均每个版本能解决两三个个bug）。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">USB 相关问题，首选是Bus Hound；</span></span></li><li><span class="name"><span class="innerContentContainer">硬件问题：把线连出来，上示波器。要会用示波器。</span></span></li><li><span class="name"><span class="innerContentContainer">用trace 跟无问题，不跟才有，一般和踢狗相关。</span></span></li><li><span class="name"><span class="innerContentContainer">性能问题，先要流程分解成3-6个阶段，然后通过log 打印等方式得出各阶段的时耗，找到突破点。</span></span></li><li><span class="name"><span class="innerContentContainer">功耗问题，逐个器件拔。</span></span></li><li><span class="name"><span class="innerContentContainer">迅速缩小焦点：</span></span><ul><li><span class="name"><span class="innerContentContainer">FFA上有吗? 有, 就是高通的问题. 没有,则是我们的修改引入的.</span></span></li><li><span class="name"><span class="innerContentContainer">新版本有吗? 没有, 则已经解决.</span></span></li><li><span class="name"><span class="innerContentContainer">老版本有吗? 没有, 则是最近修改引入的. 有, 则是固有问题.</span></span></li><li><span class="name"><span class="innerContentContainer">新单板有吗? 没有, 则已经解决. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">老单板有吗? 没有, 则为硬件修改引入. (软件版本一致的情况下)</span></span></li><li><span class="name"><span class="innerContentContainer">第三方应用有吗? 有, 说明是底层问题. 没有, 说明是应用的问题. (非绝对)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">时刻关注自己是在哪个层面上考虑问题：</span></span><ul><li><span class="name"><span class="innerContentContainer">是cpu层次（包括cpu、硬件寄存器、dma）</span></span></li><li><span class="name"><span class="innerContentContainer">是外设级别（要考虑时序、电源）</span></span></li><li><span class="name"><span class="innerContentContainer">还是task级别（sig、队列、task切换、堆栈、中断等）</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">张建春的定位技巧  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">多看 MODEM SOFTWARE INTERFACE .pdf，学会对arm硬件寄存器的直接操作。</span></span></li><li><span class="name"><span class="innerContentContainer">下发“FALSH读”的指令：D.S SD:0X60000304 %LE %LONG 1；D.S SD:0X60000100 %LE %LONG 0x2。0X60000304&nbsp; 即 page read指令。</span></span></li><li><span class="name"><span class="innerContentContainer">设置读地址：D.S SD:0X60000300 %LE %LONG 0x0279c00；</span></span></li><li><span class="name"><span class="innerContentContainer">查看FALSH读写状态：0X60000308；</span></span></li><li><span class="name"><span class="innerContentContainer">查看ECC 纠错的位数：0X6000030C。0表示无错误；超过4个字节就无法正确纠正。</span></span></li></ul></li></ul>
  </body>
</html>