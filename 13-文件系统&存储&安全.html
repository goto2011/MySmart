<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {font-family:'Helvetica Neue', Arial, sans-serif; color:#333; font-size:13px; line-height:17px;}
      body .name,body .note {white-space:pre-wrap;}
      body ul {list-style:disc; margin:0; padding:0;}
      body li {margin:4px 0 4px 20px; padding:0;}
      body>.name {font-size:16px; line-height:21px;}
      body>.note {font-size:13px; line-height:17px;}
      body>ul {margin-top:15px;}
      body .name.done {text-decoration:line-through; color:#999;}
      body .note {font-size:12px; color:#666;}
    </style>
  </head>
  <body>
    <span class="name"><span class="innerContentContainer">13-文件系统&amp;存储&amp;安全</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux文件系统接口</span></span><ul><li><span class="name"><span class="innerContentContainer">open</span></span></li><li><span class="name"><span class="innerContentContainer">close</span></span></li><li><span class="name"><span class="innerContentContainer">read</span></span></li><li><span class="name"><span class="innerContentContainer">write</span></span></li><li><span class="name"><span class="innerContentContainer">ioctl</span></span></li><li><span class="name"><span class="innerContentContainer">access</span></span><ul><li><span class="name"><span class="innerContentContainer">int access(const char *pathname, int mode);</span></span></li><li><span class="name"><span class="innerContentContainer">参数:</span></span><ul><li><span class="name"><span class="innerContentContainer">pathname: 需要测试的文件路径名。</span></span></li><li><span class="name"><span class="innerContentContainer">mode: 需要测试的操作模式，可能值是一个或多个R_OK(可读), W_OK(可写), X_OK(可执行) 或 F_OK(文件存在)的组合体。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">返回值</span></span><ul><li><span class="name"><span class="innerContentContainer">成功执行时，返回0。失败返回-1，<b>errno</b> 被设为以下的某个值</span></span></li><li><span class="name"><span class="innerContentContainer">EINVAL： 模式值无效</span></span></li><li><span class="name"><span class="innerContentContainer">EACCES： 文件或路径名中包含的目录不可访问</span></span></li><li><span class="name"><span class="innerContentContainer">ELOOP ： 解释路径名过程中存在太多的符号连接</span></span></li><li><span class="name"><span class="innerContentContainer">ENAMETOOLONG：路径名太长</span></span></li><li><span class="name"><span class="innerContentContainer">ENOENT：路径名中的目录不存在或是无效的符号连接</span></span></li><li><span class="name"><span class="innerContentContainer">ENOTDIR： 路径名中当作目录的组件并非目录</span></span></li><li><span class="name"><span class="innerContentContainer">EROFS： 文件系统只读</span></span></li><li><span class="name"><span class="innerContentContainer">EFAULT： 路径名指向可访问的空间外</span></span></li><li><span class="name"><span class="innerContentContainer">EIO：输入输出错误</span></span></li><li><span class="name"><span class="innerContentContainer">ENOMEM： 不能获取足够的内核内存</span></span></li><li><span class="name"><span class="innerContentContainer">ETXTBSY：对程序写入出错</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">文件系统</span></span><ul><li><span class="name"><span class="innerContentContainer">file_operations</span></span><ul><li><span class="name"><span class="innerContentContainer">简称fops，这个结构的每个字段都指向驱动程序中的实现特定操作的函数，同时也是该设备文件对用户发布的接口。</span></span></li><li><span class="name"><span class="innerContentContainer">采用的包括open/close/read/write/ioctl(用于执行设备特定命令)</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">file</span></span><ul><li><span class="name"><span class="innerContentContainer">file表示一个打开的文件，不限于设备文件，每个打开的问题在内核空间都有一个对应的file 结构。</span></span></li><li><span class="name"><span class="innerContentContainer">指向file的指针一般简称为filp。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">inode</span></span><ul><li><span class="name"><span class="innerContentContainer">inode结构在内部表示文件，和文件一一对应。一个inode结果可能有多个file结构指向它。</span></span></li><li><span class="name"><span class="innerContentContainer">从inode结构获取主设备号和次设备号：</span></span></li><li><span class="name"><span class="innerContentContainer">uint iminor(inode *);</span></span></li><li><span class="name"><span class="innerContentContainer">uint imagor(inode *);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">cdev结构</span></span><ul><li><span class="name"><span class="innerContentContainer">内核用cdev结构来表示字符设备。inode 结构中就有cdev指针的字段。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">/proc文件系统</span></span><ul><li><span class="name"><span class="innerContentContainer">/proc 文件系统是一个由软件创建的文件系统，内核使用它向外界导出信息。</span></span></li><li><span class="name"><span class="innerContentContainer">/proc 下面的每个文件都绑定于一个内核函数；用户访问这个文件时，该函数动态的生产文件的内容。</span></span></li><li><span class="name"><span class="innerContentContainer">不建议使用 /proc，建议使用 sysfs。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">模块</span></span><ul><li><span class="name"><span class="innerContentContainer">Linux中的模块一般用于动态加载.</span></span></li><li><span class="name"><span class="innerContentContainer">由于模块参数直接导出为sysfs设备节点, 所以模块放在文件系统中介绍.</span></span></li><li><span class="name"><span class="innerContentContainer">初始化</span></span><ul><li><span class="name"><span class="innerContentContainer">static int __init init_func(void){;;;}</span></span></li><li><span class="name"><span class="innerContentContainer">module_init(init_func);</span></span></li><li><span class="name"><span class="innerContentContainer">module_init是宏，告诉编译器要在目标代码中加一个特殊段，以便指明init_func() 的位置。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">清除</span></span><ul><li><span class="name"><span class="innerContentContainer">static int __exit exit_func(void){;;;}</span></span></li><li><span class="name"><span class="innerContentContainer">模块退出时被call.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">模块参数</span></span><ul><li><span class="name"><span class="innerContentContainer">定义的模块参数将被公布为sysfs的节点，以供读写。---精彩的设计。</span></span></li><li><span class="name"><span class="innerContentContainer">内核支持的模块参数类型有限，如下：bool、charp（字符串）、int、long、short、uint、ulong、ushort</span></span></li><li><span class="name"><span class="innerContentContainer">定义方法：</span></span></li><li><span class="name"><span class="innerContentContainer">module_param(howmany, int, S_IRUGO);&nbsp;&nbsp;&nbsp; // 参数分别为名称、类型、sysfs节点的读写权限（定义在 linux/stat.h 中）</span></span></li><li><span class="name"><span class="innerContentContainer">也支持数组。定义方法：</span></span></li><li><span class="name"><span class="innerContentContainer">module_param_array(name, type, num, permission);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">模块log打印  --介绍一个精彩的设计  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">打印开关 synaptics_debug_mask 被导出为设备节点, 可以在系统运行时动态控制, 非常方便.</span></span></li><li><span class="name"><span class="innerContentContainer">static int synaptics_debug_mask;</span></span></li><li><span class="name"><span class="innerContentContainer">module_param_named(synaptics_debug, synaptics_debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);</span></span></li><li><span class="name"><span class="innerContentContainer"><span class="contentTag" title="Filter #define">#<span class="contentTagText">define</span><span class="contentTagNub"></span></span> DBG_MASK(x...) do {\</span></span></li><li><span class="name"><span class="innerContentContainer">if (synaptics_debug_mask) \</span></span></li><li><span class="name"><span class="innerContentContainer">printk(KERN_DEBUG x);\</span></span></li><li><span class="name"><span class="innerContentContainer">} while (0)</span></span></li><li><span class="name"><span class="innerContentContainer">打印时如下即可：</span></span></li><li><span class="name"><span class="innerContentContainer">DBG_MASK("the touch io is ok!\n");</span></span></li><li><span class="name"><span class="innerContentContainer">DBG_MASK("the x is %d the y is %d the stauts is %d!\n", x, y, finger_status);</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">Vold</span></span><ul><li><span class="name"><span class="innerContentContainer">vold.conf: android\system\core\rootdir\etc\msm7630_surf\vold.qcom.conf</span></span></li><li><span class="name"><span class="innerContentContainer">mount service的代码: nativeDaemonConnector.java 之 doCommand()</span></span></li><li><span class="name"><span class="innerContentContainer">外置sd卡插拔的uevent发出: VolumeManager::handleBlockEvent()</span></span></li><li><span class="name"><span class="innerContentContainer">mount service下发mount命令的入口: VolumeManager::mountVolume()</span></span></li><li><span class="name"><span class="innerContentContainer">mount service下发umount命令的入口: Volume::unmountVol()</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡mount成功的log: Volume sdcard state Changing 3(checking) -&gt; 4(Mounted)</span></span></li><li><span class="name"><span class="innerContentContainer">fat check工具</span></span><ul><li><span class="name"><span class="innerContentContainer">/system/bin/fsck_msdos -p -f /mnt/sdcard</span></span></li><li><span class="name"><span class="innerContentContainer">作为对比：windows上，chkdsk h:</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">fat check的处理流程</span></span><ul><li><span class="name"><span class="innerContentContainer">在logswap()中，调用fork，创建一个子进程，然后调用child()加载 fsck_msdos工具进行检查。</span></span></li><li><span class="name"><span class="innerContentContainer">此时父进程通过 wait(&amp;status) 来等待子进程执行完毕。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP</span></span><ul><li><span class="name"><span class="innerContentContainer">PTP（Picture Transfer Protocol），MTP的前身，用在数码相机和MP3播放器上做文件传输。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP（Media Transfer Protocol，媒体传输协议），微软2006年提出。</span></span></li><li><span class="name"><span class="innerContentContainer">Android从3.0开始支持MTP。</span></span></li><li><span class="name"><span class="innerContentContainer">usb插入后，系统会弹出一个对话框，选择“Transfer files"即打开MTP。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP和UMS（即U盘）的对比</span></span><ul><li><span class="name"><span class="innerContentContainer">优势：</span></span><ul><li><span class="name"><span class="innerContentContainer">UMS挂载到PC后，存储器就被PC控制，手机侧不能再访问该存储器。这个不方便。</span></span></li><li><span class="name"><span class="innerContentContainer">在存储器重新挂载到手机后，需要重新扫描媒体文件。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP则没有这两个问题。当手机的sdcard以MTP模式挂载到PC机上，sdcard的控制权其实还是属于手机。只不过智能手机通过MTP协议向PC机构建了一个虚拟文件系统。PC机操作其中的文件时，都会通过标准MTP协议向智能手机发起请求。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP模式下，可判断PC机拷贝的媒体文件是否受目标手机支持，甚至会触发对应的转码程序将其转换成手机支持的格式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">劣势</span></span><ul><li><span class="name"><span class="innerContentContainer">速度较慢。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP不能直接修改文件本身。只能先拷贝到本地修改，完毕后再拷贝回去。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux和MacOS对MTP支持还不是很完善。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP协议有两个部分：Initiator（USB Host，例如PC机）和Responder（USB Client，例如手机或相机）。</span></span></li><li><span class="name"><span class="innerContentContainer">协议规定所有MTP操作只能由Initator发起。</span></span></li><li><span class="name"><span class="innerContentContainer">Responder 的作用就是处理Initator发起的请求。同时，它还会根据自身状态的变化发送Event以通知 Initiator。</span></span></li><li><span class="name"><span class="innerContentContainer">MTP协议栈</span></span><ul><li><span class="name"><span class="innerContentContainer">物理层。用于传输数据。目前有三种物理层可供MTP使用。它们分别是：</span></span><ul><li><span class="name"><span class="innerContentContainer">USB：其主要特点是传输文件，同步媒体文件时速度快，而且可以边工作边充电，这是目前用的最多的一种方式；</span></span></li><li><span class="name"><span class="innerContentContainer">IP：基于IP的MTP（简称MTP/IP）将通过UPnP来匹配和发现设备。它是家庭网络中是最理想的传输方式；</span></span></li><li><span class="name"><span class="innerContentContainer">Bluetooth：MTP/BT是最省电，同时也是速度最慢的一种传输方式，用处较少。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">传输层：数据传输格式遵循PTP协议。</span></span></li><li><span class="name"><span class="innerContentContainer">命令层：实现MTP协议中的各种命令。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">以PC通过MTP打开一个文件为例，介绍其中涉及到几个主要MTP命令：</span></span><ul><li><span class="name"><span class="innerContentContainer">当设备第一次连接上PC后，Initiator（即PC）首先会发送一个名为 GetDeviceInfo 的请求以获取设备的信息，包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">设备所支持PTP版本的程度，以百分号表示（默认是100）</span></span></li><li><span class="name"><span class="innerContentContainer">所支持的MTP命令（Operation Supported）、</span></span></li><li><span class="name"><span class="innerContentContainer">所支持的Event类型等等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">接着PC端会发送 OpenSession 命令以创建一个会话，该会话一直保持到设备从PC上断开为止。</span></span><ul><li><span class="name"><span class="innerContentContainer">此后所有命令（除GetDeviceInfo命令外）必须在此会话存活期间才能发送。</span></span></li><li><span class="name"><span class="innerContentContainer">会话由SessionID来标识，它是一个32位的无符号整型。</span></span></li><li><span class="name"><span class="innerContentContainer">SessionID由PC选择并传给手机。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">PC端需要通过 GetStorageIDs 命令返回某个盘符对应的 StorageID。</span></span><ul><li><span class="name"><span class="innerContentContainer">PC端如果要进行文件操作的话，必须从根目录开始定位目标文件。在windows上，根目录即为盘符。</span></span></li><li><span class="name"><span class="innerContentContainer">StorageID是一个32位无符号整型，每一个StorageID代表了一个逻辑盘符。</span></span></li><li><span class="name"><span class="innerContentContainer">注意，如果手机内部有两块存储卡的话（如内部存储卡和外部sd卡），Windows中会显示为两个盘符。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">根据上一步的StorageID号，利用 GetStorageInfo 操作去获取存储设备的信息，例如剩余存储空间、文件系统类型、访问权限等。</span></span></li><li><span class="name"><span class="innerContentContainer">通过 GetObjectHandles 命令来获取此盘符下的文件和子目录的Object Handles。</span></span><ul><li><span class="name"><span class="innerContentContainer">一个Object Handle代表一个文件或目录。该值由Responder生成并保证唯一性。</span></span></li><li><span class="name"><span class="innerContentContainer">有了Object Handle，PC就可以操作这些文件或目录了，例如继续通过GetObjectHandles获取某个目录中子文件和子目录的信息。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如果需要拷贝一个文件到手机上，那么PC会通过SendObjectInfo命令将文件信息（如文件名、文件大小）等传递给手机。而手机需要检查目标目录是否有足够的空间和对应权限。</span></span></li><li><span class="name"><span class="innerContentContainer">如果一切正常，PC将通过SendObject把数据传递给手机。真正写文件到设备存储空间的则是手机中的Responder。Android实现的MTP还会在媒体文件传输完毕后，将信息更新到媒体数据库中。</span></span></li><li><span class="name"><span class="innerContentContainer">PC还可利用SetObjectPropValue 命令来设置文件的各种属性值，如Audio BitRate（比特率），Sample Rate（采样率），Number Of Channels（声道）等。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UsbService</span></span><ul><li><span class="name"><span class="innerContentContainer">Android 的 UsbService 可同时管理USB Host/USB Device。其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">UsbDeviceManager管理Usb Device端的功能。</span></span></li><li><span class="name"><span class="innerContentContainer">UsbHostManager管理Usb Host端的功能。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpServer</b></span></span><ul><li><span class="name"><span class="innerContentContainer">Client</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>MtpReceiver</b>负责接收广播，接收到广播后会启动/关闭MtpService；例如，MtpReceiver收到"Android设备 和 PC连上"的消息时，会启动MtpService。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MtpService</b>的作用是提供管理MTP的服务，它会启动MtpServer，以及将本地存储内容和MTP的内容同步。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MediaProvider</b>负责本地存储内容查找和本地内容同步。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Server</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>MtpServer</b>相当于一个服务器，它通过和底层进行通信从而提供了MTP的相关服务。</span></span><ul><li><span class="name"><span class="innerContentContainer">MtpServer会不断地监听Kernel的消息"MTP请求"，并对相应的消息进行相关处理。</span></span></li><li><span class="name"><span class="innerContentContainer">同时，MTP的Event事件也是通过MtpServer发送给MTP驱动的。</span></span></li><li><span class="name"><span class="innerContentContainer">android_mtp_MtpServer 是一个JNI类，完成底层通讯。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpDatabase</b>充当着数据库的功能，但它本身并没有数据库对数据进行保存，本质上是通过MediaProvider数据库获取所需要的数据。</span></span><ul><li><span class="name"><span class="innerContentContainer">android_mtp_MtpDatabase 是一个JNI类，完成对MediaProvider的操作。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer"><b>MtpStorage</b>对应一个"存储单元"。例如，SD卡就对应一个MtpStorage。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MtpPacket </b>和 <b>MtpEventPacket</b>负责对MTP消息进行打包。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">JNI</span></span><ul><li><span class="name"><span class="innerContentContainer">初始化过程中，MtpServer.cpp中的MtpServer::run()会打开MTP文件节点"/dev/mtp_usb"。</span></span></li><li><span class="name"><span class="innerContentContainer">数据过程中，通过 read()，不断的从中读取"PC发来的消息"消息并进行处理。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MTP启动详细流程</span></span><ul><li><span class="name"><span class="innerContentContainer">开启MTP的核心代码如下：</span></span><ul><li><span class="name"><span class="innerContentContainer">mUsbManager = context.getSystemService(UsbManager.class);</span></span></li><li><span class="name"><span class="innerContentContainer">mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_MTP, true);</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">UsbManager的服务端实现为UsbService，其功能是：</span></span><ul><li><span class="name"><span class="innerContentContainer">1.&nbsp; 设置sys.usb.config属性的值为 mtp,adb，底层响应属性改变，切换到MTP功能。文件在： system/core/rootdir/init.usb.configfs.rc</span></span></li><li><span class="name"><span class="innerContentContainer">2.&nbsp; 上层mUEventObserver监听到USB状态改变，在手机通过USB连接到电脑的情况下，会生成两个通知，以及发送一个USB状态改变的广播。frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java</span></span><ul><li><span class="name"><span class="innerContentContainer">ACTION_USB_STATE广播携带了很多extra（可以到Tethering.java中查看extra参数用途）。</span></span></li><li><span class="name"><span class="innerContentContainer">这个广播是<b>黏性广播</b>，这意味着你在注册broadcastReceiver后马上就能收到一次。所以即使我们插着usb线开机，没有插入usb线的操作去trigger，我们注册广播后依然可以把usb模式转换为mtp模式。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MtpReceiver.java属于packages/providers/MediaProvider模块。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java</span></span></li><li><span class="name"><span class="innerContentContainer">handleUsbState()方法如何处理USB状态改变的。 packages/providers/MediaProvider/src/com/android/providers/media/MtpReceiver.java</span></span><ul><li><span class="name"><span class="innerContentContainer">USB连接时，状态是从DISCONNECTED到CONNECTED，再到CONFIGURED。</span></span></li><li><span class="name"><span class="innerContentContainer">handleUsbState中启动MtpService。参数unlocked的值是true。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MtpService 启动时候执行onStartCommand函数。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java</span></span></li><li><span class="name"><span class="innerContentContainer">StartServer函数启动MtpServer。 packages/providers/MediaProvider/src/com/android/providers/media/MtpService.java</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/base/media/java/android/mtp/MtpServer.java</span></span></li><li><span class="name"><span class="innerContentContainer">native_run函数最终调用JNI的函数android_mtp_MtpServer_run()。 frameworks/base/media/jni/android_mtp_MtpServer.cpp</span></span></li><li><span class="name"><span class="innerContentContainer">android_mtp_MtpServer_run调用MtpServer.cpp的run方法。</span></span></li><li><span class="name"><span class="innerContentContainer">frameworks/av/media/mtp/MtpServer.cpp。</span></span></li><li><span class="name"><span class="innerContentContainer">MtpServer.cpp不断从文件描述符读取请求，然后调用handleRequest进行处理。最后把处理结果返回给对端。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">FAT32</span></span></li><li><span class="name"><span class="innerContentContainer">MBR: 主引导记录（Master Boot Record）</span></span><ul><li><span class="name"><span class="innerContentContainer">可引导磁盘驱动器上的第一个物理扇区。</span></span></li><li><span class="name"><span class="innerContentContainer">计算机刚开始引导时，系统 BIOS 查看该扇区以确定当前哪个分区是活动的（可引导的），随后读取该分区的第一个（引导）扇区并从该分区引导。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">RAID: 设备冗余阵列（Redundant Array of Independent/Inexpensive Disks/Devices）</span></span><ul><li><span class="name"><span class="innerContentContainer">一种提供数据冗余、改善性能和／或从磁盘崩溃中迅速恢复数据的方法，它是通过在多个磁盘驱动器上分布或复制数据来实现这一点的。</span></span></li><li><span class="name"><span class="innerContentContainer">常用的 RAID 类型包括 RAID 0（数据条带化），RAID 1（磁盘镜像）和 RAID 5（具有分布式奇偶校验的条带化）。</span></span></li><li><span class="name"><span class="innerContentContainer">RAID 配置通常需要 SCSI 磁盘驱动器（而不是 IDE/EIDE），可能要求磁盘相同（相同的容量、品牌等等）。</span></span></li><li><span class="name"><span class="innerContentContainer">操作系统将 RAID 阵列看作单个设备。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SD卡驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">线序</span></span><ul><li><span class="name"><span class="innerContentContainer">共计10根线</span></span></li><li><span class="name"><span class="innerContentContainer">data 0-3（左右两边各2）</span></span><ul><li><span class="name"><span class="innerContentContainer">data3还可以做卡插入识别功能。</span></span></li><li><span class="name"><span class="innerContentContainer">一般卡座上会另外加一根中断线侦听sd卡插拔，所以不这么用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">clk（左4）</span></span></li><li><span class="name"><span class="innerContentContainer">GP1（左5）</span></span></li><li><span class="name"><span class="innerContentContainer">cmd（左6）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">理论速度： 4根data线，若clk配成50Mhz，则理论速率为25MB。</span></span></li><li><span class="name"><span class="innerContentContainer">命令字</span></span><ul><li><span class="name"><span class="innerContentContainer">识别高速卡： SD_ACMD 13 命令可获取sd_status，其中有speed class。</span></span></li><li><span class="name"><span class="innerContentContainer">识别spec版本： ACMD 51 命令，获取SCR寄存器，其中有版本号。</span></span></li><li><span class="name"><span class="innerContentContainer">获取制造商信息及串号： CMD2 获取，CID寄存器中有。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SD卡初始化命令序列</span></span><ul><li><span class="name"><span class="innerContentContainer">power</span></span></li><li><span class="name"><span class="innerContentContainer">clk</span></span></li><li><span class="name"><span class="innerContentContainer">CMD5: 寻找SD卡</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SDIO卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">config clk: 初始化阶段配置为400K</span></span></li><li><span class="name"><span class="innerContentContainer">CMD0: reset</span></span></li><li><span class="name"><span class="innerContentContainer">CMD8: 识别SDHC</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SDHC卡</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMD55: 是否支持ACMD</span></span></li><li><span class="name"><span class="innerContentContainer">ACMD41: 电压协商</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为SD卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">CMD1: idle</span></span><ul><li><span class="name"><span class="innerContentContainer">有回应即为 MMC卡.</span></span></li><li><span class="name"><span class="innerContentContainer">如果这个也不能回应，则为不可识别的卡。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SDIO控制器</span></span><ul><li><span class="name"><span class="innerContentContainer">sdio host控制器硬件在芯片中，共有4个控制器接口。其中:</span></span></li><li><span class="name"><span class="innerContentContainer">sdio1给sd卡用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio2给wifi用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio3给emmc用</span></span></li><li><span class="name"><span class="innerContentContainer">sdio4 闲置.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">驱动代码</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/mmc/. 下面有三个目录：</span></span><ul><li><span class="name"><span class="innerContentContainer">core</span></span><ul><li><span class="name"><span class="innerContentContainer">核心代码，与平台无关的通用代码放在这里。</span></span></li><li><span class="name"><span class="innerContentContainer">对 SDIO/SD/MMC的识别就在这个目录中。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">host</span></span><ul><li><span class="name"><span class="innerContentContainer">对应的各硬件平台的sd host控制器与sd卡交互的代码，以及sd卡驱动参数配置。</span></span></li><li><span class="name"><span class="innerContentContainer">如 msm_sdcc.c就是负责把sd命令发给sd卡。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">card</span></span><ul><li><span class="name"><span class="innerContentContainer">block.c 即块设备驱动，负责把读写IO请求放入队列；</span></span></li><li><span class="name"><span class="innerContentContainer">queue.c 即队列管理，把读写IO请求翻译为sd host控制器可以识别的信息。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">平台设备部分</span></span><ul><li><span class="name"><span class="innerContentContainer">sdio模块的驱动在内核中注册的是platform驱动模型.</span></span></li><li><span class="name"><span class="innerContentContainer">GPIO配置、SD VDD电源和时钟等，在/kernel/arch/arm/board_msm7***.c中配置。</span></span></li><li><span class="name"><span class="innerContentContainer">这部分每个产品都有区别，独立出来方便管理。</span></span></li><li><span class="name"><span class="innerContentContainer">初始化步骤分为:</span></span><ul><li><span class="name"><span class="innerContentContainer">device 的注册</span></span><ul><li><span class="name"><span class="innerContentContainer">msm7x2x_init_mmc</span></span></li><li><span class="name"><span class="innerContentContainer">msm_add_sdcc(2, &amp;msm7x2x_sdc2_data)&nbsp;</span></span></li><li><span class="name"><span class="innerContentContainer">platform_device_register&nbsp; //注册的设备名为msm_sdcc</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">driver 的注册</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel/drivers/mmc/msm_sdcc.c</span></span></li><li><span class="name"><span class="innerContentContainer">msmsdcc_init()</span></span></li><li><span class="name"><span class="innerContentContainer">platform_driver_register(&amp;msmsdcc_driver);</span></span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC驱动</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc初始化的代码: board_msm7x27a.c，msm7x27a_init_mmc()</span></span></li><li><span class="name"><span class="innerContentContainer">配置sdcc gpio的代码</span></span><ul><li><span class="name"><span class="innerContentContainer">board_msm7x30.c</span></span></li><li><span class="name"><span class="innerContentContainer">msm_gpio sdc4_cfg_data[]</span></span></li><li><span class="name"><span class="innerContentContainer">{GPIO_CFG(58, 1, GPIO_CFG_OUTPUT, ..., GPIO_CFG_15MA (启动能力), "sdc4_clk"};</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC特性</span></span><ul><li><span class="name"><span class="innerContentContainer">EMMC 就是sd卡，最小容量为2G，替代flash作为存储介质。</span></span></li><li><span class="name"><span class="innerContentContainer">emmc的一个主要特征是只允许一个执行单元访问.</span></span></li><li><span class="name"><span class="innerContentContainer">所以在app阶段，app负责访问emmc，而modem侧代码不能直接访问。</span></span><ul><li><span class="name"><span class="innerContentContainer">那么, modem侧文件系统怎么机制?</span></span><ul><li><span class="name"><span class="innerContentContainer">使用ram fs。</span></span></li><li><span class="name"><span class="innerContentContainer">modem 读写ram fs；</span></span></li><li><span class="name"><span class="innerContentContainer">其读写请求会被app侧获取，然后app访问真正的emmc，然后app把数据同步到ram fs；</span></span></li><li><span class="name"><span class="innerContentContainer">最后modem 从ram fs 中得到数据。</span></span></li><li><span class="name"><span class="innerContentContainer">也就是说，modem 必须异步的调用。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">分区表</span></span><ul><li><span class="name"><span class="innerContentContainer">生成方式变了，通过 xml+loadpt.cmm = bin文件；不需要编译。</span></span></li><li><span class="name"><span class="innerContentContainer">mbr 下有三个主分区 + 一个扩展分区（ebr）；</span></span></li><li><span class="name"><span class="innerContentContainer">ebr 下面之后可以容纳15 个逻辑分区。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何新建分区？</span></span><ul><li><span class="name"><span class="innerContentContainer">修改这个文件：AMSS\products\**\tools\jsdcc\partition_load_pt\partition.xml</span></span></li><li><span class="name"><span class="innerContentContainer">添加如下代码:&lt;extended order="1" type="59" label="OEMINFO" size="24576" readonly="false"&gt;&lt;file name="***.mbn" offset="0"/&gt;&lt;/extended&gt;</span></span></li><li><span class="name"><span class="innerContentContainer">其中：</span></span><ul><li><span class="name"><span class="innerContentContainer">order: 分区的位置；</span></span></li><li><span class="name"><span class="innerContentContainer">type: 分区id, 自己定义；</span></span></li><li><span class="name"><span class="innerContentContainer">size: 大小, 定位为sector, 即 512Byte；</span></span></li><li><span class="name"><span class="innerContentContainer">file name: 有这个选项后, 会自动生成下载该分区的cmm脚本.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">运行 loadpt.exe ，生成 partition.bin 及cmm脚本。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">emmc读写速率</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc是8根data线，时钟最大是50mhz，所以理论速率为50MBs.</span></span></li><li><span class="name"><span class="innerContentContainer">实测数据是10MBs。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">EMMC有两种方案</span></span><ul><li><span class="name"><span class="innerContentContainer">SLC</span></span><ul><li><span class="name"><span class="innerContentContainer">Single Layer Cell 单层单元。</span></span></li><li><span class="name"><span class="innerContentContainer">SLC的特点是成本高、容量小、速度快。</span></span></li><li><span class="name"><span class="innerContentContainer">SLC闪存的优点是复写次数高达100000次，比MLC闪存高10倍。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MLC</span></span><ul><li><span class="name"><span class="innerContentContainer">Multi-Level Cell 多层单元。</span></span></li><li><span class="name"><span class="innerContentContainer">MLC的特点是容量大，但速度慢。</span></span></li><li><span class="name"><span class="innerContentContainer">MLC的每个单元是2bit的，相对SLC来说整整大了一倍。</span></span></li><li><span class="name"><span class="innerContentContainer">由于结构复杂，出错的几率增加，需要做错误修正，导致其性能大幅落后于SLC闪存。&nbsp;</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SD/EMMC问题定位经验  <span class="contentTag" title="Filter #经验总结">#<span class="contentTagText">经验总结</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">注意sd卡插拔诊断方式的处理代码，是否整个sd卡初始化流程根本没有启动。</span></span></li><li><span class="name"><span class="innerContentContainer">电源电压值是否ok，是否没有打开电源。出现的概率最高，也最好测出来。</span></span></li><li><span class="name"><span class="innerContentContainer">上电时序要符合协议要求；0到2.6V，要平滑上升。</span></span></li><li><span class="name"><span class="innerContentContainer">clk是否成功配下去，clk线的速率是否和配置值吻合;&nbsp; data 线是否有数据交互。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡的类型是否成功识别；</span></span></li><li><span class="name"><span class="innerContentContainer">是否底层已经初始化成功，但是没有正确的通知上层，导致ui无法访问卡内容；</span></span></li><li><span class="name"><span class="innerContentContainer">读卡过程中出现 crc fail错误，一般为频率太高。我们的硬件信号在50M高速传输下有问题，将其改为20M此错误会不出现。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡 第0个sector 读失败，导致FAT32 无法mount，很像兼容性问题。格式化能解决该问题（数据会丢失）。</span></span></li><li><span class="name"><span class="innerContentContainer">文件夹混乱问题。使用 winhex.exe 定位。</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡初始化时间过长，导致时序相关问题。（升级时vvs不恢复）</span></span></li><li><span class="name"><span class="innerContentContainer">SD卡访问速度太慢问题。排除卡自身的问题后，软件方面的原因较可能是时钟频率设得太低。</span></span></li><li><span class="name"><span class="innerContentContainer">sd卡错误处理中断注册的问题。高通代码中对sd卡的大部分中断都没有处理，导致一些问题。遇到了注册上即可。</span></span></li><li><span class="name"><span class="innerContentContainer">在上层调用底层接口往sd卡写数据之前，应该清一下cache；因为底层sd卡读写是采用DMA 方式。如果cache和内存有不同步的地方，则DMA会写入错误的数据。</span></span></li><li><span class="name"><span class="innerContentContainer">由于高通默认配置中，蓝牙电源使用GP1配置，而我们的硬件上GP1电源给SD卡。但是相关代码没有按照这个修改来调整，导致蓝牙开关电源时实际上是在控制GP1电源，最终导致sd卡状态不正常。</span></span></li><li><span class="name"><span class="innerContentContainer">文件名超长问题。</span></span></li><li><span class="name"><span class="innerContentContainer">文件只读导致无法修改、删除、剪贴。</span></span></li><li><span class="name"><span class="innerContentContainer">seek超过文件大小的问题。</span></span></li><li><span class="name"><span class="innerContentContainer">文件系统性能。</span></span></li></ul></li><li><span class="name"></span></li><li><span class="name"><span class="innerContentContainer">android系统秘钥源 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">密钥源 = imei + bt mac + wifi mac + psn</span></span></li><li><span class="name"><span class="innerContentContainer">其中：psn即emmc的psn号。</span></span><ul><li><span class="name"><span class="innerContentContainer">该值为4字节随机数，出厂前写入，无法用软件修改。</span></span></li><li><span class="name"><span class="innerContentContainer">已确认各供应商都支持该值。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用层安全方案</span></span><ul><li><span class="name"><span class="innerContentContainer">代码安全</span></span><ul><li><span class="name"><span class="innerContentContainer">代码混淆</span></span></li><li><span class="name"><span class="innerContentContainer">反编译</span></span><ul><li><span class="name"><span class="innerContentContainer">apk反编译就是通过使用apk编译工具，将apk文件中的源文件和资源反编译出来，得到的源文件和资源文件可以进行处理后再进行编译，以达到个性化定制、汉化apk等目的。</span></span></li><li><span class="name"><span class="innerContentContainer">最典型的apk编译工具的核心是apktool，但是因为操作需要调用cmd命令，所以出现了很多具有可视化界面的各种编译工具，像easyapk、apkdb、doapk。</span></span></li><li><span class="name"><span class="innerContentContainer">方法:</span></span><ul><li><span class="name"><span class="innerContentContainer">获取apk（在/system/app下），和dex文件（在/data/dalvik-cache下）。</span></span></li><li><span class="name"><span class="innerContentContainer">用dex2jar，将dex文件转为jar文件。</span></span></li><li><span class="name"><span class="innerContentContainer">用jd-gui，将jar转化为java代码。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">应用隔离  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span></span></span><ul><li><span class="name"><span class="innerContentContainer">通过进程UID进行进程隔离。</span></span></li><li><span class="name"><span class="innerContentContainer">该机制继承于linux. 但是Android上把UID的含义大大扩展了。不知道是谁的主意，这个人移花接木的能力相当强大。</span></span></li><li><span class="name"><span class="innerContentContainer">Android的机制是：每个apk安装的时候系统都为其分配唯一UID。这个UID会陪伴应用从安装到卸载。</span></span></li><li><span class="name"><span class="innerContentContainer">这样就一下子实现了各进程之间文件和数据的隔离。各应用私有目录只有自己能访问。</span></span></li><li><span class="name"><span class="innerContentContainer">多个app可通过shareuid的方式可以使用同一个userid，这样就可以访问别人的私有目录。但要求签名使用同一个。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux还有gid的概念，即用户组，一组用户共享一些权限和资源。Android上保持PID和gid的一致性，也就保证了不共享。相当于取消了gid的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">签名 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">签名是权限系统的重要组成部分。常用于如下场景：</span></span><ul><li><span class="name"><span class="innerContentContainer">apk文件必须被开发者数字签名后才可以被安装。</span></span></li><li><span class="name"><span class="innerContentContainer">当apk升级时，需要检查新版应用的数字签名与已安装的应用程序的签名是否相同，不同会被当做一个新的应用程序。</span></span></li><li><span class="name"><span class="innerContentContainer">同一开发者可指定不同的应用程序共享UID，进而它们运行于同一进程空间，共享资源。</span></span></li><li><span class="name"><span class="innerContentContainer">permission在设置/自定义其权限时也经常会使用到签名。</span></span></li><li><span class="name"><span class="innerContentContainer">对于系统签名的应用，会有一些特殊的功能。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">签名的作用：</span></span><ul><li><span class="name"><span class="innerContentContainer">识别代码的作者。</span></span></li><li><span class="name"><span class="innerContentContainer">检测应用程序是否发生了改变。</span></span></li><li><span class="name"><span class="innerContentContainer">在应用程序之间建立信任，以便于应用程序可以安全地共享代码和数据。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Keystore &amp; Keytool</span></span><ul><li><span class="name"><span class="innerContentContainer">keystore叫做key(密钥)store(仓库)。顾名思义里面的存放的是密钥，分为公钥和私钥。</span></span></li><li><span class="name"><span class="innerContentContainer">类似于 sqlite 文件的一张表，每一条记录都是一个公私钥对和一些相关信息。</span></span></li><li><span class="name"><span class="innerContentContainer">Keytool 是jdk提供的一个把钥匙和证书储存到keystore中的工具。</span></span><ul><li><span class="name"><span class="innerContentContainer"><b>-genkey：</b>在用户主目录中创建密钥库（Keystore），后缀名为.keystore。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-alias</b> [alias]：产生别名，后面跟别名内容。若未指定，则别名默认为mykey.</span></span></li><li><span class="name"><span class="innerContentContainer"><b>-keystore：</b>指定.keystore文件的名称，如：</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -genkey -keystore dmkf.keystore</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">常用 Keytool 指令操作</span></span><ul><li><span class="name"><span class="innerContentContainer">创建Keystore文件，生成一个别名为dmkf，名为dmkf.keystore的文件。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -genkey -alias dmkf -keystore dmkf.keystore -keyalg RSA</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看Keystore文件，查看名为dmkf.keystore的Keystore文件信息。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -list -v -keystore dmkf.keystore</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">输出Keystore证书，密钥库dmkf.keystore中导出别名为dmkf的证书到dmkf.crt文件中（导出的证书中包括主体信息和公钥）。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -export -alias dmkf -keystore dmkf.keystore -file dmkf.crt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">查看导出的证书信息，查看导出并保存在dmkf.crt文件中的证书信息。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -printcert -file dmkf.crt</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">导入证书，从名为dmkf.crt文件中取出别名为dmkf的证书信息导入到名为truststore.keystore密钥库中。</span></span><ul><li><span class="name"><span class="innerContentContainer">keytool -import -alias dmfk -keystore truststore.keystore -file dmkf.crt</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">签名方案V1</span></span><ul><li><span class="name"><span class="innerContentContainer">最先生成私有、公共密钥和公共密钥证书（仅需要生成一次）。</span></span></li><li><span class="name"><span class="innerContentContainer">首先对apk里面的所有文件计算hash（使用SHA1算法计算文件的摘要信息，然后用Base64进行编码），然后保存在 MANIFEST.MF，</span></span></li><li><span class="name"><span class="innerContentContainer">然后再对这些hash计算hash，保存到 CERT.SF，</span></span></li><li><span class="name"><span class="innerContentContainer">最后再通过 keystore里面的私钥进行加密并保存到 CERT.RSA，这个文件就是证书文件。</span></span></li><li><span class="name"><span class="innerContentContainer">可以用 openssl 来查看RSA文件中的证书信息和公钥信息。</span></span></li><li><span class="name"><span class="innerContentContainer"> 证书是自签名的，并不需要由第三方权威机构发布或者认证的。</span></span></li><li><span class="name"><span class="innerContentContainer">Android中的签名有两种方式：jarsigner和signapk。这两种方式的区别是：</span></span><ul><li><span class="name"><span class="innerContentContainer">jarsigner签名时，需要的是keystore文件，而signapk签名的时候是pk8.x509.pem文件。</span></span></li><li><span class="name"><span class="innerContentContainer">jarsigner签名之后的SF和RSA文件名默认是keystore的别名，而signapk签名之后文件名是固定的:CERT。</span></span></li><li><span class="name"><span class="innerContentContainer">keystore文件和pk8.x509.pem文件之间可以互相转化。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">签名方案V2</span></span><ul><li><span class="name"><span class="innerContentContainer">v2是一种全文件签名方案，对整个zip文件（包括zip元数据）进行签名；</span></span></li><li><span class="name"><span class="innerContentContainer">v2下，zipalign需要在签名之前执行；</span></span></li><li><span class="name"><span class="innerContentContainer">v2的签名工具-apksigner，位于sdk的build-tools目录下，但由于v2是Android7.0之后才推出的，所以只有版本&gt;25的sdk中才能找到apksigner.jar。</span></span></li><li><span class="name"><span class="innerContentContainer">为了兼容7.0以下设备，需要同时使用v1和v2签名。此时，在7.0及以上设备中只会验证v2签名，在7.0以下设备中，则只会验证v1签名；</span></span></li><li><span class="name"><span class="innerContentContainer">如果试图删除v2签名保留v1签名，系统同样会验证不通过，即“防回滚保护”。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">权限控制 <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">Android应用通过权限字符串来控制权限。权限字符串通过签名来保证不被篡改。</span></span></li><li><span class="name"><span class="innerContentContainer">安装位置会影响权限</span></span><ul><li><span class="name"><span class="innerContentContainer">在 system/app下面安装的应用是 system level，能获得一些危险权限，比如静默安装权限。</span></span></li><li><span class="name"><span class="innerContentContainer">在 data/app 下面安装的应用是&nbsp;app level.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">在AndroidManifest中定义Permission</span></span><ul><li><span class="name"><span class="innerContentContainer">系统会根据应用在AndroidManifest.xml中声明的use-permission而在访问相应api或资源时判断其是否有访问权限，比如常用的android.permission.INTERNET等。</span></span></li><li><span class="name"><span class="innerContentContainer">这个是最主要的权限控制，一般开发者开发应用主要是接触这个.</span></span></li></ul></li><li><span class="name"></span></li></ul></li><li><span class="name"><span class="innerContentContainer">安全模式</span></span><ul><li><span class="name"><span class="innerContentContainer">android4.1支持安全模式。</span></span></li><li><span class="name"><span class="innerContentContainer">在这种模式下，手机界面上显示“safe mode”，并停用所有第三方应用，以方便对问题手机进行检查和维护。</span></span></li><li><span class="name"><span class="innerContentContainer">进入方式：默认为长按power键，一直到“进入安全模式”菜单出现，然后选择即进入。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">框架层安全方案</span></span><ul><li><span class="name"><span class="innerContentContainer">数字证书</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Android运行时安全方案</span></span><ul><li><span class="name"><span class="innerContentContainer">SSL（网络安全库）</span></span></li><li><span class="name"><span class="innerContentContainer">SQLite（数据库安全）</span></span></li><li><span class="name"><span class="innerContentContainer">虚拟机（安全沙箱）</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">Kernel层安全方案</span></span><ul><li><span class="name"><span class="innerContentContainer">root 权限</span></span><ul><li><span class="name"><span class="innerContentContainer">如果没有root权限，则 /system/bin/su 文件不存在.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">文件访问控制</span></span><ul><li><span class="name"><span class="innerContentContainer">修改文件访问权限：</span></span><ul><li><span class="name"><span class="innerContentContainer">system/core/include/private/android_filesystem_config.h，有 android_dirs[], android_files[]。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SELinux  <span class="contentTag" title="Filter #面试题">#<span class="contentTagText">面试题</span><span class="contentTagNub"></span></span> </span></span><ul><li><span class="name"><span class="innerContentContainer">SELinux之前</span></span><ul><li><span class="name"><span class="innerContentContainer">在 SELinux 出现之前，Linux 上的安全模型叫 DAC。</span></span></li><li><span class="name"><span class="innerContentContainer">DAC，Discretionary Access Control，自主访问控制。</span></span></li><li><span class="name"><span class="innerContentContainer">DAC 的思想是：进程理论上所拥有的权限与执行它的用户的权限相同。比如，以 root 用户启动 Browser，那么 Browser 就有 root 用户的权限。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SELinux之后</span></span><ul><li><span class="name"><span class="innerContentContainer">SELinux之后，DAC进化为MAC。</span></span></li><li><span class="name"><span class="innerContentContainer">MAC，Mandatory Access Control，强制访问控制。</span></span></li><li><span class="name"><span class="innerContentContainer">MAC 的理论也很简单，任何进程想在 SELinux 系统上干任何事情，都必须在“安全策略文件”中赋予权限，凡是没有出现在安全策略文件中的权限，就不行。</span></span></li><li><span class="name"><span class="innerContentContainer">Linux 系统先做 DAC 检查。如果没有通过 DAC 权限检查，则操作直接失败。通过 DAC 检查之后，再做 MAC 权限检查。</span></span></li><li><span class="name"><span class="innerContentContainer">SELinux 有自己的一套规则来编写安全策略文件，这套规则被称之为 SELinux Policy 语言。</span></span></li><li><span class="name"><span class="innerContentContainer">SELinux 按照默认拒绝的原则运行：任何未经明确允许的行为都会被拒绝。</span></span></li><li><span class="name"><span class="innerContentContainer"><b>MAC的本质: 没有MAC, 则有root 权限后就可以访问所有文件. 有了MAC, root也不能随便访问文件.</b></span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">SELinux的两种模式</span></span><ul><li><span class="name"><span class="innerContentContainer">宽容模式(permissive)：权限拒绝事件会被记录到Log中，但不会被强制执行。</span></span></li><li><span class="name"><span class="innerContentContainer">强制模式(enforcing)：权限拒绝事件会被记录下来并强制执行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">权限标签。重要</span></span><ul><li><span class="name"><span class="innerContentContainer">SELinux依靠标签来匹配任何访问操作和政策。</span></span></li><li><span class="name"><span class="innerContentContainer">标签在启动过程中给定。</span></span></li><li><span class="name"><span class="innerContentContainer">打标签的对象包括文件、进程和socket等。</span></span></li><li><span class="name"><span class="innerContentContainer">标签存放在te 文件中。</span></span></li><li><span class="name"><span class="innerContentContainer">路径在 /device/&lt;company&gt;/common/sepolicy 及 /device/&lt;company&gt;/$DEVICE/sepolicy 中。</span></span></li><li><span class="name"><span class="innerContentContainer">定义语法是 “user:role:type:mls_level ”形式（如u:r:init:s0），其中type是关键信息。</span></span></li><li><span class="name"><span class="innerContentContainer">如果我们需要某些进程对某些目标具有操作权限，需要用这种：allow domains types:classes permissions的形式</span></span><ul><li><span class="name"><span class="innerContentContainer">Domain：一个进程或一组进程的标签。也称为域类型，因为它只是指进程的类型。</span></span></li><li><span class="name"><span class="innerContentContainer">Type：一个对象（例如，文件、套接字）或一组对象的标签。</span></span></li><li><span class="name"><span class="innerContentContainer">Class：要访问的对象（例如，文件、套接字）的类型。</span></span></li><li><span class="name"><span class="innerContentContainer">Permission：要执行的操作（例如，读取、写入）。</span></span></li><li><span class="name"><span class="innerContentContainer">比如 allow init ipa_dev:chr_file open，表示init进程可以对chr_file类型的ipa_dev具有open权限。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">注意： te文件必须以空行结束。建议在文件末尾放三四个空行。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">权限拒绝事件的log</span></span><ul><li><span class="name"><span class="innerContentContainer">在dmesg&nbsp;和&nbsp;logcat&nbsp;都有。</span></span></li><li><span class="name"><span class="innerContentContainer">关键字：avc-denied</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">如何查看进程的标签？</span></span><ul><li><span class="name"><span class="innerContentContainer">标签又叫context，包括如下几种：</span></span><ul><li><span class="name"><span class="innerContentContainer">file_contexts    // 文件的安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">seapp_contexts  // app安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">property_contexts   // 属性的安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">service_contexts &nbsp; &nbsp;  // service文件安全上下文</span></span></li><li><span class="name"><span class="innerContentContainer">genfs_contexts    // 虚拟文件系统安全上下文</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">adb shell ls –Z，可查看文件的sContext。</span></span></li><li><span class="name"><span class="innerContentContainer">adb shell ps -Z，可查看进程的sContext。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">临时关闭SELinux</span></span><ul><li><span class="name"><span class="innerContentContainer">setenforce 0</span></span></li><li><span class="name"><span class="innerContentContainer">修改的是 /sys/fs/selinux/enforce 节点的值。断电之后，节点值会复位。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">永久关闭SELinux</span></span><ul><li><span class="name"><span class="innerContentContainer">kernel 关闭 selinux：SECURITY_SELINUX 设置为 false，重新编译 kernel</span></span></li><li><span class="name"><span class="innerContentContainer">设置 ro.boot.selinux=permissive 属性，并且修改在 system/core/init/Android.mk 中设置用于 user 版本下 selinux 模式为 permissive。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">FDE，全盘加密</span></span><ul><li><span class="name"><span class="innerContentContainer">Full Disk Encryption。从Android 4.4开始。Android 5.0开始必须打开。</span></span></li><li><span class="name"><span class="innerContentContainer">对 /data/和sdcard 进行数据加密。</span></span></li><li><span class="name"><span class="innerContentContainer">基于文件的加密。</span></span></li><li><span class="name"><span class="innerContentContainer">加密感知型应用：</span></span></li><li><span class="name"><span class="innerContentContainer">功能</span></span><ul><li><span class="name"><span class="innerContentContainer">在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：</span></span></li><li><span class="name"><span class="innerContentContainer">ce（user/0）：凭据加密 (CE) 存储空间。这是默认存储位置，只有在用户解锁设备后才可用。</span></span><ul><li><span class="name"><span class="innerContentContainer">加密方式：</span></span><ul><li><span class="name"><span class="innerContentContainer">EXT4 加密</span></span><ul><li><span class="name"><span class="innerContentContainer">FBF使用了EXT4文件系统的加密机制，配置为：</span></span><ul><li><span class="name"><span class="innerContentContainer">采用 XTS 模式的 AES-256 算法加密文件内容；</span></span></li><li><span class="name"><span class="innerContentContainer">采用 CBC-CTS 模式的 AES-256 算法加密文件名</span></span></li></ul></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">de（user_de/0）：设备加密 (DE) 存储空间。在直接启动模式（direct boot）期间以及用户解锁设备后均可用。</span></span></li><li><span class="name"><span class="innerContentContainer">在开机未解锁的场景，ce目录被锁定，只能访问de目录，但是有些应用场景，例如闹钟，即使开机未解锁也需要提供服务，因此需要适配FBE。</span></span></li><li><span class="name"><span class="innerContentContainer">这种区分能够使工作资料更加安全。</span></span></li><li><span class="name"><span class="innerContentContainer">应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">启动FDE</span></span><ul><li><span class="name"><span class="innerContentContainer">将 fileencryption 标记添加到 userdata 分区最后一列的 fstab 行，即可。</span></span></li><li><span class="name"><span class="innerContentContainer">必须在可信执行环境 (TEE) 中实现 Keymaster/Keystore 和 Gatekeeper，以便为 DE 密钥提供保护。</span></span></li><li><span class="name"><span class="innerContentContainer">内核加密性能必须要在使用 AES XTS 时至少达到 50MB/s，以确保良好的用户体验。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">检查FDE状态</span></span><ul><li><span class="name"><span class="innerContentContainer">检查&nbsp;ro.crypto.state&nbsp;是否存在，确认&nbsp;ro.crypto.state&nbsp;是否已加密。</span></span></li><li><span class="name"><span class="innerContentContainer">检查&nbsp;ro.crypto.type&nbsp;是否存在，确认&nbsp;ro.crypto.type&nbsp;是否已设为&nbsp;file。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">OEMINFO</span></span><ul><li><span class="name"><span class="innerContentContainer">数据存储方式</span></span><ul><li><span class="name"><span class="innerContentContainer">数据按type分，一个type至少占据一块，可以不连续分布。</span></span></li><li><span class="name"><span class="innerContentContainer">oeminfo分区中，有数据的每块都有一个头，记录该地的type id。</span></span></li><li><span class="name"><span class="innerContentContainer">因此，可实现不连续存储。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">type</span></span><ul><li><span class="name"><span class="innerContentContainer">otp：RSA公钥A和B。</span></span></li><li><span class="name"><span class="innerContentContainer">oem_id</span></span><ul><li><span class="name"><span class="innerContentContainer">即手机的密钥源。</span></span></li><li><span class="name"><span class="innerContentContainer">目前有如下几种数据：emei、蓝牙地址、wifi地址、emmc psn号码。</span></span></li><li><span class="name"><span class="innerContentContainer">所有这些数据，用私钥B加密过，存放在oeminfo中的是密文。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock数据</span></span><ul><li><span class="name"><span class="innerContentContainer">key[5]，5组密码</span></span></li><li><span class="name"><span class="innerContentContainer">flag：使能标志</span></span></li><li><span class="name"><span class="innerContentContainer">data：plmn id list。</span></span></li><li><span class="name"><span class="innerContentContainer">这三部分数据都有不同的加密方式。</span></span></li><li><span class="name"><span class="innerContentContainer">使用AES加密，可解码成明文。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock_alterable</span></span><ul><li><span class="name"><span class="innerContentContainer">simlock数据中的可修改部分，包括：</span></span></li><li><span class="name"><span class="innerContentContainer">simlock_dck_count：规定解锁次数</span></span></li><li><span class="name"><span class="innerContentContainer">simlock_feature_inds</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">nv_backup：rfnv备份数据</span></span></li><li><span class="name"><span class="innerContentContainer">err_times：nck密码试错的次数（最多5次，5次后手机将锁定，无法搜网）</span></span></li><li><span class="name"><span class="innerContentContainer">wifi_test：wifi校准数据。</span></span></li><li><span class="name"><span class="innerContentContainer">prl_roaming_list：prl数据，CDMA用。</span></span></li><li><span class="name"><span class="innerContentContainer">Type值只能增加，不能减少。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">头结构</span></span><ul><li><span class="name"><span class="innerContentContainer">头结构占据每个block的第一个page，长度有三种：</span></span><ul><li><span class="name"><span class="innerContentContainer">emmc和小page nand为512字节，</span></span></li><li><span class="name"><span class="innerContentContainer">2k nand为2k，</span></span></li><li><span class="name"><span class="innerContentContainer">4k nand为4k，</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">有效数据则不变，为28字节，由6个字段组成。剩余空间填0xFFFF。</span></span></li><li><span class="name"><span class="innerContentContainer">头结构包括：</span></span><ul><li><span class="name"><span class="innerContentContainer">字段1，8字节长，为migic number，为“oem_info”的asc码值，即 0x5F4D454F 0x4F464849。</span></span></li><li><span class="name"><span class="innerContentContainer">字段2，version，目前最大为4。表示为4K nand的oeminfo。1表示小块nand，2表示emmc，3没有用。</span></span></li><li><span class="name"><span class="innerContentContainer">字段3，info_type，数据类型，即oeminfo_info_type_enum_type，目前有大约30多种。</span></span></li><li><span class="name"><span class="innerContentContainer">字段4，total_blck，本类型共占据多少block；</span></span></li><li><span class="name"><span class="innerContentContainer">字段5，curr_logical_blck，当前为第多少个block，从1开始；</span></span></li><li><span class="name"><span class="innerContentContainer">字段6，total_byte，该类型的实际大小，以byte为单位。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">SimLock</span></span><ul><li><span class="name"><span class="innerContentContainer">simlock_key[5]，2组共10个密码。</span></span><ul><li><span class="name"><span class="innerContentContainer">第一组5个即 nck密码，用于simlock解锁。</span></span><ul><li><span class="name"><span class="innerContentContainer">nck密码解锁：解密时，用户输入一个16位10进制数，经md5加密后和oeminfo中的密文对比。</span></span></li><li><span class="name"><span class="innerContentContainer">如果匹配，即simlock解锁。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">第二组，第一个为uck密码，第二个用于diag鉴权.</span></span><ul><li><span class="name"><span class="innerContentContainer">nck解锁失败：nck解锁失败10次，手机就锁定了，必须用uck来解。</span></span></li><li><span class="name"><span class="innerContentContainer">uck可以使用无限次。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">diag鉴权</span></span><ul><li><span class="name"><span class="innerContentContainer">没有鉴权的状态下，diag端口只支持3个鉴权相关的握手命令和一个升级命令。</span></span></li><li><span class="name"><span class="innerContentContainer">步骤是手机侧生成随机数，传给pc侧私钥加密，然后把密文发给手机侧，手机侧解密后和原来的随机数对比，如吻合则鉴权通过。</span></span></li><li><span class="name"><span class="innerContentContainer">pc端需要加密狗才可以。</span></span></li><li><span class="name"><span class="innerContentContainer">鉴权通过后，密码会被置换为16个0.</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">其它三套不用。</span></span></li><li><span class="name"><span class="innerContentContainer">密码的生成方式</span></span><ul><li><span class="name"><span class="innerContentContainer">这5套密码均为imei+随机数，并经过md5加密后保存到手机上，即手机上没有保存明文。</span></span></li><li><span class="name"><span class="innerContentContainer">生产线会在数据库中保存明文，用 emei 可查询。</span></span></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">flag：simlock使能标志</span></span><ul><li><span class="name"><span class="innerContentContainer">当值为imei+“disable”，并经过md5加密后的值时，将去使能simlock；</span></span></li><li><span class="name"><span class="innerContentContainer">其它值，或无值，均为使能simlock。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock_data：simlock数据</span></span><ul><li><span class="name"><span class="innerContentContainer">imei号的长度：11字节，8字节有效数据，1字节有效数据长度，2字节crc值。</span></span></li><li><span class="name"><span class="innerContentContainer">蓝牙地址：6字节蓝牙地址，和2字节crc值。</span></span></li><li><span class="name"><span class="innerContentContainer">MEID：9字节，7字节有效数据+2字节crc。&nbsp; ESN：6字节，4字节有效数据+2字节crc。</span></span></li><li><span class="name"><span class="innerContentContainer">simlock_data数据会用imei做加密。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">IMSI 数据结构（关键点）</span></span><ul><li><span class="name"><span class="innerContentContainer">sim卡中的数据。IMSI共有15位，其结构为 PLMN+MSIN。</span></span></li><li><span class="name"><span class="innerContentContainer">PLMN</span></span><ul><li><span class="name"><span class="innerContentContainer">Public Land Mobile Network，公共陆地移动网络。</span></span></li><li><span class="name"><span class="innerContentContainer">另外，固定电话系统叫公用交换电话网络（PSTN）。</span></span></li><li><span class="name"><span class="innerContentContainer">PLMN=MCC+MNC。</span></span><ul><li><span class="name"><span class="innerContentContainer">MCC</span></span><ul><li><span class="name"><span class="innerContentContainer">Mobile Country Code，移动国家码，共3位十进制数字。</span></span></li><li><span class="name"><span class="innerContentContainer">中国为460。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">MNC</span></span><ul><li><span class="name"><span class="innerContentContainer">Mobile Network Code，移动网络码，2-3位十进制数字。</span></span></li><li><span class="name"><span class="innerContentContainer">中国移动00和02</span></span></li><li><span class="name"><span class="innerContentContainer">中国联通01</span></span></li><li><span class="name"><span class="innerContentContainer">中国电信03。</span></span></li></ul></li></ul></li></ul></li><li><span class="name"><span class="innerContentContainer">MSIN</span></span><ul><li><span class="name"><span class="innerContentContainer">MSIN = HLR + simcode</span></span></li><li><span class="name"><span class="innerContentContainer">HLR：子网ID，2字节</span></span></li><li><span class="name"><span class="innerContentContainer">simcode：&lt;=8字节</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">GID1 / GID2：sim/usim卡上的两个文件，用来标识卡用户的文件。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock分5级（根据IMSI的数据结构）</span></span><ul><li><span class="name"><span class="innerContentContainer">第一级：锁PLMN。解锁码是NCK（网络码）。</span></span></li><li><span class="name"><span class="innerContentContainer">第二级；锁运营商子网HLR。解锁码：NSCK（子网码）。</span></span></li><li><span class="name"><span class="innerContentContainer">第三级：锁运营商码GID1。解锁码：SPCK（运营商码）。比较少用。</span></span></li><li><span class="name"><span class="innerContentContainer">第四级：锁社区、社群。一般不用。</span></span></li><li><span class="name"><span class="innerContentContainer">第五级：锁指定sim。即只能用指定号。一般不用。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">simlock方案</span></span><ul><li><span class="name"><span class="innerContentContainer">简而言之，就是将simlock_data与sim卡上的IMSI进行匹配，通过了才可以搜网。</span></span></li><li><span class="name"><span class="innerContentContainer">simlock数据即运营商ID list，和SIM卡的IMSI卡号匹配。</span></span></li><li><span class="name"><span class="innerContentContainer">匹配方法是：前3位为国家码MCC，后面2-3位为运营商码MNC（具体2位3位取决于MCC），两个字段都匹配上即ok。</span></span></li><li><span class="name"><span class="innerContentContainer">比如中国移动的运营商ID list包括46000，那么手机IMSI包含这个字符串的手机就只能上中国移动。</span></span></li><li><span class="name"><span class="innerContentContainer">另外一种是锁HLR和NDC，即锁子网，即只能用运营商指定区域内的网络。很少用。</span></span></li><li><span class="name"><span class="innerContentContainer">子网定义由运营商自己做，一般由区域码和范围码组成。</span></span></li></ul></li><li><span class="name"><span class="innerContentContainer">sim卡上有pin码、puk码</span></span><ul><li><span class="name"><span class="innerContentContainer">pin码类似开机密码，用户可以开关其功能，也可以设置其pin码。</span></span></li><li><span class="name"><span class="innerContentContainer">pin码三次输错，需要用puk码解。</span></span></li><li><span class="name"><span class="innerContentContainer">puk10次输错，则sim卡自毁。</span></span></li><li><span class="name"><span class="innerContentContainer">puk码一般在购买sim卡时运营商会告知。</span></span></li></ul></li></ul></li></ul>
  </body>
</html>